
(function(window,DataView){
    'use strict';
// ie8 wat
//    /**
//      window.emojiSupported
//      window.eventFix
//      window.scrollToYOffset
//      Function.prototype.bind
//
//      ##string features
//      String.prototype.format
//      String.prototype.supplant
//      String.prototype.repeat
//      String.prototype.trim
//      String.prototype.utf8Encode
//      String.prototype.toCharCodeArray
//
//      ##array feature added##
//      Array.prototype.indexOf
//      Array.prototype.contains
//      Array.prototype.filter
//      Array.prototype.difference
//      Array.prototype.joinAsDataView
//
//      ## dataview feature added
//      DataView.prototype.copy
//      DataView.prototype.merge
//      DataView.prototype.addAttributeInt
//      DataView.prototype.addAttributeString
//      DataView.prototype.addAttributeData
//      DataView.prototype.print_r
//      DataView.prototype.getString
//      DataView.prototype.getIntByByte
//      DataView.prototype.setUint64
//      DataView.prototype.getBool
//      DataView.prototype.getUint24
//    */

    window.emojiSupported = (function() {
  	  var node = document.createElement('canvas');
  	  if (!node.getContext || !node.getContext('2d') || typeof node.getContext('2d').fillText !== 'function') return false;
  	  var ctx = node.getContext('2d');
  	  ctx.textBaseline = 'top';
  	  ctx.font = '32px Arial';
  	  ctx.fillText('\ud83d\ude03', 0, 0);
  	  return ctx.getImageData(16, 16, 1, 1).data[0] !== 0;
	})();

    window.eventFix = function(e){

        e = e || window.event;

        var pageX = e.pageX;
        var pageY = e.pageY;
        if (pageX === undefined) {
            pageX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            pageY = e.clientY + document.body.scrollTop + document.documentElerment.scrollTop;
        }
    }

    window.scrollToYOffset = function(targetYOffset, scrollDuration) {
        console.log(targetYOffset);
        var scrollStep = targetYOffset / (scrollDuration / 15),
        scrollInterval = setInterval(function(){
            console.log(window.scrollY," tar",targetYOffset);
            if ( window.scrollY < targetYOffset ) {
                window.scrollBy( 0, scrollStep );
            }else clearInterval(scrollInterval);
        }, 15);
    };

    if (!Function.prototype.bind) {
      Function.prototype.bind = function(oThis) {
        if (typeof this !== 'function') {
          // closest thing possible to the ECMAScript 5
          // internal IsCallable function
          throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }

        var aArgs   = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP    = function() {},
            fBound  = function() {
              return fToBind.apply(this instanceof fNOP
                     ? this
                     : oThis,
                     aArgs.concat(Array.prototype.slice.call(arguments)));
            };

        if (this.prototype) {
          // native functions don't have a prototype
          fNOP.prototype = this.prototype;
        }
        fBound.prototype = new fNOP();

        return fBound;
      };
    }

   if (!String.prototype.format) {
        String.prototype.format = function() {
          var args = Object.prototype.toString.call(arguments[0] ) === '[object Array]' ?arguments[0]:arguments;
          return this.replace(/{(\d+)}/g, function(match, number) {
            return typeof args[number] != 'undefined'
              ? args[number]
              : match
            ;
          });
        };
      }

    if (!String.prototype.supplant) {
        String.prototype.supplant = function (o) {
            return this.replace(
                /\{([^{}]*)\}/g,
                function (a, b) {
                    var r = o[b];
                    return typeof r === 'string' || typeof r === 'number' ? r : a;
                }
            );
        };
    }

    if (!String.prototype.repeat) {
        String.prototype.repeat = function(count) {
           return Array(count+1).join(this);

        };
    }
    if (!String.prototype.trim) {
          String.prototype.trim = function () {
            return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
          };
     }

    String.prototype.utf8Encode = function(){
       return unescape(encodeURIComponent(this));
    };

    String.prototype.toCharCodeArray = function(){
        var codes = [];
        for (var i = 0; i < this.length;i++) {
            codes.push(this.charCodeAt(i));
        }
        return codes;
    };

    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(elt /*, from*/) {
            var len = this.length >>> 0;
            var from = Number(arguments[1]) || 0;
            from = (from < 0) ? Math.ceil(from) : Math.floor(from);
            if (from < 0) {
                from += len;
            }

            for (; from < len; from++) {
                if (from in this && this[from] === elt) { return from; }
            }
            return -1;
        };
    }
    if (!Array.prototype.contains) {
        Array.prototype.contains = function(val,fn) { // fn is the function for equality match function if provided else it will macth whole object
            if(!fn)return this.indexOf(val);
            var len = this.length >>> 0;
            var from = Number(arguments[1]) || 0;
            from = (from < 0) ? Math.ceil(from) : Math.floor(from);
            if (from < 0) {
                from += len;
            }

            for (; from < len; from++) {
                if (from in this && fn.call(this,this[from],val)){ return from; }
            }
            return -1;

        };
    }
    if (!Array.prototype.filter) {
          Array.prototype.filter = function(fun/*, thisArg*/) {
            'use strict';

            if (this === void 0 || this === null) {
              throw new TypeError();
            }

            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== 'function') {
              throw new TypeError();
            }

            var res = [];
            var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
            for (var i = 0; i < len; i++) {
              if (i in t) {
                var val = t[i];

                // NOTE: Technically this should Object.defineProperty at
                //       the next index, as push can be affected by
                //       properties on Object.prototype and Array.prototype.
                //       But that method's new, and collisions should be
                //       rare, so use the more-compatible alternative.
                if (fun.call(thisArg, val, i, t)) {
                  res.push(val);
                }
              }
            }

            return res;
          };
    }

    if(!Array.prototype.keyValues){
        Array.prototype.keyValues = function(key){
            var index, values = [];
            for( index = 0; index < this.length; index++){
                if(!!this[index][key]){
                    values.push(this[index][key]);
                }

            }
            return values;
        };
    }

    if(!Array.prototype.values){
        Array.prototype.values = function(){
            var index, values = [];
            for( index = 0; index < this.length; index++){
                values.push(this[index]);
            }
            return values;
        };
    }


    //{utids : ""} considers all array element is instance of DataView and returns a DataView Object of all element after merge
    Array.prototype.joinAsDataView = function(){
            var self = this,currentIndex=0,dataViewLength= 0,buffer,view;
            if(!self.length)return new DataView(new ArrayBuffer(0)); // if no elements then just returns a DataView
            for(var i=0;i<self.length;i++){
                if(self[i] instanceof DataView){
                    dataViewLength += self[i].byteLength;
                }
            }
            if(!dataViewLength)return new DataView(new ArrayBuffer(0));
              buffer = new ArrayBuffer(dataViewLength);
              view = new DataView(buffer);
            for(var i=0;i<self.length;i++){
                if(self[i] instanceof DataView){
                    for(var j=0;j<self[i].byteLength;j++){
                        view.setUint8(currentIndex++,self[i].getUint8(j));
                    }
                }
            }
        return view;

    };

    Array.prototype.difference = function(elementsToRemove){
        if( !elementsToRemove || !elementsToRemove.length || !this.length){
            return this;
        }

        var mapElementsToRemove = {},
            outputArray = [],
            index = 0;


        /* Cache elementsToRemove Array */
        while( index < elementsToRemove.length ){

            mapElementsToRemove[elementsToRemove[index]] = true;
            index++;
        }

        for(index=0; index < this.length; index++ ){
            if( !mapElementsToRemove[ this[index] ] ){
                outputArray.push( this[index] )
            }
        }
        return outputArray;

    };

    DataView.prototype.copy = function(offset,length){
       //var self = this;
       //offset = offset || 0;
       //length = length || self.byteLength;
       //// var diff = length-offset;
       //var buffer = new ArrayBuffer(length);
       //var view = new DataView(buffer);
       //for(var i=0;i<length;i++){
       //     view.setUint8(i,self.getUint8(offset++));
       //}
       // return view
        return new DataView(this.buffer,offset,length);
    };
    DataView.prototype.merge = function(from,fromLength,toview,to,toLength){
        var self = this, i,j;
          var mergea = new DataView(this.buffer,from,fromLength),
            buf = new ArrayBuffer(mergea.byteLength+(toLength-to+1)),
            view = new DataView(buf);
        for(i=0;i<mergea.byteLength;i++){
            view.setUint8(i,mergea.getUint8(i));
        }
       // console.info("from : "+from +" fl : "+fromLength + " to :"+to + " length : "+toLength +" current : "+i +" to range" +torange);
        for(j=i;j<view.byteLength;j++){
            view.setUint8(j,toview.getUint8(to++));
        }
        return view;


    };
    DataView.prototype.addAttributeInt = function(i,code,len,value){
       // console.info("index : "+ i + " attr : " + code +"\n");
        this.setUint8(i++,code);
       // console.info("index : "+ i + " len : " + len +"\n");
        this.setUint8(i++,len);
        //console.info("index : "+ i + " "+len+"val : " + value +"\n");
        switch(len){
            case 1:
                this.setUint8(i++,value);
                break;
            case 2:
                this.setUint16(i,value);
                i +=2;
                break;
            case 4:
                this.setUint32(i,value);
                i+=4;
                break;
        }
        return i;

    };
    DataView.prototype.addAttributeString = function(i,code,value){
       // console.info("index : "+ i + " attr : " + code +"\n");
        this.setUint8(i++,code);
       // console.info("index : "+ i + " "+value.length+" strval : " + value +"\n");
        this.setUint8(i++,value.length);
        for (var j = 0; j< value.length;j++) {
            this.setUint8(i++,value.charCodeAt(j));
        }
      return i;
    };
    DataView.prototype.addAttributeData = function(i,code,view,fromIndex,length){
        fromIndex = fromIndex || 0;
        length = length || view.byteLength;
        this.setUint8(i++,code);
        this.setUint16(i,length);
        i+=2;
        for(var j=0;j<length;j++){
            this.setUint8(i++,view.getUint8(fromIndex++));
        }
        return i;
    };
    DataView.prototype.print_r = function(debug,starting,length){
        starting = starting || 0;
        length = length || this.byteLength;

        var str = "Index\t\tBinary\t\tInteger\t\tChar\n";
        var full="", c,inte;
        for(var i=starting;i<length;i++){
         inte = this.getUint8(i);
            c = String.fromCharCode(inte);

          str += i + "\t\t \t\t" + inte.toString(2) + "\t\t\t\t"+ inte + "\t\t\t\t"+c+"\n";
            full +=c;
        }
        if(!!debug && typeof debug !== 'string'){
            console.log(str);
            console.log("\n length : "+str.length);
        }else{
            return full;
        }

        console.log(full);

    };

    DataView.prototype.printBytes = function(){
        var bytes = [];
        for(var i=0;i<this.byteLength;i++){
            bytes.push(this.getUint8(i));
        }
        bytes.push(-1000);
        console.log(bytes.join('\n'));

    };

    DataView.prototype.getString = function(offset,length){
        var self = this,bitArray = [], firstByte, highSurrogate, lowSurrogate, codePoint;
        length = length || self.byteLength;

         /* utf8 format ref: http://www.fileformat.info/info/unicode/utf8.htm */

         while( length > 0  ) {
            firstByte = self.getUint8(offset);
            if(self.getUint8(offset) <= 127) {
              bitArray.push(self.getUint8(offset++));
              length--;
            }
            else if(self.getUint8(offset) >= 128 && self.getUint8(offset) <= 223) {

              bitArray.push(((self.getUint8(offset++) & 0x1F) << 6) | (self.getUint8(offset++) & 0x3F));
              length -=2;
            }
            else if(self.getUint8(offset) >= 224 && self.getUint8(offset) <= 239) {
              bitArray.push(((self.getUint8(offset++) & 0x1F) << 12) | ((self.getUint8(offset++) & 0x3F) << 6 | (self.getUint8(offset++) & 0x3F)));
              length -=3;
            }
            else {
               /* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint */
               codePoint = ((self.getUint8(offset++) & 0x07) << 18) | (((self.getUint8(offset++) & 0x3F) << 12) | ((self.getUint8(offset++) & 0x3F) << 6 | (self.getUint8(offset++) & 0x3F)));
               codePoint -= 0x10000;
               highSurrogate = (codePoint >> 10) + 0xD800;
               lowSurrogate = (codePoint % 0x400) + 0xDC00;
               bitArray.push(highSurrogate, lowSurrogate);
               length -=4;
            }
        }

        //var func =  new Function("function(){ return String.fromCharCode("+bitArray.join(",")+");}");
        return String.fromCharCode.apply(null,bitArray);
        //return bitArray.length ? :'';
    };


	DataView.prototype.getStringUtf16 = function(length, offset, bom) {
		offset = offset | 0;
		length = length || (this.byteLength - offset);
		var littleEndian = false,
			str = '',
			useBuffer = false;

		if (typeof Buffer !== 'undefined') {
			str = [];
			useBuffer = true;
		}
		if (length < 0) {
			length += this.byteLength;
		}
		if (bom) {
			var bomInt = this.getUint16(offset);
			if (bomInt === 0xFFFE) {
				littleEndian = true;
			}
			offset += 2;
			length -= 2;
		}

		for(var i = offset; i < (offset + length); i += 2) {
			var ch = this.getUint16(i, littleEndian);
			if((ch >= 0 && ch <= 0xD7FF) || (ch >= 0xE000 && ch <= 0xFFFF)) {
				if (useBuffer) {
					str.push(ch);
				} else {
					str += String.fromCharCode(ch);
				}
			} else if(ch >= 0x10000 && ch <= 0x10FFFF) {
				ch -= 0x10000;
				if (useBuffer) {
					str.push(((0xFFC00 & ch) >> 10) + 0xD800);
					str.push((0x3FF & ch) + 0xDC00);
				} else {
					str += String.fromCharCode(((0xFFC00 & ch) >> 10) + 0xD800) + String.fromCharCode((0x3FF & ch) + 0xDC00);
				}
			}
		}
		if (useBuffer) {
			return str.toString();
		} else {
			return decodeURIComponent(escape(str));
		}
	}


    DataView.prototype.getIntByByte = function(offset,length){
        var self = this;
        switch (length){
            case 1:
                return self.getUint8(offset);
            case 2:
                return self.getUint16(offset);
            case 4:
                return self.getUint32(offset);
            case 6:
            case 8://javascript doesn't support 64-bit integer so we assuming first two byte in our system is not used. so we cropping it
                var str="", i,tempInt;
                for(i=offset;i<offset+length;i++){
                    tempInt = self.getUint8(i).toString(2);
                    str += tempInt.length < 8 ? "0".repeat(8-tempInt.length)+tempInt:tempInt;
                }
                return parseInt(str,2);
           default : return self.getUint8(offset);
        }
    };

    DataView.prototype.getSynch = function(num) {
        var out = 0,
        mask = 0x7f000000;
        while(mask) {
            out >>= 1;
            out |= num & mask;
            mask >>= 8;
        }
        return out;
    }

    //function isInt(value) {
    //    return !isNaN(value) && (function(x) { return (x | 0) === x; })(parseFloat(value))
    //}
    //if(!Number.prototype.isInteger){
    //    Number.prototype.isInteger = function(){
    //        return !isNaN(value);
    //    };
    //};

    Number.isInteger = Number.isInteger || function(value) {
        return typeof value === "number" &&
            isFinite(value) &&
            Math.floor(value) === value;
    };
    /*ArrayBuffer.slice method polyfill for IE-10:starts: rabbi*/
    if (!ArrayBuffer.prototype.slice) {
        //Returns a new ArrayBuffer whose contents are a copy of this ArrayBuffer's
        //bytes from `begin`, inclusive, up to `end`, exclusive
        ArrayBuffer.prototype.slice = function (begin, end) {
            //If `begin` is unspecified, Chrome assumes 0, so we do the same
            if (begin === void 0) {
                begin = 0;
            }

            //If `end` is unspecified, the new ArrayBuffer contains all
            //bytes from `begin` to the end of this ArrayBuffer.
            if (end === void 0) {
                end = this.byteLength;
            }

            //Chrome converts the values to integers via flooring
            begin = Math.floor(begin);
            end = Math.floor(end);

            //If either `begin` or `end` is negative, it refers to an
            //index from the end of the array, as opposed to from the beginning.
            if (begin < 0) {
                begin += this.byteLength;
            }
            if (end < 0) {
                end += this.byteLength;
            }

            //The range specified by the `begin` and `end` values is clamped to the
            //valid index range for the current array.
            begin = Math.min(Math.max(0, begin), this.byteLength);
            end = Math.min(Math.max(0, end), this.byteLength);

            //If the computed length of the new ArrayBuffer would be negative, it
            //is clamped to zero.
            if (end - begin <= 0) {
                return new ArrayBuffer(0);
            }

            var result = new ArrayBuffer(end - begin);
            var resultBytes = new Uint8Array(result);
            var sourceBytes = new Uint8Array(this, begin, end - begin);

            resultBytes.set(sourceBytes);

            return result;
        };
    }
    /*ArrayBuffer.slice method polyfill for IE-10:ends: rabbi*/
    DataView.prototype.setUint64 = function(offset, value){
        var self = this;
        var binary = Number.isInteger(value) ? value.toString(2) : parseInt(value).toString(2);
        binary = binary.length < 64 ? "0".repeat(64-binary.length) + binary : binary;
        var binaryArray = binary.match(/.{1,32}/g);
        var intArray = binaryArray.map(function(binaryByte){
            return parseInt(binaryByte, 2);
        });
        // sorting won't be needed
        //intArray.sort(function(a, b) {
        // return a - b;
        //});//sorting in ascending order as we'll put byte in bigendian
        for(var i = 0; i< intArray.length; i++){
            self.setUint32(offset+i*4, intArray[i]);
        }
    };

    DataView.prototype.getBool = function(offset){ // length is always one byte
        return this.getUint8(offset) === 1;
    };
    /**
     * @description : ie can't sent dataview directly to socket. its sends Dataview.toString so its a pitfall for ie
     *    to send Uint8Array. note : ie can sent Uint8Array via socket
     */
    // DataView.prototype.toString = function(){
    //    return new Uint8Array(this.buffer).toString();
    // }

    
    /*Utilities DOM functions*/
    //matches polyfill
	window.Element && function(ElementPrototype) {
    	ElementPrototype.matches = ElementPrototype.matches ||
    	ElementPrototype.matchesSelector ||
   		ElementPrototype.webkitMatchesSelector ||
    	ElementPrototype.msMatchesSelector ||
    	function(selector) {
        	var node = this, nodes = (node.parentNode || node.document).querySelectorAll(selector), i = -1;
        	while (nodes[++i] && nodes[i] != node);
        	return !!nodes[i];
    	}
	}(window.Element.prototype);

	// closest polyfill
	window.Element && function(ElementPrototype) {
    	ElementPrototype.closest = ElementPrototype.closest ||
    	function(selector) {
        	var el = this;
        	while (el.matches && !el.matches(selector)) el = el.parentNode;
        	return el.matches ? el : null;
    	}
	}(window.Element.prototype);
  
    window.requestAnimationFrame = window.requestAnimationFrame || 
                                    window.mozRequestAnimationFrame || 
                                    window.webkitRequestAnimationFrame ||
                                    window.msRequestAnimationFrame;


    DataView.prototype.getUint24 = function(offset, littleEndian) {
		if(littleEndian) {
			return this.getUint8(offset) + (this.getUint8(offset + 1) << 8) + (this.getUint8(offset + 2) << 16);
		}
		return this.getUint8(offset + 2) + (this.getUint8(offset + 1) << 8) + (this.getUint8(offset) << 16);
    };

    Math.easeIn = function (t, b, c, d) {

        t /= d/2;
        if (t < 1) {
            return c/2*t*t + b
        }
        t--;
        return -c/2 * (t*(t-2) - 1) + b;
    };                                


})(window,DataView);

// date custom format extending

/*
 * © Ipvision
 */



(function() {
	'use strict';

    angular
        .module('ringid.config', []);
})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

        //var server = 'dev.ringid.com',
        var server = location.href.split("/")[2],

        protocol = 'http://';

        var baseUrl = location.protocol + '//' + location.host + '/';

        var setting_default = {

            "ac":"http://devauth.ringid.com/rac/",//rac server
            "ims":"http://devimages.ringid.com/", // image server upload
            "imsres":"http://devimagesres.ringid.com/",// image server fetch resource
            "stmapi":"http://devsticker.ringid.com/",//sticker fetch detail api server
            "stmres":"http://devstickerres.ringid.com/",// sticker fetch resource server
            "vodapi":"http://devvod.ringid.com/",// media content upload server
            "vodres":"http://devvodres.ringid.com/",//media content resource server
            "apiVersion" : 139
        };

        var settings = {
            apiVersion: setting_default.apiVersion,
            constantServer : 'http://auth.ringid.com/cnstnts?pf=2&v='+setting_default.apiVersion+'&apt=1',
            socketProtocol: 'ws://',
            secure : false,//true while server have ssl installed
            httpsUrl : 'https://'+server,
            siteUrl: server,
            baseUrl: baseUrl,
            base : location.host,
            chatImBase: protocol+'image.ringid.com/chatContens/',
            chatVideoBase: protocol+'image.ringid.com/chatContens/', // save as above might not be needed
            chatAudioBase: protocol+'image.ringid.com/chatContens/', // save as above might not be needed
            tagChatImBase: protocol+'image.ringid.com/groupContents/',

            chatHeartBeatUrl : baseUrl + 'images/ping.jpg',

            emotionServer : setting_default.imsres + '/emoticon/d5/',
            emoticonBase: protocol+ server +'/images/emoticon/',

            stickerBase: setting_default.stmres + 'stickermarket/d5/',
            stickerApi: setting_default.stmapi +'ringmarket/StickerHandler/',
            //emoticonBase: 'http://38.108.92.154/images/emoticon/',
            imMediaBase : protocol + 'image.ringid.com/ringmarket/ChatImageHandler',

            //stickerImageBase : protocol+'imagxipip' + 'e.ringid.com/stickermarket/d5/',
            //stickerImageBase : protocol+'devauth.ringid.com', // for production it will be "auth.ringid.com"

            twitterApiURL: 'https://api.twitter.com/1.1/account/verify_credentials.json',
            ogServiceUrl : protocol+ server+'/OGService',
            // end api servers

			FEED_LIMIT : 6,


            LEFT_BAR_WIDTH : 200,
            RIGHT_BAR_WIDTH : 200,
            CELL_MARGIN : 10,

            //Third Party

            //GOOGLE_MAP_KEY : 'AIzaSyDwFgSnjLgWcHLEXS5E1dC8GgWLtxsH0zM'
            GOOGLE_MAP_KEY : 'AIzaSyCHl88HAklaOu6Q0TSfX5N5eA0vjdlBNuE'

		};

        function setUrlBase(ob){
                        // api servers
            settings.signupInit = ob.ac + 'ringid?'; // append did 15/32 character long string
            settings.signupSocialInit = ob.ac + 'comports?'; // append platform = twtr/fb id and lt=4/5
            settings.imBase = ob.imsres; // for production use:  'http://images.ringid.com/uploaded/'
            settings.imServer = ob.ims+'ringmarket/'; // for production use:  'http://image.ringid.com/ringmarket/'
            settings.mediaServer = ob.vodapi + '/stream/';
            settings.mediaBase = ob.vodres;

            settings.stickerBase = ob.stmres +'stickermarket/d5/';  // protocol+'image.ringid.com/ringmarket/StickerHandler/',
            settings.stickerApi = ob.stmapi + 'ringmarket/StickerHandler/';  // protocol+'image.ringid.com/ringmarket/StickerHandler/',
        }
        settings.updateUrlBase = setUrlBase;
        settings.updateUrlBase(setting_default);

        var PLATFORM = {
            DESKTOP : 1,
            ANDROID : 2,
            IPHONE : 3,
            WINDOWS : 4,
            WEB : 5
        };

        var RING_ROUTES = {
            HOME : '/',
            USER_PROFILE : '/profile/:uId/:subpage?/:albumId?',
            CIRCLE_HOME : '/circle/:circleId/:subpage?',
            WHO_SHARED_FEED : '/feed_shares/:feedId/:commentId?',
            SINGLE_FEED : '/feed/:feedId/:commentId?/:shared?',
            SINGLE_IMAGE : '/image/:imageId/:commentId?',
            SINGLE_MEDIA : '/media/:mediaId/:commentId?',

            LOGIN_SOCIAL: '/social/:operation/:platform/:token',
            SIGNUP_SOCIAL: '/social/:operation/:platform/:token',

            FAQ : '/faq',
            /*** only for dev build ***/
            API_DASHBOARD : '/apidashboard' /*** ***/
        };


    angular
        .module('ringid.config')
        .value('settings', settings)
        .constant('PLATFORM', PLATFORM)
        .constant('RING_ROUTES', RING_ROUTES)
        .constant("MIN_TIMESTAMP",15976308080961);// the first timestamp when the project started

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

		var ATTRIBUTE_CODES = {
                AUTHIP: 1001,
                AUTHPORT: 1002,
                AUTH_E_USERNAME : 1003,
                AUTH_E_PASSWORD : 1004,
                AUTH_E_SALT : 1005,
                ACTION: 1,
                SERVER_PACKET_ID: 2,
                SESSION_ID: 3,
                TOTAL_PACKET: 4,
                PACKET_NUMBER: 5,
                UNIQUE_KEY: 6,
                USER_ID: 7,
                FRIEND_ID: 8,
                DEVICE: 9,
                CLIENT_PACKET_ID: 10,
                CALL_ID: 11,
                FRIEND_IDENTITY: 12,
                CALL_TIME: 13,
                PRESENCE: 14,
                IS_DEVIDED_PACKET: 15,
                USER_IDENTITY: 16,
                USER_NAME: 17,
                TOTAL_RECORDS: 18,
                USER_TABLE_IDS: 19,
                SUCCESS: 20,
                MESSAGE: 21,
                REASON_CODE: 22,
                STATUS: 23,
                DELETED: 24,
                WEB_UNIQUE_KEY: 28,
                WEB_TAB_ID: 29,
                DATA: 127,

                /* Contact list constants */
                CONTACT: 101,
                CONTACT_TYPE: 102,
                NEW_CONTACT_TYPE: 103,
                FRIENDSHIP_STATUS: 104,
                BLOCK_VALUE: 105,
                CHANGE_REQUESTER: 106,
                CONTACT_UPDATE_TIME: 107,
                MUTUAL_FRIEND_COUNT : 108,
                CALL_ACCESS: 110,
                CHAT_ACCESS: 111,
                FEED_ACCESS: 112,
                ANONYMOUS_CALL: 9,
                /* USER DETAILS */
                PASSWORD: 128,
                RESET_PASSWORD: 129,
                EMAIL: 130,
                DEVICE_UNIQUE_ID: 131,
                DEVICE_TOKEN: 132,
                MOBILE_PHONE: 133,
                BIRTH_DATE: 134,
                MARRIAGE_DAY: 135,
                GENDER: 136,
                COUNTRY_ID: 137,
                CURRENT_CITY: 138,
                HOME_CITY: 139,
                LANGUAGE_ID: 140,
                REGISTRATION_DATE: 141,
                DIALING_CODE: 142,
                IS_MY_NUMBER_VERIFIED: 143,
                IS_EMAIL_VERIFIED: 145,
                MY_NUMBER_VERIFICATION_CODE: 146,
                MYNUMBER_VERIFICATION_CODE_SENT_TIME: 147,
                EMAIL_VERIFICATION_CODE: 148,
                RECOVERY_VERIFICATION_CODE: 149,
                RECOVERY_VERIFICATION_CODE_SENT_TIME: 150,
                PROFILE_IMAGE: 151,
                PROFILE_IMAGE_ID: 152,
                COVER_IMAGE: 153,
                COVER_IMAGE_ID: 154,
                COVER_IMAGE_X: 155,
                COVER_IMAGE_Y: 156,
                ABOUT_ME: 157,
                TOTAL_FRIENDS: 158,
                RING_EMAIL: 159,
                UPDATE_TIME: 160,
                NOTIFICATION_VALIDITY: 161,
                WEB_LOGIN_ENABLED: 162,
                PC_LOGIN_ENABLED: 163,
                COMMON_FRIEND_SUGGESTION: 164,
                PHONE_NUMBER_SUGGESTION: 165,
                CONTACT_LIST_SUGGESTION: 166,
                ADDED_TIME: 168
		};

    angular
        .module('ringid.config')
        .constant('ATTRIBUTE_CODES', ATTRIBUTE_CODES);
})();

/*
 * © Ipvision
 */

(function() {
	'use strict';


    angular
        .module('ringid.config')
        .constant('REASON_CODES',{
            NONE : 	0,
            PERMISSION_DENIED : 	1,
            PASSCODE_SENT_INTERVAL : 	2,
            DONT_DISTURB_MODE : 	3,
            ALREADY_SHARED : 	4,
            NOT_TAG_MEMBER : 	5,
            TAG_DOES_NOT_EXIST : 	6,
            SMS_SENDING_FAILED : 	7,
            EMAIL_SENDING_FAILED : 	8,
            FRIEND_OFFLINE : 	9,
            NOT_FRIEND : 	10,
            USERID_FRIENDID_SAME : 	11,
            ALREADY_FRIEND_REQUESTED : 	12,
            EXCEPTION_OCCURED : 	13,
            DATABASE_ROLL_BACKED : 	14,
            CANT_SHARE_OWN_FEED : 	15,
            FRIEND_DID_NOT_FOUND : 	16,
            SMS_SEND_RETRY_LIMIT_OVER : 	17,
            NO_MORE_FEED : 	18,
            NOT_FOUND : 	404
        })
        .constant('MESSAGES',{
            REQUEST_PROCESSED : 'Your Request Was Successfully Processed',
            REQUEST_FAILED : 'Your Request Was Failed ! Please Try Later.',
			RC0 : "NONE.", // reason code 0
			RC1 : "PERMISSION_DENIED", // reason code 1
			RC2 : "PASSCODE_SENT_INTERVAL", // reason code 2
			RC3 : "DONT_DISTURB_MODE", // reason code 3
			RC4 : "You have already shared this post.", // reason code 4
			RC5 : "NOT_TAG_MEMBER.", // reason code 5
			RC6 : "TAG_DOES_NOT_EXIST.", // reason code 6
			RC7 : "SMS_SENDING_FAILED.", // reason code 7
			RC8 : "EMAIL_SENDING_FAILED.", // reason code 7
			RC9 : "FRIEND_OFFLINE", // reason code 9
            RC10 : "You are not permitted to share this post", // reason code 10
            RC11: "USERID_FRIENDID_SAME",	// reason code 11
            RC12: "ALREADY_FRIEND_REQUESTED", 	// reason code 12
            RC13: "EXCEPTION_OCCURED", 	// reason code 13
            RC14: "DATABASE_ROLL_BACKED", 	// reason code 14
			RC15: "You Can\'t Share Your Own Post", // reason code 15
            RC16: "FRIEND_DID_NOT_FOUND", 	// reason code  16
            RC17: "SMS_SEND_RETRY_LIMIT_OVER", 	// reason code  17
            RC18: "NO_MORE_FEED", 	// reason code  18

            RC19: "UNKNOWN",
            RC20: "UNKNOWN",
            RC21: "LOGGED_IN_FROM_ANOTHER_DEVICE",
            RC22: "UNKNOWN",
            RC23: "UNKNOWN",
            RC26: "USER_EXIST",
            RC27: "DUPLICATE_DATA",
            RC33: "THIS_IS_SPECIAL_FRIEND",
            RC37: "ANONYMOUS_CHAT_PERMISSION_DENIED",

            // signup and signin related
			RC24: "Wrong Password.", // "PASSWORD_DID_NOT_MATCHED",
			RC38: "Could not find DeviceID!", // "DEVICE_ID_DID_NOT_MATCHED",
			RC39: "This phone number is not verified.", // "PHONE_NUMBER_IS_UNVERIFIED",
			RC40: "This email is not verified.", // "EMAIL_IS_UNVERIFIED",
			RC41: "Your facebook ID is not verified.", // "FACEBOOK_IS_UNVERIFIED",
			RC42: "Your twitter ID is not verified.", //"TWITTER_IS_UNVERIFIED",
			RC43: "Could not find Your facebook ID.", // "FACEBOOK_ID_DID_NOT_MATCHED",
			RC44: "Could not find Your twitter ID.", //"TWITTER_ID_DID_NOT_MATCHED.",
			RC45: "Wrong RingID!",  //"INVALID_RINGID.",
			RC46: "Wrong Phone number!", // "INVALID_PHONE_NUMBER",
            RC47: "Wrong Email!", // "INVALID_EMAIL",
            RC48: "Device Id required!", // "DEVICE_UNIQUE_ID_MENDATORY",
            RC49: "Password required", // "PASSWORD_MENDATORY",
            RC50: "Login Type required", // "LOGIN_TYPE_MENDATORY",
            RC51: "Phone country code required!", // "DIALING_CODE_MENDATORY",
			RC52: "Phone number required!", // "PHONE_NUMBER_MENDATORY",
            RC53: "RingID required!", // "RING_ID_MENDATORY",
            RC54: "Email required!", // "EMAIL_MENDATORY",
            RC55: "Version required!", // "VERSION_MENDATORY",
            RC56: "Device required!", // "DEVICE_MENDATORY",
            RC57: "Wrong information", // "INVALID_INFORMATION",

            RC404: "NOT_FOUND", 	// reason code 404
            CRCFS1 : "Wall post cann't be shared", //custom reason code feed share wall post
            CRCFS2 : "Group post cann't be shared", //custom reason code feed share group post
            CRCFS3 : "You already shared this post", //custom reason code feed already shared post
            FEED : {
                ACT_1 : "{0} liked this post", // {0} is user card
                ACT_2 : "{0} commented on this post",// {0} is user card
                ACT_3 : "{0} shared this post",// {0} is user card
                TYPE_0 : "{0}",//"{0} updated status",//just user name
                TYPE_11 : "{0}", // single image posted by user not in friend's wall or circle
                TYPE_11C : "{0} posted",//"single image posted in circle {0} user {1} circle
                TYPE_11F : "{0} posted",//"single image posted in friend wall {0} user {1} friend's wall
                TYPE_12 : "{0} have||has updated profile picture", //{0}:user|you, {1}:have|has
                TYPE_13 : "{0} have||has updated cover picture", //{0}:user|you, {1}:have|has
                TYPE_2 : "{0}", // normal text post , not in friend's wall or circle
                TYPE_2C : "{0} posted", //normal text post on circle {0}:user,{1} circle name
                TYPE_2F : "{0} posted", //normal text post on friend wall, {0}:user,{1} friend wall
                TYPE_3 : "{0} have||has added {1} photos",//{0}:user,{1} number of photo
                TYPE_4 : "{0} created a album",// no use now
                TYPE_50 : "{0} added audio",
                TYPE_51 : "{0} shared {1}'s audio",
                TYPE_60 : "{0} added video",
                TYPE_62 : "{0} shared {1}'s video",
                TYPE_D : "{0}", // {0} updated status
                C_POSTFIX : " in {0}", //0 is the circle name
                F_POSTFIX : " on {0}'s timeline", // 0 is the friend card
                TYPE_SHARE : "{0} shared {1}'s feed"
            }

        }).constant('APP_CONSTANTS',{
            NOT_FRIEND: 0,
			FRIEND : 1,
            INCOMING_FRIEND : 2 ,
            OUTGOING_FRIEND : 3,

            TYPE_SEARCH_BY_ALL : 0,
            TYPE_SEARCH_BY_NAME : 1,
            TYPE_SEARCH_BY_PHONE : 2,
            TYPE_SEARCH_BY_EMAIL : 3,
            TYPE_SEARCH_BY_RINGID : 4,
            TYPE_SEARCH_BY_LOCATION : 5,

            IMAGE_UPLOAD_LIMIT: 40,
            VIDEO_UPLOAD_LIMIT: 5,
            AUDIO_UPLOAD_LIMIT: 5,

            COVER_PIC_UPLOAD_MAXIMUM_WIDTH: 1480, //ALL PLATFORM COMPATIBALE
            COVER_PIC_UPLOAD_MAXIMUM_HEIGHT: 2048, //ALL PLATFORM COMPATIBALE
            COVER_PIC_UPLOAD_MINIMUM_WIDTH: 740, //ALL PLATFORM COMPATIBALE
            COVER_PIC_UPLOAD_MINIMUM_HEIGHT: 280, //ALL PLATFORM COMPATIBALE
            PROFILE_PIC_UPLOAD_MINIMUM_WIDTH: 100, //ALL PLATFORM COMPATIBALE
            PROFILE_PIC_UPLOAD_MINIMUM_HEIGHT: 100, //ALL PLATFORM COMPATIBALE

            COVER_PIC_CROP_WIDTH: 1480,
            COVER_PIC_CROP_HEIGHT: 547,
            PROFILE_PIC_CROP_WIDTH: 200,

            IMAGE_UPLOAD_MIN_WIDTH: 10,
            IMAGE_UPLOAD_MIN_HEIGHT: 10,

            MEDIA_UPLOAD_SIZE_LIMIT: 524288000,


            FEED_LIMIT : 6,


            LEFT_BAR_WIDTH : 200,
            RIGHT_BAR_WIDTH : 200,
            CELL_MARGIN : 10,

            //Third Party

            //GOOGLE_MAP_KEY : 'AIzaSyDwFgSnjLgWcHLEXS5E1dC8GgWLtxsH0zM'
            GOOGLE_MAP_KEY : 'AIzaSyCHl88HAklaOu6Q0TSfX5N5eA0vjdlBNuE',

            // mdaT
            NEWS_FEED_MEDIA_TYPE_AUDIO : 1,
            NEWS_FEED_MEDIA_TYPE_VIDEO: 2
        })
        .constant('PrivacySet',{
            PVC1 :{
                icon : 'post-ico only-i',
                text : 'Only me',
                value : 1
            },
            PVC2 : {
                icon : 'post-ico fri-i',
                text : 'Friends',
                value : 2
              },
            PVC3 : {
                icon : 'post-ico pub-i',
                text : 'Public',
                value : 3
              }
        })
        .constant('CLIENT_DATA_SIZE',460)
        .constant('AUTH_SERVER_CONFIG', {
            REQUEST_DELAY : 200
        })
        //
        .value("DATE_FORMAT","MMM d, y h:mm a");
})();

/*
 * © Ipvision
 */

(function() {
	'use strict';


    angular
        .module('ringid.config')
		.constant('OPERATION_TYPES',{
			'SYSTEM': {
				REQUEST_TYPE: {
	                'KEEP_ALIVE' : 1,
					'CONFIRMATION' : 2,
					'AUTHENTICATION': 3,
					'UPDATE': 4,
					'REQUEST': 5,
					'CALL' : 6,
					'CHAT': 7
				},
				/** News feed list actn start */
                TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS: 114,
				TYPE_NEWS_FEED : 88,
				TYPE_MY_NEWS_FEED : 94,
				TYPE_FRIEND_NEWSFEED : 110,
				TYPE_GROUP_NEWS_FEED : 198,

				TYPE_COMMENTS_FOR_STATUS : 84,


				ACTION_SHARE_STATUS : 191,
                ACTION_GET_FULL_COMMENT: 137,

				TYPE_ADD_MULTI_IMAGE :117,
				TYPE_ADD_STATUS : 177,

                // todo : replace old use of feed types variable into following #feedtype
                NEWS_FEED_TYPE_IMAGE : 1,
                NEWS_FEED_TYPE_STATUS : 2,
                NEWS_FEED_TYPE_MULTIPLE_IMAGE : 3,
                NEWS_FEED_TYPE_ALBUM : 4,
                NEWS_FEED_TYPE_AUDIO : 5,
                NEWS_FEED_TYPE_VIDEO : 6,

                //#endfeedtype
                //
                //todo : remove after assuring no use #feedtypeold
				TYPE_SINGLE_IMAGE_STATUS : 1,
	            TYPE_TEXT_STATUS : 2,
	            TYPE_MULTI_IMAGE_STATUS : 3,


                TYPE_DELETE_STATUS : 179,
                TYPE_EDIT_STATUS : 178,
				TYPE_LIKE_STATUS : 184,
				TYPE_UNLIKE_STATUS : 186,

                TYPE_ADD_STATUS_COMMENT : 181,
                TYPE_LIKE_COMMENT : 123,
                TYPE_UNLIKE_COMMENT : 125,
                TYPE_DELETE_STATUS_COMMENT : 183,
                TYPE_EDIT_STATUS_COMMENT : 189,

                TYPE_LIKES_FOR_STATUS : 92,
                TYPE_LIST_LIKES_OF_COMMENT : 116,
                TYPE_TAG_USER_LIST : 274,
                TYPE_WHO_SHARES_LIST : 249,

                TYPE_UPDATE_ADD_STATUS : 377,
                TYPE_UPDATE_EDIT_STATUS : 378,
                ACTION_UPDATE_SHARE_STATUS : 391,
                TYPE_UPDATE_LIKE_STATUS : 384,
                TYPE_UPDATE_UNLIKE_STATUS : 386,
                TYPE_UPDATE_DELETE_STATUS : 379,
                TYPE_UPDATE_ADD_STATUS_COMMENT : 381,
                TYPE_UPDATE_LIKE_COMMENT : 323,
                TYPE_UPDATE_UNLIKE_COMMENT : 325,
                TYPE_UPDATE_DELETE_STATUS_COMMENT : 383,
                TYPE_UPDATE_EDIT_STATUS_COMMENT : 389,

                ALBUM: {
                    TYPE_UPLOAD_ALBUM_IMAGE: 85,
                    TYPE_UPDATE_UPLOAD_ALBUM_IMAGE: 90,
                    TYPE_DELETE_ALBUM_IMAGE: 176,
                    TYPE_UPDATE_DELETE_ALBUM_IMAGE: 376,
                },
				/** News feed list actn end */
				AUTH: {
                    TYPE_INVALID_LOGIN_SESSION : 19,
					TYPE_SIGN_IN : 20, // login
					TYPE_SIGN_OUT : 22, // logout
					TYPE_SIGN_UP : 21, // register
                    TYPE_SESSION_VALIDATION : 76,
                    TYPE_MULTIPLE_SESSION : 75,

                    SIGNUP_SEND_CODE_EMAIL: 220,
                    SIGNUP_SEND_CODE_PHONE: 100,
                    SIGNUP_REGISTER: 126,

                    PASSWORD_RECOVER_SEND_CODE: 217,
                    PASSWORD_RECOVER_VERIFY_CODE: 218,
                    PASSWORD_RECOVER: 219,

				},
                 FRIENDS : {
                    TYPE_CONTACT_UTIDS: 29, // contact utids
                    TYPE_CONTACT_LIST: 23, // get contact list details with utids
                    //TYPE_PEOPLE_YOU_MAY_KNOW: 106,  // deprecated action number,use 31 istead
                    TYPE_PEOPLE_YOU_MAY_KNOW: 31,  // people you may know list
                    TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS: 32,  // people you may know list
                    TYPE_FRIEND_CONTACT_LIST: 107, // friend's contact list
                    TYPE_CONTACT_SEARCH: 34, // search contact
                    ACTION_FRIEND_SEARCH: 35, // friend search

                    TYPE_ADD_FRIEND : 127, //"add_friend"
                    TYPE_UPDATE_ADD_FRIEND : 327, //"add_friend"
                    TYPE_DELETE_FRIEND : 128, // "delete_friend"
                    TYPE_UPDATE_DELETE_FRIEND : 328, // "delete_friend"
                    TYPE_ACCEPT_FRIEND : 129, //"accept_friend"
                    TYPE_UPDATE_ACCEPT_FRIEND : 329, //"accept_friend"
                    TYPE_ACTION_BLOCK_UNBLOCK_FRIEND : 243,
                    TYPE_ACTION_CHANGE_FRIEND_ACCESS : 244
                },
                NOTIFICATION: {
                    TYPE_MY_NOTIFICATIONS: 111, // notification list

                    //todo add replace it in notification factory file
                    TYPE_SINGLE_NOTIFICATION : 113,


                    CLEAR_NOTIFICATION_COUNTER : 195,

                    MSG_TYPE_UPDATE_PROFILE_IMAGE: 1,// Example: FrinedName(fndN) updated his profile photo.
                    MSG_TYPE_UPDATE_COVER_IMAGE: 2,// Example: FrinedName(fndN) updated his cover photo.
                    MSG_TYPE_ADD_FRIEND: 3,// Example: FrinedName(fndN) wants to be friends with you.
                    MSG_TYPE_ACCEPT_FRIEND: 4,// Example: FrinedName(fndN) has accepted your friend request.
                    MSG_TYPE_ADD_GROUP_MEMBER: 5,// Example: FrinedName(fndN) added you in groupName(Using groupId need to find groupName).
                    MSG_TYPE_ADD_STATUS_COMMENT: 6,// Example: FriendName(fndN) commented on your status. or Example: FriendName(fndN) & previousFriendName Commented on your status.
                    MSG_TYPE_LIKE_STATUS: 7,// Example: FriendName(fndN) liked your status. or Example: FriendName(fndN) & previousFriendName liked your status.
                    MSG_TYPE_LIKE_COMMENT: 8,
                    MSG_TYPE_ADD_COMMENT_ON_COMMENT: 9,
                    MSG_TYPE_SHARE_STATUS: 10,
                    MSG_TYPE_LIKE_IMAGE: 11,
                    MSG_TYPE_IMAGE_COMMENT: 12,
                    MSG_TYPE_LIKE_IMAGE_COMMENT: 13,

                    MSG_TYPE_LIKE_AUDIO_MEDIA : 17,
                    MSG_TYPE_AUDIO_MEDIA_COMMENT : 18,
                    MSG_TYPE_LIKE_AUDIO_MEDIA_COMMENT : 19,
                    MSG_TYPE_AUDIO_MEDIA_VIEW : 20,
                    MSG_TYPE_LIKE_VIDEO_MEDIA : 21,
                    MSG_TYPE_VIDEO_MEDIA_COMMENT : 22,
                    MSG_TYPE_LIKE_VIDEO_MEDIA_COMMENT : 23,
                    MSG_TYPE_VIDEO_MEDIA_VIEW : 24,
                    MSG_TYPE_YOU_HAVE_BEEN_TAGGED: 25,


                    // below should be obsolete
                    MSG_TYPE_UPGRADE_FRIEND_ACCESS: 14,
                    MSG_TYPE_ACCEPT_FRIEND_ACCESS: 15,
                    MSG_TYPE_DOWNGRADE_FRIEND_ACCESS: 16

                },
                CIRCLE : {
                    TYPE_CREATE_GROUP: 50,
                    TYPE_GROUP_DETAILS : 52,
                    TYPE_LEAVE_GROUP: 53,
                    TYPE_GROUP_LIST: 70,
                    TYPE_GROUP_MEMBERS_LIST: 99,
                    TYPE_GROUP_MEMBERS_SEARCH_RESULT: 101,
                    TYPE_DELETE_GROUP: 152,// "delete_group";
                    TYPE_REMOVE_GROUP_MEMBER: 154,  //"remove_group_member";
                    TYPE_ADD_GROUP_MEMBER: 156,// "add_group_member";
                    TYPE_EDIT_GROUP_MEMBER: 158,//  "edit_group_member"; make member/admin

                    TYPE_UPDATE_ADD_GROUP: 352,// "delete_group";

                    TYPE_UPDATE_DELETE_GROUP: 352,// "delete_group";
                    TYPE_UPDATE_REMOVE_GROUP_MEMBER: 354,  //"remove_group_member";
                    TYPE_UPDATE_ADD_GROUP_MEMBER: 356,// "add_group_member";
                    TYPE_UPDATE_EDIT_GROUP_MEMBER: 358, //  "edit_group_member";

                    TYPE_UPDATE_ADD_TO_GROUP_BY_FRIEND: 51//  "friend created group with me.";
                },

                CHAT : {
                    FRIEND_CHAT_REQUEST : 175,
                    FRIEND_CHAT_UPDATE : 375
                },

                TAG_CHAT : {
                    TAG_CHAT_REQUEST_START : 134,
                    TAG_CHAT_UPDATE_START : 334,

                    TAG_CHAT_REQUEST_ADD_MEMBER : 135,
                    TAG_CHAT_UPDATE_ADD_MEMBER : 335
                },
                MEDIA: {
                    ACTION_ADD_MEDIA_CONTENT : 258,
                    ACTION_UPDATE_MEDIA_CONTENT : 259,
                    ACTION_DELETE_MEDIA_CONTENT : 260,
                    ACTION_MEDIA_ALBUM_CONTENT_LIST : 261,
                    ACTION_MEDIA_CONTENT_DETAILS : 262,

                    ACTION_ADD_MEDIA_ALBUM : 253,
                    ACTION_UPDATE_MEDIA_ALBUM : 254,
                    ACTION_DELETE_MEDIA_ALBUM : 255,
                    ACTION_MEDIA_ALBUM_LIST : 256,
                    ACTION_MEDIA_ALBUM_DETAILS : 257,
                    ACTION_MEDIA_SEARCH_RESULT : 277,
                    ACTION_SPECIFIC_MEDIA_RESULT:278,
                    ACTION_GET_TAGGED_MEDIA_SONGS:279,
                    ACTION_GET_HASHTAG_SUGGESTION:280,
                    ACTION_GET_TRENDING_KEYWORDS:281,

                    ACTION_INCREASE_MEDIA_CONTENT_VIEW_COUNT: 272,
                    ACTION_ADD_COMMENT_ON_MEDIA: 265,
                    ACTION_LIKE_UNLIKE_MEDIA: 264,
                    ACTION_EDIT_COMMENT_ON_MEDIA: 266,
                    ACTION_MEDIA_COMMENT_LIST: 270,
                    ACTION_MEDIA_LIKE_LIST: 269,
                    ACTION_DELETE_COMMENT_ON_MEDIA: 267,
                    ACTION_LIKE_UNLIKE_MEDIA_COMMENT: 268,
                    ACTION_MEDIACOMMENT_LIKE_LIST: 271,

                    ACTION_UPDATE_LIKE_UNLIKE_MEDIA: 464, //need work
                    ACTION_UPDATE_ADD_MEDIA_COMMENT : 465,
                    ACTION_UPDATE_EDIT_MEDIA_COMMENT : 466,
                    ACTION_UPDATE_DELETE_MEDIA_COMMENT : 467,
                    ACTION_UPDATE_LIKE_UNLIKE_MEDIA_COMMENT : 468,
                    ACTION_UPDATE_INCREASE_MEDIA_CONTENT_VIEW_COUNT: 472 // need work
                    //find out the action number for delete media comment
                },
                IMAGE : {
                    PROFILE_IMAGE_ALBUM_ID: 'profileimages',
                    COVER_IMAGE_ALBUM_ID: 'coverimages',
                    FEED_IMAGE_ALBUM_ID: 'default',
                    TYPE_FRIEND_ALBUM_IMAGES: 109,
                    FETCH_ALBUM_LIST: 96,
                    FETCH_FRIEND_ALBUM_LIST: 108,
                    TYPE_ALBUM_IMAGES: 97,
                    TYPE_COMMENTS_FOR_IMAGE: 89,
                    TYPE_LIKES_FOR_IMAGE : 93,
                    TYPE_IMAGE_COMMENT_LIKES : 196,
                    TYPE_LIKE_IMAGE: 185,
                    TYPE_UNLIKE_IMAGE: 187,
                    TYPE_IMAGE_DETAILS: 121,
					TYPE_EDIT_IMAGE_COMMENT : 194,
                    TYPE_ADD_IMAGE_COMMENT: 180,
                    TYPE_LIKE_UNLIKE_IMAGE_COMMENT : 197,
                    TYPE_DELETE_IMAGE_COMMENT: 182,
                    DELETE_IMAGE: 246,

                    TYPE_UPDATE_ADD_IMAGE_COMMENT: 380,
					TYPE_UPDATE_EDIT_IMAGE_COMMENT : 394,
                    TYPE_UPDATE_DELETE_IMAGE_COMMENT: 382,
                    TYPE_UPDATE_LIKE_IMAGE: 385, // no use may be
                    TYPE_UPDATE_UNLIKE_IMAGE: 387, // no use may be
	                TYPE_UPDATE_LIKE_UNLIKE_IMAGE_COMMENT : 397
                },
                PROFILE: {
                    //TYPE_USER_DETAILS: 95,
                    TYPE_CHANGE_COVER_PIC: 103,
                    TYPE_CHANGE_PROFILE_PIC: 63,
                    TYPE_REMOVE_PROFILE_IMAGE: 43,
                    TYPE_REMOVE_COVER_IMAGE: 104,
                    TYPE_ACTION_USER_MOOD:193, // current user mood change
                    TYPE_ACTION_USER_MOOD_PRESENCE:199, // user mood and presence

                    FETCH_FRIEND_MUTUAL_FRIEND_LIST: 118,

                    CHANGE_PASSWORD:130,

                    ACTION_USERS_PRESENCE_DETAILS : 136, // check presence
                    ACTION_USERS_PRESENCE_DETAILS_DATA : 336, // get presence data

                    TYPE_ACTION_CURRENT_USER_BASICINFO: 21,
                    TYPE_ACTION_OTHER_USER_BASICINFO: 95,
                    PHN_MAIL_VERIFICATION_CHECK:28,
                    //PHN_MAIL_VERIFICATION_CHECK_FRIEND:95,
                    TYPE_ACTION_GET_USER_DETAILS: 204,
                    TYPE_ACTION_LIST_WORK_AND_EDUCATIONS: 230,
                    TYPE_ACTION_MODIFY_USER_PROFILE: 25,
                    TYPE_ACTION_MODIFY_PRIVACY_SETTINGS: 74,
                    //ACTION_UPDATE_LOGIN_SETTINGS: 216,
                    TYPE_CHANGE_PRIVACY: 216,
                    TYPE_CHANGE_FRIEND_PRIVACY: 82,
                    SEND_VERIFICATION_CODE_TO_MAIL:221,
                    SEND_VERIFICATION_CODE_TO_PHONE:212,
                    TYPE_ACTION_ADD_EDUCATION: 231,
                    TYPE_ACTION_UPDATE_EDUCATION: 232,
                    TYPE_ACTION_REMOVE_EDUCATION: 233,
                    TYPE_ACTION_GET_WORK: 234,
                    TYPE_ACTION_GET_EDUCATION: 235,
                    TYPE_ACTION_GET_SKILL: 236,
                    TYPE_ACTION_ADD_SKILL: 237,
                    TYPE_ACTION_UPDATE_SKILL:238,
                    TYPE_ACTION_REMOVE_SKILL:239,
                    TYPE_ACTION_ADD_WORK:227,
                    TYPE_ACTION_UPDATE_WORK:228,
                    TYPE_ACTION_REMOVE_WORK:229,

                    ADD_SOCIAL_NETWORK: 276
                },
                FETCH_EMOTION_LIST : 273
			},
			STICKER: {
				GET_MY_STICKER: 206,
				ADD_REMOVE_STICKER: 207,
                ADD_JT_VALUE : 1,
                REMOVE_JT_VALUE : 3
			},
        });

})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.langugae.default', [])

        .constant('DF_KEY_VALUES',{

            'add_friend'    : 'Add Friend',
            'remove_friend' : 'Remove Friend',
            'common_friend' : 'Common Friend',
            'request_sent'  : 'Request Sent',
            'unfriend'      : 'Unfriend',
            'block'         : 'Block',
            'unblock'       : 'UnBlock',
            'edit'          : 'Edit',
            'update'        : 'Update',
            'delete'        : 'Delete',
            'cancel'        : 'Cancel',
            'save'          : 'Save',
            'text_add'      : 'Add',
            'accept'        : 'Accept',
            'remove'        : 'Remove',
            'change'        : 'Change',
            'send'          : 'Send',
            'verify'        : 'verify',
            'add'           : 'Add'

        })
        


})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.language', ['ringid.langugae.default'])

        .factory('languageConstant',['DF_KEY_VALUES', function(DF_KEY_VALUES){
//config_lang,default_lang
            var languages = {
                'default' :DF_KEY_VALUES
            };


            return {

                set : function(lang){

                    languages[lang] = {}
                },
                get : function(key,lang){
                    key = key || 'default';
                    //if(!lang || !languages[lang])lang = config_lang;

                   //return (!!languages[lang][key] && languages[lang][key]) || key;

                    return languages[key];
                }

            }
        }])


})();

(function () {
    "use strict";
    angular
        .module('ringid.common.stacked_map', [])
        .factory('$$stackedMap', function () {
            return {
                createNew: function (dosort, order) {
                    var stack = [], self = this;
                    dosort = dosort || false;
                    order = order || "desc";

                    //function sortIt(){
                    //    stack.sort(function(a,b){
                    //        return (order === 'desc')? b.value['sortBy']() - a.value['sortBy']():a.value['sortBy']() - b.value['sortBy']();
                    //    });
                    //}
                    function sortIt(prop_index) {
                        prop_index = prop_index || 'sortBy';
                        var gt = -1, lt = 1;
                        if (order === 'desc') {
                            gt = 1;
                            lt = -1;
                        }
                        stack.sort(function (a, b) {
                            if (b.value[prop_index]() > a.value[prop_index]())
                                return gt;
                            if (a.value[prop_index]() > b.value[prop_index]())
                                return lt;
                            return 0;
//                                return (order === 'desc') ? b.value[prop_index]() > a.value[prop_index]() : a.value[prop_index]() > b.value[prop_index]();
                        });
                    }
                    function getIndex(key) {
                        for (var i = 0; i < stack.length; i++) {
                            if (key == stack[i].key) {
                                return i;
                            }
                        }
                        return -1;
                    }

                    function navigateNext(key) {
                        var index = getIndex(key);
                        if (index === -1 || index === (stack.length - 1))
                            return false;

                        return stack[index + 1].value;

                    }

                    function navigatePrevious(key) {
                        var index = getIndex(key);
                        if (index === -1 || index === 0)
                            return false;

                        return stack[index - 1].value;

                    }

                     var ObjectToReturn = {
                        concat:  function(stackedMap) {
                            stack = stack.concat(stackedMap);
                        },
                        reset: function () {
                            //stack.length = 0;
                            stack = [];
                        },
                        all: function () {
                            return stack;
                        },
                        setStack: function (st) {
                            stack = st;
                        },
                        add: function (key, value) {
                            stack.push({
                                key: key,
                                value: value
                            });
                            if (dosort !== false) {
                                sortIt();
                            }
                            return false;
                        },
                        next: function (key) {
                            return navigateNext(key);
                        },
                        previous: function (key) {
                            return navigatePrevious(key);
                        },
                        getByIndex : function(i,withIndex){
                             if(stack.length && (i>=0 || i < stack.length)){
                                 return (withIndex) ?stack[i] : stack[i].value;
                             }
                             return false;
                         },
                        getIndex: function (key) {
                            return getIndex(key);
                        },
                        get: function (key) {
                            var i = getIndex(key);
                            return i >= 0 ? stack[i].value : !1;
                        },
                        save: function (key, value) {
                            var idx;
                            idx = getIndex(key);
                            if (idx === -1) {
                                ObjectToReturn.add(key, value);//pushing if not existing index
                            } else {
                                stack[idx] = {key: key, value: value};//saving if existing index
                            }
                            if (dosort !== false) {
                                sortIt();
                            }
                        },
                        sort: function (type, prop_index) {
                            if (type)
                                order = type;
                            sortIt(prop_index);

                        },

                        keys: function () {
                            var keys = [];
                            for (var i = 0; i < stack.length; i++) {
                                keys.push(stack[i].key);
                            }
                            return keys;
                        },
                        values : function(){

                            var values = [];
                            for (var i = 0; i < stack.length; i++) {
                                values.push(stack[i].value);
                            }
                            return values;
                        },
                        top: function (withIndex) {
                            if(!stack.length)return false;
                            withIndex = !!withIndex;//
                            return (withIndex) ?stack[stack.length - 1] : stack[stack.length - 1].value;
                        },
                        bottom: function(withIndex) {
                            if(!stack.length)return false;
                            withIndex = !!withIndex;//
                            return (withIndex) ?stack[0] : stack[0].value;
                        },
                        sliceBy: function (length, starting_index) {
                            //if(!length)return stack;
                            if (!starting_index)starting_index = 0;
                            if (length > stack.length || !length)length = stack.length;
                            return stack.slice(starting_index, length);
                        },


                        remove: function (key) {
                            var idx = getIndex(key);
                            //return idx > -1 ? stack.splice(idx, 1)[0]:[];
                            if(idx > -1) {
                                stack.splice(idx, 1);
                                return true;
                            } else {
                                return false;
                            }
                        },
                        removeTop: function () {
                            return stack.splice(stack.length - 1, 1)[0];
                        },
                        length: function () {
                            return stack.length;
                        },
                        nonClosedLength: function(){
                            var count = 0;
                            //var boxesArray = boxes.all();
                            angular.forEach(stack, function(box, key){
                                count += box.closedBox ? 1 : 0;
                            });
                            return count;
                        },
                        copy: function () { // shallow copy pushing just into a new stack but the value reference is same
                            var ob = self.createNew(dosort, order);
                            for (var i = 0; i < stack.length; i++) {
                                ob.add(stack[i].key, stack[i].value);
                            }
                            return ob;
                        },
                        doForAll : function(fn){ // looping through all and process a function
                            for (var i = 0; i < stack.length; i++) {
                               fn.call(null,stack[i].value);
                            }
                        }
                    };

                     return ObjectToReturn;
                }
            };
        });
})();
//{"dvc":5,"lot":1429161670578,"actn":175,"rc":0,"chIp":"38.127.68.55","sucs":true,"fndId":"2000003519","pckId":"20000045691429161692648","psnc":2,"chRp":1500,"pckFs":172412}
//{"dvc":5,"lot":1429161692821,"actn":175,"rc":0,"chIp":"38.127.68.55","sucs":true,"fndId":"2000004569","psnc":2,"chRp":1500,"pckFs":172412}





/*
* © Ipvision
*/

(function(){
    'use strict';
    angular
        .module('ringid.common.storage_factory', [])
        .factory('Storage', StorageFactory);


        StorageFactory.$inject = [];
        function StorageFactory() {
            var _storeKey,
                gotStore = false,
                storage;

            var _storageAvailable = function(type) {
                try {
                    var testStorage = window[type],
                        x = '__storage_test__';
                    testStorage.setItem(x, x);
                    testStorage.removeItem(x);
                    gotStore = true;
                    return window[type];
                }
                catch(e) {
                    gotStore = false;
                    return {};
                }
            };

            storage = _storageAvailable('localStorage');

            var _setKey = function(key) {
                _storeKey = key;
                if( angular.isDefined(storage[_storeKey]) )  { // in case localStorage data does not have key/utId
                    _setData(_storeKey, {});
                }
            };

            var _getKey = function(key) {
                switch(key) {
                        //key = 'ngStorage' + '-' + key;
                        //break;
                    case 'loginData':
                    case 'country':
                    case 'remInfo':
                    case 'stickerData':
                        break;

                    case 'chatOpenedBoxes':
                    case 'chatBoxes':
                    case 'cgInf':
                    case 'cts' :
                    case 'unreadMessageIds':

                    case 'mood':
                    case 'utIds':
                    case 'incomingUtIds':
                    case 'outgoingUtIds':
                    case 'suggestionUtIds':
                    case 'contacts':
                    case 'notikeys':
                    case 'notiseen':
                    case 'mediaRecent':
                    case 'albumname':
                    case 'circledata':
                    case 'circleut':
                    case 'myStickers':
                        key = _storeKey + '-' + key;
                        break;
                    default:
                        // nothing to do. send key as is
                }
                return key;
            };

            var _setData = function(key, data) {
                key = _getKey(key);
                if(gotStore) {
                    storage.setItem(key, angular.toJson(data));
                } else {
                    storage[key] =  angular.toJson(data);
                }
            };

            var _getData = function(key) {
                key = _getKey(key);
                if(gotStore) {
                    return angular.fromJson(storage.getItem(key));
                } else {
                    return angular.fromJson(storage[key]);
                }
            };

            var _clearData = function(key) {
                key = _getKey(key);
                if(gotStore) {
                    storage.removeItem(key);
                } else {
                    delete storage[key];
                }
            };

            function _init(loginData) {
                var regExMatch;

                function initStorage() {
                    //if( !_getData('utIds') ) { // initialize in case no data from previous login
                        //_setData('utIds', []);
                    //}
                    //if( !_getData('incomingUtIds') ) { // initialize in case no data from previous login
                        //_setData('incomingUtIds', []);
                    //}

                    //if( !_getData('outgoingUtIds') ) { // initialize in case no data from previous login
                        //_setData('outgoingUtIds', []);
                    //}

                    if( !_getData('contacts')) {
                        _setData('contacts', {});
                    }

                    if( !_getData('chatOpenedBoxes')) {
                        _setData('chatOpenedBoxes', {});
                    }

                    if( !_getData('chatBoxes')) {
                        _setData('chatBoxes', {});
                    }

                    if( !_getData('unreadMessageIds')) {
                        _setData('unreadMessageIds', []);
                    }

                    if( !_getData('mediaRecent')) {
                        _setData('mediaRecent', []);
                    }
                    // check if other user data present and delete
                    if(gotStore) {
                        var removeKeys = [];
                        for ( var i = 0, len = storage.length; i < len; ++i ) {
                            regExMatch = storage.key(i).match(/(\d+)-([a-z]+)/i);
                            if(regExMatch && regExMatch.length > 1 && regExMatch[1] != _storeKey  ) {
                                // remove this other user data
                                //console.warn('deleted key: ' + storage.key(i));
                                //console.log(regExMatch);
                                removeKeys.push(storage.key(i));

                            }

                        }
                        removeKeys.forEach(function(key) {
                            _clearData(key);
                        });
                    }

                }

                if(loginData) {
                    loginData = angular.fromJson(loginData);
                    _setKey(loginData.utId);
                    _setData('loginData', loginData);
                    initStorage();
                } else  if (Cookies.get('utId')){
                    _setKey(Cookies.get('utId'));
                    initStorage();
                }


            }

            var _asyncSetData = function(key, value){
                setTimeout(function(){
                    _setData(key, value);
                }, 200);
            };

            _init(_getData('loginData'));

            return {
                init: function(loginData) {
                    _init(loginData);
                },
                reset: function() {
                    _clearData('loginData');
                    _clearData('remInfo');
                    _clearData('contacts');
                    _clearData('chatOpenedBoxes');
                    _clearData('suggestionUtIds');
                },
                setData: function(key, value, async) {
                    if( !!async){
                        _asyncSetData(key, value);
                    }else{
                        _setData(key, value);
                    }
                },
                getData: function(key) {
                    return _getData(key);
                },
                deleteData : function(key){
                    _clearData(key);
                },
                // customised setter and getters
                setContact: function(utId, contact) {
                    if (utId) {
                        var contacts = _getData('contacts') || {};
                        if(contacts.hasOwnProperty(utId)) {
                            contacts[utId] = angular.extend({}, contacts[utId], contact);
                        } else {
                            contacts[utId] = contact;
                        }
                        _setData('contacts', contacts);
                    }
                },
                getContact: function(utId) {
                    var contacts =  _getData['contacts'];
                    if(contacts && contacts[utId]) {
                        return contacts[utId];
                    } else {
                        return null;
                    }
                },

                updateLoginData: function(key, value) {
                    var loginData = _getData('loginData');
                    loginData[key] = value;
                    _setData('loginData', loginData);
                },
                //
                setCookie : function(key, val, days){

                    if(!!days){
                        Cookies.set(key, val, { expires: days });
                    }else{
                        Cookies.set(key, val);
                    }
                },

                getCookie : function(key){
                    return Cookies.get(key);

                },
                removeCookie : function(key){
                    return Cookies.remove(key);
                }

            };

            /////////

            function _writeCookie (key, value, days) {
                var date = new Date();

                // Default at 365 days.
                days = days || 365;

                // Get unix milliseconds at current time plus number of days
                date.setTime(+ date + (days * 86400000)); //24 * 60 * 60 * 1000

                window.document.cookie = key + "=" + value + "; expires=" + date.toGMTString() + "; path=/";

                return value;
            }

        }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.sticker', ['ringid.config'])
        .value('STICKER_IMAGE_TYPE', {
            EMOTICON  : 1,
            LARGE_EMOTICON : 2,
            STICKER : 3

        })
        .value('STICKER_COLLECTION_CATEGORY_PRE_FETCH_COUNT', 5 );

})();

"use strict";

//Helpers.js

/**
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.sticker')
        .factory('StickerHelper', StickerHelper);


    StickerHelper.$inject = ['STICKER_IMAGE_TYPE', '$$stickerMap'];
    function StickerHelper(STICKER_IMAGE_TYPE, $$stickerMap) {

        var parseCategoryStickerData = function(data, stickersByCatIdMap, allStickerIdMap){
            /*
            * Parses Sticker Category Responses and returns a $stickerMap
            * $stickerMap Signature
            *
            * {
            *   collectionId : INT
            *   imageListMap : $stackedMap
            *   type : INT
            *   installed : BOOLEAN
            * }
            *
            * $stackedMap Signature
            * {
            *   name: STRING
            *   symbol : STRING
            *   type : ENUM (STICKER_IMAGE_TYPE)
            *   ID : INT
            * }
            *
            * */

            var allStickers = { type : STICKER_IMAGE_TYPE.STICKER, imageList: [] };
            var stickerImages = data.imagesList;

            if(angular.isArray(stickerImages)){


                var catId = stickerImages[0].sCtId;
                var stickerFactoryObj = allStickerIdMap[catId];

                allStickers['collectionId'] = stickerFactoryObj.getCollectionId();
                allStickers['categoryId'] = catId;

                angular.forEach(stickerImages, function(aStickerObj){

                    allStickers['imageList'].push({
                        name : aStickerObj.imUrl,
                        type: STICKER_IMAGE_TYPE.STICKER,
                        id : aStickerObj.imId
                    });

                    stickersByCatIdMap[aStickerObj.sCtId] =  $$stickerMap.create(allStickers);
                });

            }

            return stickersByCatIdMap;

        };

        return {
            parseCategoryStickerData : parseCategoryStickerData
        }

    }



})();

/**
 *
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.sticker')
        .controller('StickerPopupController', StickerPopupController);

        StickerPopupController.$inject = ['$boxInstance', 'localData', '$scope', 'StickerFactory'];
        function StickerPopupController($boxInstance, localData, $scope, StickerFactory) { // jshint ignore:line

            $scope.stickerCategories =StickerFactory.getStickerCategories();

            $scope.stickerCollections = StickerFactory.getStickerCollections();

            if (localData && localData.stickerKey) {
                $scope.sticker = StickerFactory.getStickerCategoryObject(localData.stickerKey);
                $scope.$rgDigest();
            }

            $scope.addSticker = function(sticker) {
                StickerFactory.addMySticker(sticker.getKey());
                $scope.$rgDigest();
            };

            $scope.removeSticker = function(sticker) {
                StickerFactory.removeMySticker(sticker.getKey());
                $scope.$rgDigest();
            };

            $scope.isInstalled = function(stickerId){
                return StickerFactory.isDownloaded(stickerId);
            };

            $scope.close = function($event){
                $boxInstance.close();
                if($event){
                    $event.preventDefault();
                    $event.stopPropagation();
                }
            };

            //$scope.showsticker = true;

        }
})();

/**
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.sticker')
        .factory('StickerCategoryModel', StickerCategoryModel);


    StickerCategoryModel.$inject = ['settings'];
    function StickerCategoryModel(settings){
        return {
            keyString : 'sCtId',
            getKeyString : function(){
                return StickerCategoryModel.keyString;
            },
            create : function(apiObject) {



                var factoryObject = {
                    sCtId: 0,
                    sctName: "",
                    sClId: 0,
                    cgBnrImg: "",
                    rnk: 1,
                    dtlImg: "",
                    thmColor: "",
                    txtColor: "",
                    cgNw: 0,
                    icn: "",
                    prz: 0,
                    free: 0,
                    dcpn: ""
                };

                var collectionObjectAdaptor = function (apiObject) {
                    /*
                     *
                     * @Adaptor
                     *
                     * Converts Collection Object Obtained Via API Methods to Factory Defined Attribute Set
                     *
                     * API PARAMS :
                     *
                     * LIST RESPONSE :
                     *
                     * API OBJECT 2 FACTORY OBJECT SIGNATURE :
                     *
                     * 1. sClId : sClId
                     * 2. name: name
                     * 3. txtColor : txtColor
                     * 4. bnrImg : bnrImg,
                     * 5. thmColor : thmColor
                     *
                     * */

                    var newfactoryObject = angular.extend({}, factoryObject, apiObject);

                    return newfactoryObject

                };

                if (angular.isObject(apiObject)) {
                    factoryObject = collectionObjectAdaptor(apiObject);
                }


                return {

                    getCategoryId: function () {
                        return factoryObject.sCtId;
                    },

                    setCategoryId: function (sCategoryId) {
                        factoryObject.sCtId = sCategoryId;
                    },

                    getCollectionId: function(){
                        return factoryObject.sClId;
                    },

                    setCollectionId : function(collectionId){
                      factoryObject.sClId = collectionId;
                    },

                    getKey: function () {
                        return this.getCategoryId()
                    },

                    setKey: function (sCategoryId) {
                        this.setCategoryId(sCategoryId);
                    },

                    getName: function () {
                        return factoryObject.sctName
                    },

                    setName: function (sCategoryName) {
                        factoryObject.sctName = sCategoryName;
                    },

                    getTextColor: function () {
                        return factoryObject.txtColor;
                    },

                    setTextColor: function (textColor) {
                        factoryObject.txtColor = textColor;
                    },

                    getBannerImage: function () {
                        return factoryObject.bnrImg;
                    },

                    setBannerImage: function (bannerImage) {
                        factoryObject.cgBnrImg = bannerImage;
                    },

                    getRank: function () {
                        return factoryObject.rnk;
                    },

                    setRank: function (rank) {
                        factoryObject.rnk = rank;
                    },

                    getDetailImage: function () {
                        return factoryObject.dtlImg;
                    },

                    getDetailImageUrl : function(){
                        var url = settings.stickerBase + this.getCollectionId() + '/' +  this.getCategoryId() + '/' + this.getDetailImage();
                        return url;
                    },

                    setDetailImage: function (detailImage) {
                        factoryObject.dtlImg = detailImage;
                    },

                    getNewCategory: function () {
                        return factoryObject.cgNw;
                    },

                    setNewCategory: function (newCategory) {
                        factoryObject.cgNw = newCategory;
                    },

                    getIconImage: function () {
                        return factoryObject.icn;
                    },
                    setIconImage: function (iconImage) {
                        factoryObject.icn = iconImage;
                    },

                    getIconImageUrl : function(){
                        var url = settings.stickerBase + this.getCollectionId() + '/' +  this.getCategoryId() + '/' + this.getIconImage();
                        return url;
                    },

                    getCaptionImageUrl :function(isHover){
                        var url = settings.stickerBase + this.getCollectionId() + '/' +  this.getCategoryId() + '/';
                        if(!!isHover){
                            return url + 'ca.png';
                        }else{
                            return url + 'c.png';
                        }
                    },

                    getPrice: function () {
                        return factoryObject.prz;
                    },
                    setPrice: function (price) {
                        factoryObject.prz = price;
                    },

                    isFree: function () {
                        return factoryObject.free;
                    },

                    setIsFree: function (isFree) {
                        factoryObject.free = isFree;
                    },

                    getDescription: function () {
                        return factoryObject.dcpn;
                    },

                    setDescription: function (description) {
                        factoryObject.dcpn = description;
                    },

                    getThumbColor: function () {
                        return factoryObject.thmColor;
                    },

                    setThumbColor: function (thumbColor) {
                        factoryObject.thmColor = thumbColor;
                    }
                }

            }



        }


    }


})();

/**
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.sticker')
        .factory('StickerCollectionModel', StickerCollectionModel);


    StickerCollectionModel.$inject = ['settings', '$$stackedMap'];
    function StickerCollectionModel(settings, $$stackedMap){
        return {

            create : function(apiObject) {
                var factoryObject = {
                    sClId : 0,
                    name : '',
                    txtColor : '',
                    bnrImg : "",
                    thmColor : "",
                    categories :  []
                };

                var collectionObjectAdaptor = function(apiObject){
                    /*
                     *
                     * @Adaptor
                     *
                     * Converts Collection Object Obtained Via API Methods to Factory Defined Attribute Set
                     *
                     * API PARAMS :
                     *
                     * LIST RESPONSE :
                     *
                     * API OBJECT 2 FACTORY OBJECT SIGNATURE :
                     *
                     * 1. sClId : sClId
                     * 2. name: name
                     * 3. txtColor : txtColor
                     * 4. bnrImg : bnrImg,
                     * 5. thmColor : thmColor
                     *
                     * */

                     var newfactoryObject = angular.extend({}, factoryObject, apiObject);

                     return newfactoryObject

                };

                if (angular.isObject(apiObject)) {
                    factoryObject = collectionObjectAdaptor(apiObject);
                }

                return {
                    getId : function(){
                        return factoryObject.sClId;
                    },

                    setId : function(sClId){
                        factoryObject.sClId = sClId;
                    },

                    getKey : function(){
                        return this.getId();
                    },

                    setKey : function(key){
                        this.setId(key);
                    },

                    getName : function(){
                        return factoryObject.name
                    },

                    setName : function(name){
                        factoryObject.name = name;
                    },

                    getTextColor : function(){
                        return factoryObject.txtColor;
                    },

                    setTextColor : function(textColor){
                        factoryObject.txtColor = textColor;
                    },

                    getBannerImage : function(){
                        return factoryObject.bnrImg;
                    },

                    setBannerImage : function(bannerImage){
                        factoryObject.bnrImg =  bannerImage;
                    },

                    getBannerImageUrl : function(){
                        var url = settings.stickerBase + this.getId() + '/' + this.getBannerImage();
                        return url;
                    },

                    getThumbColor : function(){
                        return factoryObject.thmColor;
                    },

                    setThumbColor : function(thumbColor){
                        factoryObject.thmColor = thumbColor;
                    },

                    addCategories : function(aCategoryId){
                        factoryObject.categories.push(aCategoryId);
                    },

                    removeCategories : function(catId){
                        factoryObject.categories.splice(catId, 1);
                    },

                    getCategories : function(){
                        return factoryObject.categories;
                    }
                }
            }

        }

    }


})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.sticker')
        .service('stickerHttpService', stickerHttpService);

    stickerHttpService.$inject = ['$ringhttp', '$$connector', 'settings', 'OPERATION_TYPES'];
    function stickerHttpService($ringhttp, $$connector, settings, OPERATION_TYPES) {
        var STICKER_OPERATION_TYPES = OPERATION_TYPES.STICKER;
        var	SYSTEM_REQUEST_TYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;
        var self = this;

        self.go = function (url, method, data ) {
            method = method || 'get';
            data = data || [];
            return $ringhttp[method](url, data);
        };

        self.getAll = function(){
            var url = settings.stickerApi + '?all=1';
            return self.go(url);
        };

        self.getStickerCategoriesByCollectionId = function (collectionId) {
            var url = settings.stickerApi + '?collectionId=' + collectionId;
            return self.go(url);
        };

        self.getStickersByCatId = function (catId) {
            var url = settings.stickerApi + '?categoryId=' + catId;
            return self.go(url);
        };


        self.getMyStickers = function () {
            var payload = {
                actn: STICKER_OPERATION_TYPES.GET_MY_STICKER
            };
            return $$connector.request(payload, SYSTEM_REQUEST_TYPE.REQUEST);

        };

        self.addSticker = function (obj) {
            var payload = {
                actn: STICKER_OPERATION_TYPES.ADD_REMOVE_STICKER,
                catId: obj.catId,
                jt : STICKER_OPERATION_TYPES.ADD_JT_VALUE
            };

            return $$connector.request(payload, SYSTEM_REQUEST_TYPE.UPDATE);
        };

        self.removeSticker = function (obj) {
            var payload = {
                actn: STICKER_OPERATION_TYPES.ADD_REMOVE_STICKER,
                catId: obj.catId,
                jt : STICKER_OPERATION_TYPES.REMOVE_JT_VALUE
            };

            return $$connector.request(payload, SYSTEM_REQUEST_TYPE.UPDATE);
        };



    }
})();

/**
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.sticker')
        .service('StickerEmoticonService', StickerEmoticonService)
        .factory('StickerEmoticonFactory', StickerEmoticonFactory);

    StickerEmoticonService.$inject = [ 'STICKER_IMAGE_TYPE', 'settings' ];
    function StickerEmoticonService(STICKER_IMAGE_TYPE, settings){
        var self = this;

        /*var emoPattern = /\(laugh\-with\-tears\)|:\)|:\(|:D|\(cool\)|:O|;\)|;\(|\(:|:l|:P|:\$|\|\-\)|\|\-\(|\(in\-love\)|\(evil\-grin\)|\(yn\)|\(yawn\)|\(puke\)|\(doh\)|\(angry\)|\(angry2\)|\(wasntme\)|\(party\)|\(devil\)|\(angel\)|\(worry\)|\(nerd\)|\(zipping\-his\-mouth\)|\(facepalm\)|\(envy\)|\(wait\)|\(rofl\)|\(dap\)|\(shake\)|\(an\-happy\)|\(shame\)|\(sta\)|\(nice\)|\(ms\-of\)|\(tness\)|\(e\-smile\)|\(trouble\)|\(over\)|\(amour\)|\(minus\)|\(unex\)|\(forgotten\)|\(flashed\)|\(head\-hot\)|\(re\-sad\)|\(creative\-man\)|\(regretted\-borne\-crying\)|\(extreme\-crying\)|\(pointing\-an\-accusing\-finger\)|\(with\-headphones\)|\(furious\)|\(exhausted\)|\(shouting\)|\(panic\)|:x|\(reading\-a\-newspaper\)|\(happy\-birthday\)|\(run\)|:\*\(girl\)|:\*\(boy\)|\(cartoon\-alarm\-clock1\)|\(cartoon\-alarm\-clock2\)|\(brokenheart\)|<3|\(fire\)|\(flower\)|\(gift\)|\(kiss\)|\(pinkheart\)|\(redkiss\)|\(\*\)|\(sun\)/g;
        */var emoMap = {
            ':D' : 'awesome.png',
            ':<3' : 'loved.png',
            '*D*' : 'excited.png',
            ':)' : 'happy.png',
            ':\-(' : 'alone.png',
            '(cool)' : 'cool.png',
            'x=(' : 'angry.png',
            'o_\-' : 'fresh.png',
            ':>s' : 'sick.png',
            ':?' : 'confused.png',
            ';|' : 'thoughtful.png',
            ':*' : 'fantastic.png',
            ':=(' : 'upset.png',
            '>u<' : 'blah.png',
            '(amused)' : 'amused.png',
            '(hot)' : 'hot.png',
            '(\-_^)' : 'motivated.png',
            '(^_^)' : 'satisfied.png',
            '>=<' : 'hurt.png',
            ':(s' : 'ill.png',
            '(cute)' : 'cute.png',
            'I=)' : 'relived.png',
            ':O' : 'shoked.png',
            '(beautiful)' : 'beautiful.png',
            ':|p' : 'hyper.png',
            '(pumped)' : 'pumped.png',
            '%)' : 'drunk.png',
            'o(' : 'impatient.png',
            '(restless)' : 'restless.png',
            ':-)' : 'emotional.png',
            '(hungry)' : 'hungry.png',
            '(nostalgic)' : 'nostalgic.png',
            '(blessed)' : 'blessed.png',
            '</3' : 'heartboken.png',
            '(naughty)' : 'naughty.png',
            '(entertained)' : 'entertained.png',
            '(broken)' : 'broken.png',
            '(cold)' : 'cold.png',
            '(down)' : 'down.png',
            '(sorry)' : 'sorry.png',
            '(frustrated)' : 'frustrated.png',
            ':\-s' : 'scared.png',
            ':@' : 'fuming.png',
            'NN' : 'run.png',
            ':\'q' : 'crying.png',
            ':\'D' : 'laughing.png',
            ':\'(' : 'soreness.png',
            '(boiling)' : 'boiling.png',
            ':x' : 'xmode.png',
            ':p' : 'cheeky.png',
            ':=0' : 'laughing-inside.png',
            '|\-O' : 'yawn.png',
            ':6' : 'devil.png',
            ':\-#' : 'zipped-lip.png',
            '(clap)' : 'clap.png',
            '<3' : 'heart.png',
            '(pink\-heart)' : 'pink-heart.png',
            '(k)' : 'pink-lip.png',
            '(#)' : 'sun.png',
            '(*)' : 'star.png',
            '(g)' : 'gift.png',
            '(K)' : 'red-lip.png',
            '(f)' : 'rose.png'

        },// duplicate glu for htmlentityencode
        largeEmoMap = angular.extend({
                                         ':\&lt;3' : 'loved.png',
                                         '\&lt;\/3' : 'heartboken.png',
                                         '\&gt;=\&lt;' : 'hurt.png',
                                         '\&gt;u\&lt;' : 'blah.png',
                                         ':\&gt;s' : 'sick.png',
                                         '\&lt;3' : 'heart.png'

                                         // ':\&lt;3' : 'loved.png',
                                         // '\&lt;\/3' : 'heartboken.png',
                                         // '\&gt;=\&lt;' : 'hurt.png',
                                         // '\&gt;u\&lt;' : 'blah.png',
                                         // ':\&gt;s' : 'sick.png',
                                         // '\&lt;3' : 'heart.png',

                                     }, emoMap);
                    //emo map converting function
         function escapeRegExp(str) {
              return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
         }
         var retstr = [];
         for(var key in largeEmoMap){
            if(largeEmoMap.hasOwnProperty(key)){
               retstr.push(escapeRegExp(key));
            }
         }
         // for


        var emoPattern = new RegExp(retstr.join("|"),'g');

        self.getEmoImageName = function(symbolKey){
            try{

                return emoMap[symbolKey]

            }catch(e){
                return 'default.png'
            }
        };


        self.getAllEmoticons = function(){
            var allEmoticons = { type : STICKER_IMAGE_TYPE.EMOTICON, imageList: []},i=0;
            angular.forEach(emoMap, function(anEmoImageName, emoSymbol){
                //console.log(anEmoImageName,emoSymbol,i++);
                allEmoticons['imageList'].push({
                    name : anEmoImageName,
                    symbol : emoSymbol,
                    type: STICKER_IMAGE_TYPE.EMOTICON

                });
            });

            return allEmoticons;
        };

        self.getEmoticonUrlMap = function(){
            var emoticonUrlMap = {}
            angular.forEach(emoMap, function(anEmoImageName, emoSymbol){
                emoticonUrlMap[emoSymbol] = settings.emoticonBase + anEmoImageName;
            });
            return emoticonUrlMap;
        };
        self.getEmoticonUrlMapWithHtmlEncode = function(){
            var emoticonUrlMap = {}
            angular.forEach(largeEmoMap, function(anEmoImageName, emoSymbol){
                emoticonUrlMap[emoSymbol] = settings.emoticonBase + anEmoImageName;
            });
            return emoticonUrlMap;
        };

        self.getEmoticonPattern = function(){
            return emoPattern;
        };
    }


    StickerEmoticonFactory.$inject = ['StickerEmoticonService'];
    function StickerEmoticonFactory(StickerEmoticonService){


        function getAllEmoticons(){
            return StickerEmoticonService.getAllEmoticons()
        }

        function getEmoImageName(symbolKey){
            return StickerEmoticonService.getEmoImageName(symbolKey);
        }

        function getStickerImageUrl(collectionId, categoryId, imageName){
            var url = settings.stickerBase + collectionId + '/' + categoryId + '/' + imageName;
            return url;
        }

        return {

            getAllEmoticons : getAllEmoticons,
            getEmoImageName: getEmoImageName,
            getStickerImageUrl: getStickerImageUrl,
            getEmoticonUrlMap : StickerEmoticonService.getEmoticonUrlMap,
            getEmoticonUrlMapWithHtmlEncode : StickerEmoticonService.getEmoticonUrlMapWithHtmlEncode,
            getEmoticonPattern : StickerEmoticonService.getEmoticonPattern

        }

    }
})();
    /**
     //emo map converting function
     function escapeRegExp(str) {
          return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
     }
     var retstr = [];
     for(var key in map){
        if(map.hasOwnProperty(key)){
           retstr.push(escapeRegExp(key));
        }
     }
    retstr.join("|");
     */


 /**
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.sticker')
        .factory('StickerFactory', StickerFactory)
        .factory('$$stickerMap', $$stickerMap)
        .factory('$$stickerImageMap', $$stickerImageMap);

    $$stickerImageMap.$inject = ['settings', 'STICKER_IMAGE_TYPE'];
    function $$stickerImageMap(settings, STICKER_IMAGE_TYPE) { //jshint ignore:line

        return {
            create: function (ob, stickerType, stickerSrcBaseUrl) {
                //var types = {e: 1, el: 2, s: 3}; //emoticon : 1, emoticonlarge : 2 ,sticker 3
                var image = {
                    id: ob.id || 0,
                    name: ob.name || '',
                    symbol: ob.symbol || ob.name,
                    type: ob.type || 0,
                    src: (stickerType === 1) ? settings.emoticonBase + ob.name : stickerSrcBaseUrl + ob.name,
                    isEmoticon: stickerType === STICKER_IMAGE_TYPE.EMOTICON,
                    isLargeEmoticon: stickerType === STICKER_IMAGE_TYPE.LARGE_EMOTICON,
                    isSticker: stickerType === STICKER_IMAGE_TYPE.STICKER
                };

                return {
                    getKey: function () {
                        return image.id;
                    },
                    src: function () {
                        return image.src;
                    },
                    symbol: function () {
                        return image.symbol;
                    },
                    getName: function () {
                        return image.name;
                    },
                    srcWithoutBase: function () {
                        return image.src.replace(settings.stickerBase,'');
                    },
                    isEmoticon: function () {
                        return image.isEmoticon;
                    },
                    isLargeEmoticon: function () {
                        return image.isLargeEmoticon;
                    },
                    isSticker: function () {
                        return image.isSticker;
                    }
                };
            }
        };
    }

    $$stickerMap.$inject = ['$$stackedMap', '$$stickerImageMap', 'settings'];
    function $$stickerMap($$stackedMap, $$stickerImageMap, settings) { //jshint ignore:line


        return {
            create: function (ob, installed) {
                //var stickerSrcBaseUrl = settings.stickerImageBase + ob.collectionId + '/' + ob.categoryId + '/';
                var stickerSrcBaseUrl = settings.stickerBase + ob.collectionId + '/' + ob.categoryId + '/';

                RingLogger.information('$$stickerMap', RingLogger.tags.STICKER);
                RingLogger.print(ob, RingLogger.tags.STICKER);
                var image,
                    sticker = {
                        categoryId: ob.categoryId || 0,
                        collectionId: ob.collectionId || 0,
                        imageListMap: $$stackedMap.createNew(),
                        type: ob.type || 0,
                        isEmoticon: (ob.type === 1) ? true : false,
                        isLargeEmoticon: (ob.type === 2) ? true : false,
                        isSticker: (ob.type === 3) ? true : false,
                        regularUrl: (ob.type === 1) ? '/images/emoticon/c.png' :  + stickerSrcBaseUrl + 'c.png',
                        hoverUrl: (ob.type === 1) ? '/images/emoticon/ca.png' : stickerSrcBaseUrl + 'ca.png',
                        installed: installed || false
                    };

                // RingLogger.information(ob, RingLogger.tags.STICKER);
                for (var key=0;key<ob.imageList.length;key++) {
                    image = $$stickerImageMap.create(ob.imageList[key], sticker.type, stickerSrcBaseUrl);
                    sticker.imageListMap.add(image.getKey(), image);
                }

                return {
                    sortBy: function () {
                        return sticker.categoryId;
                    },
                    isInstalled: function () {
                        return sticker.installed;
                    },
                    setInstalled: function (isInstalled) {
                        sticker.installed = isInstalled;
                    },
                    isEmoticon: function () {
                        return sticker.isEmoticon;
                    },
                    isLargeEmoticon: function () {
                        return sticker.isLargeEmoticon;
                    },
                    isSticker: function () {
                        return sticker.isSticker;
                    },
                    getKey: function () {
                        return sticker.categoryId;
                    },
                    getImages: function () {
                        return sticker.imageListMap;
                    },
                    getType: function () {
                        return sticker.type;
                    },
                    link: function () {
                        return sticker.regularUrl;
                    },
                    hoverLink: function () {
                        return sticker.hoverUrl;
                    }
                };
            }
        };
    }

    StickerFactory.$inject = ['$$stackedMap', '$$stickerMap', 'stickerHttpService', 'StickerEmoticonFactory', 'StickerHelper',
        'StickerCategoryModel', 'StickerCollectionModel',  'STICKER_IMAGE_TYPE', '$$q', 'Storage'];
    function StickerFactory($$stackedMap, $$stickerMap, stickerHttpService, StickerEmoticonFactory, StickerHelper, // jshint ignore:line
                            StickerCategoryModel, StickerCollectionModel,  STICKER_IMAGE_TYPE, $q, Storage) {

        var localStorageKey = 'stickerData';

        var myStickerLocalStorageKey = 'myStickers';

        /* Cashes All FactoryStickerObj By CategoryId */
        var allStickerIdMap = {};

        /* Cashes sticker details by catIds */
        var stickersByCatIdMap = {};

        /* Stores the sticker categories by group */
        var stickerCategories = {
            free : [],
            new : [],
            top : []
        };

        /* Stores sticker categories by collection id */
        var stickerCollections = {};

        /* Stores My Sticker CatIds */
        var myStickerList = {};


        /* $stickerMap holds the Emoticon and Sticker*/

        /* All Emoticon $stickerMap */
        var allEmoticon = StickerEmoticonFactory.getAllEmoticons();
        var emoticonMap = $$stickerMap.create(allEmoticon,true);

        /* All Sticker $stickerMap */
        //var allStickersMap = $$stickerMap.create(allEmoticon,true);

        var myStickerRefreshed = false;


        var initStickersByCatId = function(catId){
            var deferred = $q.defer();

            if(!stickersByCatIdMap[catId]){
                stickerHttpService.getStickersByCatId(catId)
                    .success(function(data){
                        if(!!data && data.sucs  === true){
                            StickerHelper.parseCategoryStickerData(data, stickersByCatIdMap, allStickerIdMap);
                            deferred.resolve(data);

                        }else{
                            RingLogger.information('ERROR IN STICKER DETAIL INIT FOR INVALID DATA', RingLogger.tags.STICKER);
                        }

                    }).error(function(response){
                        RingLogger.information('ERROR IN STICKER DETAIL INTT BY CAT ID', RingLogger.tags.STICKER);
                        deferred.reject(response);
                    });
            }

            return deferred.promise;
        };

        function initCollectionCategories(collectionFactoryObject){

            /* Parses Collection Categories To PRE FETCH LIMIT
             *
             * Does API Request To Get Categories under a collections.
             *
             * */
            // todo add limit on this call if there are too many collections, paginate support

            try{

                var collectionId = collectionFactoryObject.getKey();

                stickerHttpService.getStickerCategoriesByCollectionId(collectionId)
                    .success(function(data){
                        RingLogger.print(data, RingLogger.tags.STICKER);
                        if(!!data && data.sucs === true && !!data.categoriesList){

                            var categoryList = data.categoriesList;

                            if(angular.isArray(categoryList)){
                                angular.forEach(categoryList, function(aCategory){

                                    var keyString = aCategory[StickerCategoryModel.getKeyString()];
                                    var stickerCategoryFactoryObject = allStickerIdMap[keyString];

                                    if(!stickerCategoryFactoryObject){
                                        stickerCategoryFactoryObject = StickerCategoryModel.create(aCategory);
                                        allStickerIdMap[stickerCategoryFactoryObject.getKey()] = stickerCategoryFactoryObject;
                                    }

                                    collectionFactoryObject.addCategories(stickerCategoryFactoryObject.getKey());

                                });
                            }

                        }else{
                            RingLogger.error('ERROR IN COLLECTION CATEGORY FETCH, INVALID RESPONSE', RingLogger.tags.STICKER);
                        }
                    }).error(function(response){
                        RingLogger.error('ERROR COLLECTION CATEGORY FETCH', response, RingLogger.tags.STICKER);
                    });

            }catch(e){
                RingLogger.error('PARSING ERROR IN COLLECTION CATEGORY LIST', RingLogger.tags.STICKER);
            }

        }

        function initStickerCollectionAndCategories(dataList){

            /* Parse Free Categories */
            try{
                angular.forEach(dataList.freeCategoriesList, function(aCategory){

                    var aStickerCategoryFactoryObject = StickerCategoryModel.create(aCategory);
                    allStickerIdMap[aStickerCategoryFactoryObject.getKey()] = aStickerCategoryFactoryObject;
                    stickerCategories.free.push(aStickerCategoryFactoryObject.getKey());

                });
            }catch(e){
                RingLogger.error('PARSING ERROR STICKER FREE CATEGORY LIST', e, RingLogger.tags.STICKER);
            }

            /* Parse Top Categories */
            try{
                angular.forEach(dataList.topCategoriesList, function(aCategory){

                    var aStickerCategoryFactoryObject = StickerCategoryModel.create(aCategory);
                    allStickerIdMap[aStickerCategoryFactoryObject.getKey()] = aStickerCategoryFactoryObject;
                    stickerCategories.top.push(aStickerCategoryFactoryObject.getKey());

                });
            }catch(e){
                RingLogger.error('PARSING ERROR STICKER Top CATEGORY LIST', e, RingLogger.tags.STICKER);
            }

            /* Parse New Categories */
            try{
                angular.forEach(dataList.stNewCategoriesList, function(aCategory){

                    var aStickerCategoryFactoryObject = StickerCategoryModel.create(aCategory);
                    allStickerIdMap[aStickerCategoryFactoryObject.getKey()] = aStickerCategoryFactoryObject;
                    stickerCategories.new.push(aStickerCategoryFactoryObject.getKey());

                });
            }catch(e){
                RingLogger.error('PARSING ERROR STICKER New CATEGORY LIST', e, RingLogger.tags.STICKER);
            }

            /* Parse Collections */
            try{
                angular.forEach(dataList.stickerCollectionsList, function(aCollection){

                    var aStickerCollectionFactoryObject = StickerCollectionModel.create(aCollection);

                    stickerCollections[aStickerCollectionFactoryObject.getKey()] = aStickerCollectionFactoryObject;

                    initCollectionCategories(aStickerCollectionFactoryObject);

                });
            }catch(e){
                RingLogger.error('PARSING ERROR STICKER FREE CATEGORY LIST', e, RingLogger.tags.STICKER);
            }

        }

        function fetchAllStickerData(){
            stickerHttpService.getAll().
                success(function(data){
                    try{
                        if(!!data && data.sucs === true){
                            saveStickerData(data);
                            initStickerCollectionAndCategories(data);
                            initMyStickers();
                        }
                    }catch(e){
                        RingLogger.information(e, RingLogger.tags.STICKER);
                    }

                }).error(function(response){
                    RingLogger.information(response, RingLogger.tags.STICKER);
                });
        }

        function getStickerData(){
            try{
                return Storage.getData(localStorageKey);
            }catch(e){
                return false;
            }
        }

        function saveStickerData(data){
            Storage.setData(localStorageKey, data);
        }

        function saveMyStickers(){
            Storage.setData(myStickerLocalStorageKey, myStickerList);
        }

        function initMyStickers(){
            myStickerList = Storage.getData(myStickerLocalStorageKey);
            if(!myStickerRefreshed || !myStickerList) {
                myStickerList = {};
                stickerHttpService.getMyStickers().then(function(response){
                    if(response.sucs === true){
                        angular.forEach(response.catIds, function(aCatId){
                            myStickerList[aCatId] = 1;
                            if(!!stickersByCatIdMap[aCatId]) {
                                stickersByCatIdMap[aCatId].setInstalled(true);
                            }
                        });
                        saveMyStickers();
                    }
                });

            }
        }

        function initStickerData(allData){
            try{
                initStickerCollectionAndCategories(allData);
            }catch(e){
                RingLogger.error('ERROR IN INIT STICKER DATA', RingLogger.tags.STICKER);
            }
        }

        function getStickerObjectById(stickerId) {
            try{
                return allStickerIdMap[stickerId];
            }catch(e){
                RingLogger.information('ERROR IN GETTING STICKER BY ID', RingLogger.tags.STICKER);
                return {};
            }
        }

        return {

            initStickerData : function(refresh){
                if(refresh === true){
                    fetchAllStickerData();
                }else{
                    var localData = getStickerData();
                    if(!angular.isObject(localData)){
                        fetchAllStickerData();
                    }else{
                        initStickerData(localData);
                        initMyStickers();
                    }
                }

            },
            getNoOfMyStickers: function () {
                return myStickerList ? Object.keys(myStickerList).length : 0;
            },

            getStickerCategories : function(type){
              return type ? stickerCategories[type] : stickerCategories;
            },

            getStickerCollections : function(){
              return stickerCollections;
            },

            getMyStickerCatIds: function () {
                return myStickerList ? Object.keys(myStickerList) : [];
            },

            getStickerMapByCatId :function(catId){
                var deferred = $q.defer();

                if(!!stickersByCatIdMap[catId]){
                    deferred.resolve(stickersByCatIdMap[catId]);

                }else{
                    initStickersByCatId(catId).then(function(){
                        deferred.resolve(stickersByCatIdMap[catId]);

                    }, function(response){
                        deferred.reject(response);
                    });
                }
                return deferred.promise;

            },
            isDownloaded : function(stickerCatId){
                return !!myStickerList[stickerCatId];
            },

            getStickerCategoryObject: function (key) {
                return getStickerObjectById(key);
            },

            getEmoticonMap: function () {
                return emoticonMap;
            },

            getMyStickers : function(){
                return stickerHttpService.getMyStickers();
            },

            addMySticker: function (stickerCatId) {
                try{
                    myStickerList[stickerCatId] = 1;
                    saveMyStickers();

                    if(!!stickersByCatIdMap[stickerCatId]) {
                        stickersByCatIdMap[stickerCatId].setInstalled(true);
                    }

                }catch(e){
                    RingLogger.error('ERROR IN ADD MY STICKER', e, RingLogger.tags.STICKER);
                }

                stickerHttpService.addSticker({catId: stickerCatId}).then(function (data) {
                    if(data.sucs !== true){
                        myStickerList[stickerCatId] = 0;
                        stickersByCatIdMap[stickerCatId].setInstalled(false);
                    }
                },function (errData) {
                    RingLogger.information(errData, RingLogger.tags.STICKER);

                });
            },
            removeMySticker: function (stickerCatId) {
                try{
                    delete myStickerList[stickerCatId];
                    saveMyStickers();

                    if(!!stickersByCatIdMap[stickerCatId]) {
                        stickersByCatIdMap[stickerCatId].setInstalled(false);
                    }

                }catch(e){
                    RingLogger.error('ERROR IN ADD MY STICKER', e, RingLogger.tags.STICKER);
                }

                stickerHttpService.removeSticker({catId: stickerCatId}).then(function (data) {
                    if(data.sucs !== true){
                        myStickerList[stickerCatId] = 1;
                        stickersByCatIdMap[stickerCatId].setInstalled(true);
                    }
                },function (errData) {
                    RingLogger.information(errData, RingLogger.tags.STICKER);
                });

            }

        };
    }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.sticker')
        .directive('rgStickerCategory', rgStickerCategory);

        rgStickerCategory.$inject=['StickerFactory'];

        function rgStickerCategory(StickerFactory) {
            return {
                restrict: 'E',
                templateUrl: 'pages/partials/stickers/sticker-category.html',
                scope : {
                    categories : '=categories'
                },
                link: function(scope) {

                    scope.getStickerCategory = StickerFactory.getStickerCategoryObject;

                    scope.showPreview = function(stickerId) {
                        return function() {
                            return {stickerKey: stickerId};
                        };
                    };

                    scope.isInstalled = function(stickerId){
                        return StickerFactory.isDownloaded(stickerId);
                    };

                    scope.addSticker = function(stickerId) {
                        StickerFactory.addMySticker(stickerId);
                        scope.$rgDigest();
                    };

                    scope.removeSticker = function(stickerId) {
                        StickerFactory.removeMySticker(stickerId);
                        scope.$rgDigest();
                    };


                }
            };
        }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.sticker')

        .directive('rgStickerCategoryList',
        function () {
            return {
                restrict: 'E',
                templateUrl: 'pages/partials/stickers/sticker-category-list.html',
                scope : {
                    categories : '=categories'
                }
            };
        }
    )



})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.sticker')

        .directive('rgStickerCollectionList',
        function () {
            return {
                restrict: 'E',
                templateUrl: 'pages/partials/stickers/sticker-collection-list.html',
                scope : {
                    'collections' : '='
                },
                link: function(scope) {

                    scope.currentCollectionIdToShow = 0;

                    scope.shouldShowCollectionCategories = function(collectionId){
                        return scope.currentCollectionIdToShow == collectionId;
                    };

                    scope.showCollectionCategories =  function(collectionId){
                        scope.displayingCollections = !scope.displayingCollections;
                        scope.currentCollectionIdToShow = collectionId;
                        scope.$rgDigest();
                    };

                    scope.displayingCollections = true;
                }
            };
        }
    );



})();


(function () {
    'use strict';
    var app;
      
      angular.module('rg.custom.compiler.directive', [], ['$compileProvider',function($compileProvider) {
    // configure new 'compile' directive by passing a directive
    // factory function. The factory function injects the '$compile'
    $compileProvider.directive('rgCompile', ['$compile',function($compile) {
      // directive factory creates a link function
      return function(scope, element, attrs) {
        
        scope.$watch(
          function(scope) {
             // watch the 'compile' expression for changes
            return scope.$eval(attrs.rgCompile);
          },
          function(value) {
            // when the 'compile' expression changes
            // assign it into the current DOM
            element.html(value);

            // compile the new DOM and link it to the current
            // scope.
            // NOTE: we only compile .childNodes so that
            // we don't get into infinite loop compiling ourselves
            $compile(element.contents())(scope);
          }
        );
      };
    }]);
  }]);

})();

(function() {
    'use strict';

    angular
        .module('ringid.utils',
        ['ringid.config','ringid.common.stacked_map','ringid.sticker','rg.custom.compiler.directive']
    );
            
            
})();

(function() {
    'use strict';
    var app;
    app = angular.module('ringid.utils');

    app.factory('utilsFactory',utilsFactory);

    utilsFactory.$inject = ['$window','$document','APP_CONSTANTS', 'settings', '$filter','Storage','StickerEmoticonFactory', 'RING_ROUTES','MESSAGES', '$ringhttp', '$$q','Storage'];

    function utilsFactory($window,$document,APP_CONSTANTS, settings, $filter,StorageFactory,StickerEmoticonFactory, RING_ROUTES, MESSAGES, $ringhttp, $q,Storage){

        var self = this,

            returnOb = {},
        //urlPattern = /((http|ftp|https):)?\/\/[\w-]+(\.[\w-]+)+([\w.,@?^=%&amp;:\/~+#-]*[\w@?^=%&amp;\/~+#-])?/gi,
        //    urlPattern = /[(http(s)?):\/\/(www\.)?a-zA-Z0-9@:\-%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/gi,
            urlPattern = /(((http|https):\/{2})?((([0-9a-z_-]+\.)+(aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mn|mn|mo|mp|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|nom|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ra|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw|arpa)|(0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])))(:[0-9]+)?((\/([~0-9a-zA-Z\#\+\%@\.\/_-]+))?(\?[0-9a-zA-Z\+\%@\/&\[\];=_-]+)?(\?[\w|\W]+)?)?))\b/gi,

            emopattern = StickerEmoticonFactory.getEmoticonPattern(),

            Emomapper = StickerEmoticonFactory.getEmoticonUrlMapWithHtmlEncode();

        var viewportsize = function() {
            var w = $window,
                d = $document,
                e = d[0].documentElement,
                g = d[0].getElementsByTagName('body')[0],
                x = w.innerWidth || e.clientWidth || g.clientWidth,
                y = w.innerHeight|| e.clientHeight|| g.clientHeight,
                yo = w.pageYOffset;
            return {x:x,y:y,yo:yo};
        };
        //  console.dir($window.Math);
        /**
         * @description : convert html entity to text.
         */
        var htmlentityencode = function(html){ //
            return String(html).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        };
        var addHttps = function(url){
            if (!/^(f|ht)tps?:\/\//i.test(url)) {
                url = "http://" + url;
            }
            return url;
        };
        /**
         * @description text perser for link and emoticon
         * @param text
         * @returns converted text as html
         */
        var textParseForLinkAndEmo = function(text, flag){
            //if(/<[a-z][\s\S]*>/i.test(text)){
            text = htmlentityencode(text);
            //}

            var out=text;
            var utfEmo = /\ud83d[\udc00-\ude4f]|\ud83d[\ude80-\udeff]/g;

            if(!flag){
                flag = 0;
            }

            // for temp uploaded image file starts
            if(out.substring(0,9) === 'blob:http'){// this was for tempImage; actionObj.imageSource was being used
                //if(text.substring(0,22) == 'data:image/jpeg;base64'){// this is now for tempImage; getPreview() is being used
                out = '<img width="100%" src="' + out + '" />';
                flag = 2;
            }
            // for temp uploaded image file ends

            if(flag === 0){
                //replacing the link
                out =  out.replace(urlPattern, function(match) {
                    var url = addHttps(match);
                    return '<a class="feedanchor" target="_blank" href="' + url + '"> ' + match + '</a>';
                });//replacing the link
            }

            out =  out.replace(emopattern, function(match) {
                //var img = new Image();
                //img.src = Emomapper[match];
                return '<img class="feed_emo" title="' + match + '" src="' + Emomapper[match] + '" />';
            });//replacing the emo

            /* utf emoticon */
            if(!window.emojiSupported) {
                out =  out.replace(utfEmo, function(match) {
                    var hi, low, hex;
                    hi = match.charCodeAt(0);
                    low = match.charCodeAt(1);
                    hex = (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000).toString(16);
                    return '<u class="emo_list U_'+hex+'"></u>';
                });
            }
            if(flag === 1){
                out = text;
            }
            return out;
        };
        var ThisTabId;
        var getTabId = function(){
            if(ThisTabId){return ThisTabId};
            var currentTopId = StorageFactory.getCookie('top'),current;
            if(!!currentTopId){
                current = parseInt(currentTopId) + 1;
                if(current > 255){ // tab id on backend is one byte unsigned
                    current = 1;
                }
            } else {
                current = 1;
            }
            ThisTabId = current;
            StorageFactory.setCookie('top',ThisTabId);
            return current;
        };
        var getUniqueId = function(prefix){
            if (!prefix){
                prefix = '';
            }
            return prefix + ThisTabId + $window.Math.floor($window.Math.random() * (new $window.Date()).getTime());
        };

        var hasEmoticon = function(text){
            var utfEmo = /\ud83d[\udc00-\ude4f]|\ud83d[\ude80-\udeff]/g;

            if(!text){
                return false;
            }else{
                return utfEmo.test(text) || emopattern.test(text);
            }
        };



        var getGoogleMapStaticUrl = function (lat, lng) {
            var url = "https://maps.googleapis.com/maps/api/staticmap?center={0},{1}&zoom=13&size=640x400&key={2}&markers=color:orange|{0},{1}";
            url = url.format(lat, lng, APP_CONSTANTS.GOOGLE_MAP_KEY);
            return url;
        };

        var getGoogleMapJSUrl = function (lat, lng, location, embed) {
            var url;
            if(!lat || !lng){
                url = "http://maps.google.com?q={0}".format(location)
            }else{
                url = "https://maps.google.com/maps?q={0},{1}&hl=es;z=14".format(lat, lng);
            }

            if(!!embed){
                url += "&output=embed";
            }
            
            return url;
        };



        //};

   
        function getDefaultColumn(){
            if(!returnOb.viewport){
                returnOb.viewport = viewportsize();
            }
            var windowWidth = returnOb.viewport.x;

            if(windowWidth <= 1245) { // device between 720 and 980
                return 1;
            }else if(windowWidth >= 1245 && windowWidth <=1800){
                return 2;
            }else if(windowWidth > 1800){
                return 3;
            }
        }

        function feedColumn(){
            var default_col = getDefaultColumn();
            var col = parseInt(Storage.getCookie('col'));
            if(!col || col > default_col){
                default_col = default_col > 2 ? 2 : default_col;
                //Storage.setCookie('col',default_col);
                return default_col
            }
            return col;

        }

        //function availableCellWidthByWindow(feedCol){
            //return (returnOb.viewport.x - (APP_CONSTANTS.LEFT_BAR_WIDTH + APP_CONSTANTS.RIGHT_BAR_WIDTH + (feedCol * APP_CONSTANTS.CELL_MARGIN)))/feedCol;
        //}

        function cellWidthByCss(col){
            // from media css
            var width = returnOb.viewport.x;
            if(col ===1 && width >=1280){
                return 600;
            }
            if(width >= 768 && width <= 799){ //col =1
                return 329;
            }else if(width >=800 && width <= 979){ // col =1
                return 361;
            }else if(width >=980 && width <= 1279){//col 1 and 2
                return 541;
            }else if(width >=1280 && width <= 1349){//col = 2
                return 423;
            }else if(width >=1350 && width <= 1399){//col = 2
                return 458;
            }else if(width >=1400 && width <= 1499){//col = 2
                return 475;
            }else if(width >=1500 && width <= 1649){//col = 2
                return 510;
            }else if(width >=1650 && width <= 1799){//col = 2
                return 560;
            }else if(width <= 1920){//col 3
                return 487;
            }else if(width <= 2650){//col 3
                return 487;
            }else{
                RingLogger.alert("viewport else occured should not occur",'ERROR');
                return 500;
            }
        }

        function FeedCellWidth(){
            var feedCol = feedColumn();
            feedCol = parseInt(feedCol);
            if(feedCol === 1){
                return 600;
            }else{
                return cellWidthByCss(feedCol);
            }
            //     availableWidthByWindow = cellWidthByCss(feedCol);

            // if(feedCol == 1){
            //     cellWidth = availableWidthByWindow > 500 ? 500 : availableWidthByWindow;
            // }else if(feedCol == 2){
            //     cellWidth = availableWidthByWindow > 475 ? 475 : availableWidthByWindow;
            // }else if(feedCol == 3){
            //     cellWidth = availableWidthByWindow > 440 ? 440 : availableWidthByWindow;
            // }


            // return cellWidth;
        }

        function _getOGDetails(url){
            return $ringhttp.get(settings.ogServiceUrl + '?url=' + encodeURIComponent(url));
        }

        function _getReasonMessageFromResponse(responseObj){
            if(!!responseObj.mg){
                return responseObj.mg;
            }else{
                return _getReasonMessage(responseObj.rc);
            }
        }

        function _getReasonMessage(reasonCode){
            if(!!MESSAGES['RC' + reasonCode]){
                return MESSAGES['RC' + reasonCode];
            }

            return "";
        }

        function _debounce(func, wait, immediate) {
            var timeout;
            return function() {
                var context = this, args = arguments;
                var later = function() {
                    timeout = null;
                    if (!immediate){ func.apply(context, args); }
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) {
                    func.apply(context, args);
                }
            };
        }

        function _getImageUrlDimension(imgUrl){
            var defer = $q.defer();

            var img = new Image();
            img.onload = function() {
                defer.resolve({imgUrl: this.src, width : this.width, height: this.height});
            };
            img.src = imgUrl;

            setTimeout(function(){
                defer.resolve({width : 0, height: 0});
            }, 15000);

            return defer.promise;

        }

        function _dataURLToBlob(dataURL) {
            var BASE64_MARKER = ';base64,',
                parts,
                contentType,
                binary;

            if (dataURL.indexOf(BASE64_MARKER) == -1) {
                parts = dataURL.split(',');
                contentType = parts[0].split(':')[1];
                binary = decodeURIComponent(parts[1]);

                return new Blob([binary], {type: contentType});
            }

            parts = dataURL.split(BASE64_MARKER);
            contentType = parts[0].split(':')[1];
            binary = window.atob(parts[1]);

            var uInt8Array = new Uint8Array(binary.length);

            for (var i = 0; i < binary.length; ++i) {
                uInt8Array[i] = binary.charCodeAt(i);
            }

            return new Blob([uInt8Array], {type: contentType});

        }

        function _filterImagesByDimentions(imageUrls, lowestDimension){
            var defer = $q.defer();

            var allImageDimensionPromises = [];
            var filteredImages = [];

            if(!lowestDimension.width){
                lowestDimension.width = 0;
            }

            if(!lowestDimension.height){
                lowestDimension.height = 0;
            }

            angular.forEach(imageUrls, function(anImageUrl){
                allImageDimensionPromises.push( _getImageUrlDimension(anImageUrl) );
            });

            $q.all(allImageDimensionPromises).then( function(allImageDimensions){
                console.log(allImageDimensions);
                angular.forEach(allImageDimensions, function(anImageDimension){
                    var widthValid, heightValid;

                    if( !!anImageDimension.width && ( anImageDimension.width >= lowestDimension.width ) ){
                        widthValid = true;
                    }

                    if( !!anImageDimension.height && ( anImageDimension.height >= lowestDimension.height ) ){
                        heightValid = true;
                    }

                    if(!!widthValid && !!heightValid){
                        filteredImages.push(anImageDimension.imgUrl);
                    }
                });

                return defer.resolve(filteredImages);

            });

            setTimeout(function(){ defer.resolve([]); }, 20000);

            return defer.promise;

        }

        function _callXTimeAfterYIntervalStopOnSuccess(callback, successChecker, onFailCallback, maxExecutionCount, interval){
            var currentExecutionCount = 0;

            var doExecute = function(){
                if( !currentExecutionCount || ( currentExecutionCount < maxExecutionCount && !successChecker.call(null, currentExecutionCount) ) ){

                    callback.call();
                    currentExecutionCount++;
                    setTimeout(doExecute, interval);

                }else{

                    if(!successChecker.call(null, currentExecutionCount)){
                        onFailCallback.call();
                    }
                }
            };

            doExecute();
        }

        var _requestMultipleTime = function(func, args){

            var defer = $q.defer();
            var success = false;

            _callXTimeAfterYIntervalStopOnSuccess(function(){

                var response = func.apply(this, args);

                if(!!response.then){

                    response.then(function(response){
                        success = true;
                        defer.resolve(response);

                    }, function(response){
                        success = true;
                        defer.reject(response);
                    });

                }else{
                    defer.reject({sucs :false, rc : 'Invalid' });
                    RingLogger.alert('RequestMultipleTime Expect `func` as promise', RingLogger.tags.DEBUG);
                }

            }, function(){

                return success;

            }, function(){
                if( !success){
                    defer.reject({timeout : true, sucs :false })
                }
            }, 5, 3000);

            return defer.promise;
        };

        function _triggerCustomEvent(eventName, data){
            var event = document.createEvent('Event');
            event.initEvent(eventName, true, true);
            event.data = data;
            document.dispatchEvent(event);
        }

        //function _onCustomEvent(eventName, callback){
        //    document.addEventListener(eventName, function(response){
        //        callback.call(this, response.data);
        //    });
        //
        //}
        function _onCustomEvent(eventName, callback){
            var funcRef = function(response){
                callback.call(this, response.data);
            };

            document.addEventListener(eventName, funcRef);

            return funcRef;

        }

        function _removeCustomEvent(eventName, callback){
            document.removeEventListener(eventName, callback);
        }

        //function _extendIfSet(target, firstSource){
        //    var targetKeys = Object.keys(target);
        //
        //    for(var index = 0; index < targetKeys.length; index++){
        //        var aTargetKey = targetKeys[index];
        //        if( !!firstSource[aTargetKey] ){
        //            target[aTargetKey] = firstSource[aTargetKey];
        //        }
        //    }
        //
        //    return target;
        //
        //}
        /**
         * return current selected range from current input. if nothing selected and cursor focusing some element its return current cursor point
         *
         */
        function getSelection() {
            var sel;
            sel = window.getSelection();
            if (sel.getRangeAt) {

                return sel.getRangeAt(0);

            } else if (document.selection && document.selection.createRange) {
                var range = document.createRange();
                range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
                return range;
            }
            return null;
        }

        function _string2ArrayBuffer(str) {
            var arr = str.split(","),
                view = new Uint8Array( arr );
            return view.buffer;
        }

        function _arrayBuffer2String(buf) {
            var view = new Uint8Array( buf );
            return Array.prototype.join.call(view, ",");
        }

        function safeDigest($scope){
            if ( $scope.$parent && $scope.$parent.$id !== 1){
                $scope.$parent.$rgDigest();
            }else{
                $scope.$rgDigest();
            }
        }

        function generateUUID() {
            var d = new Date().getTime();
            if(window.performance && typeof window.performance.now === "function"){
                d += performance.now(); //use high-precision timer if available
            }
            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = (d + Math.random()*16)%16 | 0;
                d = Math.floor(d/16);
                return (c=='x' ? r : (r&0x3|0x8)).toString(16);
            });
            return uuid;
        }

        var animationStart, animationCurrentTime, animationChange, animationDuration = 500;

        function _resetScroll() {
            animationStart = document.documentElement.scrollTop || document.body.parentNode.scrollTop || document.body.scrollTop,
            animationCurrentTime = 0, 
            animationChange = (-1)*animationStart;
        }

        function _animateScroll() {

                animationCurrentTime += 25;
                var val = Math.easeIn(animationCurrentTime, animationStart, animationChange, animationDuration);

                document.documentElement.scrollTop = val;
                document.body.parentNode.scrollTop = val;
                document.body.scrollTop = val;

                if (animationCurrentTime < animationDuration) {
                     requestAnimationFrame(_animateScroll);
                } 
        }

        function getScrollBarWidth() {
                
                var inner = document.createElement('p');
                inner.style.width = "100%";
                inner.style.height = "200px";

                var outer = document.createElement('div');
                outer.style.position = "absolute";
                outer.style.top = "0px";
                outer.style.left = "0px";
                outer.style.visibility = "hidden";
                outer.style.width = "200px";
                outer.style.height = "150px";
                outer.style.overflow = "hidden";
                outer.appendChild(inner);

                document.body.appendChild(outer);
                var w1 = inner.offsetWidth;
                outer.style.overflow = 'scroll';
                var w2 = inner.offsetWidth;

                if (w1 == w2) {
                    w2 = outer.clientWidth;
                }

                document.body.removeChild(outer);
                inner = outer = null;
                return (w1 - w2);
        }

        function _getUserLocation(){

            var defer = $q.defer();

            // if the browser supports the w3c geo api
            if(navigator.geolocation){
              // get the current position
              navigator.geolocation.getCurrentPosition(

              // if this was successful, get the latitude and longitude
              function(position){
                var lat = position.coords.latitude;
                var lng = position.coords.longitude;

                var latLng = {lat : lat, lng: lng }

                var geocoder = new google.maps.Geocoder;
                geocoder.geocode({'location': latLng}, function(results, status) {
                    if (status === google.maps.GeocoderStatus.OK) {

                        defer.resolve({sucs: true, lat : lat, lng : lng, description : results[1].formatted_address});

                    }else{
                        
                        defer.resolve({sucs: true, lat : lat, lng : lng});
                    }
                });

                

              },
              // if there was an error
              function(error){
                defer.resolve({sucs: false, error : error })
              });
            }

            return defer.promise;
        }

        getTabId();
        returnOb =  {
            generateUUID: generateUUID,

            getRingRoute : getRingRoute,
            getOGDetails : _getOGDetails,
            getReasoneMessage : _getReasonMessage,
            getReasonMessageFromResponse : _getReasonMessageFromResponse,
            debounce : _debounce,
            tabId : ThisTabId,
            getTabId : getTabId,
            animateScroll : _animateScroll,
            resetScroll : _resetScroll,    

            viewport : viewportsize(),
            viewportsize : viewportsize,
            scrollbarWidth: getScrollBarWidth(),
            feedCellWidth : FeedCellWidth(),
            string2ArrayBuffer : _string2ArrayBuffer,
            arrayBuffer2String : _arrayBuffer2String,

            setFeedCellWidth : function(){
                returnOb.feedCellWidth = FeedCellWidth();
            },
            hasSocket : function(){
                return true;
                //console.log($localStorage.socketon);
                //console.log($localStorage.loginData.socketOn);
                //return $localStorage.loginData && !!$localStorage.loginData.socketOn;
            },
            parseForLE : function(text, flag){ // prases for link and emoticon
                return textParseForLinkAndEmo(text, flag);
            },
            init:function(){
                //returnOb.viewport = viewportsize();
            },
            feedColumn : feedColumn,
            getDefaultColumn : getDefaultColumn,
            setFeedColumn : function(num){
                Storage.setCookie('col',parseInt(num));
            },
            getUniqueID: function (prefix) {
                return getUniqueId(prefix);
            },
            getRandomString: function(length) {
                var result = '',
                    chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

                for (var i = length; i > 0; --i) {
                    result += chars[Math.round(Math.random() * (chars.length - 1))];
                }

                return result;
            },
            getToken : '234', //$document[0].getElementById('sectoken').getAttribute('data-sec'),
            chatVerbalDate: function(timestamp){
                //return $filter('date')(timestamp,"MMM d, yyyy 'at' h:mm a");
                return $filter('date')(timestamp,"h:mm a");
            },
            profileVerbalDate: function(timestamp){
                return $filter('date')(timestamp,"yyyy-MM-dd");
            },
            verbalDate : function(timestamp,fromTimeStamp){
                var date,diff,day_diff,Math = $window.Math;

                fromTimeStamp = fromTimeStamp || Date.now();

                if(isNaN(timestamp)){
                    date = new Date((timestamp || "").replace(/-/g,"/").replace(/[TZ]/g," ")),
                        timestamp = date.getTime();
                }
                diff = ((fromTimeStamp - timestamp) / 1000);//diff in second
                day_diff = Math.floor(diff / 86400);// 1 day = 86400 second// its calculate diff in day
                // if ( isNaN(day_diff) || day_diff < 0 )
                if (isNaN(day_diff))
                    return "";
                switch (true){
                    case day_diff < 1: // time is equal from date
                        switch(true){
                            case diff < 60:
                                return "just now";
                            case diff < 120 :
                                return "1 minute ago";
                            case diff < 3600 : // within a hour
                                return Math.floor( diff / 60 ) + " minutes ago";
                            case diff < 7200 :
                                return "1 hour ago";
                            case diff < 86400 : //within a day show as minute
                                return Math.floor( diff / 3600 ) + " hours ago";
                            default :
                                return $filter('date')(timestamp,"MMM d, h:mm a");
                        }
                        break;
                    case day_diff === 1 : // 1 day before from date
                        return "yesterday at "+ $filter('date')(timestamp,"h:mm a");
                    case day_diff < 7 :
                        return $filter('date')(timestamp,"EEEE 'at' h:mm a");
                    case day_diff < 365 :
                        return $filter('date')(timestamp,"MMMM d yyyy 'at' h:mm a");
                    default :
                        return $filter('date')(timestamp,"MMM d, yyyy");
                }
            },

            getUserLocation : _getUserLocation,

            getImageUrlDimension : _getImageUrlDimension,
            filterImagesByDimentions : _filterImagesByDimentions,
            dataURLToBlob : _dataURLToBlob,
            callXTimeAfterYIntervalStopOnSuccess : _callXTimeAfterYIntervalStopOnSuccess,
            requestMultipleTime : _requestMultipleTime,
            triggerCustomEvent : _triggerCustomEvent,
            onCustomEvent : _onCustomEvent,
            removeCustomEvent : _removeCustomEvent,
            getSelection : getSelection,
            getGoogleMapStaticUrl : getGoogleMapStaticUrl,
            getGoogleMapJSUrl : getGoogleMapJSUrl,

            hasEmoticon : hasEmoticon,
            safeDigest : safeDigest

        };

        ////////////////////////////


        function getRingRoute(name, params){

            if( !RING_ROUTES[name] )
                return '';

            var routeString = RING_ROUTES[name];

            switch (name){
                case 'HOME':
                case 'FAQ' :
                    break;

                case 'SINGLE_FEED':
                    if( !!params['feedId']){
                        routeString =  routeString.replace(':feedId', params['feedId']);
                    }

                    var shared = !!params['shared'] ? 'shared' : '';
                    routeString =  routeString.replace(':shared?', shared );

                    var commentId;
                    if( !!shared){
                        commentId = params['commentId'] || 0;
                        routeString =  routeString.replace(':commentId?', commentId);
                    }else{
                        commentId = params['commentId'] || '';
                        routeString =  routeString.replace(':commentId?/', commentId);
                    }


                    break;

                case 'WHO_SHARED_FEED' :
                    if( !!params['feedId']){
                        routeString =  routeString.replace(':feedId', params['feedId']);
                    }

                    var commentId = params['commentId'] || '';
                    routeString =  routeString.replace(':commentId?', commentId);

                    break;


                case 'SINGLE_IMAGE':
                    if( !!params['imageId']){
                        routeString = routeString.replace(':imageId', params['imageId']);
                    }

                    var commentId = params['commentId'] || '';
                    routeString =  routeString.replace(':commentId?', commentId);

                    break;

                case 'SINGLE_MEDIA':
                    if( !!params['mediaId']){
                        routeString = routeString.replace(':mediaId', params['mediaId']);
                    }

                    var commentId = params['commentId'] || '';
                    routeString =  routeString.replace(':commentId?', commentId);

                    break;
                case 'USER_PROFILE':
                    if( !!params['uId']){
                        routeString = routeString.replace(':uId', params['uId']);
                    }else{
                        RingLogger.print(params, RingLogger.tags.PROFILE);
                        RingLogger.print('Invalid Route Params Provided', RingLogger.tags.PROFILE);

                    }

                    if( !!params['utId']){
                        routeString = routeString.replace(':utId', params['utId']);
                    }else{
                        routeString = routeString.replace('/:utId', '');
                    }

                    if( !!params['albumId']){
                        routeString = routeString.replace(':albumId?', params['albumId']);
                    }else{
                        routeString = routeString.replace('/:albumId?', '');
                    }
                    break;

                case 'CIRCLE_HOME':
                    if( !!params['circleId']){
                        routeString = routeString.replace(':circleId', params['circleId']);
                    }
                    break;


            }

            if( !!params['subpage']){
                routeString = routeString.replace(':subpage?', params['subpage']);
            }else{
                routeString = routeString.replace('/:subpage?', '');
            }

            return '#' + routeString;

        }

        return returnOb;




    }




})();

(function () {
    'use strict';
    var app;
    app = angular.module('ringid.utils');

    app.directive('rgKeyUp',function(){
        return function(scope,element,attr){
            function process(e){
                try{
                 scope[attr.rgKeyUp](e);
                }catch(err){
                     RingLogger.alert(err,"DEBUG");
                }
            }
            element.bind("keyup",process);
            scope.$on('$destroy', function(){
                element.unbind("keyup",process)
            });
         };
    });
        
    app.directive('rgScroll',rgScroll);
    rgScroll.$inject = ['utilsFactory','$window'];
    function rgScroll (utilsFactory,$window) {
        return function (scope,element,attr) {

             var wEl = angular.element($window);

             wEl.bind('scroll', function () {

                    requestAnimationFrame(function() {
                      
                          var newValue =utilsFactory.viewportsize();

                          utilsFactory.viewport.x = newValue.x;
                          utilsFactory.viewport.y = newValue.y;
                          utilsFactory.viewport.yo = newValue.yo;
                    });
                  
              });   
        }
    };     

})();

/**
 * Created by USER on 09-Sep-15.
 */
(function () {
    'use strict';
    var app;
    app = angular.module('ringid.utils');
    app.directive('rgResize',rgResize);
    rgResize.$inject = ['utilsFactory','$window','$rootScope','SystemEvents'];
    function rgResize (utilsFactory,$window,$rootScope,SystemEvents) {
        return function (scope,element,attr) {

            //scope.windowHeight = utilsFactory.viewport.y;
            //scope.windowWidth = utilsFactory.viewport.x;

             var wEl = angular.element($window);

             wEl.bind('resize', function () {

                    requestAnimationFrame(function() {
                      
                          var newValue =utilsFactory.viewportsize();

                          $rootScope.windowHeight = newValue.y;
                          $rootScope.windowWidth = newValue.x;
                          utilsFactory.viewport.x = newValue.x;
                          utilsFactory.viewport.y = newValue.y;
                          utilsFactory.viewport.yo = newValue.yo;
                          utilsFactory.setFeedCellWidth();

                          $rootScope.$broadcast(SystemEvents.COMMON.WINDOW_RESIZED,utilsFactory.viewport);

                    });
                  
              });   
        }
    };

})();

(function() {
    'use strict';
    var app;
    app = angular.module('ringid.utils');

    app.factory('windowFocusHandler',windowFocusHandler);
    windowFocusHandler.$inject = ['$window','utilsFactory','$$stackedMap'];


    function windowFocusHandler($window,utilsFactory,$$stackedMap){

        var fns = $$stackedMap.createNew();

        var process = function(){
            fns.doForAll(function(fn){
                fn.call(null);
            });
        };

        $window.onfocus = process;

        return {
            add : function(fn){
                var key = utilsFactory.getUniqueID();
                fns.add(key,fn);
                return key
            },
            remove : function(key){
                return fns.remove(key);
            },
            fire : function(){//to manually fire focus event
                process();
            }

        };
    }
    app.factory('windowBlurHandler',windowBlurHandler);
    windowBlurHandler.$inject = ['$window','utilsFactory','$$stackedMap'];


    function windowBlurHandler($window,utilsFactory,$$stackedMap){

        var fns = $$stackedMap.createNew();

        var process = function(){
            fns.doForAll(function(fn){
                fn.call(null);
            });
        };

        $window.onblur = process;

        return {
            add : function(fn){
                var key = utilsFactory.getUniqueID();
                fns.add(key,fn);
                return key
            },
            remove : function(key){
                return fns.remove(key);
            },
            fire : function(){//to manually fire focus event
                process();
            }

        };
    }

})();
(function() {
    'use strict';

    angular
        .module('ringid.syncher',['ringid.common.stacked_map','ringid.utils'])
        .factory('$$rgsyncher',rgSynchar);

        rgSynchar.$inject = ['$$stackedMap','$rootScope', 'utilsFactory']; // injecting rootscope to digest changes

        function rgSynchar($$stackedMap,$rootScope, utilsFactory){
            /*
            * rgSynchar
            *
            *
            * */

            var syncfns = $$stackedMap.createNew();

            var _synch = function(){//to manually fire focus event
                if(syncfns.length() > 0)
                    process();
            };

            var process = function(){
                var scopeToDigest;
                syncfns.doForAll(function(fn){
                    scopeToDigest = fn.call(null); // fn should return scope to digest if any changes occurs
                    if(!!scopeToDigest && !scopeToDigest.$$phase){
                        scopeToDigest.$digest();//safe digesting the current scope
                    }
                });
            };

            $rootScope.$on('ringActive', _synch);

            return {
                add : function(fn){
                    var key = utilsFactory.getUniqueID();
                    syncfns.add(key,fn);
                    return key
                },
                remove : function(key){
                    return syncfns.remove(key);
                },
                synch : _synch
            };
        }


})();

(function(DataView,String) {// placing dataview and String globals to locals for better performance
    'use strict';
    angular
        .module('ringid.connector', ['ngWebSocket','ringid.utils','ringid.config','ringid.common.stacked_map','ringid.syncher'])

})(DataView,String);
(function() {
    'use strict';
    angular
    .module('ringid.connector')
    .factory('RingParser',RingParser) // header parser
    .service('parserService', parserService)//broken packet parser
    .service('mergerService', mergerService);//broken packet parser

    RingParser.$inject = ['ATTRIBUTE_CODES', 'parserService'];
    function RingParser(ATTRIBUTE_CODES, parserService){ //jshint ignore:line
        var ReturnObject,packetDataStorage={};// for accessing from self property assigning to be returned object to a variable
        var ByteParsers = {};

        var parseHeader = function(dataViewObject, offset){
            var index,len,attribute,headerObject={},val;//offset = offset || 1;

            for(index=offset;index<dataViewObject.byteLength;){
                attribute = dataViewObject.getUint16(index);// reading int from 2 byte
                index +=2;// so increasing the index to two
                len = dataViewObject.getUint8(index++);// one byte of length
                //val = dataViewObject.getInt16(index);
                val = dataViewObject.getIntByByte(index,len);
                switch(attribute){
                    case ATTRIBUTE_CODES.ACTION:// one byte
                        headerObject.actn = val;
                        break;
                    case ATTRIBUTE_CODES.SERVER_PACKET_ID:
                        headerObject.pckFs = val;
                        break;
                    case ATTRIBUTE_CODES.CLIENT_PACKET_ID:
                        headerObject.pckId = dataViewObject.getString(index,len);
                        break;
                    case ATTRIBUTE_CODES.WEB_UNIQUE_KEY:// TODO : find use
                        break;
                    case ATTRIBUTE_CODES.WEB_TAB_ID:
                        headerObject.tabId = val;
                        break;
                    case ATTRIBUTE_CODES.AUTHIP:
                        headerObject.authServer = dataViewObject.getString(index,len);
                        break;
                    case ATTRIBUTE_CODES.AUTHPORT:
                        headerObject.comPort = val;
                        break;
                    case ATTRIBUTE_CODES.AUTH_E_USERNAME:
                        headerObject.authEUsername = dataViewObject.getString(index,len);
                        break;
                    case ATTRIBUTE_CODES.AUTH_E_PASSWORD:
                        headerObject.authEPassword = dataViewObject.getString(index,len);
                        break;
                    case ATTRIBUTE_CODES.AUTH_E_SALT:
                        headerObject.authESalt = dataViewObject.getString(index,len);
                        break;
                    case ATTRIBUTE_CODES.TOTAL_PACKET:
                        headerObject.total = val;//total number of packet int
                        break;

                    case ATTRIBUTE_CODES.PACKET_NUMBER:
                        headerObject.current = val;//current number of packet int
                        break;

                    case ATTRIBUTE_CODES.UNIQUE_KEY:
                        headerObject.key = val;//packet Identification number long
                        break;
                    default:
                        index -=3;// we readed attribute and len for three byte so fallback three bytes because there is no match for header tag
                        headerObject.headerLength = index;// setting header length
                        return headerObject;
                }
                // if not returning from switch case, its means we find a match for header variable so moving index to len byte
                index += len;
            }
            return headerObject;

        };

        var parseBrokenPacketHeader = function(dataViewObject,offset){
            var index,len,attribute,
                headerObject = {//defaults values
                    actn : 0,
                    pckFs : 0,
                    total : 0,
                    current:0,
                    key :0
                },val;offset = offset || 1;

            for(index=offset;index<dataViewObject.byteLength;){
                attribute = dataViewObject.getUint8(index++);// reading int from 1 byte

                len = dataViewObject.getUint8(index++);// one byte of length
                val = dataViewObject.getIntByByte(index,len);
                //val = dataViewObject.getInt32(index);
                switch(attribute){
                    case ATTRIBUTE_CODES.ACTION:// one byte
                        headerObject.actn = val;//int
                        break;

                    case ATTRIBUTE_CODES.SERVER_PACKET_ID:
                        headerObject.pckFs = val;//long
                        break;

                    case ATTRIBUTE_CODES.TOTAL_PACKET:
                        headerObject.total = val;//total number of packet int
                        break;

                    case ATTRIBUTE_CODES.PACKET_NUMBER:
                        headerObject.current = val;//current number of packet int
                        break;

                    case ATTRIBUTE_CODES.UNIQUE_KEY:
                        headerObject.key = val;//packet Identification number long
                        break;

                    case ATTRIBUTE_CODES.DATA:
                        // for data len is in two byte so for returning to previsous byte
                        index--;
                        len = dataViewObject.getUint16(index);//reading int from two byte
                        index +=2;//incresing it by two byte
                        headerObject.data = dataViewObject.copy(index,len);
                        break;

                    case ATTRIBUTE_CODES.WEB_UNIQUE_KEY:// TODO : find use
                        break;
                    case ATTRIBUTE_CODES.WEB_TAB_ID:
                        headerObject.tabId = val;
                        break;

                    default:
                        console.log("Attribute COde Not Found" +attribute);
                        //len = (bytes[index++] & 0xFF);
                        break;


                }
                // if not returning from switch case, its means we find a match for header variable so moving index to len byte
                index += len;


            }
            return headerObject;
        };

        var parse = function(DataViewObject){
            /**
             * Data view object keeps beffer returning from server
             */
            var
                /**
                 * packet_type is the first byte of any packet represents the packet format
                 * 0 : the response contains complete json formatted data
                 * 2 : the response contains complete byte formatted data
                 * 1 : the response contains broken json formatted data needed to merge
                 * 3 : the response contains broken byte formatted data needed to merge
                 * */
                packet_type,
            // to keep header information after parsing
                header,
                bp_header,//broken packet header different from orginal packet header
                return_data,
                full_packet
                ;

            packet_type = DataViewObject.getUint8(0);// first byte represent what type of packet
            //return_data = header;
            switch (packet_type){
                case 0://json complete packet
                case 2://byte complete packet
                    header = parseHeader(DataViewObject,1);
                    if(header.actn === 200) {
                        RingLogger.info(header.pckId,"ACKNWOLEDGED");
                        return false; }
                    if(packet_type === 0){// json complete packet
                        return_data = DataViewObject.getString(header.headerLength,DataViewObject.byteLength-header.headerLength);
                        try{
                            return_data = angular.fromJson(return_data);
                            return_data = angular.extend({},header,return_data);
                        }
                        catch(e){
                            console.warn(return_data);
                            return_data = false;
                            return false;
                        }
                        return return_data;
                        //return return_data ? angular.extend({},header,angular.fromJson(return_data)):false;
                    }else{// byte complete packet
                        // todo : byte processor
                        return_data = parserService.parseData(DataViewObject, header.headerLength);
                        return return_data ? angular.extend({},header,return_data):false;
                    }

                    break;
                case 1:// json broken data
                case 3://byte broken data
                    bp_header = parseBrokenPacketHeader(DataViewObject,1);//broken packet header
                    RingLogger.print("join as data view should get called for byte broken data","Parser");
                    //console.dir(bp_header);
                    
                    if(!bp_header.key){ return false; }//returning if header key not found cause if key is not there then we can't identify broken packet
                    if(!packetDataStorage[bp_header.key]) { // packet with this key not present in the map
                        packetDataStorage[bp_header.key] = [];
                        packetDataStorage[bp_header.key].packetLength = 1;
                    }else{
                        packetDataStorage[bp_header.key].packetLength++;
                    }
                    packetDataStorage[bp_header.key][bp_header.current] = bp_header.data;

                    if(bp_header.total === packetDataStorage[bp_header.key].packetLength){ //all packet has arrived so marge it and parse as normal header
                        full_packet = packetDataStorage[bp_header.key].joinAsDataView();
                        delete packetDataStorage[bp_header.key];
                        header = parseHeader(full_packet,0);
                        if(packet_type === 1){// json broken packet
                            return_data = full_packet.getString(header.headerLength,full_packet.byteLength-header.headerLength);
                            try{
                                return_data = angular.fromJson(return_data);
                                return_data = angular.extend({},header,return_data);
                            }
                            catch(e){
                                return_data = false;
                                return false;
                            }
                            return return_data;


                            //return angular.extend({},header,angular.fromJson(return_data));
                        }else{// byte broken packet
                            // todo: byte processor
                            //console.log('broken packet');
                            return_data = parserService.parseData(full_packet, header.headerLength);
                            return return_data ? angular.extend({},header,return_data):false;
                        }
                    }
                    return false;
            }
            //if(header.pckFs > 0){
            // TODO check if there needs to sent any confirmation message to the server
            //}
        };
        ReturnObject =  {
            parse : function(viewob){
                //viewob.print_r(true);
                //console.log(viewob.getString(0, viewob.byteLength));
                return parse(viewob);
            },
            addParser : function(action,fn){
                ByteParsers[action] = fn;
            }
        };

        return ReturnObject;

    }


    parserService.$inject = ['OPERATION_TYPES', 'ATTRIBUTE_CODES', '$$stackedMap'];
    function parserService(OPERATION_TYPES, ATCODE, $$stackedMap) { //jshint ignore:line
        var self = this, //jshint ignore:line
            attrMap =  [];

            /*
             * ATTRIBUTE CODE 108 missing. got data for actn 23
             */
            attrMap[ATCODE.SUCCESS] =  'sucs';
            attrMap[ATCODE.REASON_CODE] = 'reasonCode';
            attrMap[ATCODE.MESSAGE] = 'message';
            attrMap[ATCODE.TOTAL_PACKET] = 'totalPacket';
            attrMap[ATCODE.PACKET_NUMBER] = 'packetNo';
            attrMap[ATCODE.TOTAL_RECORDS] =  'totalRecord';
            attrMap[ATCODE.USER_TABLE_IDS] = 'utIds';
            attrMap[ATCODE.USER_ID] = 'utId';
            attrMap[ATCODE.USER_IDENTITY] =  'uId';
            attrMap[ATCODE.USER_NAME] = 'fn';
            attrMap[ATCODE.PROFILE_IMAGE] = 'prIm';
            attrMap[ATCODE.PROFILE_IMAGE_ID] = 'prImId';
            attrMap[ATCODE.UPDATE_TIME] = 'ut';
            attrMap[ATCODE.CONTACT_UPDATE_TIME] = 'cut';
            attrMap[ATCODE.CONTACT_TYPE] = 'ct';
            attrMap[ATCODE.NEW_CONTACT_TYPE] = 'nct';
            attrMap[ATCODE.DELETED] = 'deleted';
            attrMap[ATCODE.BLOCK_VALUE] = 'bv';
            attrMap[ATCODE.FRIENDSHIP_STATUS] = 'frnS';
            attrMap[ATCODE.CHANGE_REQUESTER] = 'changeRequester';
            attrMap[ATCODE.CONTACT] = 'contacts';
            attrMap[ATCODE.CALL_ACCESS] = 'cla';
            attrMap[ATCODE.CHAT_ACCESS] = 'chta';
            attrMap[ATCODE.FEED_ACCESS] = 'fda';
            attrMap[ATCODE.ANONYMOUS_CALL] = 'anc';
            attrMap[ATCODE.ADDED_TIME] = 'adt';


            attrMap[ATCODE.SESSION_ID] = 'sessionId';
            attrMap[ATCODE.MUTUAL_FRIEND_COUNT] = 'mutualFriends';

        self.parseData = function(dataView, offset) {
            var attribute,
                length,
                Data = {};

            for (var index = offset; index < dataView.byteLength; ) {
                attribute = dataView.getUint16(index);
                index += 2;
                length = 0;

                switch(attribute) {
                    case ATCODE.SUCCESS:
                        length = dataView.getUint8(index++);
                        Data[attrMap[attribute]] = dataView.getBool(index);
                        break;
                    case ATCODE.REASON_CODE://1
                    case ATCODE.TOTAL_PACKET://1
                    case ATCODE.PACKET_NUMBER://1
                    case ATCODE.TOTAL_RECORDS://1
                    case ATCODE.USER_ID://1
                    case ATCODE.PROFILE_IMAGE_ID://1
                    case ATCODE.UPDATE_TIME:
                    case ATCODE.CONTACT_UPDATE_TIME:
                    case ATCODE.CONTACT_TYPE:
                    case ATCODE.NEW_CONTACT_TYPE:
                    case ATCODE.DELETED:
                    case ATCODE.BLOCK_VALUE:
                    case ATCODE.FRIENDSHIP_STATUS:
                    case ATCODE.CHANGE_REQUESTER:
                    case ATCODE.MUTUAL_FRIEND_COUNT:
                    case ATCODE.CALL_ACCESS:
                    case ATCODE.CHAT_ACCESS:
                    case ATCODE.FEED_ACCESS:
                    case ATCODE.ADDED_TIME:
                        length = dataView.getUint8(index++);
                        Data[attrMap[attribute]] = dataView.getIntByByte(index, length);
                        break;
                    case ATCODE.MESSAGE:
                    case ATCODE.USER_NAME:
                    case ATCODE.USER_IDENTITY:
                    case ATCODE.PROFILE_IMAGE:
                    case ATCODE.SESSION_ID:
                    case ATCODE.ADDED_TIME:
                        length = dataView.getUint8(index++);
                        Data[attrMap[attribute]] = dataView.getString(index, length);
                        break;
                    case ATCODE.USER_TABLE_IDS:
                        length = dataView.getUint16(index);
                        index += 2;
                        Data[attrMap[attribute]] = []; //$$stackedMap.createNew();
                        var utId, contactType, matchBy, frnS;

                        for(var i = index; i < index+length; ) {
                            utId = dataView.getIntByByte(i, 8);
                            i += 8;
                            contactType = dataView.getUint8(i++);
                            matchBy = dataView.getUint8(i++);
                            frnS = dataView.getUint8(i++);
                            Data[attrMap[attribute]].push({
                                    key: utId,
                                    value: {
                                        ct: contactType,
                                        mb: matchBy,
                                        frnS: frnS
                                    }
                                });
                                ////Data[attrMap[attribute]].save(
                                //utId, {
                                    //'ct': contactType,
                                    //'matchBy': matchBy
                                //}
                            //);
                        }
                        break;
                    case ATCODE.CONTACT:
                       // console.info('CONTACT');
                        // LONG PROCESS
                        length = dataView.getUint16(index);
                        index += 2;
                        if (! angular.isArray(Data[attrMap[attribute]])) {
                            Data[attrMap[attribute]] = [];
                        }
                        Data[attrMap[attribute]].push( self.parseData(dataView.copy(index, length), 0) );
                        break;
                    default:
                        length = dataView.getUint8(index++);
                        break;
                }
                index += length;
            }

            return Data;
        };
    }


mergerService.$inject = ['$$q'];
function mergerService($q){ //jshint ignore:line

        var ob = {
            defer : function(){
                    var defer = $q.defer();
                    var PACKET_DATA = {};
                return {
                    resolve : function(json){
                        var key, pack_info, seperatorPos;
                        var pack_no, pack_count;
                        RingLogger.print(json,"Merger");
                        if(json.seq || json.totalPacket){
                            key = json.pckId;
                            if(!PACKET_DATA[json.pckId]){
                                PACKET_DATA[json.pckId] = [];
                            }

                            defer.notify(json);// just notifying caller

                            //pack_info = json.seq ? json.seq.split("/") : json.packetNo;
                            if (json.seq) {
                                seperatorPos = json.seq.lastIndexOf('/');
                                pack_no =  json.seq.substr(0, seperatorPos);
                                pack_count = json.seq.substr(seperatorPos+1, json.seq.length);
                            } else {
                                pack_no = json.packetNo;
                                pack_count = json.totalPacket;
                            }
                            //if(!!PACKET_DATA[json.pckId]['sq'+pack_info[0]]){
                            if(!!PACKET_DATA[json.pckId]['sq'+pack_no]){
                                return;// see what to return
                            }

                            //PACKET_DATA[json.pckId]['sq'+pack_info[0]] = true;
                            PACKET_DATA[json.pckId]['sq'+pack_no] = true;
                            PACKET_DATA[json.pckId].push(json);
                            if(pack_count == PACKET_DATA[json.pckId].length){ // all packet received
                                var obj = {};
                                for(var i = 0;i < PACKET_DATA[json.pckId].length;i++){
                                    for(key in PACKET_DATA[json.pckId][i]){
                                        if(PACKET_DATA[json.pckId][i][key] instanceof Array){
                                            obj[key]  = (obj[key] || []).concat(PACKET_DATA[json.pckId][i][key]);
                                        }else{
                                            obj[key] = PACKET_DATA[json.pckId][i][key];
                                        }
                                    }
                                }

                                defer.resolve(obj);
                                delete PACKET_DATA[json.pckId];
                             }else{
                                return true;
                             }
                        } else {
                            defer.resolve(json);
                        }
                    },
                    promise : defer.promise
                };


            }
        };
        return ob;
}



})();

(function(DataView) {// placing dataview and String globals to locals for better performance
    'use strict';
    angular
        .module('ringid.connector')
        .factory('$$connector',$$connector);

           $$connector.$inject =
                ['settings', 'RingParser','Storage', '$rootScope','$websocket','$$stackedMap','ATTRIBUTE_CODES',
                    'utilsFactory','$$q','OPERATION_TYPES','CLIENT_DATA_SIZE','mergerService'];
         function $$connector(settings, RingParser,Storage, $rootScope,$websocket,$$stackedMap,ATTRIBUTE_CODES, //jshint ignore:line
                     utilsFactory,$q,OPERATION_TYPES,CLIENT_DATA_SIZE,mergerService){
                var ObjectToBeReturn,
                    sessionID = Storage.getCookie('sessionID'),
                    CurrentuId = Storage.getCookie('uId'),
                    socket,
                    keepAliveSender,
                    deferToBeResolved={},
                    resolvedPacket={},
                    stopSending=!1,
                    sendQueue = [],
                    lastSendingTime = Date.now(),
                    timeoutSetted = false,
                    keepAlive = false,
                    subscribers=$$stackedMap.createNew(),
                    floodingData = {},
                    floodingDataInterval,
                    reconnectCountError = 0,
                    UnresolvedData = [],
                    intervalFunctions = $$stackedMap.createNew();

                function getMessageFilterByActionNumber(action_number){

                    return function(message){// websocket message event
                        if (!message || !message.actn){ return false; }
                        if(angular.isArray(action_number)){
                            for(var i=0;i<action_number.length;i++){
                                if(message.actn === action_number[i]){
                                    return true;
                                }
                            }
                        }else{
                            return message.actn === action_number;
                        }
                        return false;

                    };
                }
               function parseMessageData(DataViewObject){
                    if(!DataViewObject) { return {}; }
                     return RingParser.parse(DataViewObject);
                    //if(angular.isString(message.data)){
                    //    return angular.fromJson(message.data);
                    //}else if(angular.isObject(message.data)){
                    //    return message.data;
                    //}else{
                    //    return message;
                    //}
               }
               function resolvePendingRequest(message){
                    if(deferToBeResolved[message.pckId] === true){
                        return true;
                    }
                    if(!!deferToBeResolved[message.pckId]){
                        var a = deferToBeResolved[message.pckId].resolve.call(deferToBeResolved[message.pckId],message);

                        if(!a){
                            deferToBeResolved[message.pckId] = !!a;
                            setTimeout(function(){
                                delete deferToBeResolved[message.pckId];
                            },3000);
                        }
                        //deleting after processing
                        return true;
                    }else{
                        return false;
                    }
               }

               function broadcastUpdates(message){
                    var foundSubscriber = false;
                   if(subscribers.length() > 0){
                        subscribers.doForAll(function(currentCallBackObject){
                           var should_call_with,pattern = currentCallBackObject.filter;
                            if (pattern) {
                                if(angular.isFunction(pattern)){
                                    should_call_with = pattern.call(null,message);
                                    if(!!should_call_with){
                                        foundSubscriber = true;
                                        currentCallBackObject.fn.call(currentCallBackObject,message);
                                    }
                                }
                            }else{
                                currentCallBackObject.fn.call(null, message);
                                 RingLogger.print("No Filter Found",currentCallBackObject,RingLogger.tags.CONNECTION);
                            }
                            // if (currentCallBackObject.autoApply && !currentCallBackObject.scope.$$phase) {
                            //     currentCallBackObject.scope.$digest(); // safe digest
                            // }
                        });
                      if(!foundSubscriber){
                         RingLogger.print("Not Found Subscriber For" , message,RingLogger.tags.CONNECTION);
                      }
                   }
                   return foundSubscriber;

               }

                function processOnMessageListners(json){
                    if(!json){ return; }

                    var MadeRquest,resolved;
                    if(json.actn === OPERATION_TYPES.SYSTEM.AUTH.TYPE_INVALID_LOGIN_SESSION){
                        broadcastUpdates(json);return;
                    }
                    if(json.hasOwnProperty('pckId')){ // its a response of a request so process resolve the defer of this packet id
                        MadeRquest = resolvePendingRequest(json);
                    }
                    if(json.hasOwnProperty('pckFs')){ // packet id From Server so its update need to process subscriber
                        var pack = json.pckFs;
                        if(!resolvedPacket[pack]){
                            broadcastUpdates(json);
                            resolvedPacket[pack] = true;
                        }
                    }else if(!MadeRquest){
                       resolved = broadcastUpdates(json);
                       if(!resolved){
                          UnresolvedData.push(json);
                       }
                    }
                }

                function MainOnMessageHandler(message){ // if message has pckId then its a request response, if message has pckFs its a subscriber
                    var DataViewObject;
                    try{
                        //if(window.Blob && ((message.data ||message) instanceof Blob)){
                        //
                        //}
                        DataViewObject = new DataView(message.data || message);
                        if(!DataViewObject.byteLength){
                            throw new Error("Byte Length of Zero");
                        }
                    }catch(e){ // buffer is not a arrayBuffer so throws exception
                        // console.dir(e);
                        RingLogger.err("Invalid Array Buffer to Parse : "+ e.message,RingLogger.tags.RECEIVED);
                        return;
                    }
                   // DataViewObject.print_r(); //ajax is banned
                   // if(!socket.socket ){ //data coming via ajax so coming as 2-byte integer padded
                   //     for(var i=0;i<DataViewObject.byteLength;){
                   //          length = DataViewObject.getUint16(i,!0); // length as 2-byte integer
                   //           i+=2;
                   //         if(length > 0){
                   //             try{
                   //                 tempDataView = DataViewObject.copy(i,length);
                   //                 message = parseMessageData(tempDataView);
                   //                // tempDataView.print_r();
                   //                 processOnMessageListners(message);
                   //             }catch(e){
                   //                 console.warn("Invalid Array Buffer to Parse : "+ e.message);
                   //             }finally{
                   //                 i+=length;
                   //             }
                   //         }
                   //     }
                   // }else{ // data coming via socket .. so no need to parse as byte array
                        message = parseMessageData(DataViewObject);
                        RingLogger.information(angular.toJson(message),RingLogger.tags.RECEIVED);
                        processOnMessageListners(message);
                  //  }

                    // for broken packets and falsy data
                }

            function getKeepAlivePacket(){

                var sess = Storage.getCookie('sId') || '',index=2;
                if (!sess.length){ return false; }
                var dataTosend = new ArrayBuffer(sess.length +2),
                    dataview  = new DataView(dataTosend);

                 dataview.setUint8(0,OPERATION_TYPES.SYSTEM.REQUEST_TYPE.KEEP_ALIVE);
                 dataview.setUint8(1,0);//complete packet
                    angular.forEach(sess.toCharCodeArray(),function(val){
                        dataview.setUint8(index++,val);
                    });
                return dataview;
             }

             function init(){
                // console.log("socket Init Called");
                    if(angular.isObject(socket)){
                        if(!socket.isOpen() && socket.readyState !== 0){
                            socket.reconnect();
                        }
                        return; // if socket is already initiated then return
                    }
                   if(utilsFactory.hasSocket()){
                       try{
                           socket = $websocket( settings.socketProtocol + settings.siteUrl +'/DataSocket/' + utilsFactory.tabId);
                           if(false === socket){
                                return;
                           }
                           socket.onError(function(e){
                               ga('send', 'event', 'Socket', 'Socket Failed: ' + JSON.stringify(e), 'Browser OS ' + navigator.userAgent || 'Unknown Browser');
                              if(reconnectCountError > 2){
                                $rootScope.$broadcast('CONNECTION_ERROR');
                              }else{
                                reconnectCountError++;
                              }

                           });
                           socket.onOpen(function(){
                               Storage.removeCookie('reloaded');
                               if(sendQueue.length){
                                 send();
                               }
                              //  var t0 = window.performance().now();
                              //  RingLogger.print("socket opened",'CONNECTIONTEST');
                              // setInterval(function(){
                              //   var t1 = window.performance().now();
                              //      RingLogger.print("socket status : "+socket.socket.readyState + "time from start"+(t1-t0),'CONNECTIONTEST');
                              // },200);
                           });
                           socket.onClose(function(e){
                                 RingLogger.print("SOCKET CLOSED : ",e,RingLogger.tags.CONNECTION);
                           });
                           window.onbeforeunload = function(){
                                 RingLogger.print("On before unload connection closed",RingLogger.tags.CONNECTION);

                                 if($rootScope.unloadWarn) {
                                   return "You have unsaved changes.  Do you want to leave this page and lose your changes?";
                                 }

                                 closeConnection();

                                 //return "are You Sure";
                           };

                       }catch(e){
                            //$rootScope.$broadcast('CONNECTION_ERROR');
                           RingLogger.alert("CONNECTION_ERROR"+e.message,RingLogger.tags.CONNECTION);
                       }
                   }else{
                        //$rootScope.$broadcast('CONNECTION_ERROR');
                       alert("Your browser seem back dated. To use RingId with greater user experience we advice you to use modern browser. ");
                       return; //ajax is removed
                   }
                   socket.onMessage(MainOnMessageHandler,{});
               }
             function initInterval(){
                var kpPacket = getKeepAlivePacket();
                    if (!kpPacket){ return; }
                    kpPacket.keepalive = true;//for log purpose
                 keepAliveSender = window.setInterval(function(kpPacket){
                     processIntervals();
                     if(!kpPacket){
                         stopInterVal();return;//sessionId not found so stopping the interval
                     }
                     //if(!socket.socket){ // ajax stop working
                       //  socket.fetch(getKeepAlivePacket());
                    // }else{ // else socket
                         send(kpPacket);
                    // }
                 }.bind(null,kpPacket),5000);
             }
             function connectionReset(){
                // throw new Error("Socket Reset");
                // socket.socket.binaryType = 'arraybuffer';
                 stopInterVal();
                 socket.close();
                 socket = null;
                 stopSending = true;
                 init();
                 stopSending = false;
                 //socket.socket.binaryType = 'arraybuffer';
                 //if(!socket.socket){
                 //  socket.init(getKeepAlivePacket());
                 //}
                 if (keepAlive){ initInterval(); }
             }
             function closeConnection(){
                // throw new Error("Socket Closed");
                 if(keepAliveSender){
                     //$interval.cancel(keepAliveSender);
                     window.clearInterval(keepAliveSender);
                 }

                 if(socket.isOpen()){
                     socket.close();
                 }else{
                    if (socket.socket.readyState === 0){
                        socket.onOpen(function(){
                        socket.close();
                     });
                    }

                 }

             }

             function stopInterVal(){
               //  $interval.cancel(keepAliveSender);
               window.clearInterval(keepAliveSender);
             }



             function sendBrokenPacket(request_type,messageViewArray,data,packetId){ //message expected as string
                 var packets = [],hi, i,headerLength=129,full_packet,packet_start=0,packet_end,// with full packet there are two bytes of request type and packet type sp excluding it
                     len = messageViewArray.byteLength,header,headbuf,last_sent = Date.now(),now;
                     var sId = Storage.getCookie('sId');
                 var totalPacket = Math.ceil(len/CLIENT_DATA_SIZE),
                     uniqueKey =  (CurrentuId || "")  + utilsFactory.tabId + utilsFactory.getUniqueID().toString(),
                     glu = totalPacket < 128 ? 1:2;//one byte or two byte
                 for(i=0;i<totalPacket;i++){
                     packet_end = (CLIENT_DATA_SIZE*(i+1))-1;
                     if(packet_end > len){
                         packet_end = len-1;//if its over the data
                     }
                     headbuf = new ArrayBuffer(headerLength+(packet_end-packet_start+1));
                     header = new DataView(headbuf);
                     header.setUint8(0,request_type);//setting request type on first byte
                     header.setUint8(1,1);//setting packet type on second byte
                     hi = 2;
                     if(data.actn){
                         hi = header.addAttributeInt(hi,ATTRIBUTE_CODES.ACTION,2,data.actn);
                     }
                     if(!!packetId){
                         packetId = packetId.toString();
                         hi = header.addAttributeString(hi,ATTRIBUTE_CODES.CLIENT_PACKET_ID,packetId);
                     }
                     hi = header.addAttributeInt(hi,ATTRIBUTE_CODES.TOTAL_PACKET,glu,totalPacket);
                     hi = header.addAttributeInt(hi,ATTRIBUTE_CODES.PACKET_NUMBER,glu,i);//current packet number
                     hi = header.addAttributeInt(hi,ATTRIBUTE_CODES.WEB_TAB_ID,1,utilsFactory.tabId);//current packet number
                     hi = header.addAttributeString(hi,ATTRIBUTE_CODES.UNIQUE_KEY,uniqueKey);
                     if(sId){
                      hi = header.addAttributeString(hi,ATTRIBUTE_CODES.WEB_UNIQUE_KEY,sId);
                     }

                     hi = header.addAttributeData(hi,ATTRIBUTE_CODES.DATA,messageViewArray,packet_start,(packet_end-packet_start+1));
                     packet_start = packet_end+1;
                     //full_packet = header.merge(0,hi,messageViewArray,packet_start,packet_end);
                     //data_packet = messageViewArray.copy(packet_start,packet_end+1);
                     //console.info("packet Number" + i);
                      full_packet = header.copy(0,hi);
                      // if(!socket.socket){
                          // packets.push(header.copy(0,hi));
                      // }else{

                     packets.push(full_packet);
                      // }
                   }
                // console.log()
                    var sendPacket = function sendPackInner(){
                        while(packets.length){
                            var pack;
                            now = Date.now();
                            if(now - last_sent >=180){
                                pack = packets.shift();
                                send(pack);
                                // var message = parseMessageData(pack);
                                // if(message){
                                //    RingLogger.print(mes,RingLogger.tags.RECEIVED + "BROKEN");
                                // }
                                last_sent = now;
                            }else{
                                setTimeout(sendPackInner,180);
                                return;
                            }
                        }
                    };
                    sendPacket();
                 return false;
             }

             function changeMessageToByte(message,packetType,request_type){ // message as string/object
                 if (!angular.isString(message)) {
                    message = angular.toJson(message);
                 }

                 var buffer,messageViewArray,index= 0,len = packetType ? message.length : message.length + 2;
                 buffer = new ArrayBuffer(len);
                 messageViewArray = new DataView(buffer);
                 if(!packetType){ // for broken packet 1, else 0 so we have to add two byte if its complete packet
                     messageViewArray.setUint8(index++,request_type);
                     messageViewArray.setUint8(index++,0);
                 }
                 if(message.length){
                     angular.forEach(message.toCharCodeArray(),function(val){
                         messageViewArray.setUint8(index++,val);
                     });
                 }
                 return messageViewArray;
             }

                //init(); //initing the socket
             function buildPacketToSend(packetId, data,request_type){//append sessionIdBefore Send
                    var message,messageViewArray,sId = Storage.getCookie('sId');
                    data = data || {};
                    data.pckId = packetId;
                    if (!!sId) {
                        data.sId = sId;
                    }
                    data.tbid = utilsFactory.tabId;
                    data.dvc = 5;
                    message = angular.toJson(data);

                    //if(data.actn === 134) {
                    //    //return sendBrokenListPacket(request_type,data,packetId);
                    //}else
                    if((message.length + 2 > CLIENT_DATA_SIZE)&& data.actn !== 23 && data.actn !== 25 && request_type !== 3){ // including request_type and packet_type
                        messageViewArray = changeMessageToByte(message,1,request_type);//broken packet type is 1
                        return sendBrokenPacket(request_type,messageViewArray,data,packetId);
                    }else{
                        return changeMessageToByte(message,0,request_type); // complete packet type is 0
                    }

             }

             var send = function sendD(data,force){
                 if(!!data){
                     sendQueue.push(data);
                 }
                 if(stopSending && !force){
                     return;
                 }
                 if(socket.socket.readyState === 0){
                    return;
                 }
                 if(!socket.isOpen() && socket.socket.readyState !== 0){
                    socket.reconnect();return;
                 }
                 // if(socket.readyState === 0){
                 //     if(!timeoutSetted){
                 //         setTimeout(function(){
                 //             timeoutSetted = false;
                 //             sendD();
                 //         },1000);
                 //         timeoutSetted = true;
                 //     }
                 //     return;
                 // }
                 while (sendQueue.length) {
                     var now = Date.now(),timediff = now - lastSendingTime; // for testing pupose
                   //  if(timediff > 200){ // Auth Server Drop Out Packets if previous packet receives in 200ms
                         var tempdata = sendQueue.shift();

                         RingLogger.information("socket state :" + socket.socket.readyState + " time diff : " + (timediff/1000),RingLogger.tags.CONNECTION);
                         RingLogger.infoblack(tempdata.print_r("return"),!!tempdata.keepalive ? RingLogger.tags.KEEPALIVE : RingLogger.tags.SEND);
                         socket.send(tempdata);
                         lastSendingTime = now;
                    // }else{
                       // setTimeout(function(){
                          //  send();
                        //},200-timediff);
                   //  }
                 }
             };

                function sendData(data,request_type,defer){
                    var message,packetId;
                    packetId = data.pckId || utilsFactory.getUniqueID();
                    message = buildPacketToSend(packetId,data,request_type);
                    if(!!defer) {
                        deferToBeResolved[packetId] = defer;//keeping defer to resolve while data catched with this packet Id
                    }
                    if(message){
                        return send(message,request_type === OPERATION_TYPES.SYSTEM.REQUEST_TYPE.AUTHENTICATION);
                    }// sending through socket or ajax
                }

                function initDeferRequest(data,request_type,mergeData){
                    var defer = mergeData ? mergerService.defer():$q.defer(),res;
                    res = sendData(data,request_type,defer);
                    //if(!socket.socket){ // for ajax request
                      //  res.success(function(data,status,headers){
                      //response that coming result on request with ajax for example auth request
                      //      MainOnMessageHandler(data,true);
                      //  });//sending byte view data through socket/ajax
                  //  }else{
                        // note : for websocket it just sent the data and waits for receive
                  //  }
                    //setTimeout(function(){
                    //    defer.notify(CUSTOM_PROMISE.REQUEST_SENT);
                    //},10);
                    return defer.promise;
                 }
                 function initDeferRequestSafeMode(data,request_type, mergeData){
                    var defer = mergeData ? mergerService.defer():$q.defer();
                    if(!floodingData[data.actn]){
                      floodingData[data.actn] = [];
                    }
                    floodingData[data.actn].push(sendData.bind(null,data,request_type,defer));
                    if(!floodingDataInterval){
                      floodingDataInterval = setInterval(processSafeModeSender,300);
                    }
                    return defer.promise;
                 }

                 function processSafeModeSender(){
                   // RingLogger.print("inter val called" , floodingData,"SafeModeSender");
                    var actn,fn,floodingFlag=false;
                    for(actn in floodingData){
                    //   RingLogger.print("inside loop flooding data" ,"SafeModeSender");
                        if(floodingData.hasOwnProperty(actn) && floodingData[actn].length){
                            fn = floodingData[actn].shift();
                            fn.call();
                            if(!floodingData[actn].length){
                                delete floodingData[actn];
                            }else{
                              floodingFlag = true;
                            }
                        }
                    }
                   // RingLogger.print("values in interval ", floodingFlag ,floodingDataInterval,"SafeModeSender");
                    if(!floodingFlag && floodingDataInterval){
                        //RingLogger.print("clearing interval ", floodingDataInterval,"SafeModeSender");
                        clearInterval(floodingDataInterval);
                        floodingDataInterval = angular.noop();
                      //  RingLogger.print("after clearing interval ", floodingDataInterval,"SafeModeSender");
                    }
                 }

                 function processIntervals(){
                        intervalFunctions.doForAll(function(f){
                            f.call(null);
                        });
                 }


                ObjectToBeReturn = {
                    init : init,
                    close : closeConnection,
                    send : function(data,request_type){ // do not return any promise
                        sendData(data,request_type);
                    },
                    request : function(data, request_type, flooding){//returns a $q promise
                        if(!flooding){
                            return initDeferRequest(data, request_type);
                        }else{
                           return initDeferRequestSafeMode(data,request_type);
                        }

                    },
                    pull : function(data, request_type, flooding){//returns a $q promise
                        if(!flooding){
                            return initDeferRequest(data, request_type, true);
                        }else{
                           return initDeferRequestSafeMode(data, request_type, true);
                        }
                    },
                    subscribe : function(callback,options){
                      var i,should_call_with,backUp = [];

                        options = options || {};
                        options.key = options.key || utilsFactory.getUniqueID();
                        options.scope = options.scope || $rootScope;
                        options.autoApply = false;
                        options.fn = callback || angular.noop;
                        // filter must be a function
                        if(!options.filter && !!options.action){
                            options.filter = getMessageFilterByActionNumber(options.action);
                        }

                        subscribers.add(options.key,options);
                        if(!!options.callWithUnresolved){
                            for(i = 0;i<UnresolvedData.length;i++){
                                   should_call_with = options.filter.call(null,UnresolvedData[i]);
                                    if(!!should_call_with){
                                        options.fn.call(null,UnresolvedData[i]);
                                    }else{
                                      backUp.push(UnresolvedData[i]);
                                    }
                            }
                            UnresolvedData.length = 0;
                            UnresolvedData = backUp;
                        }
                        return options.key;// key returned : useful when need to unsubscribe
                    },
                    unsubscribe : function(key){
                        subscribers.remove(key);
                    },
                    stop :function(){
                        stopSending = true;
                    },
                    resume : function(){
                        stopSending = false;
                        if(!socket.isOpen() && socket.socket.readyState !== 0){
                            socket.reconnect();
                        }
                        send();

                    },
                    reset : function(){
                        connectionReset();
                        send();
                    },
                    addInterval : function(func){
                        var key = utilsFactory.getUniqueID();
                        intervalFunctions.add(key,func);
                        return key;
                    },
                    removeInterval :function(key){
                        intervalFunctions.remove(key);
                    },
                    keepAlive : function(){
                        keepAlive = true;
                        initInterval();
                    }
                };

             //$cookies.act = utilsFactory.tabId;
             //$cookies.tt = ($cookies.tt && ($cookies.tt+1)) || 1;

             //var actChecker = setInterval(function(){
             //       if($cookies.a)
             //},1000);
             // we will keep a single connection if multiple tab is opened
             // so on $rootScope ringactive we should re connect and in ringInactive we should close connection

             $rootScope.$on('ringInactive',function(event){
                // console.log("soccket stat : " + socket.isOpen() +" currentTabId :" + utilsFactory.tabId );
                // closeConnection();
                 //setTimeout(function(){
                 //   if($cookies.act === utilsFactory.tabId){
                 //       if(!socket.isOpen()){
                 //           connectionReset();
                 //       }
                 //   }
                 //},3000);
                 //$rootScope.$on('$destroy',function(){
                 //       console.log("hello");
                 //});
                 //console.info("Window Is Not Active");
                 //if($cookies.sessionID != sessionID) {
                     //sessionID = $cookies.sessionID;
                     //connectionReset();
                 //}
             });

             $rootScope.$on('$locationChangeStart', function( event ) {
                 //var answer = confirm("Are you sure you want to leave this page?")
                 //if (!answer) {
                 //    event.preventDefault();
                 //}
             });

                return ObjectToBeReturn;
            }
})(DataView);




/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* * Copyright : Ipvision
*
* * File Name : video-metadata.service.js
*
* * Creation Date : 01-01-2015
*
* * Last Modified : Tue 03 Nov 2015 14:36:47 BDT
*
* _._._._._._._._._._._._._._._._._._._._._.*/


(function (DataView) {
    'use strict';

    var frameTypes = {
        /*
         * Textual frames
         */
        //'TALB': 'album',
        //'TBPM': 'bpm',
        //'TCOM': 'composer',
        //'TCON': 'genre',
        //'TCOP': 'copyright',
        //'TDEN': 'encoding-time',
        //'TDLY': 'playlist-delay',
        //'TDOR': 'original-release-time',
        //'TDRC': 'recording-time',
        //'TDRL': 'release-time',
        //'TDTG': 'tagging-time',
        //'TENC': 'encoder',
        //'TEXT': 'writer',
        //'TFLT': 'file-type',
        //'TIPL': 'involved-people',
        //'TIT1': 'content-group',
        'TIT2': 'title',
        //'TIT3': 'subtitle',
        //'TKEY': 'initial-key',
        //'TLAN': 'language',
        //'TLEN': 'length',
        //'TMCL': 'credits',
        //'TMED': 'media-type',
        //'TMOO': 'mood',
        //'TOAL': 'original-album',
        //'TOFN': 'original-filename',
        //'TOLY': 'original-writer',
        'TOPE': 'original-artist',
        //'TOWN': 'owner',
        'TPE1': 'artist',
        //'TPE2': 'band',
        //'TPE3': 'conductor',
        //'TPE4': 'remixer',
        //'TPOS': 'set-part',
        //'TPRO': 'produced-notice',
        //'TPUB': 'publisher',
        //'TRCK': 'track',
        //'TRSN': 'radio-name',
        //'TRSO': 'radio-owner',
        //'TSOA': 'album-sort',
        //'TSOP': 'performer-sort',
        //'TSOT': 'title-sort',
        //'TSRC': 'isrc',
        //'TSSE': 'encoder-settings',
        //'TSST': 'set-subtitle',
        /*
         * Textual frames (<=2.2)
         */
        //'TAL': 'album',
        //'TBP': 'bpm',
        //'TCM': 'composer',
        //'TCO': 'genre',
        //'TCR': 'copyright',
        //'TDY': 'playlist-delay',
        //'TEN': 'encoder',
        //'TFT': 'file-type',
        //'TKE': 'initial-key',
        //'TLA': 'language',
        //'TLE': 'length',
        //'TMT': 'media-type',
        'TOA': 'original-artist',
        //'TOF': 'original-filename',
        //'TOL': 'original-writer',
        //'TOT': 'original-album',
        'TP1': 'artist',
        //'TP2': 'band',
        //'TP3': 'conductor',
        //'TP4': 'remixer',
        //'TPA': 'set-part',
        //'TPB': 'publisher',
        //'TRC': 'isrc',
        //'TRK': 'track',
        //'TSS': 'encoder-settings',
        //'TT1': 'content-group',
        'TT2': 'title',
        //'TT3': 'subtitle',
        //'TXT': 'writer',
        /*
         * URL frames
         */
        //'WCOM': 'url-commercial',
        //'WCOP': 'url-legal',
        //'WOAF': 'url-file',
        //'WOAR': 'url-artist',
        //'WOAS': 'url-source',
        //'WORS': 'url-radio',
        //'WPAY': 'url-payment',
        //'WPUB': 'url-publisher',
        /*
         * URL frames (<=2.2)
         */
        //'WAF': 'url-file',
        //'WAR': 'url-artist',
        //'WAS': 'url-source',
        //'WCM': 'url-commercial',
        //'WCP': 'url-copyright',
        //'WPB': 'url-publisher',
        /*
         * Comment frame
         */
        //'COMM': 'comments',
        /*
         * Image frame
         */
        'APIC': 'image',
        'PIC': 'image'
    };

    /*
     * ID3 image types
     */
    var frameImageTypes = [
        'other',
        'file-icon',
        'icon',
        'cover-front',
        'cover-back',
        'leaflet',
        'media',
        'artist-lead',
        'artist',
        'conductor',
        'band',
        'composer',
        'writer',
        'location',
        'during-recording',
        'during-performance',
        'screen',
        'fish',
        'illustration',
        'logo-band',
        'logo-publisher'
    ];

    angular
        .module('ringid.common.media_metadata_service', ['ringid.utils'])
        .service('mediaMetadata', mediaMetadata);

        mediaMetadata.$inject = [ '$$q', 'Ringalert', 'utilsFactory'];
        function mediaMetadata( $q, Ringalert, utilsFactory) { //jshint ignore:line
            var self = this;  //jshint ignore:line

            function fetchVideoMeta(thisVideo) {
                    //var thisVideo = this;
                    var //canvas = document.createElement('canvas'),
                        thumb = {
                            drtn: Math.floor(thisVideo.duration),
                            tiw: thisVideo.videoHeight,
                            tih: thisVideo.videoWidth,
                            artst: '',
                            ttl: thisVideo.nameFromFile.substr(0, thisVideo.nameFromFile.lastIndexOf('.')) || thisVideo.nameFromFile,
                            //uniqueId: thisVideo.uniqueId,
                            //thmbURL: '',
                            //previewUrl: ''
                        };

                    //canvas.height = thumb.ih;
                    //canvas.width = thumb.iw;
                    //ctx = canvas.getContext('2d');

                    //ctx.drawImage(thisVideo, 0, 0, thumb.iw, thumb.ih);
                    //thumb.previewUrl= canvas.toDataURL('image/jpeg');
                    //thumb.file = utilsFactory.dataURLToBlob(thumb.previewUrl);
                    //RingLogger.information('size: ' + thumb.file.size + ' currentTime: ' + thisVideo.currentTime + ' file: ' + thisVideo.nameFromFile, RingLogger.tags.MEDIA);


                    //thumb.file.name = 'video-thumb.jpg';

                    //if (thumb.file.size < 2000 && thisVideo.currentTime > 4) {
                        ////thisVideo.currentTime = thisVideo.currentTime - 0.5;
                        //thumb.previewUrl = '';
                    //}


                    window.URL.revokeObjectURL(thisVideo.src);

                    thisVideo.deferObj.resolve(thumb);

            }


            function parseFrameLegacy(buffer) {
                var dv = new DataView(buffer),
                    result = {tag: null, value: null},
                    encoding,
                    header = {
                        id: dv.getString(0, 3),
                        type: dv.getString(0, 1),
                        size: dv.getUint24(3)
                };
                RingLogger.print( header , RingLogger.tags.UPLOAD);
                /*
                * No support for compressed, unsychronised, etc frames
                **/
               if (!(header.id in frameTypes)) {
                   return false;
               }

               result.tag = frameTypes[header.id];
               if (header.type === 'T') {
                    encoding = dv.getUint8(7);
                    RingLogger.information('encoding: ' + encoding, RingLogger.tags.UPLOAD);

					result.value = dv.getString(7, dv.byteLength-7);
                    //if(header.id === 'TCO' && !!parseInt(result.value)) {
                        //result.value = Genres[parseInt(result.value)];
                    //}
				//} else if (header.type === 'W') {
					//result.value = dv.getString(7, dv.byteLength-7);
                //} else if (header.id === 'COM')	 {
                    //encoding = dv.getUint8(6);
                    //result.value = dv.getString(10, dv.byteLength-10);
                    //if (result.value.indexOf('\x00') !== -1) {
                        //result.value = result.value.substr(result.value.indexOf('\x00') + 1);
                    //}
               } else if (header.id === 'PIC') {
                    encoding = dv.getUint8(6);
                    var image = {
						type: null,
						mime: 'image/' + dv.getString(7, 3).toLowerCase(),
						description: null,
						data: null
                    };
                    image.type = frameImageTypes[dv.getUint8(11)] || 'other';
                    var variableStart = 11, variableLength = 0;
                    for(var i = variableStart;; i++) {
                        if(dv.getUint8(i) === 0x00) {
                            variableLength = i - variableStart;
                            break;
                        }
                    }
                    image.description = (variableLength === 0 ? null : dv.getString(variableStart, variableLength));
                    //image.data = new Uint8Array(buffer.slice(variableStart + 1));
                    result.value = new Blob(new Uint8Array(buffer.slice(variableStart + 1)), {type: image.mime});

                }

                return (result.tag ? result : false);
            }

            function parseFrame(buffer, major, minor) {
                minor = minor || 0;
                major = major || 4;

                if (major < 3) {
                    return parseFrameLegacy(buffer);
                }

				var dv = new DataView(buffer),
                    encoding,
                    result = {tag: null, value: null},
					header = {
						id: dv.getString(0, 4),
						type: dv.getString(0, 1),
						size: dv.getSynch(dv.getUint32(4)), //dv.getSynch(dv.getIntByByte(start+4, 4)),
						flags: [
							dv.getUint8(8),  // dv.getIntByByte(start+8, 1),
							dv.getUint8(9) //dv.getIntByByte(start+9, 1)
						]
					};
				RingLogger.print( header , RingLogger.tags.UPLOAD  );

                //No support for compressed, unsychronised, etc frames
                if (header.flags[0] !== 0 || !(header.id in frameTypes)) {
                    return false;
                }

                result.tag = frameTypes[header.id];
				if(header.type === 'T') {
					encoding = dv.getUint8(10);
					/*
					 * TODO: Implement UTF-8, UTF-16 and UTF-16 with BOM properly?
					 */
					if(encoding === 0 || encoding === 3) {
						result.value = dv.getString(11, dv.byteLength-11);
					} else if(encoding === 1) {
						result.value = dv.getStringUtf16(-11, 11, true);
					} else if(encoding === 2) {
						result.value = dv.getStringUtf16(-11, 11);
					} else {
						return false;
					}
					//if(header.id === 'TCON' && !!parseInt(result.value)) {
						//result.value = Genres[parseInt(result.value)];
					//}
				//} else if(header.type === 'W') {
					//result.value = dv.getString(10, dv.byteLength-10);
				//} else if(header.id === 'COMM') {
					/*
					 * TODO: Implement UTF-8, UTF-16 and UTF-16 with BOM properly?
					 */
					//var variableStart = 14, variableLength = 0;
					//encoding = dv.getUint8(10);
					/*
					 * Skip the comment description and retrieve only the comment its self
					 */
					//for(var i = variableStart;; i++) {
						//if(encoding === 1 || encoding === 2) {
							//if(dv.getUint16(i) === 0x0000) {
								//variableStart = i + 2;
								//break;
							//}
							//i++;
						//} else {
							//if(dv.getUint8(i) === 0x00) {
								//variableStart = i + 1;
								//break;
							//}
						//}
					//}
					//if(encoding === 0 || encoding === 3) {
						//result.value = dv.getString(variableStart, dv.byteLength - variableStart);
					//} else if(encoding === 1) {
						////result.value = dv.getStringUtf16(-1 * variableStart, variableStart, true);
					//} else if(encoding === 2) {
						////result.value = dv.getStringUtf16(-1 * variableStart, variableStart);
					//} else {
                        //return false;
					//}
				} else if(header.id === 'APIC') {
					encoding = dv.getUint8(10);
					var image = {
							type: null,
							mime: null,
							description: null,
							data: null
						};
					var variableStart = 11, variableLength = 0;
					for(var i = variableStart;;i++) {
						if(dv.getUint8(i) === 0x00) {
							variableLength = i - variableStart;
							break;
						}
					}
					image.mime = dv.getString(variableStart, variableLength);
                    image.type = frameImageTypes[dv.getUint8(variableStart + variableLength + 1)] || 'other';
                    variableStart += variableLength + 2;
                    variableLength = 0;
                    for(var i = variableStart;; i++) {
                        if(dv.getUint8(i) === 0x00) {
                            variableLength = i - variableStart;
                            break;
                        }
                    }
                    image.description = (variableLength === 0 ? null : dv.getString(variableStart, variableLength));
                    //image.data = new Uint8Array(buffer.slice(variableStart + 1));
                    result.value = new Blob(new Uint8Array(buffer.slice(variableStart + 1)), {type: image.mime});
				}
				return (result.tag ? result : false);


            }

            function readID3Tags(buffer, meta) {
                var dv = new DataView(buffer),
                    metaV2 = {},
                    tagVersion,
                    tagSize = 0,
                    headerSize = 10,
                    tagFlags,
                    offset = dv.byteLength - 128;


                // id3v1
                if (dv.getString(offset, 3) === 'TAG') {
                    offset += 3;
                    meta.ttl = dv.getString(offset, 30).trim() || null;
                    offset += 30;
                    meta.artst = dv.getString(offset, 30).trim() || null;
                // id3v2
                } else {
                    RingLogger.warning('ID3V1 MISSING', RingLogger.tags.UPLOAD);
                }

                // id3v2
                tagVersion = dv.getUint8(3);
                tagFlags = dv.getUint8(5); //dv.getIntByByte(5, 1);
                tagSize += dv.getSynch(dv.getUint32(6));
                RingLogger.information('tagVersion: ' + tagVersion, RingLogger.tags.UPLOAD);
                RingLogger.information('tagFlags: ' + tagFlags, RingLogger.tags.UPLOAD);
                if (tagSize > dv.byteLength || dv.getString(0, 3) !== 'ID3' || tagVersion > 4 || (tagFlags & 0x80) !== 0) {
                    RingLogger.information('NO ID3V2 TAG', RingLogger.tags.UPLOAD);
                } else {
                    if ((tagFlags & 0x40) !== 0) {
                        headerSize += dv.getSynch(dv.getUint32(11));
                    }

                    // calculate the tag size to be read
                    while(headerSize < tagSize) {
                        RingLogger.information('headerSize: ' + headerSize, RingLogger.tags.UPLOAD);
                        RingLogger.information('tagSize: ' + tagSize, RingLogger.tags.UPLOAD);
                        var frame,
                            slice,
                            frameBit,
                            isFrame = true;

                        for(var i = 0; i < 3; i++) {
                            frameBit = dv.getUint8(headerSize+i);
                            if((frameBit < 0x41 || frameBit > 0x5A) && (frameBit < 0x30 || frameBit > 0x39)) {
                                isFrame = false;
                            }
                        }
                        if(!isFrame)  {
                            RingLogger.warning('NO FRAME FOUND FOR MP3', RingLogger.tags.UPLOAD);
                            break;
                        }
                        /*
                         * < v2.3, frame ID is 3 chars, size is 3 bytes making a total size of 6 bytes
                         * >= v2.3, frame ID is 4 chars, size is 4 bytes, flags are 2 bytes, total 10 bytes
                         */
                        if(tagVersion < 3) {
                            slice = buffer.slice(headerSize, headerSize + 6 + dv.getUint24(headerSize + 3));
                        } else {
                            slice = buffer.slice(headerSize, headerSize + 10 + dv.getSynch( dv.getUint32(headerSize + 4) ));
                        }

                        frame = parseFrame(slice, tagVersion);


                        RingLogger.print(frame, RingLogger.tags.UPLOAD);
                        if(frame) {
                            metaV2[frame.tag] = frame.value;
                        }
                        headerSize += slice.byteLength;
                    }

                }

                // put id3v1 or id3v2 tags
                meta.ttl = metaV2.title ||  meta.ttl || '';
                meta.artst = metaV2.artist || metaV2['original-artist'] || meta.artst || '';
                // TODO FIX AUDIO IMAGE CAPTURE THEN ENABLE BELOW LINE
                //meta.thmbURL = metaV2.image || null;
            }


            function fetchAudioMeta()  {
                    var thisAudio = this, //jshint ignore:line
                        meta = {
                                drtn: Math.floor(thisAudio.duration),
                                tiw: 0,
                                tih: 0,
                                artst: '',
                                ttl: thisAudio.nameFromFile.substr(0, thisAudio.nameFromFile.lastIndexOf('.')) || thisAudio.nameFromFile,
                                thmbURL: '',
                                //uniqueId: thisAudio.uniqueId,
                        };

                    RingLogger.log(meta, RingLogger.tags.MEDIA);


                    var reader = new FileReader();
                    reader.onload = function() {
                        readID3Tags(this.result, meta);
                        RingLogger.print(meta, RingLogger.tags.UPLOAD);
                        thisAudio.deferObj.resolve(meta);
                    };
                    reader.readAsArrayBuffer(thisAudio.fileObj);

            }


            function errorHandler(cause) {
                RingLogger.error(cause, RingLogger.tags.MEDIA);
                this.deferObj.reject(); //jshint ignore:line
            }

            self.generateMeta = function(uploadFile, mediaType) {
                var defer = $q.defer(),
                    mediaElement;


                if(mediaType === 'audio') {
                    mediaElement = document.createElement('audio');
                    mediaElement.addEventListener('loadeddata', fetchAudioMeta);
                    mediaElement.fileObj = uploadFile;
                } else {
                    mediaElement = document.createElement('video');
                    mediaElement.addEventListener('loadeddata', function() {
                        var thisVideo = this;
                        thisVideo.currentTime =  (thisVideo.duration > 20.0) ? 10.0 : thisVideo.duration / 2;

                        function fetchMeta() {
                            mediaElement.removeEventListener('timeupdate', fetchMeta);
                            fetchVideoMeta(thisVideo);
                        }

                        mediaElement.addEventListener('timeupdate', fetchMeta);
                    });

                }

                mediaElement.deferObj = defer;
                mediaElement.nameFromFile = uploadFile.name;
                //mediaElement.uniqueId = uploadFile.getKey();

                mediaElement.addEventListener('onerror', errorHandler);
                mediaElement.src = window.URL.createObjectURL(uploadFile);


                return defer.promise;
            };


        }

})(DataView);

/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* * Copyright : Ipvision
* _._._._._._._._._._._._._._._._._._._._._.*/

(function () {
    'use strict';

    angular
        .module('ringid.common.file_upload_service', ['ringid.utils'])
        .service('fileUploadService', fileUploadService);

        fileUploadService.$inject = [ '$$q', 'Storage', 'settings', '$rootScope', 'SystemEvents', 'Ringalert',  'utilsFactory', '$ringhttp', 'imageQuality', 'mediaMetadata'];
        function fileUploadService( $q, StorageFactory, settings, $rootScope, SystemEvents, Ringalert, utilsFactory, $ringhttp, imageQuality, mediaMetadata) { //jshint ignore:line
            var SCOPES = {};
            function getByteResponse(xhrResponse) {
                var DataViewObject = new DataView(xhrResponse),
                    success,
                    response,
                    responseLength;

                if(!DataViewObject.byteLength){
                    response = {sucs: false, mg: 'Failed. Response unreadable' };
                    response = {sucs: false, mg: 'Failed. Response unreadable' };
                } else {
                    success = DataViewObject.getBool(0);
                    if(success === false) {
                        responseLength = DataViewObject.getUint8(1);
                        response = {sucs: false, mg: DataViewObject.getString(2, responseLength)};
                    } else if (success === true) {
                        responseLength = DataViewObject.getUint8(1);
                        response = {sucs: true, url: DataViewObject.getString(2, responseLength) };
                    }
                }
                return response;
            }


            // constructor function
            function UploadFile(uploadType, file,safeDigest) {
                var uploadPath = '',
                    deferred,
                    fileObj = {
                        //uniqueId: file.uniqueId || utilsFactory.getUniqueID(),
                        uniqueId: utilsFactory.getUniqueID(),
                        uploadType: uploadType,
                        file: file || null,
                        fileType: file.type ? file.type.substr(0, file.type.indexOf('/')) : 'image',
                        response: {
                            url: ''
                        },
                        //ttl: (uploadType !== 'status' ) ? obj.file.name.substr(0, obj.file.name.lastIndexOf('.')) || obj.file.name : '',
                        meta: {
                            ttl: (uploadType === 'status' || uploadType === 'image' || !file.name ) ? '' : file.name.substr(0, file.name.lastIndexOf('.')) || file.name
                        },
                        gotMeta: false,
                        previewUrl: '',
                        progressVal: 0,
                        queued: false,
                        uploadComplete: false,
                        uploadFail: false
                    };

                fileObj.previewUrl = settings.baseUrl + 'images/' + fileObj.fileType + '-preview.jpg';
                //fileObj = angular.extend({}, fileObj, obj);

                if(uploadType === 'profilephoto' || uploadType === 'coverphoto') {
                    fileObj.repositionD = {ih: 0, iw: 0, cimX: 0, cimY: 0};
                }


                function onProgress(progress) {
                    //if (e.lengthComputable) {
                        //fileObj.progressVal = Math.round(e.loaded / e.total * 100);
                        fileObj.progressVal = progress;
                        if(fileObj.uploadType === 'coverphoto' || fileObj.uploadType === 'profilephoto') {
                            self.progress = fileObj.progressVal;
                        }
                        $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.PROGRESS_UPDATE);
                        safeDigest();
                    //}
                }

                function deleteGarbage() {
                    delete fileObj.file;
                }

                function onLoad(responseData) {
                    var response;
                    // upload complete
                    switch(fileObj.uploadType) {
                        case 'chatimage':
                            response = getByteResponse(responseData);
                            if(response.sucs === true) {
                                //response.url = settings.chatImBase + response.url;
                                response.url = response.url;
                            }
                            self.uploadProgress = false;
                            angular.extend(response, fileObj.meta || {});
                            break;
                        case 'tagchatimage':
                            response = angular.fromJson(responseData);
                            if(response.sucs === true) {
                                response.url = response.iurl;
                            }
                            self.uploadProgress = false;
                            angular.extend(response, fileObj.meta || {});
                            break;
                        case 'video':
                            response = getByteResponse(responseData);
                            fileObj.meta.thmbURL = response.url ? response.url.substr(0, response.url.lastIndexOf('.')) + '.jpg' : '';
                            fileObj.previewUrl = response.url ? settings.mediaBase + fileObj.meta.thmbURL : '';
                            break;
                        case 'audio':
                            response = getByteResponse(responseData);
                            break;
                        case 'coverphoto':
                        case 'profilephoto':
                            response =  angular.fromJson(responseData);
                            // readjust ih, iw to image original height and width
                            response.ih =  fileObj.meta.ih;
                            response.iw =  fileObj.meta.iw;
                            self.uploadProgress = false;
                            break;
                        case 'image':
                            response = angular.fromJson(responseData);
                            fileObj.previewUrl = response.iurl ?
                                settings.imBase + response.iurl.substr(0, response.iurl.lastIndexOf('/')+1) + 'pthumb' + response.iurl.substr(response.iurl.lastIndexOf('/')+1)
                                    : '';
                            // revoke
                            break;
                        case 'thumb':
                            response = getByteResponse(responseData);
                            break;
                        default:
                            response =  angular.fromJson(responseData);
                    }


                    fileObj.response = angular.extend({}, fileObj.response, response );


                    if(response.sucs === true) {
                        fileObj.uploadComplete = true;
                    } else {
                        fileObj.uploadFail = true;
                    }

                    RingLogger.print(angular.toJson(response), RingLogger.tags.UPLOAD);
                    if(response.sucs !== true) {
                        Ringalert.show(response.mg || 'Failed', 'error');
                    }
                    deferred.resolve( response );

                    deleteGarbage();
                    //safeDigest();
                }

                function onAbort() {
                    safeDigest();
                    deferred.reject();
                }

                function onError(response) {
                    if (response && response.mg) {
                        Ringalert.show(response.mg, 'error');
                    }
                    deferred.reject();
                }


                function fetchMeta(callBack) {
                    switch(fileObj.fileType) {
                        case 'video':
                        case 'audio':
                            mediaMetadata.generateMeta(fileObj.file, fileObj.fileType).then(function(meta) {
                                fileObj.meta = meta;
                                callBack({success: true});
                                safeDigest();
                            }, function(errMsg) {
                                Ringalert(errMsg, 'error');
                                fileObj.uploadFail = true;
                                if (deferred) {
                                    deferred.reject(errMsg);
                                } else {
                                    callBack({success: false, message: errMsg});
                                }
                                safeDigest();
                            });
                            break;
                        case 'image':
                            imageQuality.resizeImage(fileObj.file, fileObj.uploadType).then(function(meta) {
                                fileObj.file = meta.file;
                                fileObj.meta.ih = meta.ih;
                                fileObj.meta.iw = meta.iw;
                                fileObj.previewUrl = meta.previewUrl;
                                callBack({success: true});
                                safeDigest();
                            }, function(errMsg) {
                                fileObj.uploadFail = true;
                                if (deferred) {
                                    Ringalert.show(errMsg, 'error');
                                    deferred.reject(errMsg);
                                } else {
                                    callBack({success: false, message: errMsg});
                                }
                                safeDigest();
                            });
                            break;
                    }
                    fileObj.gotMeta = true;
                    safeDigest();
                }

                return {
                    getKey: function() {
                        return fileObj.uniqueId;
                    },
                    setRepositionData: function(obj) {
                        RingLogger.information( 'Set Reposition to : ' + angular.toJson(obj) , RingLogger.tags.UPLOAD);
                        fileObj.repositionD  = angular.extend({}, fileObj.repositionD || {}, obj);
                    },
                    getRepositionData: function() {
                        if (fileObj.uploadType === 'profilephoto') {
                            return { pimX: fileObj.repositionD.cimX, pimY: fileObj.repositionD.cimY};
                        } else {
                            return { cimX: fileObj.repositionD.cimX, cimY: fileObj.repositionD.cimY};
                        }
                    },
                    getFile: function() {
                        return fileObj.file;
                    },
                    getName: function() {
                        return fileObj.file.name;
                    },
                    fetchMeta: fetchMeta,
                    initUpload: function() {
                        var formData = new FormData(),
                            responseType = 'text';

                        deferred = $q.defer();
                        fileObj.queued = true;

                        formData.append('sId', StorageFactory.getCookie('sId'));
                        formData.append('uId', StorageFactory.getCookie('uId'));
                        formData.append('authServer', StorageFactory.getCookie('authServer'));
                        formData.append('comPort', StorageFactory.getCookie('comPort'));
                        formData.append('x-app-version', settings.apiVersion);

                        // put additional data for image files
                        switch(fileObj.uploadType) {
                            case 'profilephoto':
                                uploadPath = settings.imServer + 'ImageUploadHandler';
                                break;
                            case 'coverphoto':
                                uploadPath = settings.imServer +  'CoverImageUploadHandler';
                                break;
                            case 'tagchatimage':
                                uploadPath = settings.imServer + 'GroupContentHandler';
                                break;
                            case 'chatimage':
                                uploadPath = settings.imServer + 'ChatImageHandler';
                                responseType = 'arraybuffer';
                                break;
                            case 'image':
                                uploadPath = settings.imServer + 'AlbumImageUploadHandler';
                                break;
                            case 'video':
                                uploadPath = settings.mediaServer + 'Mp4UploadHandler';
                                responseType = 'arraybuffer';
                                break;
                            case 'audio':
                                uploadPath = settings.mediaServer + 'Mp3UploadHandler';
                                responseType = 'arraybuffer';
                                break;
                            case 'thumb':
                                uploadPath = settings.mediaServer + 'ThumbImageHandler';
                                responseType = 'arraybuffer';
                                fileObj.gotMeta = true; // no need to fetch meta of thumb image
                                break;
                            default:
                                RingLogger.warning('Can not Determine File upload Path: ' + uploadType, RingLogger.tags.UPLOAD);

                        }

                        if (fileObj.gotMeta) {
                            sendFile();
                        } else {
                            fetchMeta(sendFile);
                        }

                        function sendFile() {
                            if (fileObj.uploadType === 'coverphoto' || fileObj.uploadType === 'profilephoto' ) {
                                Object.keys(fileObj.repositionD).forEach(function (key) {
                                    formData.append(key, fileObj.repositionD[key]);
                                });

                            }
                            formData.append('file', fileObj.file, fileObj.file.name  || 'imagefile.jpg');
                            fileObj.xhr = $ringhttp.post(uploadPath, formData, responseType)
                                .success(onLoad)
                                .error(onError)
                                .progress(onProgress)
                                .abort(onAbort);
                        }


                        return deferred.promise;
                    },
                    cptn: function(newCaption) {
                        //if (fileObj.meta) {
                            return arguments.length ? (fileObj.meta.ttl = newCaption) : fileObj.meta.ttl;
                        //} else {
                            //return arguments.length ? (fileObj.ttl = newCaption) : fileObj.ttl;
                        //}
                        //if (fileObj.uploadType === 'audio') {
                        //} else {
                            //return arguments.length ? (fileObj.ttl = newCaption) : fileObj.ttl;
                        //}
                    }, // used in rg-upload directive to bind as a caption model for status images and maybe for video captions
                    getPreview: function() {
                        return fileObj.previewUrl;
                    },
                    cancelUpload: function() {
                        fileObj.uploadFail = true;
                        if (fileObj.xhr) {
                            fileObj.xhr.abortRequest();
                        } else if (fileObj.deferred) {
                            fileObj.deferred.reject();
                        }
                    },
                    setPreview: function(previewUrl) {
                        fileObj.previewUrl = previewUrl;
                    },
                    getProgress: function() {
                        return fileObj.progressVal;
                    },
                    uploadCompleted: function() {
                         return fileObj.uploadComplete;
                    },
                    uploadFailed: function() {
                        return fileObj.uploadFail;
                    },
                    getQueued: function() {
                        return fileObj.queued;
                    },
                    setQueued: function(bool) {
                        fileObj.queued = bool || true;
                    },
                    setMeta: function(metaObj) {
                        fileObj.meta =  metaObj;
                    },
                    getMeta: function() {
                        if(fileObj.hasOwnProperty('meta')) {
                            return fileObj.meta;
                        } else {
                            return false;
                        }
                    },
                    getAuthData: function(addTagList) {
                        var returnObj = {};

                        switch(fileObj.fileType) {
                            case 'image':
                                returnObj = {
                                    ih: fileObj.meta.ih,
                                    iw: fileObj.meta.iw,
                                    iurl: fileObj.response.iurl,
                                    cptn: fileObj.meta.ttl.utf8Encode()
                                };
                                break;
                            case 'video':
                                //returnObj =  {
                                    //strmURL: fileObj.response.url
                                //};
                                //returnObj = angular.extend({}, returnObj, fileObj.meta);
                                //returnObj.thmbURL = returnObj.strmURL.substr(0, returnObj.strmURL.lastIndexOf('.')) + '.jpg';
                                ////returnObj.previewURL = settings.imBase + returnObj.thmbURL;
                                //returnObj.ttl = fileObj.meta.ttl.utf8Encode(); // overriting video thumb ttl with user modified caption
                                //break;
                            case 'audio':
                                returnObj = {
                                    strmURL: fileObj.response.url,
                                    tiw: fileObj.meta.tiw,
                                    tih: fileObj.meta.tih,
                                    drtn: fileObj.meta.drtn,
                                    thmbURL: fileObj.meta.thmbURL,
                                    artst: fileObj.meta.artst.utf8Encode(),
                                    //ttl: fileObj.cptn.utf8Encode() //fileObj.meta.ttl
                                    ttl: fileObj.meta.ttl.utf8Encode()
                                };

                                if (addTagList) {
                                    for(var i = 0; i < self.tagList.length; i++) {
                                        self.tagList[i].sk =   self.tagList[i].sk.utf8Encode();
                                    }
                                    returnObj.htgLst = self.tagList;
                                }
                                break;
                            default:
                                returnObj = fileObj.response;
                                RingLogger.warning('File type for getAuthData did not match: ' + fileObj.fileType);
                        }

                        return returnObj;

                    }
                };
            }


            var self = this, // jshint ignore:line
                _albumId = -1;


            self.resetUpload = function resetUpload() {
                self.progress = 0;
                self.tagList = [];
                self.uploadProgress = false;
                self.profileImageFile = null;
                self.coverImageFile = null;
                self.imageFiles = [];
                self.videoFiles = [];
                self.audioFiles = [];
                self.chatImageFiles = {};

                self.selectFromAlbum = false; // from browse album.
            };

            self.resetUpload();

            self.createUploadFile = function(uploadType, obj) {
                return new UploadFile(uploadType, obj,safeDigest);
            };

            self.statusMediaCount = function(uploadWhat) {
                if(uploadWhat) {
                    return self[uploadWhat+'Files'].length;
                } else {
                    return 0;
                }
            };

            self.setUploadAlbum = function(albumId) {
                _albumId = albumId;
            };
            self.getUploadAlbum = function() {
                return _albumId;
            };

            self.queueFile = function(uploadType, fileObj) {
                //_albumId = -1;
                switch(uploadType) {
                    case 'profilephoto':
                        RingLogger.information('PROFILE UPLOAD FILE QUEEUD', RingLogger.tags.UPLOAD);
                        self.progress = 0;
                        self.profileImageFile = new UploadFile(uploadType, fileObj,safeDigest);
                        return self.profileImageFile;
                    case 'coverphoto':
                        RingLogger.information( 'COVER UPLOAD FILE QUEEUD', RingLogger.tags.UPLOAD);
                        self.progress = 0;
                        self.coverImageFile = new UploadFile(uploadType, fileObj,safeDigest);
                        return self.coverImageFile;
                    case 'tagchatimage':
                    case 'chatimage':
                        return new UploadFile(uploadType, fileObj,safeDigest);
                    case 'image':
                        self.imageFiles.push( new UploadFile(uploadType, fileObj,safeDigest));
                        break;
                    case 'video':
                        self.videoFiles.push(new UploadFile(uploadType, fileObj,safeDigest));
                        break;
                    case 'audio':
                        self.audioFiles.push(new UploadFile(uploadType, fileObj,safeDigest));
                        break;
                    default:
                        RingLogger.warning('Could not queu file. uploadType did not match: ' + uploadType, RingLogger.tags.UPLOAD);
                }
                safeDigest();
            };

            self.setReposition = function(dimension, uploadType) {
                if(uploadType === 'coverphoto') {
                    self.coverImageFile.setRepositionData(dimension);
                } else if (uploadType === 'profilephoto') {
                    self.profileImageFile.setRepositionData(dimension);
                } else {
                    RingLogger.warning('UPLOADTYPE: ' + uploadType, RingLogger.tags.UPLOAD);
                }
            };
            // used while changing cover and profile pic
            self.getReposition = function(uploadType) {
                if(uploadType === 'coverphoto') {
                    return self.coverImageFile.getRepositionData();
                } else if (uploadType === 'profilephoto') {
                    return self.profileImageFile.getRepositionData();
                } else {
                    RingLogger.warning('UPLOADTYPE: ' + uploadType, RingLogger.tags.UPLOAD);
                    return {};
                }
            };


            self.uploadQueue = function(uploadType, startIndex) {
                // for status videos, images, audios
                var promises = [],
                    endIndex,
                    whichFiles = uploadType + 'Files';

                if (startIndex < self[whichFiles].length) {
                    endIndex = (startIndex+2 < self[whichFiles].length) ? startIndex + 2 : self[whichFiles].length;
                    for (var i = startIndex; i < endIndex; i++) {
                        //reduce size if necessary and put to queue for upload
                        if ( self[whichFiles][i] &&
                            !self[whichFiles][i].getQueued() &&
                            !self[whichFiles][i].uploadFailed() ) {

                            promises.push(self[whichFiles][i].initUpload());
                            //promises.push(imageQuality.resizeImage(self[whichFiles][i].getFile(), $scope.rgUploadType));
                        } else {
                            RingLogger.warning('File alread queued for upload but FAILED', RingLogger.tags.UPLOAD);
                        }
                    }

                    // in case of failed uploads no promises
                    if (promises.length === 0) {
                        self.uploadQueue(uploadType, endIndex );
                        return;
                    }

                    $q.all(promises).then(function() {
                        removeFailed();
                        self.uploadQueue(uploadType, endIndex);
                        // show preview and resize postbox to accomodate image preview area
                    }, function(errData) {
                        endIndex = endIndex - removeFailed();
                        self.uploadQueue(uploadType, endIndex);
                    });

                } else {
                    var interval = setInterval(function() {
                        self.uploadProgress = false;
                        removeFailed(true);
                        for(var i = 0; i < self[whichFiles].length; i++) {
                            if (!self[whichFiles][i].uploadCompleted()) {
                                self.uploadProgress = true;
                                break;
                            }
                        }
                        if (!self.uploadProgress) {
                            clearInterval(interval);
                            $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.QUEUE_COMPLETE, uploadType);
                            if (self[whichFiles].length > 0) {
                                Ringalert.show('All files uploaded', 'success');
                            }
                            safeDigest();
                        }
                    }, 2000);
                }

                function removeFailed(startFromZero) {
                    var start = startFromZero ? 0 : startIndex;
                    var removeCounter = 0;
                    for(var i = start, l = self[whichFiles].length; i < l; i++) {
                        if (self[whichFiles][i] && self[whichFiles][i].uploadFailed()) {
                            self[whichFiles].splice(i, 1);
                            removeCounter++;
                            i--;
                            l--;
                        }
                    }
                    if (removeCounter > 0) {
                        safeDigest();
                    }
                    return removeCounter;
                }

            };
                self.setScopeForDigest = function(scope){
                    SCOPES[scope.$id] = scope;
                };
                self.removeScope = function(scope){
                    if(SCOPES[scope.$id]){
                        SCOPES[scope.$id] = null;
                    }
                };
            function safeDigest(){
                var digestScope;
                for(var key in SCOPES){
                    if (SCOPES.hasOwnProperty(key)) {
                        digestScope = SCOPES[key];
                        if(digestScope && digestScope.$id && !digestScope.$$destroyed){
                            digestScope.$rgDigest();
                        }
                    }
                }

            }

        }

})();



/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* * Copyright : Ipvision
*
* * File Name : image-quality.service.js
*
* * Creation Date : 01-01-2015
*
* * Last Modified : Tue 03 Nov 2015 17:13:48 BDT
*
* _._._._._._._._._._._._._._._._._._._._._.*/

(function () {

    'use strict';

    angular
        .module('ringid.common.image_quality_service', ['ringid.common.file_upload_service', 'ringid.utils'])
        .service('imageQuality', imageQuality);

        imageQuality.$inject = [ '$$q', 'APP_CONSTANTS', 'Ringalert', 'utilsFactory'];
        function imageQuality( $q, APP_CONSTANTS, Ringalert, utilsFactory) { // jshint ignore:line
            var self = this, // jshint ignore:line
                coverMinW = APP_CONSTANTS.COVER_PIC_UPLOAD_MINIMUM_WIDTH,
                coverMinH = APP_CONSTANTS.COVER_PIC_UPLOAD_MINIMUM_HEIGHT,
                coverMaxW = APP_CONSTANTS.COVER_PIC_UPLOAD_MAXIMUM_WIDTH,
                coverMaxH = APP_CONSTANTS.COVER_PIC_UPLOAD_MAXIMUM_HEIGHT,
                profileMinW = APP_CONSTANTS.PROFILE_PIC_UPLOAD_MINIMUM_WIDTH,
                profileMinH = APP_CONSTANTS.PROFILE_PIC_UPLOAD_MINIMUM_HEIGHT,
                imageMinH = APP_CONSTANTS.IMAGE_UPLOAD_MIN_HEIGHT,
                imageMinW = APP_CONSTANTS.IMAGE_UPLOAD_MIN_WIDTH;



            self.resizeImage = function(imageFile, uploadType) {
                // imageFile can be image source path or imageMap object

                var image = new Image(),
                    limitCross = false,
                    defer = $q.defer(),
                    meta = {
                        ih: 0,
                        iw: 0,
                        previewUrl: '',
                        file: ''
                    },
                    URL = window.URL || window.webkitURL;


                function imageLoaded() {
                        var imgObj = this; // jshint ignore:line
                        var canvas,
                            scale = 1,
                            ctx,
                            imageWidth =  imgObj.width,
                            imageHeight = imgObj.height;


                        function resizeInCanvas(imgQuality) {

                            canvas = document.createElement('canvas');
                            canvas.width = meta.iw;
                            canvas.height = meta.ih;
                            ctx = canvas.getContext('2d');

                            ctx.drawImage(imgObj, 0, 0, meta.iw, meta.ih);

                            if(imgQuality) {
                                meta.imQ = imgQuality.qualityIM.quality;
                            }

                            meta.previewUrl = canvas.toDataURL('image/jpeg');
                            meta.file = utilsFactory.dataURLToBlob(meta.previewUrl);

                            meta.file.name = imageFile.name || uploadType + '.jpg';

                            defer.resolve(meta);

                            //RingLogger.print('img: ' + imageFile.name + ' Quality: ' + meta.imQ, RingLogger.tags.UPLOAD);

                            // queue in upload service for actual upload later
                            //fileUploadService.queueFile(uploadType, meta);

                            // only for chat images retain objectURL otherwise remoke it
                            //if (uploadType  && (uploadType === 'chatimage' || uploadType === 'tagchatimage')) {
                                //defer.resolve(image.src, meta.boxValue);
                            //} else {
                                //RingLogger.information('revoking ObjectURL: ' + uploadType, RingLogger.tags.UPLOAD);
                                //URL.revokeObjectURL(image.src);
                                //defer.resolve(meta.previewUrl, meta.boxValue);
                            //}

                        }

                        // meature actual resize dimensions
                        if(imageWidth > coverMaxW || imageHeight > coverMaxH) {
                            // set width = maximum allowed Width and adjust Height
                            if ( (imageWidth / coverMaxW) > (imageHeight / coverMaxH)) {
                                scale = coverMaxW / imageWidth;
                                meta.iw= coverMaxW;
                                meta.ih = Math.floor( scale * imageHeight);
                            } else { // set height = maximum allowed and adjust width
                                scale = coverMaxH / imageHeight;
                                meta.ih = coverMaxH;
                                meta.iw= Math.floor(scale * imageWidth);
                            }
                        } else {
                            // no need to resize
                            meta.iw = imageWidth;
                            meta.ih = imageHeight;
                        }

                        RingLogger.print('Resize scale: ' + scale, RingLogger.tags.UPLOAD);
                        RingLogger.print('image.Width: ' + imageWidth + ' image.Height: ' + imageHeight, RingLogger.tags.UPLOAD);
                        RingLogger.print('resized.Width: ' + meta.iw + ' resized.Height: ' + meta.ih, RingLogger.tags.UPLOAD);
                        var minimumH = imageMinH,
                            minimumW = imageMinW;

                        switch(uploadType) {
                            case 'profilephoto':
                                if(meta.iw < profileMinW || meta.ih < profileMinH) {
                                    minimumH = profileMinH;
                                    minimumW = profileMinW;
                                    limitCross = true;
                                }
                                break;
                            case 'coverphoto':
                                if(meta.iw < coverMinW || meta.ih < coverMinH) {
                                    minimumH = coverMinH;
                                    minimumW = coverMinW;
                                    limitCross = true;
                                }
                                break;
                            case 'status':
                            case 'chatimage':
                            case 'tagchatimage':
                                if(meta.iw < imageMinW || meta.ih < imageMinH) {
                                    limitCross = true;
                                }
                                break;
                            default:
                                RingLogger.warn(': ' + uploadType, RingLogger.tags.UPLOAD);
                        }



                        if(limitCross) {
                            defer.reject('Image Size below Minimum(' + minimumW + 'px by ' + minimumH  + 'px) :' + imageFile.name);
                        } else {
                            // get quality and then resize and queue for uploading
                            // ignore
                            //if(imageFile.type === 'image/jpeg') {
                                //// calculate quality only for jpeg
                                //self.calculate(imgObj, resizeInCanvas);
                            //} else {
                                resizeInCanvas(false);
                            //}

                        }


                    }

                    function imageError () {
                        RingLogger.warning('invalid image error: ' + imageFile.name, RingLogger.tags.UPLOAD);
                        defer.reject('Image invalid: ' + imageFile.name);
                    }

                    if(typeof imageFile === 'string' ) {
                        image.setAttribute('crossOrigin', 'anonymous');
                        image.src = imageFile;
                    } else {
                        image.src = URL.createObjectURL(imageFile); // new file upload
                    }

                    image.onload = imageLoaded;
                    image.onerror = imageError;

                return defer.promise;
            };

        }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.common.services', [
            'ringid.common.media_metadata_service',
            'ringid.common.file_upload_service',
            'ringid.common.image_quality_service',
			'ringid.config',
			'ngWebSocket'
			//'ngCookies'
			])
		.factory('countryListService', countryListService)
        // get list of countries with code from a json file
		countryListService.$inject = ['$ringhttp', 'settings'];
		function countryListService($ringhttp, settings) {
			return {
					getList: function(forSignup) {
						return $ringhttp.get( settings.baseUrl + '/resources/countries.json');
					}
			};
		}
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

     angular
        .module('ringid.common.services')
        .service('imageHttpService', imageHttpService);

        imageHttpService.$inject = ['$$q', 'settings', '$$connector', 'OPERATION_TYPES'];
        function imageHttpService($q, settings, $$connector, OPERATION_TYPES){ // jshint ignore:line
            var self = this, //jshint ignore:line
                REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE,
                OTYPES = OPERATION_TYPES.SYSTEM.IMAGE,
                OTYPEFRIEND = OPERATION_TYPES.SYSTEM.FRIENDS;


            self.getAlbumList = function(fndId) {
                var payload = {};
                if(fndId) {
                    payload.actn = OTYPES.FETCH_FRIEND_ALBUM_LIST;
                    payload.fndId = fndId;
                } else {
                        payload.actn = OTYPES.FETCH_ALBUM_LIST;
                }
                return $$connector.request(payload, REQTYPE.REQUEST);
            };


            /**
            * @api {request} /APIREQUEST/97,109 Get Photos of Album
            * @apiVersion 0.1.0
            * @apiDescription Fetches photos of 3 predefined albums( profileImages, coverImages, feed Images/default)
            * @apiName GetAlbumImages
            * @apiGroup Image
            *
            * @apiParam {Number=97,109} actn TYPE_ALBUM_IMAGES / TYPE_FRIEND_ALBUM_IMAGES
            * @apiParam {Number} [fndId] Friend uId in case of friends photos
            * @apiParam {String='profileImages', 'coverImages', 'default'} albId Album id. predefined for three types of albums
            * @apiParam {Number} st=0 Pagination
            *
            *
            * @apiSuccess {Number} actn TYPE_FRIEND_ALBUM_IMAGES
            * @apiSuccess {String='default','coverImages','profileImages'} Album Id
            * @apiSuccess {Object[]{1..5}} imageList Image list
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} timg No of total Images in Album
            * @apiSuccess {Number} tr No of Image in response
            *
            * @apiSuccess (imageList) {String} cptn Caption
            * @apiSuccess (imageList) {Number=0,1} ic Image have User's comment or not
            * @apiSuccess (imageList) {Number} ih Image height
            * @apiSuccess (imageList) {Number=0,1} il Image have User's Like or not
            * @apiSuccess (imageList) {Number} imT Image Type
            * @apiSuccess (imageList) {Number} imgId Image Id
            * @apiSuccess (imageList) {Number} iw Image Width
            * @apiSuccess (imageList) {Number} nc No of Comments
            * @apiSuccess (imageList) {Number} nl No of Likes
            * @apiSuccess (imageList) {Number} tm Image upload time
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 97
            *       albId: "default"
            *       headerLength: 20
            *       imageList:  [
            *           0: {
            *               cptn: ""
            *               ic: 0
            *               ih: 183
            *               il: 0
            *               imT: 1
            *               imgId: 16343
            *               iurl: "2000001794/1435711880942.jpg"
            *               iw: 275
            *               nc: 0
            *               nl: 0
            *               tm: 1435732845444
            *           }
            *       ]
            *       pckId: "895751887743"
            *       seq: "2/2"
            *       sucs: true
            *       timg: 14
            *       tr: 10
            *     }
            *
            * @apiError Album has no Image
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 200 Not Found
            *     {
            *       "sucs": false
            *     }
            */

            self.getAlbumImages = function (obj) {
                var payload = {};
                if (obj.fndId) {
                    payload.actn = OTYPES.TYPE_FRIEND_ALBUM_IMAGES; // 109
                    payload.fndId  = obj.fndId;
                } else {
                    payload.actn = OTYPES.TYPE_ALBUM_IMAGES; // 97
                }
                payload.st = obj.st || 0;
                payload.albId = obj.albId;

                return $$connector.pull(payload, REQTYPE.REQUEST, true);
            };


            /**
            * @api {request} /APIREQUEST/89 Get Image Comments
            * @apiVersion 0.1.0
            * @apiDescription Fetches Comments for an Image
            * @apiName GetImageComments
            * @apiGroup Image
            *
            * @apiParam {Number=89} actn TYPE_COMMENTS_FOR_IMAGE
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number} st=0 Pagination
            *
            * @apiSuccess {Number=89} actn TYPE_COMMENTS_FOR_IMAGE
            * @apiSuccess {Object[]{1..5}} comments Comment list
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            *
            * @apiSuccess (comments) {String} cmn Comment Text
            * @apiSuccess (comments) {Number} cmnId Comment Id
            * @apiSuccess (comments) {String} fn User Name
            * @apiSuccess (comments) {il=1,0} il Image have User's Like or not
            * @apiSuccess (comments) {String} prIm Image Url
            * @apiSuccess (comments) {Number} sc Undefined
            * @apiSuccess (comments) {Number} tl Total Like
            * @apiSuccess (comments) {Number} tm Image upload time
            * @apiSuccess (comments) {Number} uId User uId
            *
            *
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 89
            *       comments: [
            *           0: {
            *               cmn: "more comments"
            *               cmnId: 2328
            *               fn: "Spirit Walker"
            *               il: 0
            *               prIm: "2000001794/1428886675955.jpg"
            *               sc: false
            *               tl: 0
            *               tm: 1435747371055
            *               uId: "2000001794"
            *           }
            *       ]
            *       headerLength: 60
            *       imgId: 16339
            *       pckFs: 1161342
            *       pckId: "574746651601"
            *       seq: "1/1"
            *       sucs: true
            *
            *     }
            *
            * @apiError Image has no Comments
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 404 Not Found
            *     {
            *       "sucs": false
            *     }
            */

            // self.getComments = function(obj) {
            //     var payload = {
            //             actn: OTYPES.TYPE_COMMENTS_FOR_IMAGE,
            //             imgId: obj.imgId,
            //             st: obj.st || 0
            //     };
            //     return $$connector.request(payload, REQTYPE.REQUEST);
            // };

            self.deleteImage = function(imgId) {
                return $$connector.request({
                    actn: OTYPES.DELETE_IMAGE,
                    imgIds: [imgId]
                }, REQTYPE.UPDATE);
            };


            // self.getCommentById = function(imgId, commentId) {
            //     $$connector.request({
            //         actn: OTYPES.ACTION_GET_FULL_COMMENT,
            //         imgId: imgId,
            //         cmnId: commentId,
            //         cmntT: 2 // 1=feed comment, 2= image comment

            //     },OTYPES.REQUEST_TYPE.REQUEST);
            // };



            /**
            * @api {request} /APIREQUEST/93 Get Image Likes (INCOMPLETE OR UNUSED)
            * @apiVersion 0.1.0
            * @apiDescription Fetches Likes for an Image
            * @apiName GetImageLikes
            * @apiGroup Image
            *
            * @apiParam {Number=93} actn TYPE_LIKES_FOR_IMAGE
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number} st=0 Pagination
            *
            * @apiSuccess {Number} actn TYPE_FRIEND_ALBUM_IMAGES
            * @apiSuccess {String='default','coverImages','profileImages'} Album Id
            * @apiSuccess {Object[]{1..5}} imageList Image list
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} timg No of total Images in Album
            * @apiSuccess {Number} tr No of Image in response
            *
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 97
            *       albId: "default"
            *       headerLength: 20
            *       pckId: "895751887743"
            *       seq: "2/2"
            *       sucs: true
            *       timg: 14
            *       tr: 10
            *     }
            *
            * @apiError Album has no Image
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 404 Not Found
            *     {
            *       "sucs": false
            *     }
            */

            // self.getLikes = function(obj) {
            //     var payload = {
            //         actn: OTYPES.TYPE_LIKES_FOR_IMAGE,
            //             imgId: obj.imgId,
            //             st: obj.st || 0
            //     };
            //     return $$connector.request(payload, REQTYPE.REQUEST);
            // };



            /**
            * @api {request} /APIREQUEST/121 Get Image Details
            * @apiVersion 0.1.0
            * @apiDescription Get Image Details, i.e who owns, album, no of likes, comments etc
            * @apiName GetImageDetails
            * @apiGroup Image
            *
            * @apiParam {Number=121} actn TYPE_IMAGE_DETAILS
            * @apiParam {Number} imgId Image Id
            *
            *
            * @apiSuccess {Number=121} actn TYPE_IMAGE_DETAILS
            * @apiSuccess {String='default','coverImages','profileImages'} Album Id
            * @apiSuccess {String} albn Album Name i.e. Feed Images, Profile Images, Cover images etc
            * @apiSuccess {String} cptn Caption
            * @apiSuccess {String} fn User Name
            * @apiSuccess {Number=0,1} ic Image have User's comment or not
            * @apiSuccess {Number} ih Image height
            * @apiSuccess {Number=0,1} il Image have User's Like or not
            * @apiSuccess {Number} imT Image Type
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {String} iurl Image Url
            * @apiSuccess {Number} iw Image Width
            * @apiSuccess {Number} nc No of Comments
            * @apiSuccess {Number} nl No of Likes
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} tm Image time
            * @apiSuccess {Number} uId User Id
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 121
            *       albId: "default"
            *       albn: "Feed Photos"
            *       cptn: ""
            *       fn: "Spirit Walker"
            *       headerLength: 53
            *       ic: 1
            *       ih: 153
            *       il: 0
            *       imT: 1
            *       imgId: 16339
            *       iurl: "2000001794/1435711441058.jpg"
            *       iw: 300
            *       nc: 2
            *       nl: 0
            *       pckId: "745902702948"
            *       sucs: true
            *       tm: 1435732409019
            *       uId: "2000001794"
            *     }
            *
            */

            self.getImageDetails = function(imgId){
             return  $$connector.request({
                    actn :OTYPES.TYPE_IMAGE_DETAILS,
                    imgId : imgId
                }, REQTYPE.REQUEST);

            };



            /**
            * @api {UPDATE} /APIREQUEST/185 Like/Unlike Image
            * @apiVersion 0.1.0
            * @apiDescription Request to Like or Unlike Image
            * @apiName ImageLikeUnlike
            * @apiGroup Image
            *
            * @apiParam {Number=185} actn TYPE_LIKE_IMAGE
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number=0,1} ikd I like(0)/unlike(1)
            *
            *
            * @apiSuccess {Number=185} actn TYPE_LIKE_IMAGE
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {String} mg Message
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 185
            *       headerLength: 53
            *       imgId: 16339
            *       nfId : 1511
            *       pckId: "770981966122"
            *       sucs: true
            *     }
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 404 Not Found
            *     {
            *       actn: 185
            *       headerLength: 53
            *       imgId: 16339
            *       mg: "Unable to post like/unlike."
            *       pckId: "770981966122"
            *       sucs: false
            *     }
            */


            // self.toggleLike = function(imgId, lkd,nfId) {
            //     var payload = {
            //         actn: OTYPES.TYPE_LIKE_IMAGE,
            //         imgId : imgId,
            //         lkd : lkd
            //     };
            //     if(nfId){
            //         payload.nfId = nfId;
            //     }
            //     return $$connector.request(payload,  REQTYPE.UPDATE );
            // };

            /**
            * @api {UPDATE} /APIREQUEST/180 Comment On Image
            * @apiVersion 0.1.0
            * @apiDescription Request to Add Comment to Image
            * @apiName ImageAddComment
            * @apiGroup Image
            *
            * @apiParam {Number=180} actn TYPE_ADD_IMAGE_COMMENT
            * @apiParam {Number} imgId Image Id
            * @apiParam {String} cmn Comment Text
            *
            *
            * @apiSuccess {Number=180} actn TYPE_ADD_IMAGE_COMMENT
            * @apiSuccess {String} cmn Comment Text
            * @apiSuccess {Number} cmnId Comment Id
            * @apiSuccess {String} fn User Name
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {Number} loc Undefined
            * @apiSuccess {Boolean} sc Undefined
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} tm Comment Time
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 180
            *       cmn: "test comment"
            *       cmnId: 2330
            *       fn: "Spirit Walker"
            *       headerLength: 53
            *       imgId: 16339
            *       loc: 3
            *       pckId: "794680017483"
            *       sc: false
            *       sucs: true
            *       tm: 1435752098339
            *     }
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 404 Not Found
            *     {
            *       sucs: false
            *     }
            */
            // self.addComment = function(imgId, comment) {
            //     return $$connector.request({
            //         actn : OTYPES.TYPE_ADD_IMAGE_COMMENT,
            //         imgId : imgId,
            //         cmn : comment.utf8Encode()
            //     }, REQTYPE.UPDATE);
            // };

            /**
            * @api {UPDATE} /APIREQUEST/194 Edit Comment
            * @apiVersion 0.1.0
            * @apiDescription Request to Edit Comment
            * @apiName ImageEditComment
            * @apiGroup Image
            *
            * @apiParam {Number=194} actn TYPE_EDIT_IMAGE_COMMENT
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number} cmnId Comment Id
            * @apiParam {String} cmn Comment Text
            *
            *
            * @apiSuccess {Number=194} actn TYPE_EDIT_IMAGE_COMMENT
            * @apiSuccess {String} cmn Comment Text
            * @apiSuccess {Number} cmnId Comment Id
            * @apiSuccess {String} fn User Name
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {Boolean} sc Undefined
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 194
            *       cmn: "comment again dsfasfas"
            *       cmnId: 2322
            *       fn: "Spirit Walker"
            *       headerLength: 54
            *       imgId: 16340
            *       pckId: "1083486106462"
            *       sc: false
            *       sucs: true
            *     }
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 200 Not Found
            *     {
            *       actn: 194
            *       sucs: false
            *     }
            */
            // self.updateComment = function(imgId, cmnId, cmn) {
            //     return $$connector.request({
            //             actn : OTYPES.TYPE_EDIT_IMAGE_COMMENT,
            //             imgId : imgId,
            //             cmnId :cmnId,
            //             cmn: cmn.utf8Encode()
            //         }, REQTYPE.UPDATE );
            // };

            /**
            * @api {UPDATE} /APIREQUEST/182 Delete Image Comment
            * @apiVersion 0.1.0
            * @apiDescription Request to Delete Image Comment
            * @apiName ImageDeleteComment
            * @apiGroup Image
            *
            * @apiParam {Number=182} actn TYPE_DELETE_IMAGE_COMMENT
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number} cmnId Comment Id
            *
            *
            * @apiSuccess {Number=182} actn TYPE_DELETE_IMAGE_COMMENT
            * @apiSuccess {Number} cmnId Comment Id
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {Number} loc Undefined
            * @apiSuccess {Boolean} sc Undefined
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 182
            *       cmnId: 2322
            *       headerLength: 53
            *       imgId: 16340
            *       loc: 1
            *       pckId: "234858749621"
            *       sc: false
            *       sucs: true
            *     }
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 200 Not Found
            *     {
            *       actn: 182
            *       sucs: false
            *     }
            */
            // self.deleteComment = function(imgId, cmnId) {
            //     return $$connector.request({
            //         actn : OTYPES.TYPE_DELETE_IMAGE_COMMENT,
            //         imgId : imgId,
            //         cmnId :cmnId
            //     }, REQTYPE.UPDATE);
            // };

            /**
            * @api {UPDATE} /APIREQUEST/197 Like/Unlike Image Comment
            * @apiVersion 0.1.0
            * @apiDescription Request to Like or Unlike Image Comment
            * @apiName ImageCommentLikeUnlike
            * @apiGroup Image
            *
            * @apiParam {Number=197} actn TYPE_LIKE_UNLIKE_IMAGE_COMMENT,
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number} cmnId Comment Id
            * @apiParam {Number=0,1} lkd I like(0)/unlike(1) Comment
            *
            *
            * @apiSuccess {Number=185} actn TYPE_LIKE_UNLIKE_IMAGE_COMMENT,
            * @apiSuccess {Number} cmnId Comment Id
            * @apiSuccess {Number} id Undefined
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {Number=0,1} lkd Like/Unlike value
            * @apiSuccess {Number} loc Undefined
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} tm Image time
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 197
            *       cmnId: 2321
            *       headerLength: 53
            *       id: 492
            *       imgId: 16340
            *       lkd: 1
            *       loc: 1
            *       pckId: "449485259142"
            *       sucs: true
            *       tm: 1435753240084
            *     }
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 200 Not Found
            *     {
            *       actn: 197
            *       sucs: false
            *     }
            */
            // self.toggleCommentLike = function(imgId, cmnId, lkd) {
            //     return $$connector.request({
            //         actn : OTYPES.TYPE_LIKE_UNLIKE_IMAGE_COMMENT,
            //         imgId : imgId,
            //         cmnId: cmnId,
            //         lkd : lkd
            //     }, REQTYPE.UPDATE );
            // };

            self.getProfilePicORCoverPicImageDetails = function(obj){
                var defer = $q.defer();
                 self.go({
                    actn :OTYPES.GET_CP_OR_PP_DETAIL,
                    type : obj.type
                }).then(function(data){
                        defer.resolve(data);
                 },function(reason){
                    defer.reject(reason);
                 });
                return defer.promise;
            };

             // self.fetchWhoLikes = function(imgId,ulength,nfId){
             //    var requestData = {
             //        actn: OTYPES.TYPE_LIKES_FOR_IMAGE,
             //        imgId: imgId
             //        //st: this parameter is required for load more.have to set.
             //    };
             //    if(nfId){
             //        requestData.nfId = nfId;
             //    }
             //     if ( ulength > 0 ) {
             //         requestData.st = ulength;
             //     }
             //   return $$connector.pull(requestData, REQTYPE.REQUEST);
             // };

            // self.peopleDetails = function ( utids ) {
            //     var payload = {
            //         actn: OTYPEFRIEND.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS,//OTYPES.FRIENDS.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS,
            //         idList: utids
            //     };
            //     $$connector.send(payload, REQTYPE.REQUEST);
            // };

             self.getFeedImages= function(nfId) {
                var payload = {
                    actn: OPERATION_TYPES.SYSTEM.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS,
                    nfId: nfId
                };
                return $$connector.request(payload, REQTYPE.REQUEST);
             };

        }


})();

/*
 * copyright Ipvision
 */



(function(){
    'use strict';

    angular
        .module('ringid.common.services')
        .factory('$ringhttp', ringhttp);


    ringhttp.$inject = ['settings', '$templateCache'];
    function ringhttp(settings, $templateCache) { //jshint ignore:line
        var requestQueue = {},
            config = {
            //contentType: 'application/x-www-form-urlencoded'
            'contentType': 'multipart/formdata'
        };
        var parse = function (req) {
            var result;
            try {
                result = JSON.parse(req.responseText);
            } catch (e) {
                result = req.response;
            }
            return [result, req];
        };

        function XHR(type, url, data, responseType) {
            var templateRequest = false,
                methods = {
                success: function() {},
                error: function() {},
                abort: function() {},
                progress: function() {}
            };

            var templateIndex = url;
            url = /^(http|https):\/\//.test(url) ? url : settings.baseUrl + url;

            var ajaxRequest = {
                success: function(callback) {
                    methods.success = callback;
                    return ajaxRequest;
                },
                error: function(callback) {
                    methods.error = callback;
                    return ajaxRequest;
                },
                abort: function(callback) {
                    methods.abort = callback;
                    return ajaxRequest;
                },
                progress: function(callback) {
                    methods.progress = callback;
                    return ajaxRequest;
                },
                abortRequest: function() {
                    xhr.abort();
                }
            };

            try {
                var xhr = new XMLHttpRequest();
                templateRequest =  (type === 'GET' && /\.html$/.test(url));
                if (templateRequest && requestQueue.hasOwnProperty(templateIndex)) {
                        requestQueue[templateIndex].push(methods);
                }
                //else if (templateRequest && $templateCache.get(url)) {
                    //setTimeout(function() {
                        //requestQueue[url].forEach(function(methods) {
                            //methods.success.apply(methods, [$templateCache.get(url), xhr]);
                        //});
                        //delete requestQueue[url];
                    //});
                else {
                    if (templateRequest) {
                        url = url + '?time=' + new Date().getTime();
                        requestQueue[templateIndex] = [];
                        requestQueue[templateIndex].push(methods);
                    }
                    xhr.open(type, url, true);
                    //xhr.setRequestHeader('x-app-version', settings.apiVersion )
                    xhr.responseType = responseType || 'text';

                    xhr.onreadystatechange = function() {
                        var response ;
                        if (xhr.readyState === 4) {
                            response = parse(xhr);
                            if (xhr.status === 200 ) {
                                // if template put it inside templatecache
                                if (templateRequest) {
                                    $templateCache.put(templateIndex, response[0]);
                                    requestQueue[templateIndex].forEach(function(methods) {
                                        methods.success.apply(methods, [$templateCache.get(templateIndex), xhr]);
                                    });
                                    delete requestQueue[templateIndex];
                                } else {
                                    methods.progress.apply(methods, [100]);
                                    methods.success.apply(methods, response);
                                }
                            } else {
                                methods.error.apply(methods, response);
                            }
                        }

                    };

                    xhr.upload.onabort = function() {
                        methods.abort.apply(methods);
                    };

                    xhr.upload.onprogress= function(e) {
                        methods.progress.apply(methods, [Math.round(e.loaded / e.total * 100) - 1]);
                    };

                    xhr.send(data);
                }

            } catch (e) {
                RingLogger.alert('xmlhttprequest not available');
            }


            return ajaxRequest;
        }



        return {
            //create: XHRWorking,
            get: function(url, headers, responseType) {
                return XHR('GET', url, headers, responseType);
            },
            post: function(url, data, responseType) {
                return XHR('POST', url, data, responseType);
            },
            getTemplatePromise : function(url,headers,responseType){
                // var request,defer = $q.defer();




                // return defer.promise;
            }
        };

    }


})();


/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.common.imagepopup_controller', [
			'ringid.config',
            'ringid.ringbox',
            'ringid.common.image_factory',
            'ringid.common.imagemap_factory'
        ])
        .controller('ImagePopupController',
        ['$routeParams', '$scope', 'Auth', 'ImageFactory', '$$imageMap', '$$stackedMap', 'AlbumFactory','$$connector','OPERATION_TYPES',
    function ImagePopupController($routeParams, $scope, Auth, ImageFactory, $$imageMap, $$stackedMap, AlbumFactory,$$connector,OPERATION_TYPES) { // jshint ignore:line

        /***
         *
         * Base Controller,
         * - Can't be used directly,
         * Need to Use With Wrapper Controller  (i.e, ringbox-image-popup.controller, single-image-controller
         *
         *
         */

        var imageList = $$stackedMap.createNew(),OTYPES  = OPERATION_TYPES.SYSTEM.IMAGE,commentUpdateSubcriber;

        $scope.currentUser = Auth.currentUser();
        $scope.boxIsLoading = true;
        $scope.showCommentBox = true;
        $scope.changeImage = changeImage;
        $scope.nextImg = false;
        $scope.prevImg = false;
        //$scope.imageComments = [];

        if (!!$scope.params.image) { // image popup from profile photos tab
            $scope.image = $scope.params.image;
            initImageDetails(false);
        } else if (!!$scope.params.imgId) { // image popup from notification dropdown

                if(!!$scope.remoteData){
                    $scope.image = $scope.remoteData; //imageMap;
                    initImageDetails();
                }else{
                    ImageFactory.getImageDetails($scope.params.imgId).then(function (imageMap) {
                        $scope.image = imageMap;
                        initImageDetails();
                    });
                }
            //});
        }

        if ($scope.params.feed) {
            // get list of images for the feed
            $scope.feed = $scope.params.feed;
            getImages($scope.feed.getKey());
        }

        if ($scope.params.popupFrom === 'profile') { //
            // get album images
            getImages();
        }


        function initImageDetails(showalert) {
            $scope.boxIsLoading = false;
            $scope.isReady = true;
        }


        // get image list
        function getImages(nfId) {
            if (nfId) {
                ImageFactory.getFeedImages(nfId).then(function(response) {
                    if (response.sucs === true) {
                        var imageArray = response.newsFeedList[0].imageList,
                            image;
                        for(var i = 0, lt = imageArray.length; i < lt; i++) {
                            imageArray[i].nfId = response.nfId;
                            if(imageArray[i].imgId === $scope.image.getKey()){
                                $scope.image.updateImage(imageArray[i]);
                                imageList.save($scope.image.getKey(), $scope.image);
                            }else{
                                image = $$imageMap.create(imageArray[i]);
                                imageList.save(image.getKey(), image);
                            }

                        }
                        setRotation();
                    }

                });
            } else {
                var albums = AlbumFactory.albums($routeParams.uId);
                imageList = albums.get($scope.image.getAlbumId()).getImages();
                setRotation();
            }
        }

        function setRotation() {
            if(imageList.length() > 1) {
                $scope.nextImg = !!imageList.next($scope.image.getKey()) || !!imageList.bottom();
                $scope.prevImg = !!imageList.previous($scope.image.getKey()) || !!imageList.top();
            }
            $scope.$rgDigest();
        }

        function preloadImage(direction) {
            var img = new Image(),
                imgObj;

            if (direction === 'next') {
                imgObj = imageList.next($scope.image.getKey());
            } else {
                imgObj = imageList.previous($scope.image.getKey());
            }
            setTimeout(function() {
                img.src = imgObj ? imgObj.src() : '';
            }, 200);
        }


        function changeImage(direction) {
            // create image from image list
            if (direction === 'next') {
                if($scope.params.popupFrom === 'profile') {
                    // check if reached end of imagelist then call for more images
                    if( !imageList.previous($scope.image.getKey())) {
                        AlbumFactory.loadMoreImage($scope.image.getAlbumId(), $routeParams.uId).then(function() {
                            imageList = AlbumFactory.albums($routeParams.uId).get($scope.image.getAlbumId()).getImages();
                            $scope.image = imageList.next($scope.image.getKey()) || imageList.bottom();
                            $scope.$rgDigest();
                        });
                    } else {
                        $scope.image = imageList.next($scope.image.getKey()) || imageList.bottom();
                    }
                } else {
                    $scope.image = imageList.next($scope.image.getKey()) || imageList.bottom();
                }
            } else {
                $scope.image = imageList.previous($scope.image.getKey()) || imageList.top(); //$$imageMap.create(imageList[changeTo]);
            }
            //setRotation(); // rotation need to be checked only once upon receiving image list. because now it'll rotate circular if there are more than one image
            // request comments;
            initImageDetails();
            preloadImage(direction);
            $scope.$rgDigest();
        }



        $scope.openRingboxLike = function(){
            return $scope.image && $scope.image.getLikes() > 0;
        };

        commentUpdateSubcriber = $$connector.subscribe(function(message){
            if($scope.image && $scope.image.getKey() === message.imgId){
                $scope.image.setTotalComment(message.loc);
                $scope.$rgDigest();
            }

        },{
            action :[OTYPES.TYPE_UPDATE_ADD_IMAGE_COMMENT,OTYPES.TYPE_UPDATE_DELETE_IMAGE_COMMENT]
        });

        $scope.$on('$destroy', function() {
            if(commentUpdateSubcriber){
                $$connector.unsubscribe(commentUpdateSubcriber);
            }

        });
    }]);


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
            .module('ringid.common.media_controller', [
                'ringid.config',
                'ringid.ringbox'
            ])
            .controller('MediaController', MediaController);


    MediaController.$inject =
            ['APP_CONSTANTS', 'fileUploadService', '$routeParams', '$scope', 'Auth', 'rgDropdownService', 'Media', '$$connector', 'OPERATION_TYPES', 'Ringalert', 'feedFactory', '$ringbox'];
    function MediaController(APP_CONSTANTS, fileUploadService, $routeParams, $scope, Auth, rgDropdownService, Media, $$connector, OPERATION_TYPES, Ringalert, feedFactory, $ringbox) { // jshint ignore:line

        /***
         *
         * Base Controller,
         * - Can't be used directly,
         * Need to Use With Wrapper Controller  (i.e, ringbox-image-popup.controller, single-image-controller
         *
         */
        var OTYPES = OPERATION_TYPES.SYSTEM.MEDIA,
                AC = APP_CONSTANTS,
                commentUpdateSubcriber;

        $scope.currentUser = Auth.currentUser();
        $scope.showCommentBox = true;


        $scope.changeMedia = changeMedia;
        // $scope.fetchWhoLikes = fetchWhoLikes;

        if ($scope.params && $scope.params.popupFrom === 'notification') {
            $scope.media = $scope.remoteData;
            $scope.album = Media.getAlbum($scope.media.getAlbumId());
        } else {
            $scope.media = $scope.remoteData;
            $scope.album = $scope.params.album;
        }

        initMedia();

        function initMedia() {
            $scope.media.increaseView().then(function() {
                $scope.$rgDigest();
            }, function() {
                $scope.$rgDigest();
            });
        }

        // add to album dropdown
        $scope.ddControl = {
            Media: Media,
            uploadWhat: $scope.media.isAudio() ? 'audio' : 'video',
            createAlbum: false,
            albumName: '',
            selectedAlbum: 0
        };
        $scope.ddHtml = 'pages/dropdowns/popup-album-dropdown.html';
        $scope.ddAction = selectAlbum;

        function selectAlbum(actionObj) { // jshint ignore:line
            switch (actionObj.action) {
                case 'select':
                    $scope.ddControl.selectedAlbum = actionObj.albumMap;
                    $scope.ddControl.selectedAlbum.addNewContent($scope.media);
                    RingLogger.information('Selected Album: ' + $scope.ddControl.selectedAlbum.getName(), RingLogger.tags.UPLOAD);
                    rgDropdownService.close();
                    break;
                case 'toggleCreate':
                    $scope.ddControl.createAlbum = !$scope.ddControl.createAlbum;
                    //rgDropdownService.close();
                    break;
                case 'create':
                    if ($scope.ddControl.albumName.length === 0) {
                        break;
                    }
                    $scope.ddControl.createAlbum = false;
                    RingLogger.information('Create Album: ' + $scope.ddControl.albumName, RingLogger.tags.UPLOAD);
                    Media.createAlbum({
                        albn: $scope.ddControl.albumName,
                        mdaT: $scope.ddControl.uploadWhat === 'audio' ? AC.NEWS_FEED_MEDIA_TYPE_AUDIO : AC.NEWS_FEED_MEDIA_TYPE_VIDEO
                    }, true).then(function(albumMap) {
                        $scope.ddControl.createAlbum = false;
                        $scope.ddControl.albumName = '';
                        $scope.ddControl.selectedAlbum = albumMap;
                        $scope.ddControl.selectedAlbum.addNewContent($scope.media);
                        rgDropdownService.close();
                    });
                    break;
            }
            $scope.$rgDigest();
        }



        function changeMedia(media) {
            $scope.media = media;
            $scope.ddControl.uploadWhat = $scope.media.isAudio() ? 'audio' : 'video';
            // request comments;
            Media.fetchContentDetails($scope.media.getKey(), false, $scope.media.owner());
            initMedia();
        }



        // function fetchWhoLikes () {
        //     return {
        //         data: function () {
        //             return {
        //                 target: $scope.media
        //             };
        //         },
        //         promise:  Media.fetchLikeList($scope.media)
        //     };
        // }

        $scope.shareMedia = function() {

            
                var instance = $ringbox.open({
                    type: 'remote',
                    scope: false,
                    controller: 'feedMediaShareController',
                    scopeData: {
                        media: $scope.media
                    },
                    onBackDropClickClose: true,
                    templateUrl: 'pages/home/share-media.html',
                });
                instance.result.then(function() {
                    $scope.$rgDigest();
                });
            


        };


        commentUpdateSubcriber = $$connector.subscribe(function(message) {
            if ($scope.media && $scope.media.getKey() === message.cntntId) {
                $scope.media.setTotalComment(message.loc);
            }
        }, {
            action: [
                OTYPES.ACTION_UPDATE_ADD_MEDIA_COMMENT,
                OTYPES.ACTION_UPDATE_DELETE_MEDIA_COMMENT
            ]
        });

        $scope.$on('$destroy', function() {
            if (commentUpdateSubcriber) {
                $$connector.unsubscribe(commentUpdateSubcriber);
            }

        });
    }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.common.ringbox_imagepopup_controller', [
            'ringid.common.imagepopup_controller'
        ])
        .controller('RingBoxImagePopupController', RingBoxImagePopupController);


    RingBoxImagePopupController.$inject = [ '$scope', '$boxInstance', '$controller', 'localData', 'remoteData', 'feedFactory'];
    function RingBoxImagePopupController($scope, $boxInstance, $controller, localData, remoteData, feedFactory) { // jshint ignore:line
        /****
         *
         * Extends Basic Image Popup controller to use in Ringbox
         *
         *
         */



        $scope.close = $boxInstance.close;

        if (localData && localData.imgId) {
            $scope.templateType = localData.templateType;
        }
        $scope.params = localData;
        $scope.remoteData = remoteData;
         if(localData.noti && localData.noti.getCommentId() > 0){
            $scope.activeCommentId = localData.noti.getCommentId();
        }

        $controller('ImagePopupController', {$scope: $scope} );

        //////////////////////////////////

        //----------- Public --------------

    }


})();



/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.common.ringbox_media_controller', [
            'ringid.common.media_controller'
        ])
        .controller('RingBoxMediaController', RingBoxMediaController);


    RingBoxMediaController.$inject = [ '$scope', '$boxInstance', '$controller', 'localData', 'remoteData', 'Media'];
    function RingBoxMediaController($scope, $boxInstance, $controller, localData, remoteData, Media) {
        /****
         *
         * Extends Basic Image Popup controller to use in Ringbox
         *
         *
         */

        $scope.close = close;
        RingLogger.log(remoteData,"medoacontroller");
        if (localData && localData.mediaId) {
            $scope.templateType = localData.templateType;
        }
         RingLogger.print(localData,"MEDIA_POPUP");
        //var noti = notificationFactory.getNotification(localData.notiKey||0);
        $scope.params = localData;
        $scope.remoteData = remoteData;



        $controller('MediaController', {$scope: $scope} );
        //////////////////////////////////

        //----------- Public --------------
        $scope.destroyPlayer = angular.noop;
        function close() {
            $scope.destroyPlayer();
            $boxInstance.close();
        }

    }


})();



/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.common.ringbox_confirm_controller', [])
        .controller('RingBoxConfirmController', RingBoxConfirmController);


    RingBoxConfirmController.$inject = [ '$scope', '$boxInstance', 'localData'];
    function RingBoxConfirmController($scope, $boxInstance, localData) {

        $scope.close = close;
        $scope.params = localData;

        function close(confirmed) {
            $boxInstance.close(confirmed);
        }

    }


})();



/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.singleimage_controller', [
            'ringid.common.imagepopup_controller'
        ])
        .controller('SingleImageController', SingleImageController);


    SingleImageController.$inject = ['$scope', '$routeParams', '$controller', 'Auth' ];

    function SingleImageController($scope, $routeParams, $controller, Auth) {
        /****
         *
         * Extends Basic Image Popup controller to ReUse the functionality
         *
         *
         *
         */

        $scope.params  = {};
        $scope.params.imgId = $routeParams.imageId;

        $scope.isReady = false;

        $scope.currentUser = Auth.currentUser();

        $controller('ImagePopupController', {$scope: $scope});
        $scope.showCommentBox = true;

    }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.all_suggestions_controller', [])
        .controller('allSuggestionController', allSuggestionController);

    allSuggestionController.$inject = [ '$scope', '$boxInstance', 'localData', 'friendsFactory','InviteFactory','OPERATION_TYPES','$$connector','rgScrollbarService' ];
    function allSuggestionController( $scope, $boxInstance, localData, friendsFactory,InviteFactory,OPERATION_TYPES,$$connector,rgScrollbarService ) { // jshint ignore:line

        $scope.users = [];
        var OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS;
        $scope.state = InviteFactory.state;
        $boxInstance.opened.then(function () {

            $scope.users = localData.target.all();
            //RingLogger.log(localData.target.getName());
            $scope.$rgDigest();

        });
        var totalFriend = localData.target.length();

        $scope.$watch('state.isRequestsLoading', function (n,o) {
            $scope.$rgDigest();
        });

        $scope.contactListAction = function(actionObj) {
            if (!actionObj.friend.isLoading()) {
                friendsFactory.friendAction(actionObj,true).then(function() {
                    $scope.$rgDigest();
                }, function() {
                    $scope.$rgDigest();
                });
                $scope.$rgDigest();
            }
        };

        $scope.loadmorefriend = function() {
            InviteFactory.getSuggestionContactsDetails(5);
            $scope.$rgDigest();
        };

        $scope.getMutualFriend = function(user) {

            return{
                data: function() {
                    return {
                        target: user
                    };
                },
                promise: InviteFactory.getMutualFriend(user)
            };
        };

        var subscriptionKey = $$connector.subscribe(processPeople, {action: [
                OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS
            ]
        });

        function processPeople(data){
            if(data){
                if(InviteFactory.noOfSuggestions() > totalFriend){
                    rgScrollbarService.recalculate($scope);
                    $scope.$rgDigest();
                }
                totalFriend = InviteFactory.noOfSuggestions();
            }
        }

        $scope.$on('$destroy', function() {
            $$connector.unsubscribe(subscriptionKey);
        });
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.mutualfriends_controller', [])
        .controller('mutualFriendsController', mutualFriendsController);

    mutualFriendsController.$inject = [ '$scope','remoteData', 'friendsFactory','userFactory','InviteFactory','rgScrollbarService' ];
    function mutualFriendsController( $scope,remoteData, friendsFactory,userFactory,InviteFactory,rgScrollbarService ) { // jshint ignore:line

        var mutualIds = remoteData.mfIDs;
        $scope.mutualfriends = [];
        $scope.state = InviteFactory.state;

        friendsFactory.getContactDetailsByUtIds(mutualIds).then(function(data){
            $scope.mutualfriends = [];
            if(data.sucs===true){
                for(var i=0; i<data.contacts.length; i++){
                    $scope.mutualfriends.push(userFactory.create(data.contacts[i]));
                }
                $scope.$rgDigest();
            }
            rgScrollbarService.recalculate($scope);
            $scope.$rgDigest();
        });

        $scope.getMutualFriend = function(user) {

            return{
                data: function() {
                    return {
                        target: user
                    };
                },
                promise: InviteFactory.getMutualFriend(user)
            };
        };

        // MUTUAL FRIENDS MEAN USER AND THEY ARE ALREADY FRIENDS NO NEED OF friendsAction
        //$scope.contactListAction = function(actionObj) {
             //if (!actionObj.friend.isLoading()) {
                 //friendsFactory.friendAction(actionObj, true).then(function() {
                     //$scope.$rgDigest();
                 //}, function() {
                     //$scope.$rgDigest();
                 //});
                //$scope.$rgDigest();
             //}
        //};

    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.all_notification_controller', [])
        .controller('allNotificationController', allNotificationController);

    allNotificationController.$inject = [ 'NotificationFactory', '$location', 'circlesManager', 'ImageFactory', 'Auth', 'Media', 'rgDropdownService', 'Ringalert', 'Storage', '$scope', 'rgScrollbarService',
        'OPERATION_TYPES', '$$connector', 'notificationHttpService' ];
    function allNotificationController( NotificationFactory, $location, circlesManager, ImageFactory, Auth, Media, rgDropdownService, Ringalert, Storage, $scope, rgScrollbarService,
                                        OPERATION_TYPES, $$connector, notificationHttpService ) { // jshint ignore:line

        //var mutualIds = remoteData.mfIDs;






    }

})();

(function() {
  'use strict';
  angular
    .module('ringid.common.header_controller', [
        'ringid.auth',
        'ringid.common.image_factory',
        'ringid.media',
        'ringid.friend.friends_factory',
        'ringid.common.rgscrollbar_directive',
        'ringid.notification',
        'ringid.profile',
        'ringid.config'
    ])
    .controller('HeaderController', HeaderController);

    HeaderController.$inject = ['$scope', '$rootScope', '$location','rgDropdownService', '$$connector', 'OPERATION_TYPES',
        'friendsFactory', 'NotificationFactory', 'Auth',   'rgScrollbarService', 'ChatFactory','utilsFactory','SystemEvents'];
    function HeaderController( $scope, $rootScope, $location, rgDropdownService,  $$connector, OPERATION_TYPES,  // jshint ignore:line
                              friendsFactory, NotificationFactory, Auth, rgScrollbarService, ChatFactory,utilsFactory,SystemEvents) {
      var vm = this,
          OTYPES = OPERATION_TYPES.SYSTEM,
        active_menu = setActiveMenu();
        vm.getActiveMenu = getActiveMenu;


      /****************************
        LOGOUT Dropdown section
       */
      vm.logout = {
        ddHtml: 'pages/dropdowns/logout-dropdown.html', //$templateCache.get('logout-dropdown.html'),
        ddControl: Auth,
        ddAction: function() {
            rgDropdownService.close();
            Auth.logout();
        },
        ddOpened: function() {
          setActiveMenu('logout');
        },
        ddBeforeClose: function(){
          setActiveMenu('');
        }
      };
      /*****************************
         END LOGOUT Dropdown section
       */



      /********************************
        FRIEND REQUEST Dropdown section
       */
      vm.freq = {
        //ddHtml:'pages/partials/requests-directive.html', // $templateCache.get('friend-request-dropdown.html'),
        ddTemplate:'<rg-requests load-on-scroll="true" load-count="10" ></rg-requests>',
        ddOpened: function() {
          setActiveMenu('friend_request');
        },
        ddBeforeClose: function(){
          setActiveMenu('');
        }
      };


      vm.requestCount = friendsFactory.getRequestCount;
      /*****************************
        END FRIEND REQUEST Dropdown section
       */


        /********************************
         Chat History  Dropdown section
         */
        vm.chatHistory = {
            ddHtml:'pages/partials/chat/chat-history-dropdown.html', // $templateCache.get('friend-request-dropdown.html'),
            ddOpened: function() {
                setActiveMenu('chat_history');
            },
            ddBeforeClose: function(){
                setActiveMenu('');
            }
        };


        vm.unreadChatCount = ChatFactory.getUnreadMessageCount;

        utilsFactory.onCustomEvent(SystemEvents.CHAT.UNREAD_MESSAGE_INFO_UPDATED, function(){
            $scope.$rgDigest();
        });


        /*****************************
         Chat History REQUEST Dropdown section
         */



      /*****************************
         NOTIFICATION Dropdown section
       */

        vm.noti = {
            //ddHtml: 'pages/partials/notification-directive.html',
            ddTemplate: '<rg-notification load-count="10" template-url="pages/dropdowns/notification-dropdown.html"></rg-notification>',
            //ddTemplate: '<rg-notification ></rg-notification>',
            ddOpened: function() {
              setActiveMenu('notification');
              NotificationFactory.clearCounter();
            },
            ddBeforeClose: function(){
              setActiveMenu('');
            }
        };

        vm.notiCount = NotificationFactory.getNotiCount;
        var subscriptionKey = $$connector.subscribe(function() {
            setTimeout(function() {
                $scope.$rgDigest();
            }, 200);

        }, {
            action: [
                OTYPES.FRIENDS.TYPE_UPDATE_ADD_FRIEND,
                OTYPES.FRIENDS.TYPE_UPDATE_DELETE_FRIEND,
                OTYPES.NOTIFICATION.TYPE_MY_NOTIFICATIONS,
                OTYPES.NOTIFICATION.TYPE_SINGLE_NOTIFICATION
            ]
        });

      /*****************************
         END NOTIFICATION Dropdown section
       */

      function setActiveMenu(name){
        if( name && name !== ''){
          active_menu = name;
        }else if( $location.path() === '/'){
          active_menu = 'home';
        }else{
          active_menu = 'none';
        }
        $scope.$rgDigest();
      }


      function getActiveMenu(){
        return active_menu;
      }

      vm.defaultSpan = utilsFactory.getDefaultColumn;

      $rootScope.$on('$routeChangeStart', function() {
        setActiveMenu();
        $$connector.unsubscribe(subscriptionKey);
      });
      $scope.$on(SystemEvents.COMMON.WINDOW_RESIZED,function(){
          $scope.$rgDigest();
      });

      // ##DIGEST_DEBUG_START##
            if(RingLogger.tags.DIGEST){
                $scope.$watch(function(){
                     RingLogger.info("from HeaderController",RingLogger.tags.DIGEST);
                 });
            }
      // ##DIGEST_DEBUG_END##

    }

}(angular));

/**
 *
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.menu_controller', [
            'ringid.circle',
            'ringid.ringbox',
            'ringid.friend.friends_factory',
            'ringid.common.rgscrollbar_directive'
        ])
        .controller('MenuController', MenuController);

        MenuController.$inject = ['$scope','$location', 'circlesManager', 'rgScrollbarService', '$$connector','circleHttpService', 'OPERATION_TYPES', '$timeout'];
        function MenuController($scope,$location, circlesManager, rgScrollbarService, $$connector,circleHttpService, OPERATION_TYPES, $timeout) { // jshint ignore:line

            var OTYPES = OPERATION_TYPES.SYSTEM.CIRCLE;

            var vm = this,
                subkey,
                circleUpdateSubscribeKey;


            function gotCircleData() {
                //setTimeout(function() {
                    $scope.$rgDigest();
                //},200);
            }

            // initialize
            subkey = $$connector.subscribe( gotCircleData,
                { action:OTYPES.TYPE_GROUP_LIST }
            );

            circleUpdateSubscribeKey = $$connector.subscribe( gotCircleData,{
                filter : circlesManager.circleUpdateFilter
            });

            //setTimeout(function(){ // TODO : find out why it is not working without timer function after login
            //    circleHttpService.getCircles();
            //    $scope.$rgDigest();
            //});


            vm.ddHtml = 'pages/dropdowns/circle-list-dropdown.html'; // IMPORTANT this template is preloaded
            vm.ddControl = {
                getCircles: getCircles
            };
            //vm.ddAction = vm.toggleRingCircle;
            //vm.ddAction = getCircles;

            function getCircles(own) {
                if (own === 'true' || own === true) {
                    return circlesManager.getCircles(true);
                } else {
                    return circlesManager.getCircles(false);
                }
            }

            $scope.isCurrentPath = function (path,contain) {
                return contain ?$location.path().indexOf(path) > -1 : $location.path() == path;
            };

            $scope.$on('$destroy',function(){
                $$connector.unsubscribe(subkey);
                $$connector.unsubscribe(circleUpdateSubscribeKey);
            });

        }
})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.controllers', [
            'ringid.common.header_controller',
            'ringid.common.menu_controller',
            'ringid.common.mutualfriends_controller',
            'ringid.common.all_suggestions_controller',
           // 'ringid.common.fetch_like_controller',
            'ringid.common.imagepopup_controller',
            'ringid.common.media_controller',
            'ringid.common.ringbox_confirm_controller',
            'ringid.common.ringbox_imagepopup_controller',
            'ringid.common.ringbox_media_controller',
            'ringid.common.singleimage_controller',
            //'ringid.common.incoming_request_controller',
            'ringid.common.all_notification_controller'
        ]);
})();


/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.filters', ['ringid.config'])
		.filter('validProfileImage', validProfileImage)
		.filter('friendListFilter', friendListFilter) // filter by a regex
		.filter('mapListFilter', mapListFilter) // filter friend map list by another user map list
		.filter('stackMapFilter', stackMapFilter)
		.filter('ymdDateFilter', ymdDateFilter)
		.filter('mediaFilter', mediaFilter)
		.filter('mapFilter', mapFilter)
		.filter('objectFilter', objectFilter);

		validProfileImage.$inject = ['settings'];
		function validProfileImage (settings) {
			return function(item) {
				return item.indexOf('prof.png') > 0 ? item : settings.imBase + item;
			};
		}

		function stackMapFilter() {
			return function(items, filterItems) {
				if (items) {
					for (var i = 0; i < items.length; i++) {
						if (filterItems.get(items[i].key)) {
							console.log('got a matching item:' + items[i].key);
						}
					}
					return items;
				}
			};
		}

        friendListFilter.$inject = ['APP_CONSTANTS'];
		function friendListFilter(APP_CONSTANTS) {
			return function(items, obj) {
				if (items) {
					var filtered = [];
                    //var nameMatch = new RegExp(obj.name, 'ig');
                    var nameMatch = obj.name.toLowerCase();
					for (var i = 0; i < items.length; i++) {
                        if(obj.showMutual && items[i].value.friendshipStatus() !== APP_CONSTANTS.FRIEND) {
                            continue;
                        }
                        //if ( nameMatch.test(items[i].value.getName())) {
                        if (items[i].value.getName().toLowerCase().indexOf(nameMatch) > -1) {
                            filtered.push(items[i]);
                        }
					}
					return filtered;
				}
			};
		}


		function mapListFilter() {
			return function(items, filterList) {
				if (items) {
					var filtered = [];
					for(var i = 0; i < items.length; i++) {
						if( ! filterList.get( items[i].value.getKey() ) ) {
							filtered.push(items[i]);
						}
					}
					return filtered;
				}
			};

		}

		function ymdDateFilter() {
			return function(date) {
				var d = new Date(date),
					month = '' + (d.getMonth() + 1),
					day = '' + d.getDate(),
					year = d.getFullYear();

				if (month.length < 2) {
                    month = '0' + month;
                }
				if (day.length < 2) {
                    day = '0' + day;
                }

				return [year, month, day].join('-');
			};
		}


		function mediaFilter() {
			return function(items, mediaType) {
				if (items) {
					var filtered = [];
					for(var i = 0; i < items.length; i++) {
						if( items[i].value.getType() === mediaType ) {
							filtered.push(items[i]);
						}
					}
					return filtered;
				}
			};

		}

        // generic Map Filter
		function mapFilter() {
			return function(items, obj) {
				if (items) {
					var filtered = [],
						nameToMatch = obj.value ? obj.value.toLowerCase(): '';
						//regEx;
					for(var i = 0; i < items.length; i++) {

						//nameMatch = items[i].value[obj.mapApi]().toLowerCase();
						//if ( nameMatch.test(items[i].value.getName())) {
						if (items[i].value[obj.mapApi]().toLowerCase().indexOf(nameToMatch) > -1) {
							filtered.push(items[i]);
						}

						//if(obj.hasOwnProperty('compare') && obj.compare === 'regex') {
					     //   regEx = new RegExp(obj.value || '', 'ig');
                         //   if (regEx.test( items[i].value[obj.mapApi]() )) {
						//	    filtered.push(items[i]);
                         //   }
                        //
						//} else if (items[i].value[obj.mapApi]() === obj.value) { // default is just plain equal compare
						//	filtered.push(items[i]);
						//}
					}
					return filtered;
				}
			};

		}


        function objectFilter() {
            function compareString(compareTo, compareThis) {
                return compareTo.indexOf(compareThis) > -1;
            }

            function compareDefault(compareTo, compareThis) {
                return compareThis === compareTo;
            }

            return function(items, obj) {
                var compareFunc, filtered = [];
                if (items && items.length > 0) {
                    switch(obj.compare) {
                        case 'string':
                            compareFunc = compareString;
                            break;
                        default:
                            compareFunc = compareDefault;
                    }

                    for(var i = 0; i < items.length; i++) {
                        if (compareFunc(items[i][obj.prop], obj.value)) {
                            filtered.push(items[i]);
                        }
                    }
                    return filtered;
                }
            };
        }
})();

'use strict';
angular.module("ringid.ringbox",['ringid.common.stacked_map','ringid.utils'])
    .provider('$ringbox', function () {

        var $ringboxProvider = {
            boxes: [],
            boxeScopes: [],
            boxeDeferred: [],
            template : '<div class="ringbox">'
            					+'<div class="ringbox-overlay"></div>'
    							+'<div class="ringbox-outerContainer">'
        							 +'<div class="ringbox-content">'
        							 	+'<div class="ringbox-inner"></div>'
        							 	+'<div class="ringbox-loader"><div class="loader"><div class="circle1"></div><div class="circle2"></div><div class="circle3"></div></div>'
        							 +'</div>'
    							 +'</div>'
						+'</div>',
    		    init: function () {
    		       var boxDom = angular.element(this.template);
    		       document.body.appendChild(boxDom[0]);
    		       document.body.className = document.body.className.replace('ringbox-opened','');
    		       document.body.className = document.body.className.trim()+' ringbox-opened';
    		       this.boxes.push(boxDom);
    		       return boxDom;
    		    },
            adjustBoxes: function() {

               for(var i=0;i<this.boxes.length;i++) {
                  this.boxes[i].removeClass('rl_'+i);
               }
               for(var i=0;i<this.boxes.length;i++) {
                  this.boxes[i].addClass('rl_'+i);
               }
            },

            $get: ['$injector', '$rootScope', '$$q', '$templateCache', '$controller','$compile','$document', '$player','$ringhttp','$sniffer','Notification', 'SystemEvents', 'utilsFactory',
                function ($injector, $rootScope, $q, $templateCache, $controller, $compile, $document, $player,$ringhttp,$sniffer, Notification, SystemEvents, utilsFactory) {
                    var $ringbox = {}, $this = this, prefix = $sniffer.vendorPrefix.toLowerCase();

                    function getTemplatePromise(options) {
                        if(options.template){
                          return $q.when(options.template);
                        }
                        var url = angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl;
                        if($templateCache.get(url)){
                            return $q.when($templateCache.get(url));
                        }else{
                          var defer = $q.defer();
                          $ringhttp.get(url).success(function(result){
                                $templateCache.put(url,result);
                                defer.resolve(result);
                             // return result;
                          }).error(function(){
                              defer.reject();
                          });
                          return defer.promise;
                        }

                        // return options.template ? $q.when(options.template) :
                        //     $http.get(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl,
                        //         {cache: $templateCache}).then(function (result) {
                        //             return result.data;
                        //         });
                    }

                  function getResolvePromises(resolves) {
                      var promisesArr = [];
                       angular.forEach(resolves, function (value) {
                            if(angular.isDefined(value.promise)){
                                promisesArr.push(value.promise);
                            } else if (angular.isFunction(value)) {
                                promisesArr.push($q.when($injector.invoke(value)));
                            }else if(angular.isArray(value) || angular.isObject(value)){
                                    promisesArr.push(value);
                            }
                       });
                      return promisesArr;
                   }

                    $ringbox.minimizedBox = {dom:null, scope:null, deferred:null};

                    $ringbox.clear = function (scope, defer, param) {

                      if($this.boxes.length==0) {
                        document.body.className = document.body.className.replace('ringbox-opened','').trim();
                      }

                      if(scope) {
                        scope.$destroy();
                      }

                      if(defer) {
                        defer.resolve.apply(null, param);
                      }


                       /*clear player resource*/
                       if(!$player.miniPlayer.player && $this.boxes.length == 0) {
                          $player.destroyAll();
                       }

                    }

                    $ringbox.close = function(event) {
                        if (event && event.stopPropagation) {
                            event.stopPropagation();
                        }

                       if($this.boxes.length>0)
                       {
                         $this.boxes.pop().remove();
                         $ringbox.clear($this.boxeScopes.pop(), $this.boxeDeferred.pop(), arguments);
                       }

                    }

                    $ringbox.closeAll = function() {
                       for(var i=$this.boxes.length-1;i>=0;i--) {
                          $this.boxes.pop().remove();
                          $ringbox.clear($this.boxeScopes.pop(), $this.boxeDeferred.pop(), arguments);
                       }
                    }


                    /* required for mini player*/
                    var eventTranstionEnd = function () {

                        $ringbox.minimizedBox.dom[0].style.display = 'none';
                        $player.showMiniPlayer();

                        if($this.boxes.length == 0) {
                          document.body.className = document.body.className.replace('ringbox-opened','');
                        }
                    };

                    $ringbox.removeMinimize = function() {

                       if($ringbox.minimizedBox.dom) {
                          $ringbox.minimizedBox.dom.remove();
                       }

                       if($ringbox.minimizedBox.scope) {
                         $ringbox.minimizedBox.scope.$destroy();
                       }
                       /*
                       if($ringbox.minimizedBox.deferred) {
                         $ringbox.minimizedBox.deferred.resolve.apply(null, param);
                       } */

                    }

                    $ringbox.minimize = function() {

                       if($this.boxes.length>0) {

                             $ringbox.minimizedBox.dom = $this.boxes.pop();
                             $ringbox.minimizedBox.scope = $this.boxeScopes.pop();
                             $ringbox.minimizedBox.deferred = $this.boxeDeferred.pop();

                             var boxcontainer = $ringbox.minimizedBox.dom[0].querySelector('.ringbox-content'),
                             x = (boxcontainer.offsetLeft + ((boxcontainer.offsetWidth - 335)/2) - 200),
                        	   y = window.innerHeight - (boxcontainer.offsetTop + ((boxcontainer.offsetHeight - 150)/2)) - 120,
                             transfrom = ("translate(-" + x + "px," + y + "px) scale(0.35,0.24)");

                             $ringbox.minimizedBox.dom[0].querySelector('.pv-profile').style.display = 'none'; // hide comment part

                             boxcontainer.style.webkitTransition = 'transform 0.5s';
                  					 boxcontainer.style.MozTransition = 'transform 0.5s';
                  				   boxcontainer.style.msTransition = 'transform 0.5s';
                  					 boxcontainer.style.OTransition = 'transform 0.5s';
                  					 boxcontainer.style.transition = 'transform 0.5s';

                             boxcontainer.style.webkitTransform = transfrom;
                  					 boxcontainer.style.MozTransform = transfrom;
                  				   boxcontainer.style.msTransform = transfrom;
                  					 boxcontainer.style.OTransform = transfrom;
                  					 boxcontainer.style.transform = transfrom;

        					           //boxcontainer.addEventListener('webkitTransitionEnd', eventTranstionEnd);
                             //boxcontainer.addEventListener('msTransitionEnd', eventTranstionEnd);

                  					 boxcontainer.addEventListener(prefix+'TransitionEnd', eventTranstionEnd);
                  					 boxcontainer.addEventListener('transitionend', eventTranstionEnd);


                       }
                    }

                   $ringbox.maximize = function(parent, content) {

                     if($ringbox.minimizedBox.dom) {

                         var boxcontainer = $ringbox.minimizedBox.dom[0].querySelector('.ringbox-content');
                         var boxOverlayDom = $ringbox.minimizedBox.dom[0].querySelector('div.ringbox-overlay');


                         $ringbox.minimizedBox.dom[0].querySelector('.pv-profile').style.display = 'block';
                         $ringbox.minimizedBox.dom[0].style.display = 'table';
                         parent.appendChild(content);

                         boxcontainer.style.webkitTransform = 'initial';
            					   boxcontainer.style.MozTransform = 'initial';
            				     boxcontainer.style.msTransform = 'initial';
            					   boxcontainer.style.OTransform = 'initial';
            					   boxcontainer.style.transform = 'initial';

              					 $this.boxes.push($ringbox.minimizedBox.dom);
              					 $this.boxeScopes.push($ringbox.minimizedBox.scope);
                         $this.boxeDeferred.push($ringbox.minimizedBox.deferred);
                         if($this.boxes.length == 1) {
                            document.body.className = document.body.className.trim()+' ringbox-opened';
                         }

    					           $ringbox.minimizedBox = {dom:null, scope:null, deferred:null};

    					           //boxcontainer.removeEventListener('webkitTransitionEnd', eventTranstionEnd);
                		     //boxcontainer.removeEventListener('msTransitionEnd', eventTranstionEnd);
    					           //boxcontainer.removeEventListener('transitionend', eventTranstionEnd);


            					   boxcontainer.removeEventListener(prefix+'TransitionEnd', eventTranstionEnd);
            					   boxcontainer.removeEventListener('transitionend', eventTranstionEnd);

                      }

                   }
                   /*end of player api*/

                    $ringbox.open = function (boxOptions) {

                        var boxResultDeferred = $q.defer();
                        var boxOpenedDeferred = $q.defer();
                        var boxTimer = false;

                        var boxDom = $this.init(),
                         	boxContentDom = angular.element(boxDom[0].querySelector('div.ringbox-content')),
                         	boxLoaderDom = angular.element(boxContentDom[0].querySelector('div.ringbox-loader')),
                         	boxInnerDom = angular.element(boxContentDom[0].querySelector('div.ringbox-inner')),
                          boxOverlayDom = angular.element(boxDom[0].querySelector('div.ringbox-overlay')),
                        	margin, boxOffsetHeight = boxContentDom[0].offsetHeight;

                        boxContentDom.css({'width':'200px','height':'95px','max-width':'200px','max-height':'95px'});
                        if(boxOptions.animation) {
                          boxContentDom.addClass('animation');
                        }
                        $this.adjustBoxes();
                        //merge and clean up options
                        boxOptions = angular.extend({}, boxOptions);
                        var boxScope = (boxOptions.scope || $rootScope).$new();
                        boxScope.boxIsLoading = true;
                        angular.forEach($ringboxProvider.options,function(value,key){
                            boxScope[key] = boxOptions[key];
                        });
                        if(angular.isObject(boxOptions.scopeData)){
                          angular.forEach(boxOptions.scopeData,function(value,key){
                            boxScope[key] = boxOptions.scopeData[key];
                        });
                        }
                        $this.boxeScopes.push(boxScope);
                        $this.boxeDeferred.push(boxResultDeferred);

                        var showLoader = function() {
                            boxLoaderDom.css({'display':'block'});
                            boxInnerDom.css({'display':'none'});
                            boxContentDom.css({'width':'200px','height':'95px','max-width':'200px','max-height':'95px'});
                        };

                        var hideLoader = function() {

                           setTimeout(function(){
                                boxLoaderDom.css({'display':'none'});
                                boxInnerDom.css({'display':'inline-block'});
                                boxContentDom.css({'width':'auto','height':'auto','max-width':'100%','max-height':'100%'});
                             }, 100);
                        };


                        var fastdomFrame = null;

                        boxScope.$watch(heightChagned);


                        boxScope.$on(SystemEvents.FEED.HEIGHT, function($event, key){
                            heightChagned();
                        });

                       var heightChagned = function() {

                            if(fastdomFrame) return;
                            fastdomFrame = fastdom.defer(function() {
                               if(boxContentDom && boxOptions.scrollable) {
                                 boxOffsetHeight = boxContentDom[0].offsetHeight;
                                 margin = Math.max((utilsFactory.viewport.y/2 - boxOffsetHeight/2),40);
                                 boxContentDom.css({'margin-top':margin+'px'});

                                 if(boxOffsetHeight > utilsFactory.viewport.y ) {
                                   boxOverlayDom.css({'right':utilsFactory.scrollbarWidth+'px'});
                                 }
                                 else {
                                   boxOverlayDom.css({'right':'0px'});
                                 }

                                 fastdomFrame = null;

                               }

                            }, 2);
                            return boxOffsetHeight;
                        };


                        //verify options
                        if (!boxOptions.template && !boxOptions.templateUrl) {
                            throw new Error('One of template or templateUrl options is required.');
                        }

                        var templateAndResolvePromise =
                            $q.all([getTemplatePromise(boxOptions)].concat(getResolvePromises(boxOptions.resolve)));

                            var boxlInstance = {
                                result: boxResultDeferred.promise,
                                opened: boxOpenedDeferred.promise,
                                close: $ringbox.close,
                                closeAll: $ringbox.closeAll,
                                showLoader: showLoader,
                                hideLoader: hideLoader
                            };


                            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {

                             boxScope.boxIsLoading = false;
                             boxScope.$close = $ringbox.close;

                             if(!boxInnerDom) return;

                             if(boxTimer) {
                              clearTimeout(boxTimer);
                            }

                            var ctrlInstance, ctrlLocals = {};
                            var resolveIter = 1;

                            //controllers
                            if (boxOptions.controller) {
                                ctrlLocals.$scope = boxScope;
                                ctrlLocals.$boxInstance = boxlInstance;
                                for(var key in boxOptions.resolve){
                                  if(boxOptions.resolve.hasOwnProperty(key)){
                                    ctrlLocals[key] = tplAndVars[resolveIter++];
                                  }

                                }
                                // angular.forEach(boxOptions.resolve, function (value, key) {

                                // });

                                ctrlInstance = $controller(boxOptions.controller, ctrlLocals);
                                if (boxOptions.controllerAs) {
                                    boxScope[boxOptions.controllerAs] = ctrlInstance;
                                }
                            }

                             boxInnerDom.html(tplAndVars[0]);
                             //boxInnerDom.append($compile(angular.element(tplAndVars[0]))(boxScope));
                             $compile(boxInnerDom.contents())(boxScope);
                             boxContentDom.css({'width':'auto','height':'auto','max-width':'100%','max-height':'100%'});
                             hideLoader();

                             if(boxOptions.scrollable) {

                             	 fastdom.read(function() {
                                 	boxOffsetHeight = boxContentDom[0].offsetHeight;

                                 	margin = Math.max((utilsFactory.viewport.y/2 - boxOffsetHeight/2),40);
                              	 	fastdom.write(function() {
                                 	  boxContentDom.css({'margin-top':margin+'px'});
                              	 	});
                            	 });

                                if(boxOffsetHeight > utilsFactory.viewport.y ) {
                                  boxOverlayDom.css({'right':utilsFactory.scrollbarWidth+'px'});
                                }

                             }

                             boxScope.$parent.$rgDigest();
                             RingLogger.info("from ringbox",RingLogger.tags.DIGEST);

                        }, function resolveError(reason) {
                            boxResultDeferred.reject(reason);
                                $ringbox.close();
                        });

                        templateAndResolvePromise.then(function () {
                            boxOpenedDeferred.resolve(true);
                        }, function () {
                            boxOpenedDeferred.reject(false);
                        });

                        /*Attached Event*/
                        if(boxOptions.scrollable) {
                           boxDom.addClass('scrollable');
                           margin = utilsFactory.viewport.y/2 - boxOffsetHeight/2;
                           boxContentDom.css({'margin-top':margin+'px'});
                        }

                        if(boxOptions.onBackDropClickClose) {

                           boxOverlayDom.on('click', function() {
                              $ringbox.close();
                           });

                           /*This hack is required only if ringbox is scrollable*/
                           if(boxOptions.scrollable) {
                           		$document.bind('click', function boxClick(evt) {
                             		if (evt.target.className.indexOf('ringbox-outerContainer') != -1) {
                                		$document.unbind('click',boxClick);
                                		$ringbox.close();
                              		}
                           		});
                           }
                        }

                        if(boxOptions.onEscape) {
                           $document.bind('keyup', function boxKeyup(evt) {
                               var keyCode = evt.which || evt.keyCode || evt.key;

                               if (keyCode != 32) {
                                 evt.stopImmediatePropagation();
                               }

                               if (keyCode == 27) {

                                  /* Player status */
                                  if($player.escapeKey) {
                                    $player.escapeKey = false;
                                    return;
                                  }

                                  $document.unbind('keyup',boxKeyup);
                                  $ringbox.close();
                                }
                                return false;
                           });
                        }

                        if(boxOptions.scrollable) {
                           		boxDom.bind('scroll', function boxScroll(evt) {
                             		  if((boxDom[0].scrollHeight - (boxDom[0].offsetHeight+boxDom[0].scrollTop)) < 100) {
                             		     if(angular.isFunction(boxScope.onScroll)) boxScope.onScroll();
                             		     if(angular.isFunction(boxScope.loadMore)) boxScope.loadMore();
                             		  }
                           		});
                         }
                        /* End of events*/

                        boxScope.$on('$destroy',function(){
                           boxDom = null;
                           boxContentDom = null;
                           boxLoaderDom = null;
                           boxInnerDom = null;
                           boxlInstance = null;
                           boxOptions = null;
                           boxOverlayDom = null;
                           templateAndResolvePromise = null;
                        });

                        boxTimer = setTimeout(function() {

                            if(boxScope && boxScope.boxIsLoading) {
                              Notification.error({message: "Something went wrong! Please try again."});
                              $ringbox.close();
                            }

                        }, 10000);

                       return boxlInstance;
                    };

                    return $ringbox;
                }]
        };

        return $ringboxProvider;
    })
    .directive('rgRingbox',['$ringbox',function($ringbox){
        return {
            restrict : 'EA',
            scope:{
                ringboxData : '&',
                scopeData : '&',
                onRingBoxOpen : '&',
                onRingBoxClose : '&',
                onScroll : '&',
                ringboxFalsyFunc : '&',
                ringboxOpen : '&'
            },
            link : function(scope,element,attr){
                var scopeOffEvent;
                function mainFunction(event) {
                    event.preventDefault();
                    //event.stopPropagation();

                    var type,target,items={}, scopeDataItems = {};

                    type = attr.ringboxType;// html,remote:require template url
                    if(!type)type='html';//innerhtmlof the provided content or a data content

                    if(attr.ringboxData){
                        if(angular.isFunction(scope.ringboxData)){
                            items = scope.ringboxData();
                        }else{
                            items = scope.ringboxData;
                        }
                    }

                    if(attr.scopeData){
                        if(angular.isFunction(scope.scopeData)){
                            scopeDataItems = scope.scopeData();
                        }else{
                            scopeDataItems = scope.scopeData;
                        }
                    }

                    var tempitems = items.data ? items.data:items;
                    var ringOb = {
                        type : type,
                        scrollable: (attr.ringboxScrollable && (attr.ringboxScrollable=="true" || attr.ringboxScrollable==true))?true :false,
                        scope : attr.ringboxScope?scope:false,
                        scopeData : scopeDataItems || {},
                        controller: attr.ringboxController || '',
                        resolve : {
                            localData : tempitems,
                            remoteData : items.promise ? items:angular.noop
                        },
                        onBackDropClickClose : (attr.ringBackdropClose && (attr.ringBackdropClose=="false" || attr.ringBackdropClose==false))?false :true,
                        animation : (attr.ringboxAnimation && (attr.ringboxAnimation=="false" || attr.ringboxAnimation==false))?false :true,
                        onEscape : (attr.ringCloseEscape && (attr.ringCloseEscape=="false" || attr.ringCloseEscape==false))?false :true
                    };

                    if(type === 'remote'){
                        ringOb.templateUrl = attr.ringboxTarget || scope.ringboxTarget || attr.href || attr.src;
                    }else if(type === 'video') {

                    } else if (type === 'inline'){
                        ringOb.template = attr.ringboxTarget || scope.ringboxTarget;
                    } else {
                         type = 'html';
                         target = attr.ringboxTarget || scope.ringboxTarget;
                         if(!target){
                             ringOb.template = element.html();
                         }else{
                            ringOb.template = angular.element(document.querySelector(target));
                            if(ringOb.template.length > 0){
                                ringOb.template = ringOb.template[0].outerHTML;
                            } else{
                                throw new Error("Opps ! Your Provideed Target element Does Not Exist!");
                            }
                         }

                    }

                    var boxInstance = $ringbox.open(ringOb);

                    boxInstance.result.then(function (selectedItem) {
                        if(angular.isDefined(scope.onRingBoxClose) && angular.isFunction(scope.onRingBoxClose)){
                            scope.onRingBoxClose();
                        }

                    });

                    boxInstance.opened.then(function() {
                        if(angular.isDefined(scope.onRingBoxOpen) && angular.isFunction(scope.onRingBoxOpen)){
                            scope.onRingBoxOpen();
                        }
                    });

                };

                function bindEvent(fn) {
                    element.on("click",fn);
                    scopeOffEvent =  scope.$on('$destroy',function(){
                        element.off('click', fn);
                    });
                };

                function bindFalsyEvent(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if(angular.isFunction(scope.ringboxFalsyFunc)){
                        scope.ringboxFalsyFunc();
                    }
                }

                if(attr.ringboxOpen){
                   // RingLogger.print("attr found : "+attr.ringboxOpen,'Ringbox');
                    scope.$watch('ringboxOpen()', function(newValue) {
                        if(scopeOffEvent){
                          element.off("click");
                          scopeOffEvent();
                        }
                         if(newValue){
                            bindEvent(mainFunction);
                         }else{
                            bindEvent(bindFalsyEvent);
                         }
                    });
                }else if(attr.rgRingbox === "" || attr.rgRingbox === "true" || attr.rgRingbox === true){
                  bindEvent(mainFunction);
                }else{
                  bindEvent(bindFalsyEvent);
                }
            }
        };
    }]);

(function () {
    "use strict";
    angular
            .module('ringid.common.contacts_factory', ['ringid.config', 'ringid.common.stacked_map'])
            .factory('Contacts', ContactsFactory);

            ContactsFactory.$inject = ['settings','$$stackedMap', 'utilsFactory', 'Storage'];
            function ContactsFactory(settings, $$stackedMap,  utilsFactory, Storage) {
                var utIdMap = {
                        utIds:  $$stackedMap.createNew(),
                        incomingUtIds: $$stackedMap.createNew(),
                        outgoingUtIds: $$stackedMap.createNew()
                    },
                    tempUtIds = $$stackedMap.createNew();

                function syncStorage(utidType, utid, frnsObj, addNew) {
                        tempUtIds.setStack(Storage.getData(utidType)); // set from localStorage
                        if(addNew) {
                            tempUtIds.save(utid, frnsObj); // modify data
                        } else {
                            tempUtIds.remove(utid); // modify data
                        }

                        Storage.setData(utidType, tempUtIds.all()); // save changes to localstorage
                        tempUtIds.reset(); // reset temp variable
                }

                return {
                    init: function() {
                        tempUtIds.setStack([]);
                        // all time fresh utid list is taken from server and shown to user
                        //utIdMap.utIds.setStack(Storage.getData('utIds') || []);
                        //utIdMap.incomingUtIds.setStack(Storage.getData('incomingUtIds') || []);
                        //utIdMap.outgoingUtIds.setStack(Storage.getData('outgoingUtIds') || []);
                    },
                    initStorage: function() {
                        //Storage.setData('utIds', utIdMap.utIds.all() );
                        //Storage.setData('incomingUtIds', utIdMap.incomingUtIds.all() );
                        //Storage.setData('outgoingUtIds', utIdMap.outgoingUtIds.all() );
                    },
                    utIds : function() {
                        return utIdMap.utIds; // all friends
                    },
                    outgoingUtIds : function() {
                        return utIdMap.outgoingUtIds; // all friends
                    },
                    incomingUtIds :function() {
                        return utIdMap.incomingUtIds; // all friends
                    },
                    remove: function(utidType, utid) {
                        //syncStorage(utidType, utid);
                        return utIdMap[utidType].remove(utid);
                    },
                    add: function(utidType, utid, frnsObj) {
                        //syncStorage(utidType, utid, frnsObj, true);
                        utIdMap[utidType].save(utid, frnsObj);
                    },
                    getFrns: function(utId) {
                        return utIdMap.utIds.get(utId) ||
                               utIdMap.incomingUtIds.get(utId) ||
                               utIdMap.outgoingUtIds.get(utId) ||
                               {frnS: 0};
                    }
                };
            }

})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.global_events_factory', [])
        .factory('GlobalEvents', GlobalEvents);


    GlobalEvents.$inject = ['$document'];
    function GlobalEvents($document){
        var handlers = [];


        var handleClick = function(event) {
            /*
            * http://ringgit.com/ringID/ringIDWeb/issues/99
            *
            * Firefox right click also detect as click
            *
            * */
            if( event.which === 3 || handlers.length === 0){
                return;
            }


            RingLogger.warn('CLICKED ON WINDOW');
            RingLogger.log(handlers);
            for(var i = 0, l = handlers.length; i < l; i++) {
                handlers[i].call(null, event);
            }
            event.preventDefault();
            //event.stopPropagation();
        };



        return {
            bindHandler: function(attachTo, eventType,  handler) {
                handlers.push(handler);
                if(handlers.length === 1) { // only once bind when handlers goes from 0 to 1
                    $document.bind('click', handleClick);
                }

            },
            unbindHandler: function(removeFrom, eventType, handler) {
                setTimeout(function() {
                    handlers.splice( handlers.indexOf(handler), 1 );
                    if(handlers.length === 0) { // remove event binding when no handlers present
                        $document.unbind('click', handleClick);
                    }
                });
            }
        };
    }


})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.events_factory', [])
        .factory('SystemEvents', SystemEvents);


    SystemEvents.$inject = ['$rootScope'];
    function SystemEvents(){
        return {
            COMMON : {
                WINDOW_RESIZED : 'WINDOW_RESIZED',
                COLUMN_CHANGED : 'COLUMN_CHANGED',
                LOADING: 'LOADING'
            },
            CIRCLE : {
                MY_CIRCLE_LIST_FETCH_COMPLETE : 'MY_CIRCLE_LOAD_COMPLETE',
                MY_CIRCLE_LIST_PROCESS_COMPLETE : 'MY_CIRCLE_LIST_PROCESS_COMPLETE',

                MY_CIRCLE_MEMBER_LIST_FETCH_COMPLETE : 'MY_CIRCLE_MEMBER_LIST_FETCH_COMPLETE',
                MY_CIRCLE_MEMBER_LIST_PROCESS_COMPLETE : 'MY_CIRCLE_MEMBER_LIST_PROCESS_COMPLETE',

                MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE : 'MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE',

                MY_CIRCLE_MEMBER_REMOVED : 'MY_CIRCLE_MEMBER_REMOVED',

                MY_CIRCLE_REMOVED : 'MY_CIRCLE_REMOVED'
            },

            FILE_UPLOAD : {
                PROGRESS_UPDATE : 'PROGRESS_UPDATE',
                QUEUE_START : 'QUEUE_START',
                QUEUE_COMPLETE : 'QUEUE_COMPLETE',
                UPLOADS_POSTED : 'UPLOADS_POSTED'
            },

            ALBUM : {
                PHOTOS_SELECTED : 'PHOTOS_SELECTED'
            },

            IMAGE : {
                DO_REPOSITION : 'DO_REPOSITION',
                RESIZE: 'RESIZE'
            },

            FEED : {

                UPDATED : 'UPDATED',
                CREATED : 'CREATED',
                DELETED : 'DELETED',
                RESET : 'RESET',
                HEIGHT : 'HEIGHT',
                BUSY : 'BUSY'

            },

            AUTH: {
                LOGIN : 'LOGIN'
            },

            CHAT : {
                CHAT_REGISTER : 'CHAT_REGISTER',
                MESSAGE_RECEIVED : 'MESSAGE_RECEIVED',
                MESSAGE_SUBMITTED : 'MESSAGE_SUBMITTED',

                TAB_SYNC : 'TAB_SYNC',
                TAB_SYNC_NEW_DATA : 'TAB_SYNC_NEW_DATA',

                UNREAD_MESSAGE_INFO_UPDATED : 'UNREAD_MESSAGE_INFO_UPDATED'
            }




        }

    }


})();

(function () {
    "use strict";
    angular
            .module('ringid.common.user_factory', [
                'ringid.config',
                'ringid.common.stacked_map',
                'ringid.common.contacts_factory'
            ]).factory('$$userMap', ['profileHttpService', 'settings','$$stackedMap','$filter',  'utilsFactory', 'Storage', 'Contacts','$$q',
                function (profileHttpService, settings, $$stackedMap,$filter,   utilsFactory, Storage, Contacts,$q) {
                    var DEVICES = {
                        0 : 'p',
                        1 : 'desktop',
                        2 : 'android',
                        3 : 'iphone',
                        4 : 'windows',
                        5 :  'web'
                    };
                    return {

                        create: function (obj, isProfile, isCurrent,usersByUtId,withMfc) {
                            var user = {
                                fn: "",
                                uId: 0,
                                cnty: "",
                                el: "",
                                gr: "",
                                am: "",
                                mblDc: "",
                                prIm: "images/prof.png",
                                cIm : "images/default_cover.jpg",
                                prImId: 0,
                                cImId: 0,
                                cimX: 0,
                                cimY: 0,
                                bDay: "",
                                blc: 0, // block maybe
                                re: '',
                                utId: 0,
                                tf: 0,
                                nmf: 0, // no of common friends
                                // access parameters
                                chta: 0,
                                cla: 0,
                                fda: 0,
                                cc:"",
                                hc:"",
                                adt: 0, // added time

                                // presence detail
                                psnc: 0, // 1=online, 2=offline, 3=away, 4=do not disturb
                                lot: 0,
                                mood: 0, // 1=alive, 2=do not disturb, 3=busy, 4=invisible
                                apt : 0,
                                dt : "",

                                groups: {}, // groups memberships info
                                frnS: 0,
                                ct: 0,
                                nct: 0,
                                pimX: 0,
                                pimY: 0,
                                bv: 0,
                                owner: 0,
                                basicInfo: false,
                                privacyInfo: {},
                                isCurrent: false,
                                loading: false
                            };

                            user.isCurrent = isCurrent;
                            user.isProfile = isProfile;

                            user.psnc = isCurrent ? 2 : user.psnc;
                            user.dvc =  isCurrent ? 5 : user.dvc;
                            //if group information present store it
                            if ( obj.hasOwnProperty('grpId') ) {
                                user.groups[obj.grpId] = obj.admin;
                            }

                            var updateUser = function(o) {
                                var userObj = o || obj;


                                user = angular.extend({}, user, userObj);
                                //console.log('info: '+user.gr);
                                // update group info
                                if(userObj.grpId) {
                                    user.groups[userObj.grpId] = userObj.admin;
                                }

                                // if prIm and cIm is empty string set them to default
                                if (user.prIm === '') {
                                    user.prIm =   "images/prof.png";
                                }
                                if (user.cIm ===  '') {
                                    user.cIm = "images/default_cover.jpg";
                                }

                                if( user.frnS === 0) {
                                    user.frnS = Contacts.getFrns(user.utId).frnS || user.frnS;
                                }
                                if(userObj.mfc){
                                    user.nmf = userObj.mfc;
                                }
                                if(userObj.mutualFriends){
                                    user.nmf = userObj.mutualFriends;
                                }

                            };

                            if (angular.isObject(obj)) {
                                if(!obj.utId) {
                                   RingLogger.warning('CAN NOT DETERMINE FRNS NO utId', RingLogger.tags.FRIEND);
                                }
                                updateUser();
                            }

                            function createAvatar(size){
                                var imageLink = user.prIm || "";
                                    if (size === 'iurl') {
                                        return imageLink;
                                    }

                                    if (size === 'original') {
                                        return settings.imBase + imageLink;
                                    }

                                    // default image
                                    if (imageLink.indexOf('prof.png') > 0) {
                                        return imageLink;
                                    }

                                    imageLink =  imageLink.replace('profileimages/','');
                                    if(size === 'original') {
                                        size = '';
                                    } else if(!size){
                                      size = 'crp';
                                    }
                                    // add progressive prefix
                                    size = (/\/uploaded\//.test(imageLink) ? '': 'p') + size;

                                    var position = imageLink.lastIndexOf('/') + 1;
                                    imageLink = [settings.imBase, imageLink.slice(0, position), size,  imageLink.slice(position)].join('');

                                    return imageLink.indexOf('prof.png') > 0 ? user.prIm : imageLink ;
                            }
                            // RingLogger.print("user create Map : #"+user.utId + " ID:"+ user.uId + " Name"+ user.fn,"SafeModeSender");
                            if(!user.prIm || !user.uId || !user.utId || (!user.nmf && withMfc)){
                                requestUserDetails(!!withMfc);
                            }
                            var requestedMutualFriend = false;
                            function requestUserDetails(mfc){//mutual Friend count
                                var reqData = {},promise;
                                if(user.utId){
                                    reqData.utId = user.utId;
                                }
                                else if(user.uId){
                                    reqData.uId = user.uId;
                                }
                                if(reqData.utId || reqData.uId){
                                    if(mfc){
                                        requestedMutualFriend = true;
                                    }
                                   // RingLogger.print("http Service called : #"+user.utId + " ID:"+ user.uId + " Name"+ user.fn,"SafeModeSender");
                                    promise = profileHttpService.getUserDetails(reqData,!!mfc);
                                    promise.then(function(json){
                                       // RingLogger.print("Response ",json,"SafeModeSender");
                                        if(json.sucs){
                                            updateUser(json.userDetails);
                                        }
                                        if(user.utId && usersByUtId && !usersByUtId[user.utId]){
                                            usersByUtId[user.utId] = ObjectToReturn;
                                        }

                                    });
                                    return promise;
                                }
                            }

                            //user.avatar = createAvatar;

                           var liteUser = {
                                getName: function (type) {
                                    return user.fn;
                                },
                                avatar: createAvatar,
                                getKey: function () {
                                    return user.uId || user.utId;
                                },
                                getUId : function(){
                                    return user.uId;
                                },
                                setUid : function(uid){
                                    user.uId = uid;
                                },
                                getUtId: function () {
                                    return +user.utId;
                                },
                                updateUserObj : function(obj) {
                                    updateUser(obj);
                                },
                                equals: function(u,check){// id or instance of
                                    // for match utId sent utId else sent uId or sent nothing
                                    if (!check){
                                        check = 'uId';
                                    }
                                    if(angular.isObject(u)){
                                        u = (check === 'uId') ? u.getKey() : u.getUtId();
                                    }
                                    return user[check] === u;
                                },
                                link: function () {

                                    if( !!user.uId || !!user.utId ){
                                        //return settings.baseUrl + utilsFactory.getRingRoute('USER_PROFILE', { uId : user.uId, utId : user.utId }) + (user.frnS !== 1 && !user.isCurrent) ? '/about' : '';
                                        return settings.baseUrl + utilsFactory.getRingRoute('USER_PROFILE', { uId : user.uId, utId : user.utId }) + ((user.frnS !== 1 && !user.isCurrent) ? '/about' : '');
                                    }else{
                                        return '';
                                    }
                                },
                               navActiveLink: function () {

                                   if( !!user.uId || !!user.utId ){
                                       var url = '/profile/'+user.uId+'/post';
                                       return  url;
                                   }else{
                                       return '';
                                   }
                               },
                                toString : function(){
                                    return user.uId;
                                },
                                getRingNumber: function () {
                                   return  (user.uId.replace(/(\d{2})(\d{4})(\d+?)/,"$2 $3"));
                                   //return user.uId.substring(2);
                                },
                                friendshipStatus: function () {
                                   return user.frnS; // 0=not friend, 1=accepted friend, 2=incoming friend request, 3=outgoing friend request
                                },
                                isLoading: function(bool) {
                                    if (typeof bool === 'undefined') {
                                        return user.loading;
                                    } else {
                                        user.loading = bool;
                                        return user.loading;
                                    }
                                },
                                commonFriends: function (force,returnPromise) {
                                    var promise;
                                    if((!user.nmf && !requestedMutualFriend) || force){
                                        promise = requestUserDetails(true,returnPromise);
                                    }
                                    return returnPromise ? (promise || $q.when(user.nmf)) : user.nmf;
                                },
                               isCurrentUser: function () {
                                   //return key === user.uId;
                                   return user.isCurrent;
                               }
                            };

                            var ObjectToReturn = {
                                sortBy: function() {
                                    //return user.fn.toLowerCase();
                                    return user.adt;
                                },
                                getLiteUser : function(){
                                    return liteUser;
                                },
                                isAdmin: function(grpId) { // check if user admin of a group
                                    if(user.groups.hasOwnProperty(grpId)) {
                                        return user.groups[grpId];
                                    } else {
                                        return false;
                                    }
                                },
                                setGroupAdmin : function(groupId){
                                    user.groups[groupId]=true;
                                },
                                removeGroupAdmin : function(groupId){
                                    delete user.groups[groupId];
                                },
                                updateUserObj : function(obj) {
                                    updateUser(obj);
                                },
                                overwriteInfo : function(ob){
                                    user.prIm = ob.prIm || user.prIm;
                                },
                                haveProfileData: function() {
                                    return user.isProfile;
                                },
                                getBasicInfo: function() {
                                    var frTime = utilsFactory.profileVerbalDate(user.bDay);
                                    var mTime = utilsFactory.profileVerbalDate(user.mDay);

                                    return {
                                        fn: user.fn || '',
                                        birthDay: user.bDay || '',
                                        mDay: user.mDay || '',
                                        birthday: frTime,
                                        marriageDay: mTime,
                                        el: user.el || '',
                                        hc: user.hc || '',
                                        cc: user.cc || '',
                                        gr: user.gr || '',
                                        am: user.am || '',
                                        uId: user.uId.toString().substring(2) || ''
                                    };
                                },

                                setBasicInfo: function(basicInfoObj) {
                                   // console.log(basicInfoObj);
                                   //return setProfileInfo(basicInfoObj);
                                },
                                resetCover: function() {
                                    user.cIm = "images/default_cover.jpg";
                                },
                                getCover: function(size) {
                                    var cIm = user.cIm,
                                        prefix,
                                        position;

                                    if (size === 'iurl') {
                                        return cIm;
                                    }

                                    if (size && size === 'original') {
                                        return settings.imBase + cIm;
                                            //prefix = (/\/uploaded\//.test(cIm) ? '': 'p');
                                            //position = cIm.lastIndexOf('/') + 1;
                                            //cIm = [settings.imBase, cIm.slice(0, position), prefix,  cIm.slice(position)].join('');
                                        //return cIm;
                                    }

                                    if (cIm) {
                                        if(cIm.indexOf('default') > 0){
                                            return cIm;
                                        }
                                        else if (cIm.indexOf('web') > 0) {
                                            return settings.imBase + cIm;
                                        } else {

                                            prefix = (/\/uploaded\//.test(cIm) ? '': 'p') + (size || 'crp') ;
                                            position = cIm.lastIndexOf('/') + 1;
                                            cIm = [settings.imBase, cIm.slice(0, position), prefix,  cIm.slice(position)].join('');
                                            return cIm;
                                        }
                                    } else {
                                        return "images/default_cover.jpg";
                                    }
                                },
                                getCoverXY: function() {
                                    return {x:user.cimX, y:user.cimY};
                                },
                                setCover: function(obj) {
                                    user.cIm = obj.iurl;
                                    user.cimX = obj.cimX;
                                    user.cimY = obj.cimY;
                                    user.cImId = obj.cImId;
                                },
                                getAvatarXY: function() {
                                    return {x:user.pimX, y:user.pimY};
                                },
                                setProfileImage: function (prImg, prImId) {
                                    user.prIm = prImg;
                                    user.prImId = prImId;
                                },
                                setName: function (fn) {
                                    user.fn = fn;
                                },
                                setAboutMe: function (am) {
                                    user.am = am;
                                },
                                setHomeCity: function (hc) {
                                    user.hc = hc;
                                },
                                setCurrentCity: function (cc) {
                                    user.cc = cc;
                                },
                                setGender: function (gr) {
                                    user.gr=gr;
                                },
                                setBirthday: function(bd) {
                                   user.bDay=bd;
                                },
                                setMarriageday: function(md) {
                                   user.mDay=md;
                                },
                                getEmail: function(){
                                  return user.el;
                                },
                                getCountry: function () {
                                    return user.cnty;
                                },
                                friendshipStatus: function () {
                                    return user.frnS; // 0=not friend, 1=accepted friend, 2=incoming friend request, 3=outgoing friend request
                                },
                                isLoading: function(bool) {
                                    if (typeof bool === 'undefined') {
                                        return user.loading;
                                    } else {
                                        user.loading = bool;
                                        return user.loading;
                                    }
                                },
                                friendType: function () {
                                    return user.ct; // 0=not friend, 1=call&chat, 2=fullprofile, 3= special friend
                                },
                                setFriendType: function(ct) {
                                    user.ct = ct;
                                },
                                newFriendType: function () {
                                    return user.nct; // 0=not friend, 1=call&chat, 2=fullprofile
                                },

                                getLink : function(attrs){
                                    var attrsStr ="";
                                    if(!!attrs){
                                        for(var key in attrs){
                                            if (attrs.hasOwnProperty(key)){
                                                attrsStr += key + '="'+attrs[key]+'" ';
                                            }
                                        }
                                    }
                                  return '<a '+attrsStr+' href="'+ liteUser.link() +'">' + user.fn +'</a>';
                                },
                                isCurrentUser: function () {
                                    //return key === user.uId;
                                    return user.isCurrent;
                                },
                                resetAvatar: function() {
                                    user.prIm =  "images/prof.png";
                                },
                                avatarXY: function() {
                                    return {x:user.pimX, y:user.pimY};
                                },
                                getBday: function() {
                                    return user.bDay;
                                },
                                getUserMood: function() {
                                    //switch(user.mood) {
                                        //case 1:
                                            //return 'Available';
                                            //break;
                                        //case 2:
                                            //return 'Do not disturb';
                                            //break;
                                        //case 3:
                                            //return 'Busy';
                                            //break;
                                        //case 4:
                                            //return 'Invisible';
                                            //break;
                                        //default:
                                            return user.mood;
                                    //}
                                },
                                setUserMood : function(mood){
                                    user.mood = mood;
                                },
                                getAppType : function(){
                                    return user.apt;
                                },
                                setAppType : function(appType){
                                    user.apt = appType;
                                },
                                getDeviceToken : function(){
                                    return user.dt;
                                },
                                setDeviceToken : function(deviceToken){
                                    user.dt = deviceToken;
                                },
                                getRingNumber: function () {
                                   return  (user.uId.replace(/(\d{2})(\d{4})(\d+?)/,"$2 $3"));
                                   //return user.uId.substring(2);
                                },
                                isBlocked: function() {
                                    return user.bv;
                                },
                                setBlock: function(block) {
                                    user.bv = block;
                                },
                                isFriend: function() {
                                    return user.frnS === 1;
                                },
                                unFriend: function() {
                                    user.frnS = 0;
                                },
                                getAccess: function() {
                                    return {
                                        chta: user.chta,
                                        cla: user.cla,
                                        fda: user.fda
                                    };
                                },
                                canChat: function() {
                                    if(user.chta === 1) {
                                        return true;
                                    } else {
                                        return false;
                                    }
                                },
                                canSeeFeed: function() {
                                    if(user.fda === 1) {
                                        return true;
                                    } else {
                                        return false;
                                    }
                                },
                                setOnlineStatus: function(status){
                                    user.psnc = status;
                                },
                                getOnlineStatus : function(){
                                    return user.psnc;
                                },
                                isOnline: function() {
                                    return (user.psnc === 2 && user.mood === 1);
                                },
                                onlineDevice: function() {
                                    return DEVICES[user.dvc];
                                },
                                getPlatform : function(){
                                  return user.dvc;
                                },
                                setPlatform : function(platfrom){
                                    user.dvc = platfrom;
                                },
                                lastOnline: function() {
                                    if(user.lot === 0) {
                                        return false;
                                        //return user.lot;
                                    } else {

                                        return utilsFactory.verbalDate(user.lot);
                                    }
                                },
                                getProfileImageId : function () {
                                    return user.prImId;
                                },
                                getCoverImageId : function () {
                                    return user.cImId;
                                },
                                // api methods
                                toggleMood: function(mood) {
                                    //console.log('mood: ' + mood);
                                    user.mood = mood ? 1 : 2;
                                    profileHttpService.changeMood(user.mood).then(function(json) {
                                        //console.log('%c' + angular.toJson(json), 'color:green');
                                        if(json.sucs !== true) {
                                            user.mood = json.mood;
                                        }
                                    });
                                },
                            };

                            angular.extend(ObjectToReturn, liteUser);
                            return ObjectToReturn;
                        }
                    };
                }])
            .factory("userFactory", ['$$userMap', '$$stackedMap', function ($$userMap, $$stackedMap) {
                    var users = $$stackedMap.createNew();

                    var usersByUtId = {};

                    var prefix = "ru_";

                    var ObjectToReturn = {
                        getSortIndex: function() {
                            return 'adt';
                            //return 'fn';
                        },
                        create: function (ob, isProfile, isCurrent) {
                           //console.log(ob);
                             isProfile = !!isProfile;
                             isCurrent = !!isCurrent;

                            //console.log('user:');
                            //console.dir(ob);
                            var key, user;
                            if(angular.isObject(ob)){
                                if (ob.uId) {
                                   key = ob.uId;
                                   key = prefix + key;
                                   user = users.get(key);
                                } else if(ob.utId) {
                                    user = usersByUtId[ob.utId];
                                    if(!user)user=false;
                                }else{
                                    user = false;
                                }
                            }else{
                                   key = prefix + ob;
                                   user = users.get(key);
                            }




                            // existing user in the map?
                            if (user === false ) {
                                if (ob.utId && usersByUtId[ob.utId]){
                                    user = usersByUtId[ob.utId];
                                    key = prefix + ob.uId;
                                    users.save(key, user);
                                    user.updateUserObj(ob);
                                } else {
                                    user = $$userMap.create(ob, isProfile, isCurrent,usersByUtId);
                                    if(user.getUtId()){
                                        usersByUtId[user.getUtId()] = user;
                                    }

                                }
                            } else {
                                user.updateUserObj(ob);
                            }

                          users.save(key, user);
                          return user;
                        },
                        createByUtId : function(ob,returnLite,withMfc){
                            if(!usersByUtId[ob.utId]){
                               usersByUtId[ob.utId]=$$userMap.create(ob,false,false,usersByUtId,withMfc);
                            }
                            return !returnLite ? usersByUtId[ob.utId] : usersByUtId[ob.utId].getLiteUser();
                        },
                        getUser : function(key){
                            key = prefix + key;
                          return users.get(key);
                        },

                        /* get by utId */
                        getByUtId : function(utId){
                           return (utId && usersByUtId[utId]) || false;
                        },
                        getAllUtIds : function(){
                            return Object.keys(usersByUtId);
                        },
                        getUIdByUtId : function(utId){
                            return usersByUtId[utId] && usersByUtId[utId].getUId();
                        },
                        getUtIdByUId : function(uId){
                            var user;
                            try{
                                user = ObjectToReturn.getUser(uId);
                            }catch(e){
                                RingLogger.warn(e, RingLogger.tags.FRIEND);
                            }
                            return user && user.getUtId();
                        }

                    };


                    return ObjectToReturn;

                }]);

})();

"use strict";
(function(){

    angular
        .module('ringid.common.comment_factory',['ringid.config', 'ringid.common.stacked_map'])
        .factory("$$commentMap", ['$$stackedMap','settings','$filter',"DATE_FORMAT",'userFactory','utilsFactory','$$stickerMap','$sce',
            function ($$stackedMap,settings,$filter,DATE_FORMAT,userFactory,utilsFactory,$$stickerMap,$sce) {
                return {

                    getSortIndex : function(){
                        return 'tm';
                    },
                    create: function (ob,user) { // while user adding comment // user is the second paramter of $$userMap Instance
                        var comment = {
                            cmn: "",
                            cmnId: 0,
                            deleted: false,
                            edited: false,
                            fn: "",
                            il: 0,
                            isNew:1,
                            ln: "",
                            nfId: 0,
                            imageId : 0,
                            tl: 0,
                            tm: "",
                            uId: "",
                            prIm : "",
                            pending : false // for showing half opacity when add comment
                        };
                        var commentTextHtml = "";
                        function updateTime(){
                            if(comment.tm){
                                comment.time = utilsFactory.verbalDate(comment.tm);
                            }else{
                                comment.time =  {}// preventing from throwing error
                            }
                        }
                        if (angular.isObject(ob)) {
                            comment = angular.extend({}, comment, ob);
                        }

                        if(!user){
                            comment.user = userFactory.create({
                                fn : comment.fn,
                                ln : comment.ln,
                                uId : comment.uId,
                                prIm : comment.prIm

                            });
                        }else{
                            comment.user = user;
                            comment.fn = comment.user.getName('f');
                            comment.fn = comment.user.getName('l');
                            comment.uId = comment.user.getKey();
                            comment.tm = new Date().getTime();
                           // comment.time = $filter('date')(new Date(comment.tm),DATE_FORMAT);
                            //comment.prIm = comment.user.getByProperty('prIm')
                        }
                        updateTime();


                       // comment.whoLikes = $$stackedMap.createNew();

                        var setCommentTextPortions = function(){
                            commentTextHtml = $sce.trustAsHtml(utilsFactory.parseForLE(comment.cmn));
                        };

                        setCommentTextPortions();
                        function updateComment(json){
                            comment = angular.extend({}, comment, json);
                            updateTime();
                            setCommentTextPortions();
                        }
                        return {
                            user: function () {
                                return comment.user;// instance of $$userMap
                            },
                            isOwner: function(userKey) {
                                return userKey === comment.user.getKey() ? true : false;
                            },
                            text : function(){
                               return comment.cmn;// here should goes a emoticon filter
                            },
                            setComment: function (commentText) {
                                comment.cmn = commentText;
                                setCommentTextPortions();
                            },
                            setText: function (txt) {
                                comment.cmn = txt;
                            },
                            getDynamicText : function(){
                                return commentTextHtml;
                            },
                            getByProperty : function(property_name,return_default){
                                return_default = return_default || false;
                                return comment.hasOwnProperty(property_name)?comment[property_name]:return_default;
                            },
                            sortBy : function(){
                                return comment.tm;
                            },
                            getKey: function () {
                                return comment.cmnId;
                            },
                            setKey : function(key){
                              comment.cmnId = key;
                            },
                            getFeedKey: function(){ // when comment belongs to feed
                                return comment.nfId;
                            },
                            setFeedKey:function(key){ // when comment belongs to feed
                                comment.nfId = key;
                            },
                            getImageKey: function(){ // when comment belongs to image
                                return comment.imageId;
                            },
                            setImageKey:function(key){ // when comment belongs to image
                                comment.imageId = key;
                            },
                            updateComment : function(json){
                                updateComment(json);
                            },
                            getTimestamp: function(){
                                return comment.tm;
                            },
                            setTime : function(tm){
                                comment.tm = tm;
                                updateTime();
                            },
                            getTimeUpdate : function(){
                                updateTime();
                                return comment.time;
                            },
                            time : function(){
                                return comment.time;
                            },
                            like : function(dolike,totalLike){
                                if(!dolike)return comment.il;
                                comment.il = comment.il ^ 1;
                                if(totalLike){
                                    comment.tl = totalLike;
                                }else{
                                    comment.tl = (comment.il == 0)?comment.tl-1:comment.tl+1;
                                }
                                return comment.il;

                            },
                            getTotalLikes : function(){
                                return comment.tl;
                            },
                            getLikes : function(){
                                //api call to show who likes
                            },
                            incomingLike: function (tl) {
                                    comment.tl = tl;
                                  // return (type && ++comment.tl) || --comment.tl;
                           },
                            // incomingWhoLikes : function(userJson){
                            //     var user = userFactory.create(userJson);
                            //     comment.whoLikes.save(user.getKey(),user);
                            // },
                            // getWhoLikes: function(){
                            //     return comment.whoLikes.all();
                            // },
                            edit : function(){

                            },
                            delete : function(){

                            },
                            isPending : function(val){
                                if(val !== undefined){
                                    comment.pending = !!val;
                                }
                                return comment.pending;
                            }


                        };
                    }
                };
            }]);



})();


/*
 * Ipvision
 */


(function(){
    "use strict";
    angular
        .module('ringid.common.imagemap_factory',[
            'ringid.config',
            'ringid.utils',
            'ringid.common.stacked_map',
            'ringid.common.comment_factory',
            'ringid.common.user_factory'
        ])
        .factory('$$imageMap', $$imageMap);

    $$imageMap.$inject = ['settings', '$$stackedMap', 'userFactory', 'utilsFactory'];
    function $$imageMap (settings, $$stackedMap, userFactory, utilsFactory) {
        return {
            create: function (obj, user) {
                var image = {
                    albId: "",
                    albn: "",
                    cptn: "",
                    nfId : 0,
                    ic: 0,
                    ih: 0,
                    il: 0,
                    imT: 0,
                    imgId: 0,
                    iurl: "",
                    iw: 0,
                    nc: 0,
                    nl: 0,
                    tm: 0,

                    user: null
                };
                //console.log(ob);
                image.key = 'im'+obj.imgId;
               // image.comments = $$stackedMap.createNew($$commentMap.getSortIndex());
              //  image.whoLikes = $$stackedMap.createNew();


                var updateImageObj = function(imgObj) {
                    if (angular.isObject(imgObj)) {
                        image = angular.extend({}, image, imgObj);
                    }

                    if(image.tm){
                        image.time = utilsFactory.verbalDate(image.tm);;
                    }else{
                        image.time = {};// preventing from throwing error
                    }

                    if (imgObj.hasOwnProperty('uId')) {
                        image.user = userFactory.create({
                            uId: imgObj.uId,
                            fn: imgObj.fn || ''
                        });
                    } else if (user) {
                        image.user = user;
                    }

                    // set image url to progressive version
                    //var fileName = image.iurl.slice(image.iurl.lastIndexOf('/') + 1);
                    //image.iurl = image.iurl.replace(fileName, 'p' + fileName);

                };
              //   RingLogger.print("image id = > news Feed id ",obj.imgId + " : "+obj.nfId ,"IMAGEMAP");
                updateImageObj(obj);

                var ObjectToReturn =  {
                    updateImage: function(obj) {
                        updateImageObj(obj);
                    },
                    user: function() {
                        return image.user;
                    },
                    src: function (size) {
                        if (size === 'iurl') {
                            return image.iurl;
                        }

                        var position = image.iurl.lastIndexOf('/') + 1;
                        var progressive = /\/uploaded\//.test(image.iurl) ? '': 'p';
                        if(size !== undefined){
                            return [settings.imBase, image.iurl.slice(0, position), progressive , size,  image.iurl.slice(position)].join('');
                            //return [settings.imBase, image.iurl.slice(0, position), size,  image.iurl.slice(position)].join('');
                        } else {
                            return [settings.imBase, image.iurl.slice(0, position), progressive,  image.iurl.slice(position)].join('');
                            //return [settings.imBase, image.iurl.slice(0, position), image.iurl.slice(position)].join('');
                        }
                    },
                    getByProperty : function(property_name,returndefault){
                        returndefault = returndefault || false;
                        return image.hasOwnProperty(property_name)?user[property_name]:returndefault;
                    },

                    sortBy : function(){
                        return image.imgId;
                    },
                    getIh: function() {
                        return image.ih;
                    },
                    getIw: function() {
                        return image.iw;
                    },
                    sortByTime : function(){
                        return image.tm;
                    },
                    getAlbumName : function(){
                        return image.albn;
                    },
                    getAlbumId: function() {
                        return image.albId;
                    },
                    getCaption : function(){
                        return image.cptn;
                    },
                    getKey: function () {
                        return image.imgId;
                    },
                    getMapKey : function(){
                        return image.key;
                    },
                    getFeedKey: function(){
                        return image.nfId;
                    },
                    setFeedKey:function(key){
                        image.nfId = key;
                    },
                    time : function(){
                        return image.time;
                    },
                    like : function(dolike,totalLike){
                        if(!dolike)return image.il;

                        image.il = image.il ^ 1;
                        if(totalLike){
                            image.nl  = totalLike;
                        }else{
                            image.nl = (image.il == 0) ? image.nl-1 : image.nl+1;
                        }
                        return image.il;
                    },
                    getLikes : function(){
                        return image.nl;//todo remove the getLikes from templates use getTotalLikes
                    },
                    getTotalLikes : function(){
                        return image.nl;
                    },
                    getImageType : function(){
                        return image.imT;
                    },
                    // getWhoLikes : function() {
                    //     return image.whoLikes.all();
                    // },
                    incomingLike: function (type) {
                        return (type && ++image.nl) || --image.nl;
                    },
                    // incomingWhoLikes: function (userJson) {

                    //         var user = userFactory.create(userJson);
                    //         image.whoLikes.save(user.getKey(), user);


                    // },

                    offset : function(){
                        return {width:image.iw,height:image.ih};
                    },
                    selfComment: function() {
                        return image.ic;
                    },
                    getTotalComment: function() {
                        return image.nc;
                    },
                    setTotalComment: function(total,ic) {
                        image.nc = total;
                        if(angular.isDefined(ic)){
                                image.ic = ic;
                            }
                    },
                    getUrl : function(){
                        /** Not an ideal place, will be refactored */
                        return '/image/' + ObjectToReturn.getKey();
                    },
                    getRelativeHeight : function(width){
                        //if(width > image.iw) return image.ih;
                        try {
                            return (image.ih/image.iw) * width;
                        }catch(e){
                            return image.ih;
                        }

                    }
                };

                return ObjectToReturn;
            }
        };
    }




})();

(function () {
    "use strict";
    angular
        .module('ringid.common.ringalert', ['ui-notification','ringid.ringbox'])
        .factory('Ringalert', Ringalert);
        Ringalert.$inject = ['$ringbox','Notification','MESSAGES'];

       function Ringalert($ringbox,Notification,MESSAGES){
           /*
               Notification factory API's
               Notification(), Notification.primary()	Show the message with bootstrap's primary class
               Notification.info()	Show the message with bootstrap's info class
               Notification.success()	Show the message with bootstrap's success class
               Notification.warning()	Show the message with bootstrap's warn class
               Notification.error()	Show the message with bootstrap's danger class
               Notification.clearAll()	Remove all shown messages
           */
           var defaultNotificationOptions = {
                delay : 3000,
                positionX : 'right',
                positionY : 'top',
                replaceMessage : true
           };
           var defaultAlertOptions = {
                title : 'Warning',
                message : 'Click ok to continue',
                showOk : true,
                showCancel : true,
                craac : false, //close ringbox after action
                textOk : 'OK',
                textCancel : 'Cancel',
                okCallback : angular.noop,
                cencelCallback : angular.noop
           };
           return {
               show : function(messageObject,type){//message is either object or string
                    type = type || 'info';//Notification property default we shows info
                    if(angular.isString(messageObject)){
                        messageObject = {
                            message : messageObject
                        };
                    }
                    messageObject.message = messageObject.message || messageObject.mg;
                   if(!messageObject.message){
                       if('success' === type){
                           messageObject.message = MESSAGES.REQUEST_PROCESSED;
                       }else if('error' === type){
                           messageObject.message = MESSAGES.REQUEST_FAILED;
                       }
                   }
                   try{
                        Notification[type](angular.extend({},defaultNotificationOptions,messageObject));
                   }catch(e){
                       console.info(messageObject.message);
                   }

               },
               clear : function(){
                   Notification.clearAll();
               },
               alert  :function(ob){
                  ob = ob || {};
                  ob = angular.extend({},defaultAlertOptions, ob);

                     var boxInstance = $ringbox.open({
                        type : 'remote',
                        scope:false,
                        scopeData : ob,
                        templateUrl : 'pages/popups/ring-alert.html'
                      });

               boxInstance.result.then(function(sts){
                  if(sts === 'ok' && angular.isFunction(ob.okCallback)){
                      ob.okCallback.call(null);
                  }else{
                      ob.cencelCallback.call(null);
                  }
               });


               }
           };
       }
})();

/*
 * Ipvision
 */


(function(){
    "use strict";
    angular
        .module('ringid.common.image_factory',[
            'ringid.config',
            'ringid.common.stacked_map',
            //'ringid.common.comment_factory',
            'ringid.utils','ringid.connector'
        ])
        .factory('ImageFactory', ImageFactory)


        ImageFactory.$inject = [ 'utilsFactory', 'imageHttpService', '$$q', '$$imageMap','Ringalert'];
        function ImageFactory( utilsFactory, imageHttpService, $q, $$imageMap,Ringalert) {

            return {
                process: function(json, image) {
                    if(!!processorFunctions[json.actn]){
                        processorFunctions[json.actn](json,image);
                    }
                },
                getImageDetails: function(imgId,nfId) {
                    var defer = $q.defer(); // this promise is used for popup only
                    //var key = imgId ? imgId : image.getKey();
                    imageHttpService.getImageDetails(imgId).then(function(response) {
                        if (response.sucs === true) {
                            //if (imgId) { // no image provided only imgId. so resolve with image obj
                                if(nfId && !response.nfId){
                                    response.nfId = nfId;
                                }
                                defer.resolve($$imageMap.create(response));
                            //} else {
                                //image.updateImage(response);
                                //defer.resolve();
                            //}
                        }else{

                            Ringalert.show(response,'error');
                        }
                    }, function(errData) {
                        defer.reject();
                        Ringalert.show(errData,'error');
                    });
                    return defer.promise;
                    //return defer;
                },
              
                // likeUnlikeImage: function(image) {
                //     var il;
                //     if(image !== false){
                //         il = image.like(true);// updating map before sending request
                //         imageHttpService.toggleLike(image.getKey(), il,image.getFeedKey()).then(function(response) {
                //             if (response.sucs !== true) {
                //                 image.like(true); // toggling back like.
                //                 Ringalert.show(response,'error');
                //             }
                //         }, function(errData) {
                //             image.like(true); // toggling back like
                //             Ringalert.show(errData,'error');
                //         })
                //     }
                // },
             
                // fetchWhoLikesImage : function(image,ulength) { // keyId is either feedKey or imageKey // comment Id while fetch Like for comment
                //     var defer = $q.defer(),
                //         dorequest = true;

                //     if(image.getLikes() === image.getWhoLikes().length){
                //         defer.resolve({sucs:true});
                //         dorequest = false;
                //     }

                //     if(dorequest){
                //         var utids = [];
                //         imageHttpService.fetchWhoLikes(image.getKey(),ulength,image.getFeedKey()).then(function(response){
                //             if(response.sucs){
                //                 for(var i=0;i < response.likes.length;i++){
                //                     image.incomingWhoLikes(response.likes[i]);
                //                     utids[i] = response.likes[i].utId;
                //                 }
                //                 imageHttpService.peopleDetails(utids);

                //                 defer.resolve(response);
                //             }else{
                //                defer.reject(response);
                //                Ringalert.show(response,'error'); 
                //             }
                            
                //         },function(reason){
                //             defer.reject(reason);
                //             Ringalert.show(reason,'error');
                //         });
                //     }

                //     return defer.promise;
                // },
                getFeedImages : function(nfId){
                    return imageHttpService.getFeedImages(nfId);
                }
            };
        }


})();

/*
 * Ipvision
 */


(function(){
    'use strict';
    angular
        .module('ringid.common.album_factory',[
            'ringid.config',
            'ringid.common.imagemap_factory',
            'ringid.common.stacked_map',
            'ringid.utils','ringid.connector',
            'ringid.common.services',
            'ringid.profile'
        ])
        .factory('AlbumFactory', AlbumFactory);

        AlbumFactory.$inject = ['$$q', 'settings', 'Auth', '$$imageMap', '$$stackedMap', '$$connector', 'OPERATION_TYPES', 'imageHttpService', 'profileFactory'];
        function AlbumFactory($q, settings, Auth, $$imageMap, $$stackedMap, $$connector, OPERATION_TYPES, imageHttpService, profileFactory) { // jshint ignore:line
            var OTYPES = OPERATION_TYPES.SYSTEM.IMAGE,
                ownImages = $$stackedMap.createNew(),
                userImages = $$stackedMap.createNew(),
                subscriptionKey,
                fetchAlbumListRequest = false,
                loadMoreImageRequest = false,
                loadMoreImageRequestTimeout;

            var CreateAlbum = function(obj, albumOwnerUid) {
                var image,
                    albumOwner,
                    album = {
                        albId: obj.albId,
                        timg: obj.timg,
                        images: $$stackedMap.createNew(),
                        ut: 0
                    };

                albumOwner = profileFactory.getProfile(albumOwnerUid);

                album = angular.extend({}, album, obj);


                function pushImages(obj) {
                    var imageObj;
                    for( var i = 0, lt = obj.imageList.length; i < lt; i++) {
                        imageObj =  angular.extend({}, obj.imageList[i], {albId: album.albId});
                        image = $$imageMap.create(imageObj, albumOwner);
                        album.images.save(image.getKey(), image);

                        if (album.ut < obj.imageList[i].tm) {
                            album.ut = obj.imageList[i].tm;
                        }
                    }
                    //RingLogger.print('total img:' + album.images.length(), RingLogger.tags.IMAGE);
                    //RingLogger.print('album: ' + album.albId, RingLogger.tags.IMAGE);
                }
                if(obj.imageList && obj.imageList.length > 0) {
                    pushImages(obj);
                }

                return {
                    getKey: function() {
                        return album.albId;
                    },
                    pushImages: function(obj) {
                        pushImages(obj);
                    },
                    removeImage: function(imageKey) {
                        if( album.images.remove(imageKey)) {
                            // do other stuff
                            album.tn = album.tn - 1; // decrease total no of image
                        }
                    },
                    getName: function() {
                        return album.albn;
                    },
                    getCoverImage: function(size) {
                        var position = album.cvImg.lastIndexOf('/') + 1;
                        size = 'p' + size;
                        return [settings.imBase, album.cvImg.slice(0, position), size,  album.cvImg.slice(position)].join('');
                        //return album.images.top().src(size);
                    },
                    getTotalImageCount: function() {
                        return album.tn;
                    },
                    getUpdateTime: function() {
                        return album.tm;
                    },
                    getImages: function() {
                        return album.images;
                    }

                };
            };

            var processResponse = function(json) {
                var album;
                switch(json.actn) {
                    case OTYPES.TYPE_ALBUM_IMAGES:
                        RingLogger.information('got Album images for album: ' + json.albId + ' success: ' + json.sucs, RingLogger.tags.IMAGE);
                        loadMoreImageRequest = false;
                        clearTimeout(loadMoreImageRequestTimeout);
                        if (json.sucs === true) {
                            if (ownImages.get(json.albId)) {
                                ownImages.get(json.albId).pushImages(json);
                            } else {
                                album = new CreateAlbum(json);
                                ownImages.save(album.getKey(), album);
                            }
                        } else {
                            RingLogger.alert('Album request failed', RingLogger.tags.IMAGE);
                        }

                        break;
                    case OTYPES.TYPE_FRIEND_ALBUM_IMAGES:
                        loadMoreImageRequest = false;
                        clearTimeout(loadMoreImageRequestTimeout);
                        RingLogger.information('got Album images for album: ' + json.albId + ' success: ' + json.sucs, RingLogger.tags.IMAGE);
                        if (json.sucs === true) {
                            if (userImages.get(json.albId)) {
                                userImages.get(json.albId).pushImages(json);
                            } else {
                                album = new CreateAlbum(json);
                                userImages.save(album.getKey(), album);
                            }
                        } else {
                            RingLogger.alert('Album request failed', RingLogger.tags.IMAGE);
                        }
                        break;
                }
            };



            return {
                resetUserImages: function(own) {
                    if (own) {
                         ownImages.reset();
                    } else {
                        userImages.reset();
                    }
                },
                imagesLoading: function() {
                    return loadMoreImageRequest;
                },
                albumsLoading: function() {
                    return fetchAlbumListRequest;
                },
                //subscribeData: function(uId, scope) {
                    //var action = ( Auth.currentUser().getKey() === uId ) ? OTYPES.TYPE_ALBUM_IMAGES: OTYPES.TYPE_FRIEND_ALBUM_IMAGES;
                    //subscriptionKey = $$connector.subscribe(processResponse, {action: action, scope: scope});
                //},
                //unsubscribeData: function() {
                        //$$connector.unsubscribe(subscriptionKey);
                //},
                deleteImage: function(imageMap) {
                    imageHttpService.deleteImage(imageMap.getKey()).then(function(response) {
                        RingLogger.print(response, RingLogger.tags.IMAGE);
                        if(response.sucs === true) {
                            // remove image from album image list
                            ownImages.get(imageMap.getAlbumId()).removeImage(imageMap.getKey());
                        } else {
                            RingLogger.warning('Image Delete failed', RingLogger.tags.IMAGE);
                        }
                    });
                },
                albums: function(uId) {
                    if (Auth.currentUser().getKey() === uId) {
                        return ownImages;
                    }else {
                        return userImages;
                    }
                },
                loadMoreImage: function(albId, uId) {
                    var deferred = $q.defer();

                    RingLogger.information('load more images for album: ' + albId + ' uId: ' + uId, RingLogger.tags.IMAGE);
                    var fndId = false,
                        st = 0;

                    if (loadMoreImageRequest) { // request sent already. waiting for data.
                        return;
                    }

                    loadMoreImageRequest = true;
                    loadMoreImageRequestTimeout = setTimeout(function() {
                        loadMoreImageRequest = false;
                        clearTimeout(loadMoreImageRequestTimeout);
                    }, 3000);

                    if (Auth.currentUser().getKey() === uId) {
                        st = ownImages.get(albId) ? ownImages.get(albId).getImages().length() : 0;
                        if (st !== 0 && st >= ownImages.get(albId).getTotalImageCount()) { // all images already fetched.
                            return;
                        }
                    } else {
                        fndId = uId;
                        st = userImages.get(albId) ? userImages.get(albId).getImages().length() : 0;
                        if (st !== 0 && st >= userImages.get(albId).getTotalImageCount()) { // all images already fetched. no need to request more
                            return;
                        }
                    }

                    imageHttpService.getAlbumImages({
                        fndId : fndId,
                        albId: albId,
                        st: st
                    }).then(function(json) {
                        if (json.sucs === true) {
                            processResponse(json);
                            deferred.resolve();
                        } else {
                            deferred.reject();
                        }
                    });

                    return deferred.promise;
                },

                getAllAlbums: function(uId) {
                    var fndId = false,
                        deferred = $q.defer(),
                        album;

                    if (Auth.currentUser().getKey() !== uId) {
                        fndId = uId;
                    }

                    //fetchAlbumListRequest = true;
                    //fetchAlbumListRequestTimeout = setTimeout(function() {
                        //fetchAlbumListRequest = false;
                        //clearTimeout(fetchAlbumListRequestTimeout);
                    //}, 3000);

                    imageHttpService.getAlbumList(fndId).then(function(response) {
                        RingLogger.print(response, RingLogger.tags.IMAGE);
                        //fetchAlbumListRequest = false;
                        //clearTimeout(fetchAlbumListRequestTimeout);
                        if(response.sucs === true) {
                            for(var i=0, len=response.albumList.length; i<len; i++) {
                                album = new CreateAlbum(response.albumList[i], uId);
                                if(fndId) {
                                    userImages.save(album.getKey(), album);
                                } else {
                                    ownImages.save(album.getKey(), album);
                                }
                            }
                            deferred.resolve();
                        } else {
                            deferred.reject();
                        }

                    });
                    return deferred.promise;
                },
            };
        }
})();

(function () {
    'use strict';

    angular
        .module('ringid.common.emotion_factory', [])
        .factory('EmotionFactory', ['$$connector', 'settings', 'OPERATION_TYPES', function ($$connector, settings, OPERATION_TYPES) {
            var emotions = {}, OTYPES = OPERATION_TYPES.SYSTEM,count=0,SCOPES={};

            function createEmotion(ob) {
                return {
                    id: ob.id,
                    title: ob.nm,
                    nm: ob.nm,
                    url: settings.emotionServer + ob.url,
                    cat: ob.cat
                };
            }

            function process(message) {
                var i;
                if (message.sucs && message.mdLst.length) {
                    for (i = 0; i < message.mdLst.length; i++) {
                        emotions[message.mdLst[i].id] = createEmotion(message.mdLst[i]);
                        count++;
                    }
                }

                safeDigest();
                
            }

            var subKey = $$connector.subscribe(process, {
                action: OTYPES.FETCH_EMOTION_LIST
            });

            function getEmotions() {
                var arr = [];
                for(var key in emotions){
                    if(emotions.hasOwnProperty(key)){
                        arr.push(emotions[key]);
                    }
                }
                return arr;
            }
            function safeDigest(){
                var digestScope;
                for(var key in SCOPES){
                    digestScope = SCOPES[key];
                    if(digestScope && digestScope.$id && !digestScope.$$destroyed){
                        digestScope.setEmotion.call(digestScope,getEmotions());
                    }
                }
                
            }
            function init() {
                if (!count) {
                    $$connector.send({
                        actn: OTYPES.FETCH_EMOTION_LIST
                    }, OTYPES.REQUEST_TYPE.REQUEST);
                }else{
                    safeDigest();
                }

            }

           // init();
            return {
                init: init,
                getEmotions: getEmotions,
                getLength: function () {
                    return count;
                },
                getEmotion: function (ob, createIfNotExist) {
                    var id = angular.isObject(ob) ? ob.id : ob;
                    if (!createIfNotExist)return emotions[id] || false;
                    if (!!emotions[id])return emotions[id];
                    if (angular.isObject(ob))return createEmotion(ob);
                    return false;
                },
                setScopeForDigest : function(scope){
                    SCOPES[scope.$id] = scope;
                },
                removeScope : function(scope){
                    if(SCOPES[scope.$id]){
                        SCOPES[scope.$id] = null;
                    }
                }
            }
        }])


})();

/*
 * Ipvision
 */


(function(){
    "use strict";
    angular
        .module('ringid.common.invite_factory',[
            'ringid.config',
            'ringid.common.stacked_map',
            'ringid.common.user_factory',
            'ringid.utils',
            'ringid.connector'
        ])
        .factory('InviteFactory', InviteFactory);

    InviteFactory.$inject = ['$timeout', '$$connector', 'OPERATION_TYPES', 'userFactory', 'Storage', 'friendsFactory', '$$stackedMap', '$$q', 'Auth', '$rootScope'];
    function InviteFactory($timeout, $$connector, OPERATION_TYPES, userFactory, Storage, friendsFactory, $$stackedMap, $q, Auth, $rootScope) {
        var _utIds = [], //Storage.getData('suggestionUtIds') || [],
            OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS,
            REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE,
            REQPRF = OPERATION_TYPES.SYSTEM.PROFILE,
            user;

        var Factory = {
            state : {
                isRequestsLoading: false
            },
            suggestionFriends: $$stackedMap.createNew(),
            getSuggestionContactsDetails: getSuggestionContactsDetails,
            removeSuggestion: removeSuggestion,
            getMutualFriend : getMutualFriend,
            allSuggestionFriends: $$stackedMap.createNew(),
            noOfSuggestions: function() {
                return Factory.suggestionFriends.length();
            }
            //getAllsuggestionContactDetails:getAllsuggestionContactDetails
        };

        function _processResponse (json) {
            switch(json.actn) {
                case OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW:
                    if(json.sucs===true){
                        for(var i=0; i<json.contactIds.length;i++){
                            _utIds.push(json.contactIds[i])
                        }
                        //Storage.setData('suggestionUtIds', _utIds);
                        getSuggestionContactsDetails();
                    }
                    break;
                case OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS:
                    if(json.sucs===true){
                        Factory.state.isRequestsLoading = true;
                        for(var i=0; i<json.contactList.length; i++){
                            if(json.contactList[i].frnS === undefined){
                                user = userFactory.create(json.contactList[i]);
                                Factory.suggestionFriends.save(user.getUtId(), user);
                                _utIds.splice( _utIds.indexOf(json.contactList[i].utId), 1);
                            }
                        }
                    }else{
                        RingLogger.information("form rgInviteResponse",RingLogger.tags.DIGEST);
                        Factory.state.isRequestsLoading = false;
                    }
                    Factory.state.isRequestsLoading = false;
                  //  $timeout(function() {

                   // });

                    break;
            }
        }

        $$connector.subscribe(_processResponse, {action: [
                OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW,
                OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS
            ]
        });

        function _getSuggestionUtids() {
            //_utIds = [];
            return $$connector.send({
                actn: OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW
            }, REQTYPE.REQUEST);
        }


        function getSuggestionContactsDetails (count){//user details
            count = count || 10;
            //RingLogger.print(Factory.state.isRequestsLoading, RingLogger.tags.INVITE);
            if(!Factory.state.isRequestsLoading){
               // $timeout(function() {
                     RingLogger.information("form rgInvite",RingLogger.tags.DIGEST);
                    Factory.state.isRequestsLoading = true;
               // });

                setTimeout(function() {
                    RingLogger.information("form rgInvite3",RingLogger.tags.DIGEST);
                    Factory.state.isRequestsLoading = false;
                }, 3000);

                var payload = {
                    actn: OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS,
                    idList: _utIds.slice(0, count)
                };

                RingLogger.print(payload, RingLogger.tags.DEFAULT, RingLogger.tags.INVITE);

                return $$connector.send(payload, REQTYPE.REQUEST);
            }


        }

        //function getAllsuggestionContactDetails() {
        //    var suggUtIds = Storage.getData('suggestionUtIds');
        //    RingLogger.print(suggUtIds, RingLogger.tags.INVITE);
        //}
        function getMutualFriend(user) {
            var params = {
                actn: REQPRF.FETCH_FRIEND_MUTUAL_FRIEND_LIST,
                uId: user.getUId()
            };
            return $$connector.pull(params, REQTYPE.REQUEST);
        }

        function removeSuggestion(utid,action){
            var defer = $q.defer();
            var payload = {
                actn:33,
                utId:utid
            };

            RingLogger.print(payload, RingLogger.tags.INVITE);

            $$connector.request(payload, REQTYPE.REQUEST).then(function(json){
                RingLogger.print(json, RingLogger.tags.INVITE);
                RingLogger.print('REMOVE SUGGESTION DATA', RingLogger.tags.INVITE);
                RingLogger.print(json.utId, RingLogger.tags.INVITE);
                if(json.sucs===true){
                    //Factory.suggestionFriends.remove(json.utId);
                    if(action !=='remove'){
                        RingLogger.print('not remove', RingLogger.tags.INVITE);
                        friendsFactory.addToUtIdList('outgoingUtIds', json.utId);
                    }
                    if(Factory.suggestionFriends.length() < 5){
                        getSuggestionContactsDetails();
                    }
                    defer.resolve(json);
                }

            }, function(errData) {
                defer.reject(errData);
            });
            return defer.promise;
        }


        if (Auth.isLoggedIn()) {
            setTimeout(function() {
                // business logic
                //var timelimit = new Date().getTime() - 4*3600;
                //if(_utIds.length > 0 || Storage.getData('suggestionUt') < timelimit) {
                // call for utid
                _getSuggestionUtids();
                //} else {
                //    // call for detail
                //    getSuggestionContactsDetails(20);
                //}
            }, 5000);
        } else {
            $rootScope.$on(SystemEvents.AUTH.LOGIN, function() {
                setTimeout(function() {
                    // business logic
                    //var timelimit = new Date().getTime() - 4*3600;
                    //if(_utIds.length > 0 || Storage.getData('suggestionUt') < timelimit) {
                        // call for utid
                        _getSuggestionUtids();
                    //} else {
                    //    // call for detail
                    //    getSuggestionContactsDetails(20);
                    //}
                }, 5000);
            });
        }





        return Factory;

    }


})();

/*
* © Ipvision
*/

(function() {
    'use strict';
    angular
        .module('ringid.common.factories', [
            'ringid.common.global_events_factory',
            'ringid.common.storage_factory',
            'ringid.common.events_factory',
            'ringid.common.user_factory',
            'ringid.common.stacked_map',
		    'ringid.common.image_factory',
		    'ringid.common.imagemap_factory',
            'ringid.common.album_factory',
		    'ringid.common.comment_factory',
            'ringid.common.emotion_factory',
            'ringid.common.invite_factory'
        ]);
})();

/*!
 * AngularJS Round Progress Directive
 *
 * Copyright 2013 Stephane Begaudeau
 * Released under the MIT license
 */
"use strict";
angular.module('ringid.common.rground_progress_directive', [])
        .directive('rgRoundProgress', [function () {
                var compilationFunction = function (templateElement, templateAttributes, transclude) {
                    if (templateElement.length === 1) {
                        var node = templateElement[0];
                        var width;// = node.getAttribute('data-round-progress-width') || '400';
                        var height;// = node.getAttribute('data-round-progress-height') || '400';

                        var canvas = document.createElement('canvas');
//                        canvas.setAttribute('width', width);
//                        canvas.setAttribute('height', height);
//                        canvas.setAttribute('data-round-progress-model', node.getAttribute('data-round-progress-model'));

//                        node.parentNode.replaceChild(canvas, node);

                        var outerCircleWidth;// = node.getAttribute('data-round-progress-outer-circle-width') || '20';
                        var innerCircleWidth;// = node.getAttribute('data-round-progress-inner-circle-width') || '5';

                        var outerCircleBackgroundColor;// = node.getAttribute('data-round-progress-outer-circle-background-color') || '#505769';
                        var outerCircleForegroundColor;// = node.getAttribute('data-round-progress-outer-circle-foreground-color') || '#12eeb9';
                        var innerCircleColor;// = node.getAttribute('data-round-progress-inner-circle-color') || '#505769';
                        var labelColor;// = node.getAttribute('data-round-progress-label-color') || '#12eeb9';

                        var outerCircleRadius;// = node.getAttribute('data-round-progress-outer-circle-radius') || '100';
                        var innerCircleRadius;// = node.getAttribute('data-round-progress-inner-circle-radius') || '70';

                        var labelFont;// = node.getAttribute('data-round-progress-label-font') || '50pt Calibri';

                        return {
                            pre: function preLink(scope, instanceElement, instanceAttributes, controller) {
                                var scale = (window.outerWidth - 20) / 1920;
                                width = +(scope.roundProgressBarStyle.dataRoundProgressWidth || '200') * scale;
                                height = +(scope.roundProgressBarStyle.dataRoundProgressHeight || '200') * scale;

                                canvas.setAttribute('width', width);
                                canvas.setAttribute('height', height);
                                canvas.setAttribute('data-round-progress-model', node.getAttribute('data-round-progress-model'));

                                node.parentNode.replaceChild(canvas, node);


                                outerCircleWidth = +(scope.roundProgressBarStyle.dataRoundProgressOuterCircleWidth || '4') * scale;
                                innerCircleWidth = +(scope.roundProgressBarStyle.dataRoundProgressInnerCircleWidth || '8') * scale;


                                outerCircleRadius = +(scope.roundProgressBarStyle.dataRoundProgressOuterCircleRadius || '85') * scale;
                                innerCircleRadius = +(scope.roundProgressBarStyle.dataRoundProgressInnerCircleRadius || '85') * scale;

                                labelFont = (+(scope.roundProgressBarStyle.dataRoundProgressLabelFont || '24') * scale) + 'px Arial';



                                outerCircleBackgroundColor = scope.roundProgressBarStyle.dataRoundProgressOuterCircleBackgroundColor || '#505769';
                                outerCircleForegroundColor = scope.roundProgressBarStyle.dataRoundProgressOuterCircleForegroundColor || '#13A8E8';
                                innerCircleColor = scope.roundProgressBarStyle.dataRoundProgressInnerCircleColor || '#505769';
                                labelColor = scope.roundProgressBarStyle.dataRoundProgressLabelColor || '#fff';

                            },
                            post: function postLink(scope, instanceElement, instanceAttributes, controller) {

                                var expression = canvas.getAttribute('data-round-progress-model');

                                scope.$watch(expression, function (newValue, oldValue) {
                                    console.log(expression, newValue, oldValue);
                                    // Create the content of the canvas
                                    var ctx = canvas.getContext('2d');
                                    ctx.clearRect(0, 0, width, height);

                                    // The "background" circle
                                    var x = width / 2;
                                    var y = height / 2;
//                                    ctx.beginPath();
//                                    ctx.arc(x, y, parseInt(outerCircleRadius), 0, Math.PI * 2, false);
//                                    ctx.lineWidth = parseInt(outerCircleWidth);
//                                    ctx.strokeStyle = outerCircleBackgroundColor;
//                                    ctx.stroke();

                                    // The inner circle
                                    ctx.beginPath();
                                    ctx.arc(x, y, parseInt(innerCircleRadius), 0, Math.PI * 2, false);
                                    ctx.lineWidth = parseInt(innerCircleWidth);
//                                    ctx.shadowColor = innerCircleColor;
                                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                                    ctx.globalCompositeOperation = 'source-over';
                                    ctx.stroke();

                                    // The inner number
                                    ctx.font = labelFont;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillStyle = labelColor;
//                                    ctx.shadowColor = "black";
//                                    ctx.shadowOffsetY = 3;
//                                    ctx.shadowOffsetX = 3;
                                    ctx.fillText(newValue.label + '%', x, y);

                                    // The "foreground" circle
                                    var startAngle = -(Math.PI / 2);
                                    var endAngle = ((Math.PI * 2) * newValue.percentage) - (Math.PI / 2);
                                    var anticlockwise = false;
                                    ctx.beginPath();
                                    ctx.arc(x, y, parseInt(outerCircleRadius), startAngle, endAngle, anticlockwise);
                                    ctx.lineWidth = parseInt(outerCircleWidth);
                                    ctx.strokeStyle = outerCircleForegroundColor;
                                    ctx.stroke();
                                }, true);
                            }
                        };
                    }
                };

                var roundProgress = {
                    compile: compilationFunction,
                    replace: true
                };
                return roundProgress;
            }]);

/*
 * © Ipvision
 */

angular.module('ringid.common.rgfocus_directive', [])
.directive('rgFocus', ['$timeout',
    function ($timeout) {
        var checkDirectivePrerequisites = function (attrs) {
            if (!attrs.rgFocus && attrs.rgFocus != "") {
                throw "FocusOnCondition missing attribute to evaluate";
            }
        };

        return {
            restrict: "A",
            link: function (scope, element, attrs, ctrls) {
                checkDirectivePrerequisites(attrs);

                scope.$watch(attrs.rgFocus, function (currentValue, lastValue) {
                    if(currentValue == true) {
                        //$timeout(function () {
                            element[0].focus();
                        //});
                         RingLogger.print("current focus value"+currentValue,"rgFocus");
                    }
                });
            }
        };
    }
]);

(function () {
    'use strict';
    var ringUtilsModule;

    try {
        ringUtilsModule = angular.module('ringid.utils');
    } catch (e) {
        console.warn("Utils Module Not Found");
        return;
    }
    ringUtilsModule.directive('rgPageTitle', rgPageTitle );

    rgPageTitle.$inject = ['$rootScope', 'ChatFactory', 'utilsFactory', 'SystemEvents'];
    function rgPageTitle($rootScope, ChatFactory, utilsFactory, SystemEvents) {

        var blinkerInterval = 1000;
        var currentTitle = document.title;
        var timerRef;

        var getPageInActiveTitle = function(){
            var unreadMessageCount = ChatFactory.getUnreadMessageCount();
            if(unreadMessageCount > 0){
                return '('+ unreadMessageCount +') ' + currentTitle;
            }else{
                return currentTitle;
            }

        };

        var getPageActiveTitle = getPageInActiveTitle;

        return {
            link: function (scope, elem, attrs) {

                $rootScope.$on('ringActive', function () {
                   clearInterval(timerRef);
                   document.title = getPageActiveTitle();
                });
                
                $rootScope.$on('ringInactive', function () {
                   timerRef = setInterval(function(){
                       var inActivePageTitle = getPageInActiveTitle();
                       document.title = document.title === inActivePageTitle ? currentTitle : inActivePageTitle;
                   }, blinkerInterval);
                });

                utilsFactory.onCustomEvent(SystemEvents.CHAT.UNREAD_MESSAGE_INFO_UPDATED, function(){
                   document.title = getPageActiveTitle();
                });

            }
        };
    }

})();

(function () {
    'use strict';
    var ringUtilsModule;

    try {
        ringUtilsModule = angular.module('ringid.utils');
    } catch (e) {
        console.warn("Utils Module Not Found");
        return;
    }

    ringUtilsModule.directive('rgUrlOgPreview', rgUrlOgPreview );

    rgUrlOgPreview.$inject = [ '$ringhttp', '$templateCache', '$compile', 'utilsFactory' ];
    function rgUrlOgPreview($ringhttp, $templateCache, $compile, utilsFactory ){
        return {
            restrict : 'E',
            replace : true,
            scope : {
              onClick : '&',
              ogData : '=',
              showPreview : '=',
              loadingData: '=',
              filterOnProgress : '=',
              editMode : '@'
            },
            templateUrl: '',
            link : function(scope, element, attr){

                var templateUrl = "pages/partials/url-og-preview.html";

                if( !!attr.template) {
                    templateUrl = attr.template;
                }

                //$http.get(templateUrl, {cache: $templateCache}).success(function(tplContent){
                $ringhttp.get(templateUrl).success(function(tplContent){
                    element.append($compile(tplContent)(scope));
                    scope.$rgDigest();
                });


                //element.on('click', function(e){
                //    if(angular.isFunction(scope.onClick)){
                //        scope.onClick();
                //    }
                //});

            },
            controller : ['$scope' ,'$sce','settings', function($scope, $sce,settings){

                $scope.selectedOgImageIndex = 0;

                $scope.onClick = onClick;
                $scope.onImageCloseClick = onImageCloseClick;
                $scope.onDetailCloseClick = onDetailCloseClick;
                $scope.selectPreviousImage = selectPreviousImage;
                $scope.selectNextImage = selectNextImage;
                $scope.shouldShowNextButton = shouldShowNextButton;
                $scope.shouldShowPreviousButton = shouldShowPreviousButton;

                $scope.isYoutubeUrl = isYoutubeUrl;
                $scope.getYoutubeUrl = getYoutubeUrl;

                initUrlMetaData();
                processUrl($scope.ogData.url);



                /**
                 *
                 * while add ssl unblock this code
                 */
                if($scope.ogData.url){
                    if(!/^https?:\/\//.test($scope.ogData.url)){
                    $scope.ogData.url = "http://" + $scope.ogData.url;
                    }   
                }
                 if($scope.ogData.image){
                    if(!/^https?:\/\//.test($scope.ogData.image)){
                       $scope.ogData.image = "http://" + $scope.ogData.image;
                     }
                     if(settings.secure && /^http:/.test($scope.ogData.image)){
                        $scope.ogData.image = settings.httpsUrl + '/ImageProxy.png?url=' + $scope.ogData.image.replace(/http:\/\//,'');
                     }
                 }
                 

                


                // setTimeout(function(){
                //
                // }, 5000);

                /////////////////////////////

                function onClick(){
                    if(!!$scope.ogData && !$scope.ogData.images){
                        var url = $scope.ogData.url;
                        if(!!url){
                            window.open(url, '_blank');
                        }
                    }
                }

                function setImageInOgInfo(){
                    if( !!$scope.ogData.images){
                        $scope.ogData.image = $scope.ogData.images[$scope.selectedOgImageIndex];
                    }
                }
                function resetImageInOgInfo(){ $scope.ogData.image = ""; }
                function resetTitleInOgInfo(){ $scope.ogData.title = ""; }
                function resetDescriptionInOgInfo(){ $scope.ogData.description = ""; }
                function resetUrlInOgInfo(){ $scope.ogData.url = ""; }
                function resetLnkDmnInOgInfo(){ $scope.ogData.lnkDmn = ""; }

                function setUrlMetaData(key, value){
                     $scope.ogData.meta[key] = value;
                 }

                function initUrlMetaData(key, value){

                    $scope.ogData.meta = {
                        youtube : false,
                        youtube_id : ''
                    };
                }

                function selectNextImage(){
                    if( $scope.selectedOgImageIndex < $scope.ogData.images.length -1 ){
                        $scope.selectedOgImageIndex += 1;
                    }
                    setImageInOgInfo();

                    utilsFactory.safeDigest($scope);
                }
                function selectPreviousImage(){
                    if( $scope.selectedOgImageIndex > 0){
                        $scope.selectedOgImageIndex -= 1;
                    }
                    setImageInOgInfo();

                    utilsFactory.safeDigest($scope);
                }

                function onImageCloseClick($event){
                    $event.preventDefault();
                    $event.stopPropagation();
                    resetImageInOgInfo();

                    utilsFactory.safeDigest($scope);
                }

                function onDetailCloseClick($event){
                    $event.preventDefault();
                    $event.stopPropagation();
                    resetTitleInOgInfo();
                    resetDescriptionInOgInfo();
                    resetUrlInOgInfo();
                    resetLnkDmnInOgInfo();

                    utilsFactory.safeDigest($scope);
                }

                function shouldShowNextButton(){ return !!$scope.ogData.images && $scope.selectedOgImageIndex < $scope.ogData.images.length - 1 }
                function shouldShowPreviousButton(){ return $scope.selectedOgImageIndex > 0 }


                function isYoutubeUrl(){
                    if(!$scope.ogData.meta && $scope.ogData.url){
                        initUrlMetaData();
                        processUrl($scope.ogData.url);
                    }

                    return !!$scope.ogData.meta && $scope.ogData.meta.youtube
                }
                function getYoutubeId(){ return $scope.ogData.meta.youtube_id }

                function getYoutubeUrl(){
                    return $sce.trustAsResourceUrl("https://www.youtube.com/embed/" + getYoutubeId() + "?autoplay=0&autohide=1&border=0&wmode=opaque&enablejsapi=1");
                }

                function processUrl(url){
                    /*
                        Regx Explaination

                    var REGX_HTTP_HTTPS = "((http|https):\/{2})+";
                    var REGX_NAME_DOMAIN = "((www\.)?youtube.com)";
                    var REGX_PATH = "((\/([~0-9a-zA-Z\#\+\%@\.\/_-]+))?(?:\/|(?<=±@))(.*?=([^?=&]+)(=([^&]*))?(.*?))(?:±@|$|\/(?!.*±@))?)?";
                    var YOUTUBE_URL_REGX_STRING = REGX_HTTP_HTTPS + REGX_NAME_DOMAIN + REGX_PATH;
                    var YOUTUBE_URL_REGX = new RegExp(YOUTUBE_URL_REGX_STRING, "im");

                    */

                    var FULL_YOUTUBE_URL_REGX = /((http|https):\/{2})+((www\.)?youtube\.com)([?&]?([^=]+)=([^&]*))?/im;

                    if(url){
                        var matches = url.match(FULL_YOUTUBE_URL_REGX);
                        if( !!matches && !!matches[3] && !!matches[7] ){
                            setUrlMetaData('youtube', true);
                            setUrlMetaData('youtube_id', matches[7]);
                        }else{
                            setUrlMetaData('youtube', false);
                        }
                    }

                }

                // function getSelectedImage(){
                //     if(!ogData.image){
                //         if(!!$scope.ogData.images){
                //             ogData.image = $scope.ogData.images[$scope.selectedOgImageIndex];
                //         }
                //     }
                //
                // }



            }]
        }
    }

})();

(function () {
    'use strict';
    var ringUtilsModule;

    try {
        ringUtilsModule = angular.module('ringid.utils');
    } catch (e) {
        console.warn("Utils Module Not Found");
        return;
    }
    ringUtilsModule.directive('rgUrlOgFetcher', rgUrlOgFetcher );

    rgUrlOgFetcher.$inject = ['$compile'];
    function rgUrlOgFetcher($compile) {
        return {
            restrict : 'E',
            scope : {
                fetchedOgInfo : '=',
                editorContent : '=',
                showPreview : '=',
                filterOnProgress : '=',
                loadingData : '='
            },
            link : function(scope, element, attr){

                var previewDom;

                scope.fetchedOgInfo = scope.fetchedOgInfo || {};

                if(!!scope.filterOnProgress)
                    scope.filterOnProgress = false;

            },
            controller : ['$scope', '$rootScope', '$timeout', 'utilsFactory', function($scope, $rootScope, $timeout, utilsFactory){
                // var ORIG_URL_DETECTION_REGEX = /(((http|https):\/{2})+(([0-9a-z_-]+\.)+(aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mn|mn|mo|mp|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|nom|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ra|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw|arpa)(:[0-9]+)?((\/([~0-9a-zA-Z\#\+\%@\.\/_-]+))?(\?[0-9a-zA-Z\+\%@\/&\[\];=_-]+)?)?))\b/im;

                var REGX_TOP_LEVEL_DOMAINS = "(aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mn|mn|mo|mp|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|nom|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ra|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw|arpa)";
                var REGX_HTTP_HTTPS = "((http|https):\/{2})+";
                var REGX_NAME_DOMAIN = "([0-9a-z_-]+\.)+";
                var REGX_PORT = "(:[0-9]+)?";
                var REGX_PATH = "((\/([~0-9a-zA-Z\#\+\%@\.\/_-]+))?(\\?[0-9a-zA-Z\+\%@\/&\[\];=_-]+)?)?";

                var REGX_IP_ADDRESS = "0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])"

                var REGEX_URL_DETECTION_STRING = "(" +  REGX_HTTP_HTTPS +
                                                        "(" + "((" + REGX_NAME_DOMAIN + REGX_TOP_LEVEL_DOMAINS + ")"  + "|" + "(" + REGX_IP_ADDRESS + "))"
                                                        + REGX_PORT + REGX_PATH + ")" + ")\\b";


                var URL_DETECTION_REGEX = /(((http|https):\/{2})?((([0-9a-z_-]+\.)+(aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mn|mn|mo|mp|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|nom|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ra|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw|arpa)|(0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])))(:[0-9]+)?((\/([~0-9a-zA-Z\#\+\%@\.\/_-]+))?(\?[0-9a-zA-Z\+\%@\/&\[\];=_-]+)?(\?[\w|\W]+)?)?))\b/im;

                var previewDom = '';

                var urlCache = {};

                var debounceLimit = 4000;
                var lastProcessTime = 0;
                var lastSkipTime = 0;
                var lastDetectedUrl = "";
                var idleInterval = null;

                $scope.$watch('editorContent', utilsFactory.debounce(function(newValue, oldValue){

                    processModelUpdate(newValue, oldValue);

                    utilsFactory.safeDigest($scope);


                }, 500) );

                function processModelUpdate(newValue, oldValue){

                    if( !shouldProcessModelChange(newValue, oldValue)){
                        return;
                    }

                    if(!!newValue && URL_DETECTION_REGEX.test(newValue)) {
                        console.log('Updated Value ', newValue);
                        var matches = newValue.match(URL_DETECTION_REGEX);
                        var firstUrl = matches[1];
                        if (firstUrl) {
                            var firstUrlDomain = !matches[5] ? '' : matches[5];

                            if(!/^https?:\/\//.test(firstUrl)){
                                firstUrl = 'http://' + firstUrl;
                            }

                                console.log('Detected Url', firstUrl);
                            if( !shouldProcessChange(firstUrl) ) return;

                            console.log('Starting to Fetch Url', firstUrl);
                            // firstUrl = firstUrl.replace('/https/g', function(){ return ''});
                            // console.log(firstUrl);

                            var cachedValue = getFromUrlCache(firstUrl);
                            if(!!cachedValue){

                                setFetchedOgInfo( cachedValue );
                                showUrlOgInfoPreview();
                                emitFeedBoxHeightChange();

                            }else{

                                showLoading();
                                emitFeedBoxHeightChange();

                                utilsFactory.getOGDetails(firstUrl).success(function (data) {
                                    hideLoading();
                                    console.log('Server Response :', data);
                                    if (!!data && !!data.sucs) {
                                        setToUrlCache(firstUrl, data);
                                        data['lnkDmn'] = firstUrlDomain;
                                        data['url'] = firstUrl;

                                        data = fixFetchedOgInfo(data, firstUrl);

                                        setFetchedOgInfo(data);
                                        filterImages();
                                        showUrlOgInfoPreview();

                                    }else{
                                        resetFetchedOgInfo();
                                        resetFilterOnProgress();
                                        hideUrlOgInfoPreview();
                                    }


                                    emitFeedBoxHeightChange();
                                    $scope.$parent.$rgDigest();
                                }).error(function (data) {
                                    resetFetchedOgInfo();
                                    resetFilterOnProgress();
                                    resetLastDetectedUrl();
                                    hideUrlOgInfoPreview();
                                    hideLoading();
                                    emitFeedBoxHeightChange();

                                    $scope.$parent.$rgDigest();
                                });
                            }

                        }



                    }else{
                        resetFetchedOgInfo();
                        hideUrlOgInfoPreview();

                    }
                    $scope.$parent.$rgDigest();
                }

                function fixUrl(url){
                    if(!url) return '';

                    if( url[url.length -1] != '/')
                        return url + '/';
                    return url;
                }
                function shouldProcessChange(url){

                    if(!$scope.fetchedOgInfo || lastDetectedUrl != url){
                        lastDetectedUrl = url;
                        return true;
                    }
                    console.log('Same Url Will Not Fetch');
                    return false;
                }

                function setToUrlCache(url, data){ urlCache[url] = data; }
                function getFromUrlCache(url){ urlCache[url]; }

                function setFetchedOgInfo(fetchedOgInfo) { $scope.fetchedOgInfo = fetchedOgInfo;  }
                function resetFetchedOgInfo() { $scope.fetchedOgInfo = {};  }

                function showLoading(){ $scope.loadingData = true; }
                function hideLoading(){ $scope.loadingData = false; }
                function isLoading(){ return $scope.loadingData; }

                function showUrlOgInfoPreview(){ $scope.showPreview = true; }
                function hideUrlOgInfoPreview(){ $scope.showPreview = false; }

                function setFilterOnProgress(){ $scope.filterOnProgress = true; }
                function resetFilterOnProgress(){ $scope.filterOnProgress = false; }

                function resetLastDetectedUrl(){ lastDetectedUrl = '' }

                function startIdleDetectInterval(){
                    if(!idleInterval){
                        idleInterval = setInterval(function(){
                            if(detectIdleState()){
                                processModelUpdate($scope.editorContent);
                                clearIdleIteterval();
                            }
                        }, 2 * debounceLimit);
                    }

                }

                function clearIdleIteterval(){
                    clearInterval(idleInterval);
                }

                function fixFetchedOgInfo(fetchedOgInfo, requestedUrl) {
                    var fixedOgInfo = angular.extend({}, fetchedOgInfo);
                    if(!fixedOgInfo.url){
                        fixedOgInfo.url = requestedUrl;
                    }
                    if(!fixedOgInfo.title){
                        fixedOgInfo.title = fixedOgInfo.lnkDmn;
                    }

                    return fixedOgInfo;
                }

                function emitFeedBoxHeightChange(){
                    $timeout(function(){
                        $rootScope.$broadcast('statusHeightChange');
                    });
                }

                function setActiveImageInOgInfo(images){
                    if(images.length > 0){
                        $scope.fetchedOgInfo.image = images[0];
                    }
                }

                function setImagesInOgInfo(images){
                    $scope.fetchedOgInfo.images = images;
                }

                function filterImages(){
                    var imageUrls = $scope.fetchedOgInfo.images;

                    setFilterOnProgress();
                    utilsFactory.filterImagesByDimentions(imageUrls, {width: 200}).then(function(filteredImages ){
                        console.log(filteredImages);
                        console.log(imageUrls);

                        if(!!$scope.filterOnProgress){

                            setImagesInOgInfo(filteredImages);
                            setActiveImageInOgInfo(filteredImages);
                            resetFilterOnProgress();
                        }
                        $scope.$parent.$rgDigest();

                    });
                }

                function shouldProcessModelChange(newValue, oldValue){
                    // console.log($scope.fetchedOgInfo);

                    if( isLoading() ) return false;

                    if( !$scope.fetchedOgInfo ||
                        ( !$scope.fetchedOgInfo.image && !$scope.fetchedOgInfo.title && !$scope.fetchedOgInfo.description ) ){
                            resetLastDetectedUrl();
                            return true;
                    }

                    return false;

                }

                function detectIdleState(){
                    if( (Date.now() - lastSkipTime) > 1.5 * debounceLimit ){
                        return true;
                    }
                    return false;
                }


            }]
        };
    }

})();

(function () {
    'use strict';
    var ringUtilsModule;

    try {
        ringUtilsModule = angular.module('ringid.utils');
    } catch (e) {
        console.warn("Utils Module Not Found");
        return;
    }

    ringUtilsModule
        .directive('rgLoaderView', rgLoaderView);

    ringUtilsModule
        .directive('rgLoaderView1', rgLoaderView1);

    ringUtilsModule
        .directive('rgLoaderView2', rgLoaderView2);

    function rgLoaderView(){
        return {
            restrict: 'E',
            replace: true,
            scope : {
                isLoading : '='
            },
            templateUrl: 'pages/partials/loading_view.html'
        };
    }

    function rgLoaderView1(){
        return {
            restrict: 'E',
            replace: true,
            scope : {
                isLoading : '='
            },
            templateUrl: 'pages/partials/loading_view1.html'
        };
    }

    function rgLoaderView2(){
        return {
            restrict: 'E',
            replace: true,
            scope : {
                isLoading : '='
            },
            templateUrl: 'pages/partials/loading_view2.html'
        };
    }


})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
            .module('ringid.common.rgplayer_directive', [])
            .provider('$player', Player)
            .directive('rgPlayer', rgPlayer);

    function Player() {
        this.dicts = {
            'maximize': 'Back to normal view',
            'minimize': 'Go to small view',
            'fullScreen': 'Full Screen',
            'playlist': 'Playlist',
            'auto': 'Auto Play',
        };
        this.instances = [];
        this.template = '<div class="rg-player">'
                + '<div class="container">'
                + '<div class="play-info"></div>'
                + '<div class="play-error"></div>'
                + ' <div class="music-bars"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></div>'
                + '<div class="big-play"><span class="icon-player"></span></div>'
                + '<div class="loader">'
                + '<div class="circle1"></div>'
                + '<div class="circle2"></div>'
                + '<div class="circle3"></div>'
                + '</div>'
                + '<div class="player-poster">'
                + '<img class="poster" />'
                + '</div>'
                + '</div>'
                + '<div class="playlist-wrapper"></div>'
                + '<div class="media-control">'
                + '<div class="media-tip"></div>'
                + '<div class="media-control-bg"></div>'
                + '<div class="media-control-layer">'
                + '<div class="bar-panel">'
                + '<div class="bar-container">'
                + '<div class="bar-background">'
                + '<div class="bar-fill-1"></div>'
                + '<div class="bar-fill-2"></div>'
                + '<div class="bar-hover"></div>'
                + '</div>'
                + '<div class="bar-scrubber">'
                + '<div class="bar-scrubber-icon"></div>'
                + '</div>'
                + '<div class="seek-time">'
                + '<div class="timer"></div>'
                + '</div>'
                + '</div>'
                + '</div>'
                + '<div class="control-left">'
                + '<div class="play-btns">'
                + '<button class="icon-previous-p control-btn prev-btn"></button>'
                + '<button class="icon-play-p control-btn start-btn"></button>'
                + '<button class="icon-next-p control-btn next-btn"></button>'
                + '</div>'
                + '<div class="volume-bar">'
                + '<div class="icon-speaker-fill volume-icon unmute"></div>'
                + '<div class="volume-bar-container volume-bar-hide">'
                + '<div class="bar fill"></div>'
                + '<div class="bar fill"></div>'
                + '<div class="bar fill"></div>'
                + '<div class="bar fill"></div>'
                + '<div class="bar"></div>'
                + '<div class="bar"></div>'
                + '<div class="bar"></div>'
                + '<div class="bar"></div>'
                + '<div class="bar"></div>'
                + '<div class="bar"></div>'
                + '</div>'
                + '</div>'
                + '<div class="time-indicator time-running"></div>'
                + '<div class="time-indicator time-total"></div>'
                + '</div>'
                + '<div class="control-right">'
                + '<button class="control-btn hd">HD</button>'
                + '<button class="icon-minimize control-btn minimize" tooltip="' + this.dicts['minimize'] + '"></button>'
                + '<button class="icon-screen-f control-btn full-screen" tooltip="' + this.dicts['fullScreen'] + '"></button>'
                + '<button class="icon-play-list control-btn playlist-btn" tooltip="' + this.dicts['playlist'] + '"></button>'
                + '<button class="control-btn auto" tooltip="' + this.dicts['auto'] + '">AUTO</button>'
                + '</div>'
                + '</div>'
                + '</div>'
                + '</div>';

        this.trackTemplate = '<a rel="data-rel" href="#">'
                + '<span class="list-thumb"><img src="data-thumb" /></span>'
                + '<span class="list-title">data-caption<b>data-duration</b></span>'
                + '</a>';

        this.secToTime = function (seconds) {
            seconds = Math.floor(seconds);
            var hours = parseInt(seconds / 3600) % 24;
            var minutes = parseInt(seconds / 60) % 60;
            var seconds = (seconds < 0) ? 0 : seconds % 60;
            var result = '';
            if (hours > 0)
                result += (hours < 10 ? "0" + hours : hours);
            result += (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
            return result;
        };

        this.findPos = function (el) {
            var x = 0, y = 0;
            if (el.offsetParent) {
                do {
                    x += el.offsetLeft;
                    y += el.offsetTop;
                } while (el = el.offsetParent);
            }
            return {x: x, y: y};
        };

        this.destroy = function (instance) {

            try {
                instance.removeEvent();
                instance.provider.pause();
                instance.provider.src = '';
                instance.dom = null;
                delete instance.provider;
                //delete instance;
            } catch (e) {
                RingLogger.print("rg-player " + e.message, "DEFAULT");
            }

        };

        this.addRemoveClass = function (el, add, remove) {
            var i;
            for (i = 0; i < remove.length; i++) {
                el.className = el.className.replace(remove[i], '').trim();
            }

            for (i = 0; i < add.length; i++) {
                el.className += ' ' + add[i];
            }
        };

        this.createMediaObject = function (type) {
            return  (type == 'audio') ? document.createElement('audio') : document.createElement('video');
        };

        this.getDefaultThumb = function(thumb) {
            
            if (!thumb || thumb == 'images/audio-preview.jpg') {
              thumb = 'images/player-audio.png';  
            }

            return thumb;
        }

        this.$get = ['$compile', '$document',
            function ($compile, $document) {

                var $this = this, $playerProvider = {};

                $playerProvider.escapeKey = false;
                $playerProvider.miniPlayer = {dom: null, parent: null, player: null};
                $playerProvider.wh = window.innerHeight;

                $playerProvider.destroy = function () {
                    if ($this.instances.length > 0)
                    {
                        $this.destroy($this.instances.pop());
                    }
                };

                $playerProvider.destroyAll = function () {
                    for (var i = $this.instances.length - 1; i >= 0; i--) {
                        $this.destroy($this.instances.pop());
                    }
                };

                $playerProvider.showMiniPlayer = function () {
                    if ($playerProvider.miniPlayer.player) {
                        $playerProvider.miniPlayer.dom.appendChild($playerProvider.miniPlayer.player.parent)
                        $playerProvider.miniPlayer.dom.style.display = 'block';

                        if ($playerProvider.miniPlayer.player.playingState == 'PLAYING') {
                            $playerProvider.miniPlayer.player.provider.play();
                        }
                    }
                }

                $playerProvider.closeMiniPlayer = function () {
                    if ($playerProvider.miniPlayer.player) {
                        $playerProvider.ringboxRemove();
                        $playerProvider.destroy();
                        $playerProvider.miniPlayer.dom.parentNode.removeChild($playerProvider.miniPlayer.dom);
                        $playerProvider.miniPlayer.dom = null;
                        $playerProvider.miniPlayer.player = null;
                    }
                }


                $playerProvider.addToPlaylist = function (playlist) {

                    for (var i = $this.instances.length - 1; i >= 0; i--) {
                        if (!!$this.instances[i].chat) {
                            $this.instances[i].AddToPlaylist(playlist);
                            break;
                        }
                    }
                }

                $playerProvider.player = function (option) {


                    $playerProvider.ringboxRemove = (option.ringboxRemove) ? option.ringboxRemove : function () {
                    };

                    if (!option.chatVersion) {
                        $playerProvider.closeMiniPlayer();
                    }

                    var $player = {};
                    $player.source = option.source || '';
                    $player.autoPlay = option.autoPlay || false;
                    $player.auto = option.auto || false;
                    $player.parent = document.getElementById(option.parentId);
                    $player.poster = option.poster || '';
                    $player.mediaType = option.type || 'video';
                    $player.dom = {};
                    $player.playingState = (this.autoPlay) ? 'INIT' : 'STOPPED';
                    $player.screenState = 'NORMAL';
                    $player.volumeState = 'UNMUTE';
                    $player.volume = 5;
                    $player.duration = 0;
                    $player.currentTrack = 0;
                    $player.playlist = option.playlist || [];
                    $player.title = option.title || '';
                    $player.playlistState = false;
                    $player.hd = false;
                    $player.isMouseDown = false;
                    $player.isLoading = $player.autoPlay;
                    $player.isFirefox = !!(navigator.userAgent.match(/firefox/i));
                    $player.canPlay = true;
                    $player.chat = !!option.chatVersion;

                    $player.provider = $this.createMediaObject($player.mediaType);

                    $player.parent.innerHTML = $this.template;

                    $player.dom.player = $player.parent.querySelector('.rg-player');
                    $player.dom.container = $player.parent.querySelector('.container');
                    $player.dom.playlistWrap = $player.parent.querySelector('.playlist-wrapper');
                    $player.dom.control = $player.parent.querySelector('.media-control');
                    $player.dom.bigBlay = $player.dom.container.querySelector('.big-play');
                    $player.dom.bigBlayIcon = $player.dom.bigBlay.querySelector('span');
                    $player.dom.playError = $player.dom.container.querySelector('.play-error');
                    $player.dom.playInfo = $player.dom.container.querySelector('.play-info');
                    $player.dom.musicBar = $player.dom.container.querySelector('.music-bars');
                    $player.dom.loader = $player.dom.container.querySelector('.loader');
                    $player.dom.poster = $player.dom.container.querySelector('.player-poster');
                    $player.dom.posterImg = $player.dom.poster.querySelector('.poster');
                    $player.dom.barContainer = $player.dom.control.querySelector('.bar-container');
                    $player.dom.barScrubber = $player.dom.control.querySelector('.bar-scrubber');
                    $player.dom.barLoaded = $player.dom.control.querySelector('.bar-fill-1');
                    $player.dom.barPosition = $player.dom.control.querySelector('.bar-fill-2');
                    $player.dom.barHover = $player.dom.control.querySelector('.bar-hover');
                    $player.dom.controlLayer = $player.dom.control.querySelector('.media-control-layer');
                    $player.dom.controlBG = $player.dom.control.querySelector('.media-control-bg');
                    $player.dom.controlTip = $player.dom.control.querySelector('.media-tip');
                    $player.dom.playBtn = $player.dom.control.querySelector('.start-btn');
                    $player.dom.nextBtn = $player.dom.control.querySelector('.next-btn');
                    $player.dom.prevBtn = $player.dom.control.querySelector('.prev-btn');
                    $player.dom.timeRunning = $player.dom.control.querySelector('.time-running');
                    $player.dom.timeTotal = $player.dom.control.querySelector('.time-total');
                    $player.dom.hd = $player.dom.control.querySelector('.hd');
                    $player.dom.playlistBtn = $player.dom.control.querySelector('.playlist-btn');
                    $player.dom.minimize = $player.dom.control.querySelector('.minimize');
                    $player.dom.auto = $player.dom.control.querySelector('.auto');
                    $player.dom.volumeIcon = $player.dom.control.querySelector('.volume-icon');
                    $player.dom.volumeBarContainer = $player.dom.control.querySelector('.volume-bar-container');
                    $player.dom.volumeBars = $player.dom.volumeBarContainer.querySelectorAll('.bar');
                    $player.dom.fullScreenBtn = $player.dom.control.querySelector('.full-screen');
                    $player.dom.seekTimer = $player.dom.control.querySelector('.seek-time');
                    $player.dom.timer = $player.dom.control.querySelector('.timer');
                    $player.dom.playlist = null;


                    $player.dom.player.style.width = (option.width) ? option.width + 'px' : '100%';
                    $player.dom.player.style.height = (option.height) ? option.height + 'px' : '100%';
                    $player.dom.timeRunning.innerHTML = '00:00';
                    $player.dom.timeTotal.innerHTML = '00:00';

                    if (option.chatVersion)
                        $player.dom.minimize.style.display = 'none';

                    $player.dom.poster.appendChild($player.provider);

                    $playerProvider.miniPlayer.parent = $player.parent.parentNode;


                    var playerFullScreen = function () {
                        var isFullScreen = document.mozFullScreen || document.webkitIsFullScreen;
                        if (!isFullScreen && $player.screenState == 'FULL') {
                            $player.fullScreen();
                        }
                    };
                    var playerKeyEvt = function (evt) {
                        var keyCode = evt.which || evt.keyCode || evt.key;
                        if (keyCode === 32) {
                            $player.playPause();
                        }
                    };

                    $player.initEvent = function () {

                        $player.dom.playBtn.addEventListener('click', function (e) {
                            e.stopPropagation();
                            $player.playPause();
                        }, false);

                        $player.dom.nextBtn.addEventListener('click', function (e) {
                            e.stopPropagation();
                            $player.playNext();
                        }, false);

                        $player.dom.prevBtn.addEventListener('click', function (e) {
                            e.stopPropagation();
                            $player.playPrev();
                        }, false);

                        $player.dom.volumeIcon.addEventListener('click', function (e) {
                            e.stopPropagation();
                            $player.muteUnmute();
                        }, false);

                        $player.dom.fullScreenBtn.addEventListener('click', function (e) {
                            e.stopPropagation();
                            $player.fullScreen();
                        }, false);

                        $player.dom.minimize.addEventListener('click', function (e) {
                            e.stopPropagation();
                            $player.minimize();
                        }, false);

                        $player.dom.barContainer.addEventListener('mousemove', function (e) {
                            $player.timeInfo(e);
                            if ($player.isMouseDown)
                                $player.setPosition(e, false);
                        }, false);

                        $player.dom.barContainer.addEventListener('mousedown', function (e) {
                            $player.isMouseDown = true;
                            $this.addRemoveClass($player.dom.barContainer, ['down'], []);
                        }, false);

                        $player.dom.barContainer.addEventListener('mouseup', function (e) {
                            $player.isMouseDown = false;
                            $player.setPosition(e, true);
                            $this.addRemoveClass($player.dom.barContainer, [], ['down']);
                        }, false);

                        $player.dom.barContainer.addEventListener('mouseleave', function (e) {
                            $player.isMouseDown = false;
                            $this.addRemoveClass($player.dom.barContainer, [], ['down']);
                        }, false);

                        $player.dom.container.addEventListener('click', function (e) {
                            e.stopPropagation();
                            if ($player.playlistState) {
                                $player.showPlaylist(false);
                                return;
                            }
                            $player.playPause();
                        }, false);

                        $player.dom.player.addEventListener('mouseover', function (e) {
                            e.stopPropagation();
                            $player.showControl(true);
                        }, false);

                        $player.dom.player.addEventListener('mouseleave', function (e) {
                            e.stopPropagation();
                            $player.showControl(false);
                        }, false);

                        $player.dom.playlistBtn.addEventListener('click', function (e) {
                            e.stopPropagation();

                            if ($playerProvider.miniPlayer.player) {
                                $player.maximize();
                            }

                            $player.showPlaylist();
                        }, false);

                        $player.dom.auto.addEventListener('click', function (e) {
                            e.stopPropagation();
                            $player.setAuto();
                        }, false);

                        for (var i = 0; i < $player.dom.volumeBars.length; i++) {
                            (function (i) {
                                $player.dom.volumeBars[i].addEventListener('click', function (e) {
                                    e.stopPropagation();
                                    $player.changeVolume(i);
                                });
                            })(i);
                        }

                        /* tooptip event */
                        $player.dom.auto.addEventListener('mouseover', function (e) {
                            e.stopPropagation();
                            $player.showTootip(e,this.getAttribute('tooltip'));
                        }, false);

                        $player.dom.auto.addEventListener('mouseleave', function (e) {
                            e.stopPropagation();
                            $player.dom.controlTip.style.display = 'none';
                        }, false);

                        /* tooptip event */
                        $player.dom.minimize.addEventListener('mouseover', function (e) {
                            e.stopPropagation();
                            $player.showTootip(e,this.getAttribute('tooltip'));
                        }, false);

                        $player.dom.minimize.addEventListener('mouseleave', function (e) {
                            e.stopPropagation();
                            $player.dom.controlTip.style.display = 'none';
                        }, false);

                        /* tooptip event */
                        $player.dom.fullScreenBtn.addEventListener('mouseover', function (e) {
                            e.stopPropagation();
                            $player.showTootip(e,this.getAttribute('tooltip'));
                        }, false);

                        $player.dom.fullScreenBtn.addEventListener('mouseleave', function (e) {
                            e.stopPropagation();
                            $player.dom.controlTip.style.display = 'none';
                        }, false);

                        /* tooptip event */
                        $player.dom.playlistBtn.addEventListener('mouseover', function (e) {
                            e.stopPropagation();
                            $player.showTootip(e,this.getAttribute('tooltip'));
                        }, false);

                        $player.dom.playlistBtn.addEventListener('mouseleave', function (e) {
                            e.stopPropagation();
                            $player.dom.controlTip.style.display = 'none';
                        }, false);

                        

                        // document events
                        document.addEventListener("mozfullscreenchange", playerFullScreen, false);
                        document.addEventListener("webkitfullscreenchange", playerFullScreen, false);
                        document.addEventListener("fullscreenchange", playerFullScreen, false);
                        document.addEventListener("keyup", playerKeyEvt, false);

                        $player.setMediaEvent();
                        $player.createPlaylist();
                        $player.showPoster(true);

                        if ($player.auto) {
                            $player.setAuto(true);
                        }

                    };


                    $player.setMediaEvent = function () {

                        $player.provider.addEventListener('loadedmetadata', function (event, data) {
                            $player.initTime($player.provider.duration);

                            if ($player.autoPlay)
                                $player.play();
                        });

                        $player.provider.addEventListener('progress', function () {

                            var buffered = $player.provider.buffered.length > 0 ? $player.provider.buffered.end($player.provider.buffered.length - 1) : 0;
                            var bufferState = ($player.provider.currentTime + 0.05) >= buffered ? 'BUFFERING' : 'PLAYING_BUFFERING';

                            $player.showBuffered(buffered, $player.provider.duration);
                            $player.stateChanged(bufferState);

                        });

                        $player.provider.addEventListener('timeupdate', function () {
                            if (!$player.provider || $player.isMouseDown)
                                return;
                            $player.showPosition($player.provider.currentTime, $player.provider.duration);
                        });

                        $player.provider.addEventListener('play', function () {
                            $player.stateChanged('PLAYING');

                            if ($player.mediaType == 'video') {
                                $player.showPoster(false);
                            }

                            if (angular.isFunction(option.scope.onStart())) {
                                option.scope.onStart()();
                            }
                        });

                        $player.provider.addEventListener('pause', function () {
                            $player.stateChanged('PAUSED');

                            if ($player.mediaType == 'video') {
                                $player.showPoster(false);
                            }
                        });

                        $player.provider.addEventListener('ended', function () {
                            $player.stateChanged('ENDED');

                            if ($player.mediaType == 'video') {
                                $player.showPoster(false);
                            }

                            if (angular.isFunction(option.scope.onEnded())) {
                                option.scope.onEnded()();
                            }
                        });

                        $player.provider.addEventListener('stalled', function () {
                            if (!$player.provider)
                                return;
                            // $player.error = 'Media not availble';
                            //$player.canPlay = false;
                            // $player.showError();
                        });

                        $player.provider.addEventListener('error', function () {
                            if (!$player.provider)
                                return;
                            $player.error = $player.provider.error.code;
                            $player.canPlay = false;
                            $player.showError();
                        });

                    };

                    $player.removeEvent = function () {
                        document.removeEventListener("mozfullscreenchange", playerFullScreen);
                        document.removeEventListener("webkitfullscreenchange", playerFullScreen);
                        document.removeEventListener("fullscreenchange", playerFullScreen);
                        document.removeEventListener("keyup", playerKeyEvt);
                    };

                    $player.maximize = function () {

                        if ($playerProvider.miniPlayer.player) {
                            option.ringboxMaximize($playerProvider.miniPlayer.parent, $player.parent);

                            if ($player.playingState == 'PLAYING') {
                                $player.provider.play();
                            }
                            $playerProvider.miniPlayer.dom.parentNode.removeChild($playerProvider.miniPlayer.dom);
                            $playerProvider.miniPlayer.dom = null;
                            $playerProvider.miniPlayer.player = null;
                            $this.addRemoveClass($player.dom.minimize, ['icon-minimize'], ['icon-maximize']);
                            $player.dom.fullScreenBtn.style.display = 'block';
                            $player.dom.minimize.setAttribute('tooltip', $this.dicts['minimize']);
                            return;
                        }
                    };


                    $player.minimize = function () {


                        if ($playerProvider.miniPlayer.player) {
                            $player.maximize();
                            return;
                        }

                        var mouseMove = false, fromMouseMove=false, mouseResize = false, doc,
                                mini = document.createElement('div'),
                                mini_move = document.createElement('div'),
                                mini_resize = document.createElement('div'),
                                mini_close = document.createElement('a'),
                                pw = 350, // player width (predefined for perf)
                                ph = 120, // player height (predefined for perf)
                                wh;

                        mini_close.setAttribute('class', 'mini-close');
                        mini_close.innerHTML = '<div class="icon-close pop-close"></div>';

                        mini_move.setAttribute('class', 'move-player');
                        mini_move.appendChild(mini_close);

                        mini.setAttribute('id', 'mini-player');
                        mini.setAttribute('class', 'mini-player');

                        mini_resize.setAttribute('class', 'resize-player');

                        mini.style.display = 'none';
                        mini.appendChild(mini_move);
                        mini.appendChild(mini_resize);
                        document.body.appendChild(mini);

                        $player.showPlaylist(true);

                        $playerProvider.miniPlayer.dom = mini;
                        $playerProvider.miniPlayer.player = $player;
                        $player.dom.minimize.setAttribute('tooltip', $this.dicts['maximize']);

                        option.ringboxMinimize();

                        doc = angular.element(document);
                        wh = ($player.screenState == 'FULL') ? $playerProvider.wh : window.innerHeight;

                        mini.style.top = (wh - ph) + 'px';
                        $this.addRemoveClass($player.dom.minimize, ['icon-maximize'], ['icon-minimize']);
                        $player.dom.fullScreenBtn.style.display = 'none';

                        mini_close.addEventListener('click', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            $playerProvider.closeMiniPlayer();
                        });


                        /*Move player*/
                        mini_move.addEventListener('mousedown', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            mouseMove = true;
                            var ww = window.innerWidth,
                                    wh = window.innerHeight,
                                    ol = mini.offsetLeft - e.clientX,
                                    ot = mini.offsetTop - e.clientY;

                            doc.on('mousemove', function (event) {
                                fromMouseMove = true;
                                if (mouseMove) {

                                    fastdom.read(function () {
                                        if(!mini_resize) return;
                                        document.body.style.cursor = 'move';
                                        mini_resize.style.cursor = 'move';
                                        $player.dom.container.style.cursor = 'move';
                                        fastdom.write(function () {
                                            if ((event.clientX + ol) >= 200 && (event.clientX + ol) <= (ww - pw - 210)) {
                                                mini.style.left = (event.clientX + ol) + 'px';
                                            }

                                            if ((event.clientY + ot) >= 50 && (event.clientY + ot) <= (wh - ph)) {
                                                mini.style.top = (event.clientY + ot) + 'px';
                                            }
                                        });
                                    });
                                }
                            });

                            doc.on('mouseup', function (event) {
                                event.stopPropagation();
                                mouseMove = false;
                                document.body.style.cursor = 'default';
                                mini_resize.style.cursor = 'ns-resize';
                                $player.dom.container.style.cursor = 'pointer';
                                doc.off('mousemove');
                                doc.off('mouseup');

                            });

                        });

                        mini_move.addEventListener('click', function (e) {
                            
                            if(fromMouseMove) {
                               fromMouseMove = false;
                               return; 
                            } 

                            $player.playPause();

                        }, false);

                        /*resize player*/
                        mini_resize.addEventListener('mousedown', function (e) {
                            e.preventDefault();
                            e.stopPropagation();
                            mouseResize = true;
                            var ww = window.innerWidth,
                                    wh = window.innerHeight,
                                    y = e.clientY;

                            doc.on('mousemove', function (event) {
                                if (mouseResize) {

                                    fastdom.read(function () {

                                        if(!mini) return;
                                        
                                        var height = mini.offsetHeight;
                                        var top = parseInt(mini.style.top.replace('px', ''));

                                        fastdom.write(function () {
                                            document.body.style.cursor = 'ns-resize';
                                            mini_move.style.cursor = 'ns-resize';
                                            $player.dom.container.style.cursor = 'ns-resize';

                                            if (y >= event.clientY && height < 250) {
                                                height = height + 3;
                                                top = top - 3;
                                                mini.style.height = height + 'px';
                                                mini.style.top = top + 'px';
                                                y = event.clientY;
                                            }

                                            if (y < event.clientY && height > 120) {
                                                height = height - 3;
                                                top = top + 3;
                                                mini.style.height = height + 'px';
                                                mini.style.top = top + 'px';
                                                y = event.clientY;
                                            }

                                        });
                                    });
                                }
                            });

                            doc.on('mouseup', function (event) {
                                event.stopPropagation();
                                mouseResize = false;
                                document.body.style.cursor = 'default';
                                mini_move.style.cursor = 'move';
                                $player.dom.container.style.cursor = 'pointer';
                                doc.off('mousemove');
                                doc.off('mouseup');
                                doc.off('blur');
                            });

                        });

                    };

                    $player.playPause = function () {

                        if (!$player.canPlay)
                            return;

                        if ($player.playingState == 'PLAYING') {
                            $player.pause();
                            $player.showLoader();
                            $player.showBigPlay();
                            $player.showControl(false);
                            $player.showPlaylist(true);
                            $player.showInfo(true);
                            return;
                        }

                        if ($player.playingState == 'PAUSED') {
                            $player.resume();
                            $player.showLoader();
                            $player.showBigPlay();
                            $player.showInfo();
                            return;
                        }

                        if ($player.playingState == 'STOPPED') {
                            $player.play();
                            $player.showLoader();
                            $player.showBigPlay();
                            $player.showPlaylist(true);
                            $player.showInfo();
                            return;
                        }

                    };

                    $player.muteUnmute = function () {

                        if ($player.volumeState == 'UNMUTE') {
                            $player.setVolume(0);
                            $this.addRemoveClass($player.dom.volumeIcon, ['icon-speaker-m'], ['icon-speaker-fill']);
                            $player.volumeState = 'MUTE';
                            return;
                        }

                        if ($player.volumeState == 'MUTE') {
                            $player.setVolume($player.volume);
                            $this.addRemoveClass($player.dom.volumeIcon, ['icon-speaker-fill'], ['icon-speaker-m']);
                            $player.volumeState = 'UNMUTE';
                            return;
                        }
                    };

                    $player.initTime = function (duration) {
                        $player.dom.timeTotal.innerHTML = $this.secToTime(duration);
                        $player.duration = duration;
                    };

                    $player.showPosition = function (position, duration) {

                        if ($player.duration == 0 && duration > 0) {
                            $player.initTime(duration);
                        }

                        if (position > duration) {
                            $player.initTime(position);
                        }

                        $player.dom.timeRunning.innerHTML = $this.secToTime(position);
                        $player.dom.barScrubber.style.left = ($player.duration == 0) ? '-' + ($player.dom.barScrubber.offsetWidth / 2) + 'px' : 'calc(' + ((position / $player.duration) * 100) + '% - ' + ($player.dom.barScrubber.offsetWidth / 2) + 'px)';
                        $player.dom.barPosition.style.width = ($player.duration == 0) ? '0%' : ((position / $player.duration) * 100) + '%';
                    };

                    $player.showBuffered = function (buffered, duration) {

                        if ($player.duration == 0 && duration > 0) {
                            $player.initTime(duration);
                        }
                        $player.dom.barLoaded.style.width = ($player.duration == 0) ? '0%' : ((buffered / $player.duration) * 100) + '%';
                    };

                    $player.timeInfo = function (event) {

                        var pos = ($player.screenState == 'FULL') ? {'x':0, 'y':0 } : $this.findPos($player.dom.barContainer);
                        var diff = event.pageX - pos.x;
                        var curTime = Math.round((diff * $player.duration) / $player.dom.barContainer.offsetWidth);
                        if (curTime < 0)
                            curTime = 0;
                        $player.dom.timer.innerHTML = $this.secToTime(curTime);
                        $player.dom.seekTimer.style.left = (diff - $player.dom.seekTimer.offsetWidth / 2) + 'px';
                        $player.dom.barHover.style.left = (diff - $player.dom.barHover.offsetWidth / 2) + 'px';
                    };

                     $player.showTootip = function (event, text) {
                        var pos = ($player.screenState == 'FULL') ? {'x':0, 'y':0 } : $this.findPos($player.dom.barContainer);
                        var diff = event.pageX - pos.x;
                        $player.dom.controlTip.innerHTML = text;

                        $player.dom.controlTip.style.display = 'block';
                        var pw = $player.dom.barContainer.offsetWidth, tw = $player.dom.controlTip.offsetWidth;
                        diff =  pw <= (tw/2 + diff) ? (pw - tw/2) : diff;
                        $player.dom.controlTip.style.left = (diff - tw/2) + 'px';
                    };

                    $player.setPosition = function (event, seek) {

                        if ($player.playingState == 'STOPPED' || !$player.canPlay)
                            return;

                        var pos = ($player.screenState == 'FULL') ? {'x':0, 'y':0 } : $this.findPos($player.dom.barContainer);
                        var diff = event.pageX - pos.x;
                        var curTime = Math.round((diff * $player.duration) / $player.dom.barContainer.offsetWidth);
                        if (seek)
                            $player.seek(curTime);
                        $player.showPosition(curTime);
                    };

                    $player.changeVolume = function (volume) {

                        var i;
                        for (i = 0; i < $player.dom.volumeBars.length; i++) {
                            $this.addRemoveClass($player.dom.volumeBars[i], [], ['fill']);
                        }
                        for (i = 0; i <= volume; i++) {
                            $this.addRemoveClass($player.dom.volumeBars[i], ['fill'], []);
                        }

                        $player.volume = volume + 1;

                        /* if mute and try to change volume, then unmute*/
                        if ($player.volumeState == 'MUTE') {
                            $player.muteUnmute();
                            return;
                        }

                        $player.setVolume($player.volume);
                    };

                    $player.showHD = function () {

                        /* keeping it for future
                         var currentLevel = $player.levels[level]
                         if (currentLevel) {
                         $player.hd = (currentLevel.height >= 720 || (currentLevel.bitrate / 1000) >= 2000);
                         }*/

                        if ($player.hd) {
                            $player.dom.hd.style.display = 'inline-block';
                        } else {
                            $player.dom.hd.style.display = 'none';
                        }
                    };


                    $player.showPoster = function (show) {

                        if ($player.poster == '')
                            return;

                        if (show) {
                            $player.dom.posterImg.src = $player.poster;
                            $player.dom.posterImg.style.display = 'inline-block';
                        }
                        else {
                            $player.dom.posterImg.style.display = 'none';
                        }
                    };

                    $player.showInfo = function (force) {

                        if ($player.title == '' || $player.mediaType != 'audio' || force) {
                            $player.dom.playInfo.style.display = 'none';
                        }
                        else {
                            $player.dom.playInfo.innerHTML = $player.title;
                            $player.dom.playInfo.style.display = 'block';
                        }

                        if($player.playlist.length > 0) {

                            var thumb = $player.playlist[$player.currentTrack].value.getThumb();
                            thumb = $this.getDefaultThumb(thumb);

                            $player.poster = thumb;

                            if($player.mediaType == 'audio') {
                              $player.showPoster(true);   
                            }
                        }

                    };


                    $player.showLoader = function () {
                        if ($player.isLoading && $player.canPlay)
                            $player.dom.loader.style.display = 'block';
                        else
                            $player.dom.loader.style.display = 'none';

                        $player.showMusicBar();
                        $player.showBigPlay();
                    };

                    $player.showError = function () {

                        $player.dom.playError.innerHTML = 'Sorry, your browser does not support this media format.';
                        $player.showLoader();

                        if (!$player.canPlay) {
                            $player.showPoster(false);
                            $player.dom.playError.style.display = 'block';
                        }
                        else {
                            $player.dom.playError.style.display = 'none';
                        }
                    };

                    $player.showBigPlay = function (replay) {

                        if (!$player.canPlay) {
                            $player.dom.bigBlay.style.display = 'none';
                            return;
                        }

                        if (replay) {
                            $this.addRemoveClass($player.dom.bigBlayIcon, ['icon-reload-p'], []);
                        }
                        else {
                            $this.addRemoveClass($player.dom.bigBlayIcon, [], ['icon-reload-p']);
                        }

                        if (($player.playingState == 'PAUSED' || $player.playingState == 'STOPPED') && !$player.isLoading) {
                            $player.dom.bigBlay.style.display = 'block';
                        }
                        else {
                            $player.dom.bigBlay.style.display = 'none';
                        }

                        $player.showMusicBar();
                    };

                    $player.initPlaylist = function () {

                        if (($player.playlist.length > 1)) {
                            $player.dom.playlistBtn.style.display = 'inline-block';
                            $player.dom.prevBtn.style.display = 'inline-block';
                            $player.dom.nextBtn.style.display = 'inline-block';
                            $player.dom.auto.style.display = 'inline-block';
                        }
                        else {
                            $player.dom.playlistBtn.style.display = 'none';
                            $player.dom.prevBtn.style.display = 'none';
                            $player.dom.nextBtn.style.display = 'none';
                            $player.dom.auto.style.display = 'none';
                        }

                        $player.dom.playlistWrap.style.right = '-250px';
                    };

                    $player.showPlaylist = function (forceHide) {


                        if ($player.playlistState || forceHide) {
                            $player.dom.playlistWrap.style.right = '-250px';
                            $player.dom.playlistWrap.style.zIndex = 999;
                            $player.playlistState = false;
                            return;
                        }

                        if (!$player.playlistState) {
                            $player.dom.playlistWrap.style.right = '0';
                            $player.dom.playlistWrap.style.zIndex = 10000;
                            $player.playlistState = true;
                            return;
                        }

                    };



                    $player.createPlaylist = function () {

                        if ($player.playlist.length < 2)
                            return;

                        var thumb, track,
                                playlist = '<div class="playlist-scrollbar-wrapper">'
                                + '<div rg-scrollbar="true" class="playlist-scrollbar">'
                                + '<ul class="playlist">';

                        for (var i = 0; i < $player.playlist.length; i++) {
                            thumb = $player.playlist[i].value.getThumb();
                            thumb = $this.getDefaultThumb(thumb);
                           
                            track = $this.trackTemplate.replace(/data-rel/g, i);
                            track = track.replace(/data-thumb/g, thumb);
                            track = track.replace(/data-caption/g, $player.playlist[i].value.getCaption());
                            track = track.replace(/data-duration/g, $this.secToTime($player.playlist[i].value.getDuration()));

                            if ($player.source == $player.playlist[i].value.getStreamUrl()) {
                                $player.currentTrack = i;
                            }

                            playlist += '<li>' + track + '</li>';
                        }

                        playlist += '</ul></div></div>';

                        $player.dom.playlistWrap.innerHTML = '';
                        $player.dom.playlistWrap.appendChild($compile(playlist)(option.scope)[0]);
                        $player.dom.playlistUL = $player.dom.playlistWrap.querySelector('.playlist');

                        $player.dom.playlist = $player.dom.playlistWrap.querySelectorAll('ul.playlist > li > a');

                        option.scope.$parent.$rgDigest();
                        RingLogger.info("from player", RingLogger.tags.DIGEST);

                        for (var i = 0; i < $player.dom.playlist.length; i++) {
                            $player.dom.playlist[i].addEventListener('click', function (e) {
                                e.preventDefault();
                                $player.currentTrack = this.getAttribute('rel');
                                $player.title = $player.playlist[$player.currentTrack].value.getCaption();
                                $player.load($player.playlist[$player.currentTrack].value.getStreamUrl());
                            });
                        }

                    };

                    $player.updatePlaylist = function (playlist) {

                        if (!playlist)
                            return;

                        $player.playlist = playlist;
                        $player.createPlaylist();
                    };

                    $player.AddToPlaylist = function (playlist) {

                        var thumb, track;

                        if (!$player.dom.playlistUL) {
                            $player.updatePlaylist(playlist);
                            return;
                        }

                        if (playlist && $player.dom.playlistUL) {

                            for (var i = 0; i < playlist.length; i++) {

                                var li = document.createElement('li');
                                thumb = playlist[i].value.getThumb();
                                thumb = $this.getDefaultThumb(thumb);
                               
                                track = $this.trackTemplate.replace(/data-rel/g, i);
                                track = track.replace(/data-thumb/g, thumb);
                                track = track.replace(/data-caption/g, playlist[i].value.getCaption());
                                track = track.replace(/data-duration/g, $this.secToTime(playlist[i].value.getDuration()));
                                li.innerHTML = track;
                                $player.dom.playlistUL.appendChild(li);
                            }
                        }
                    };

                    $player.dom.playlistUL

                    $player.setTrack = function () {

                        if ($player.playlist.length < 2)
                            return;

                        if ($player.currentTrack == 0)
                            $this.addRemoveClass($player.dom.prevBtn, ['disabled'], []);
                        else
                            $this.addRemoveClass($player.dom.prevBtn, [], ['disabled']);

                        if ($player.currentTrack == ($player.playlist.length - 1))
                            $this.addRemoveClass($player.dom.nextBtn, ['disabled'], []);
                        else
                            $this.addRemoveClass($player.dom.nextBtn, [], ['disabled']);

                        for (var i = 0; i < $player.dom.playlist.length; i++) {
                            if (i == $player.currentTrack) {
                                $this.addRemoveClass($player.dom.playlist[i], ['active'], ['active']);
                            }
                            else {
                                $this.addRemoveClass($player.dom.playlist[i], [], ['active']);
                            }
                        }

                        $player.showInfo();

                    };

                    $player.setAuto = function (force) {

                        if (force) {
                            $this.addRemoveClass($player.dom.auto, ['enbled'], []);
                            return;
                        }

                        if ($player.auto) {
                            $player.auto = false;
                            $this.addRemoveClass($player.dom.auto, [], ['enbled']);
                            return;
                        }

                        if (!$player.auto) {
                            $player.auto = true;
                            $this.addRemoveClass($player.dom.auto, ['enbled'], []);
                            return;
                        }

                    };

                    $player.showMusicBar = function () {

                        if ($player.mediaType == 'audio' && $player.playingState == 'PLAYING' && !$player.isLoading) {
                            $player.dom.musicBar.style.display = 'block';
                        }
                        else {
                            $player.dom.musicBar.style.display = 'none';
                        }

                    };

                    $player.showControl = function (show) {

                        if ($playerProvider.miniPlayer.player)
                            return;

                        if ($player.playingState == 'PLAYING' && show) {
                            $player.dom.controlLayer.style.bottom = '0px';
                            $player.dom.controlBG.style.opacity = 1;
                        }
                        else {
                            $player.dom.controlLayer.style.bottom = '-60px';
                            $player.dom.controlBG.style.opacity = 0;
                        }
                    };

                    $player.stateChanged = function (state) {

                        if (state == 'BUFFERING') {
                            $player.isLoading = true;
                        }
                        else {
                            $player.isLoading = false;
                        }
                        $player.showLoader();

                        if (state == 'PLAYING') {
                            $player.playingState = 'PLAYING';
                            $player.showBigPlay();
                            $this.addRemoveClass($player.dom.playBtn, ['icon-pause-p'], ['icon-play-p']);
                        }
                        if (state == 'ENDED' || state == 'IDLE') {
                            $player.playingState = 'STOPPED';
                            $player.showBigPlay(true);
                            $player.showPlaylist(true);

                            $this.addRemoveClass($player.dom.playBtn, ['icon-play-p'], ['icon-pause-p']);
                            $player.initTime(0);
                            $player.showPosition(0);
                            $player.showInfo(true);

                            if ($player.auto && $player.playlist.length > 0) {
                                $player.playNext();
                            }
                        }
                    };

                    $player.reset = function () {
                        $player.isLoading = true;
                        $player.initTime(0);
                        $player.showPosition(0);
                        $player.showBuffered(0);
                        $player.showLoader();
                        $player.showInfo();
                    };

                    $player.fullScreen = function () {

                        if ($player.screenState == 'NORMAL') {

                            if ($player.dom.player.requestFullscreen) {

                                $player.dom.player.requestFullscreen();
                            }
                            else if ($player.dom.player.mozRequestFullScreen) {
                                $player.dom.player.mozRequestFullScreen();
                            }
                            else if ($player.dom.player.webkitRequestFullScreen) {
                                $player.dom.player.webkitRequestFullScreen();
                            } else {
                                return false;
                            }
                            
                            $player.screenState = 'FULL';
                            $player.showControl(true);
                        
                            $this.addRemoveClass($player.dom.player, ['full'], []);
                            $this.addRemoveClass($player.dom.fullScreenBtn, ['icon-screen-fe'], ['icon-screen-f']);

                            if ($playerProvider.miniPlayer.dom) {
                                $this.addRemoveClass($playerProvider.miniPlayer.dom, ['full'], []);
                            }

                            $player.dom.fullScreenBtn.setAttribute('tooltip', $this.dicts['maximize']); 
                            return true;
                        }

                        if ($player.screenState == 'FULL') {

                            if (document.cancelFullscreen) {
                                document.cancelFullscreen();
                            }
                            else if (document.exitFullscreen) {
                                document.exitFullscreen();
                            }
                            else if (document.mozCancelFullScreen) {
                                document.mozCancelFullScreen();
                            }
                            else if (document.webkitCancelFullScreen) {
                                document.webkitCancelFullScreen();
                            }
                            $this.addRemoveClass($player.dom.player, [], ['full']);
                            $this.addRemoveClass($player.dom.fullScreenBtn, ['icon-screen-f'], ['icon-screen-fe']);
                            if ($playerProvider.miniPlayer.dom) {
                                $this.addRemoveClass($playerProvider.miniPlayer.dom, [], ['full']);
                            }

                            $player.showControl(false);
                            $player.screenState = 'NORMAL';
                            $playerProvider.escapeKey = true;
                            $player.dom.fullScreenBtn.setAttribute('tooltip', $this.dicts['fullScreen']);
                            return true;
                        }

                    };

                    $player.playNext = function () {

                        if ($player.currentTrack == $player.playlist.length - 1) {
                            return;
                        }

                        $player.currentTrack++;
                        $player.title = $player.playlist[$player.currentTrack].value.getCaption();
                        $player.load($player.playlist[$player.currentTrack].value.getStreamUrl());

                        if (option.onNext)
                            option.onNext.apply(option.scope);

                    };

                    $player.playPrev = function () {

                        if ($player.currentTrack == 0) {
                            return;
                        }

                        $player.currentTrack--;
                        $player.title = $player.playlist[$player.currentTrack].value.getCaption();
                        $player.load($player.playlist[$player.currentTrack].value.getStreamUrl());

                        if (option.onNext)
                            option.onNext.apply(option.scope);
                    };

                    /* ui related api*/
                    $player.getPlaylistUI = function () {
                        return $player.dom.playlistWrap;
                    }

                    $player.getNextUI = function () {
                        return $player.dom.nextBtn;
                    };

                    $player.getPrevUI = function () {
                        return $player.dom.prevBtn;
                    };

                    /*  media object related*/
                    $player.load = function (url) {
                        $player.reset();
                        $player.setTrack();

                        $player.provider.pause();
                        $player.seek(0);
                        $player.provider.src = url;

                        $player.source = url;

                        /* fire event on change*/
                        if (angular.isFunction(option.scope.onChange()) && $player.playlist.length > 0) {
                            option.scope.onChange()($player.playlist[$player.currentTrack].value);
                        }
                    };

                    $player.play = function () {
                        $player.provider.play();

                        $player.playingState = 'PLAYING';
                        $this.addRemoveClass($player.dom.playBtn, ['icon-pause-p'], ['icon-play-p']);
                    };

                    $player.pause = function () {
                        $player.provider.pause();

                        $player.playingState = 'PAUSED';
                        $this.addRemoveClass($player.dom.playBtn, ['icon-play-p'], ['icon-pause-p']);
                    };

                    $player.resume = function () {
                        $player.provider.play();

                        $player.playingState = 'PLAYING';
                        $this.addRemoveClass($player.dom.playBtn, ['icon-pause-p'], ['icon-play-p']);
                    };

                    $player.seek = function (offset) {

                        try {
                            $player.provider.currentTime = offset;
                        }
                        catch (e) {
                        }

                    };

                    $player.stop = function () {
                        $player.provider.pause();
                        $player.seek(0);
                        $player.playingState = 'STOPPED';
                        $this.addRemoveClass($player.dom.playBtn, ['icon-play-p'], ['icon-pause-p']);

                    };

                    $player.setVolume = function (volume) {
                        $player.provider.volume = volume / 10;
                    };

                    $player.initEvent();
                    $player.showControl();
                    $player.showLoader();
                    $player.showBigPlay();
                    $player.showError();
                    $player.showInfo();
                    $player.showMusicBar();
                    $player.initPlaylist();
                    $player.showHD();
                    $player.playingState = 'STOPPED';

                    $player.provider.autoPlay = false;
                    $player.load(option.source);
                    $player.setVolume($player.volume);

                    $this.instances.push($player);

                    return $player;
                };
                return $playerProvider;
            }];
    }

    rgPlayer.$inject = ['$compile', '$player', '$ringbox'];
    function rgPlayer($compile, $player, $ringbox) {

        function link(scope, element, attrs) {

            var id = (attrs.id) ? attrs.id : 'player_1',
                    width = (attrs.width) ? attrs.width : '100%',
                    height = (attrs.height) ? attrs.height : '100%',
                    auto = (attrs.auto == 'false' || attrs.auto == false) ? false : true,
                    src = (attrs.url) ? attrs.url : '',
                    title = (attrs.title) ? attrs.title : '',
                    type = (attrs.isVideo == 'true' || attrs.isVideo == false) ? 'video' : 'audio',
                    poster = (attrs.poster) ? attrs.poster : (type == 'audio' ? 'images/player-audio.png' : ''),
                    autoPlay = (attrs.autoPlay == 'false' || attrs.autoPlay == false) ? false : true,
                    chat = (attrs.chat == 'true' || attrs.chat == true) ? true : false,
                    current = 0,
                    player = null,
                    playerUI = null,
                    nextBtn = null,
                    prevBtn = null,
                    fromPlaylist = false;

            if (!poster || poster == 'images/audio-preview.jpg')
                poster = 'images/player-audio.png';

            var tpl = '<div id="player_' + id + '" class="player ' + type + '"></div>';
            element.append(tpl);

            setTimeout(function () {
                player = $player.player({
                    source: src,
                    title: title,
                    playlist: scope.playlist,
                    auto: auto,
                    type: type,
                    parentId: "player_" + id,
                    autoPlay: autoPlay,
                    chatVersion: chat,
                    width: width,
                    height: height,
                    poster: poster,
                    ringboxMinimize: $ringbox.minimize,
                    ringboxMaximize: $ringbox.maximize,
                    ringboxRemove: $ringbox.removeMinimize,
                    scope: scope
                });
            });

        }

        return {
            restrict: 'E',
            scope: {
                onChange: '&',
                onStart: '&',
                onEnded: '&',
                playlist: '='
            },
            link: link
        }
    }
})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.rgloading_directive', [])
        .directive('rgLoading', rgLoading);

    rgLoading.$inject = ['$rootScope', 'SystemEvents'];
    function rgLoading($rootScope, SystemEvents) { //jshint ignore:line

        return {
            restrict: 'E',
            template:
                    '<a class="glo-l ng-cloak"> ' +
                        '<span class="load-circle">' +
                            '<span class="ld-cir1 glo-cir"></span>' +
                            '<span class="ld-cir2 glo-cir"></span>' +
                            '<span class="ld-cir3 glo-cir"></span>' +
                            '<span class="ld-cir4 glo-cir"></span>' +
                            '<span class="ld-cir5 glo-cir"></span>' +
                            '<span class="ld-cir6 glo-cir"></span>' +
                            '<span class="ld-cir7 glo-cir"></span>' +
                            '<span class="ld-cir8 glo-cir"></span>' +
                            '<span class="ld-cir9 glo-cir"></span>' +
                            '<span class="ld-cir10 glo-cir"></span>' +
                            '<span class="ld-cir11 glo-cir"></span>' +
                            '<span class="ld-cir12 glo-cir"></span>' +
                        '</span>' +
                        '<span class="glo-type">Processing...</span>' +
                        '</a>' ,
            scope: {
                rgLoadingObj: '='
            },
            link: function(scope, element) {
                $rootScope.$on(SystemEvents.AUTH.LOGIN, function() {
                    element[0].style.display = 'none';
                    scope.$rgDigest();
                });
                $rootScope.$on(SystemEvents.LOADING, function(event, bool) {
                    if (bool) {
                        element[0].style.display = 'block';
                    } else {
                        element[0].style.display = 'none';
                    }
                });

                element[0].style.display = 'none';
            }
        };
    }
})();


/*
 * © Ipvision
 */

(function() {
    'use strict';
    angular.module('ringid.common.rgRecorder', [])
        .directive('rgImageCapture', rgImageCapture);

        //.directive('rgAudioCapture', rgAudioCapture)
        //.directive('rgVideoCapture', rgVideoCapture);



    function rgRecorder(user_props){

        var self = this;

        var _props = {
            recordedImage : {
                width : 0,
                height : 0,
                image : ''
            },
            recordedVideo : {
                width : 0,
                height: 0,
                video : ''
            },
            mediaPreview : {
                width : 400,
                height : 400
            },
            mediaStream : '',
            mediaObject : '',
            isStreaming : false
        };

        angular.extend(_props, user_props);

        this._callbacks = {
            streamReady : _streamReady,
            error : _onError
        };

        var _streamReady = function(){};
        var _onError = function(){};

        var initNavigatorMedia = function(){
            navigator.getMedia_ = ( navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia );
        };

        var initMediaEvents = function(){
            self.getMediaObject().addEventListener('canplay', self.onCanPlay, false);
        };

        //var setCanvas = function(){
        //    var canvas = self.getCanvas();
        //    canvas.setAttribute('width', self.getMediaPreview().width);
        //    canvas.setAttribute('height', self.getMediaPreview().height);
        //};

        var getVideoObjectFromStream = function(stream){
            var video = document.createElement('video');
            if (navigator.mozGetUserMedia) {
                video.mozSrcObject = stream;
            } else {
                var vendorURL = window.URL || window.webkitURL;
                video.src = vendorURL.createObjectURL(stream);
            }
            return video;
        };

        var processMediaStream = function(stream){
            _props.mediaStream = stream;
            _props.mediaObject = getVideoObjectFromStream(stream);
            initMediaEvents();
        };

        var onFailure = function(e){
            self.triggerEvent('error', { text : 'Please Enable Webcam Permission'});
            RingLogger.alert('rgRecorder failure', e, RingLogger.tags.RG_RECRODER);
        };


        self.on = function(eventName, func){
            self._callbacks[eventName] = func;
        };

        self.triggerEvent = function(eventName, data){
            if(!!self._callbacks[eventName]){
                self._callbacks[eventName].call(self, data);
            }
        };

        self.getProps = function(){
            return _props;
        };

        self.getMediaPreview = function(){
            return _props.mediaPreview;
        };

        self.getMediaObject = function(){
            return _props.mediaObject;
        };

        self.getStream = function(){
            return _props.mediaStream;
        };

        self.setStream = function(stream){
            _props.mediaStream = stream;
        };

        self.isStreaming = function(isStreaming){
            if( !isStreaming ){

                return _props.isStreaming;
            }else{
                _props.isStreaming = isStreaming;
            }
        };

        self.startRecording = function(){
            self.getStream().record();
        };

        self.stopRecording = function(){
            self.getStream().stop();

        };

        self.getRecordedMedia = function(callback){
            self.getStream().getRecordedData(callback);
        };

        //self.getRecordedMedia = function(){
        //
        //};

        self.captureImage = function(){
            var mediaObject = self.getMediaObject();
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            if ( mediaObject.width && mediaObject.height) {
                canvas.width = mediaObject.width;
                canvas.height = mediaObject.height;
                context.drawImage(mediaObject, 0, 0, mediaObject.width, mediaObject.height);
                return  canvas.toDataURL('image/jpeg');

            }else{

                return false;
            }
        };

        self.onCanPlay = function(ev){
            var mediaObject = self.getMediaObject();
            var mediaPreview = self.getMediaPreview();

            if (!self.isStreaming()) {
                var height = mediaObject.videoHeight / (mediaObject.videoWidth/mediaPreview.width);

                // Firefox currently has a bug where the height can't be read from
                // the video, so we will make assumptions if this happens.

                if (isNaN(height)) {
                    height = width / (4/3);
                }

                mediaObject.setAttribute('width', mediaPreview.width);
                mediaObject.setAttribute('height', height);

                self.isStreaming(true);
                self.triggerEvent('streamReady', { stream : self.getStream(), media : mediaObject });
            }

        };

        self.openMedia = function(props){
            if( !navigator.getMedia_){

                self.triggerEvent('error', { text : 'Webcam Capture Not Supported In Your Browser'});

            }else{

                navigator.getMedia_(props, processMediaStream, onFailure);
            }

        };


        self.destroy = function(){
            var mediaObject = self.getMediaObject();
            if( !!mediaObject){
                mediaObject.removeEventListener('canplay', self.onCanPlay);    
            }

            if(  self.getStream() ){
                self.getStream().stop();
                self.setStream(null);
            }
            
        };

        var init = function(){
            initNavigatorMedia();
        };

        init();

    }


    rgImageCapture.$inject = ['utilsFactory'];
    function rgImageCapture(utilsFactory){
        return {
            link : function(scope, elem, attr){

                var _TEXT = {
                    CAPTURE : 'Capture',
                    RETAKE : 'ReTake'
                };

                scope.videoId = utilsFactory.getUniqueID('rgRec');
                scope.showLoader = true;
                scope.media = null;
                scope.errorText = "";
                scope.captureText = _TEXT.CAPTURE;


                var getVideoContainerElement = function(){
                    return document.querySelector('#' + scope.videoId);
                };

                var recorder = new rgRecorder();

                recorder.on('streamReady', function(data){

                    scope.showLoader = false;
                    scope.$rgDigest();

                    try{

                        getVideoContainerElement().appendChild(data.media);
                        scope.media = data.media;

                        data.media.play();

                    }catch(e){

                    }


                });

                recorder.on('error', function(e){
                    scope.errorText = e.text;
                    scope.showLoader = false;
                    scope.$rgDigest();
                });

                recorder.openMedia({video: true, audio : false});


                scope.doCapture = function(){

                    if( scope.captureText == _TEXT.CAPTURE){

                        var image = recorder.captureImage();
                        if( !!image ){
                            scope.capturedMedia = image;
                            scope.captureText = _TEXT.RETAKE;
                        }

                        if(!!scope.media){
                            scope.media.pause();
                        }

                    }else{
                        scope.capturedMedia = null;
                        scope.captureText = _TEXT.CAPTURE;

                        scope.media.play();

                    }

                    scope.$rgDigest();

                };

                scope.$on('$destroy', function(){

                    recorder.destroy();


                });
            },
            templateUrl : 'pages/partials/recorder/image.html'
        }

    }

    //rgAudioCapture.$inject = ['utilsFactory'];
    //function rgAudioCapture(utilsFactory){
    //    return{
    //        link : function(scope, elem, attr){
    //
    //        },
    //        templateUrl : 'pages/partials/recorder/audio.html'
    //
    //    }
    //
    //
    //}
    //
    //rgVideoCapture.$inject = ['utilsFactory'];
    //function rgVideoCapture(utilsFactory){
    //    return {
    //        link : function(scope, elem, attr){
    //
    //            var _TEXT = {
    //                CAPTURE : 'Record',
    //                STOP : 'STOP',
    //                RETAKE : 'Restart'
    //            };
    //
    //            var _VIDEO_STATES = {
    //                PLAYING : 0,
    //                PAUSED : 1
    //            };
    //
    //            scope.videoId = utilsFactory.getUniqueID('rgRec');
    //            scope.previewVideoId = utilsFactory.getUniqueID('rgRec');
    //            scope.showLoader = true;
    //            scope.errorText = "";
    //            scope.media = null;
    //            scope.videoState = _VIDEO_STATES.PAUSED;
    //            scope.captureText = _TEXT.CAPTURE;
    //
    //            var getVideoContainerElement = function(){
    //                return document.querySelector('#' + scope.videoId);
    //            };
    //
    //            var getPreviewVideoContainerElement = function(){
    //                return document.querySelector('#' + scope.previewVideoId);
    //            };
    //
    //            var pauseMedia = function(){
    //                if( !!scope.media){
    //                    scope.media.pause();
    //                    scope.videoState = _VIDEO_STATES.PAUSED;
    //                }
    //            };
    //
    //            var playMedia = function(){
    //                if( !!scope.media){
    //                    scope.media.play();
    //                    scope.videoState = _VIDEO_STATES.PLAYING;
    //                }
    //            };
    //
    //            var toggleMedia = function(){
    //                if( scope.videoState == _VIDEO_STATES.PAUSED ){
    //                    playMedia();
    //                }else{
    //                    pauseMedia();
    //                }
    //            };
    //
    //            var getMediaProps = function(){
    //                return {video: true, audio : true}
    //            };
    //
    //            var recorder = new rgRecorder();
    //            recorder.openMedia(getMediaProps());
    //
    //            recorder.on('error', function(e){
    //                scope.errorText = e.text;
    //                scope.showLoader = false;
    //            });
    //
    //
    //            recorder.on('streamReady', function(data){
    //
    //                scope.showLoader = false;
    //                scope.$rgDigest();
    //
    //                getVideoContainerElement().appendChild(data.media);
    //                scope.media = data.media;
    //
    //                playMedia();
    //
    //            });
    //
    //            scope.doCapture = function(){
    //
    //                if( scope.captureText == _TEXT.CAPTURE){
    //
    //                    recorder.startRecording();
    //                    scope.captureText = _TEXT.STOP;
    //
    //
    //                }else{
    //                    recorder.stopRecording();
    //
    //                    recorder.getMediaPreview(function(data){
    //                        var aPreviewVideo = document.createElement('video');
    //                        aPreviewVideo.src = data;
    //                        aPreviewVideo.width = "400";
    //                        aPreviewVideo.height = "400";
    //                        aPreviewVideo.autoPlay = true;
    //                        getPreviewVideoContainerElement().appendChild(aPreviewVideo);
    //
    //                    });
    //
    //
    //                    scope.captureText = _TEXT.CAPTURE;
    //
    //                    playMedia();
    //
    //                }
    //
    //                scope.$rgDigest();
    //
    //            };
    //
    //            scope.$on('togglePlayPause', function(){
    //                toggleMedia();
    //            });
    //
    //            scope.$on('$destroy', function(){
    //
    //                var element = getVideoContainerElement();
    //                recorder.destroy();
    //            });
    //        },
    //        templateUrl : 'pages/partials/recorder/video.html'
    //    }
    //
    //}


})();
/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.media', [
            'ringid.filters',
            'ringid.profile',
            'ringid.config',
            'ringid.common.stacked_map',
            'ringid.ringbox',
            'ringid.common.controllers'
        ]);

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.media')
        .service('mediaHttpService', mediaHttpService);

        mediaHttpService.$inject = [ 'OPERATION_TYPES', '$$connector'];
        function mediaHttpService( OPERATION_TYPES, $$connector) {
			var self = this,
				OTYPES = OPERATION_TYPES.SYSTEM.MEDIA,
                REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;

            // MEDIA ALBUM APIS
            self.fetchMediaAlbums = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_MEDIA_ALBUM_LIST, // 256
                    mdaT: obj.mdaT || 1,
                    utId: obj.utId // optional. maybe without utid just own media album list fetch
                };
                $$connector.send(payload, REQTYPE.REQUEST);
            };


            self.fetchHashtagSuggestion = function(schPm) {
                return $$connector.pull({
                    actn: OTYPES.ACTION_GET_HASHTAG_SUGGESTION,
                    schPm: schPm.utf8Encode()
                }, REQTYPE.REQUEST);
            };

            self.fetchSearchResult = function(param) {
                var payload = {
                    actn : OTYPES.ACTION_MEDIA_SEARCH_RESULT,
                    schPm: param.utf8Encode()
                };
                //return $$connector.send(payload,REQTYPE.REQUEST);
                return $$connector.pull(payload, REQTYPE.REQUEST);
            };

            self.fetchContent = function(param) {
                var payload = {
                    actn : OTYPES.ACTION_SPECIFIC_MEDIA_RESULT,//278
                    schPm: param.sk.utf8Encode(),
                    sugt:param.sugt,
                    pvtid:param.pvtid || 0,
                    scl:param.scl || 1
                };
                return $$connector.send(payload,REQTYPE.REQUEST);
            };
            self.fetchAlbumDetails = function(albId) {
                var payload = {
                    actn: OTYPES.ACTION_MEDIA_ALBUM_DETAILS, // 257
                    albId: albId
                };
                return $$connector.request(payload, REQTYPE.REQUEST);
            };

            self.addMediaAlbum= function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_ADD_MEDIA_ALBUM, // 253
                    imgURL: obj.imgURL,
                    albn: obj.albn,
                    mdaT: obj.mdaT
                };
                return $$connector.request(payload, REQTYPE.UPDATE);
            };

            self.updateMediaAlbum = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_UPDATE_MEDIA_ALBUM, // 254
                    albId: obj.albId,
                    imgURL: obj.imgURL,
                    mdaT: obj.mdaT,
                    albn: obj.albn.utf8Encode()
                };
                return $$connector.request(payload, REQTYPE.UPDATE);
            };

            self.deleteAlbum = function(albId) {
                var payload = {
                    actn: OTYPES.ACTION_DELETE_MEDIA_ALBUM, // 255
                    albId: albId
                };
                return $$connector.request(payload, REQTYPE.UPDATE);
            };



           // MEDIA CONTENT APIS
            self.fetchAlbumContents = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST, // 261
                    albId: obj.albId,
                    utId: obj.utId, // optional. maybe without utid just own media album list fetch
                    st: obj.st || 0
                };
                $$connector.send(payload, REQTYPE.REQUEST);
            };

            self.fetchAlbumContentsForpopup = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST, // 261
                    albId: obj.albId || obj.id,
                    utId: obj.utId, // optional. maybe without utid just own media album list fetch
                    st: obj.st || 0
                };
                return $$connector.pull(payload, REQTYPE.REQUEST);
            };

            self.fetchContentDetails= function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_MEDIA_CONTENT_DETAILS, // 262,
                    cntntId: obj.cntntId,
                    utId: obj.utId
                };
                return $$connector.request(payload, REQTYPE.REQUEST);
            };

            self.addMediaToAlbum = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_ADD_MEDIA_CONTENT, // 258
                    albId: obj.albId,
                    mdaLst: obj.mdaLst, // [{strmURL, drtn, tih, tiw, thmbURL, artst, ttl}]
                    mdaT: obj.mdaT
                };

                return $$connector.request(payload, REQTYPE.UPDATE);
            };

            self.updateMediaAlbum = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_UPDATE_MEDIA_CONTENT, // 259
                    mdaCntntDTO: obj.mdaCntntDTO // {id,strmURL,albId,drtn,thmbURL,artst,ttl,utId}
                };
                return $$connector.request(payload, REQTYPE.UPDATE);
            };

            self.deleteAlbumContent = function(cntntId) {
                var payload = {
                    actn: OTYPES.ACTION_DELETE_MEDIA_CONTENT, // 260
                    cntntId: cntntId
                };
                return $$connector.request(payload, REQTYPE.UPDATE);
            };


            // CONTENT ACTIVITY APIS
            self.increaseViewCount = function(cntntId,nfId) {
                // THERE IS AN UPDATE EVENT NOT HANDLED WITH ACTION 472
                var payload = {
                    actn: OTYPES.ACTION_INCREASE_MEDIA_CONTENT_VIEW_COUNT, // 272
                    cntntId: cntntId
                };
                if(nfId){
                    payload.nfId = nfId;
                }
                return $$connector.request(payload, REQTYPE.UPDATE);
            };


            // self.likeUnlikeContent = function(obj) {
            //     // THERE IS AN UPDATE EVENT NOT HANDLED WITH ACTION 464
            //     var payload = {
            //         actn: OTYPES.ACTION_LIKE_UNLIKE_MEDIA, // 264
            //         cntntId: obj.cntntId,
            //         lkd: obj.lkd
            //     };
            //     if(obj.nfId){
            //         payload.nfId = obj.nfId;
            //     }
            //     return $$connector.request(payload, REQTYPE.UPDATE);
            // };

            // self.likeList = function(cntntId,nfId) {
            //     var payload = {
            //         actn: OTYPES.ACTION_MEDIA_LIKE_LIST, // 269,
            //         cntntId: cntntId
            //     };
            //     if(nfId){
            //         payload.nfId = nfId;
            //     }
            //     return $$connector.pull(payload, REQTYPE.REQUEST);
            // };


            self.getSearchTrends = function () {
                var payload = {
                    actn : 281
                };
                return $$connector.pull(payload,REQTYPE.REQUEST);
            };

            self.getTaggedMedia = function (param) {
                var payload = {
                    actn : OTYPES.ACTION_GET_TAGGED_MEDIA_SONGS,//279
                    htid : param,
                    pvtid : 0,
                    scl : 2
                };
                return $$connector.send(payload,REQTYPE.REQUEST);
            };

        }

})();

/*
 * Ipvision
 */


(function(){
    'use strict';
    angular
        .module('ringid.media')
        .factory('$$mediaMap', $$mediaMap);

    $$mediaMap.$inject = [ 'utilsFactory', 'userFactory', 'Auth', '$$stackedMap', 'settings', 'APP_CONSTANTS', 'mediaHttpService', '$$q'];
    function $$mediaMap ( Utils, User, Auth, $$stackedMap, settings, APP_CONSTANTS, mediaHttpService, $q) { //jshint ignore:line
        var AC = APP_CONSTANTS;
        function __setMediaUser(media, _d, user){

                    if (angular.isDefined(user)) {
                        media.user = user;
                    } else {
                        if(_d.utId){
                            media.user = User.getByUtId(_d.utId);
                        }else if(_d.uId){
                            media.user =  User.getUser(_d.uId);
                        }else{
                            media.user = false;
                        }
                        if(!media.user){
                            var uOb = {};
                                if(_d.uId){
                                    uOb.uId = _d.uId;
                                }
                                if(_d.utId){
                                    uOb.utId = _d.utId;
                                }
                                if(_d.fn){
                                    uOb.fn = _d.fn;
                                }
                                if(_d.prIm){
                                    uOb.prIm = _d.prIm;
                                }
                            media.user = User.create(uOb);
                        }
                    }//updating feed user

                }
        return {
            createMedia: function (obj, userMap) {
                var media = {
                    ac: 0, // view count
                    albId: 0,
                    cc: 0,//count count
                    ic: 0,// i comment
                    il: 0,//i like
                    lc: 0,//like count
                    is : 0,// i share
                    ns : 0,//share count
                    // above are from notification for mdaT=2
                    nfId : 0,
                    albn:'',
                    artst: '',
                    cntntId: 0,
                    drtn: 0,
                    mdaT: 1,
                    strmURL: '',
                    thmbURL: '',
                    ttl: '',
                    tih: 0,
                    tiw: 0,
                    user: null,
                    viewtime:0,
                    utId:'',
                    autoplay:false
                    //ilkd: 0, // current user liked
                   // likeUsers: $$stackedMap.createNew() // need additional api call to get this
                   // comments: $$stackedMap.createNew()
                };





                var updatemediaObj = function(mediaObj) {
                    if (angular.isObject(mediaObj)) {
                        angular.extend(media, mediaObj);
                        media.key = media.cntntId;

                        // set cover image for media
                        //if (mediaObj.mdaT === AC.NEWS_FEED_MEDIA_TYPE_VIDEO && mediaObj.thmbURL  && mediaObj.thmbURL.length > 1) {
                        if (mediaObj.thmbURL  && mediaObj.thmbURL.length > 1) {
                            media.poster = settings.imBase + mediaObj.thmbURL;
                            // new api provides video thumb image from server not working from cloud api doc
                            //media.poster = settings.streamServer + 'media/' + mediaObj.strmURL.substr(0, mediaObj.strmURL.lastIndexOf('.')) + '.jpg';

                            //media.tih = mediaObj.tih || 600;
                            //media.tiw = mediaObj.tiw || 600;
                            //var position = mediaObj.thmbURL.lastIndexOf('/') + 1;
                                //media.feedThumb = [settings.imBase, mediaObj.thmbURL.slice(0, position), 'p', '600',  mediaObj.thmbURL.slice(position)].join('');
                                //return [settings.imBase, image.iurl.slice(0, position), image.iurl.slice(position)].join('');

                        } else {
                            media.poster = (media.mdaT === AC.NEWS_FEED_MEDIA_TYPE_AUDIO ) ? 'images/audio-preview.jpg' : 'images/video-preview.jpg';
                            media.feedThumb =  media.poster;
                            media.tih = 330;
                            media.tiw = 600;
                        }



                    } else {
                        RingLogger.warn('not valid json object media', RingLogger.tags.MEDIA);
                        RingLogger.print(mediaObj, RingLogger.tags.MEDIA);
                    }
                };

                updatemediaObj(obj);
                __setMediaUser(media,obj,userMap);

                return {
                    sortBy: function() {
                        return media.viewtime;
                    },
                    getMediaUtId:function () {
                        return media.utId;
                    },
                    getAlbumId: function() {
                        return media.albId;
                    },
                    getAlbumName: function() {
                        return media.albn;
                    },
                    getKey: function() {
                        return media.key;
                    },
                    getFeedKey : function(){
                        return media.nfId;
                    },
                    setFeedKey : function(nfId){
                        return media.nfId = nfId;
                    },
                    isAudio : function() {
                        return media.mdaT === AC.NEWS_FEED_MEDIA_TYPE_AUDIO;
                    },
                    isVideo : function() {
                       return media.mdaT === AC.NEWS_FEED_MEDIA_TYPE_VIDEO;
                    },
                    owner: function() {
                        return media.user;
                    },
                    user: function() {
                        return media.user;
                    },
                    getId: function() {
                        return media.cntntId;
                    },
                    setIsAutoPlay: function (param) {
                        media.autoplay = param;
                    },
                    getIsAutoPlay: function () {
                        return media.autoplay;
                    },
                    getViewCount: function() {
                        if( media.ac > 1 ) {
                            return 'Views : '+ media.ac;
                        } else {
                            return 'View : '+ media.ac;
                        }
                    },
                    getViewCountOnly: function () {
                      return media.ac;
                    },
                    getDuration: function(formated) {
                        if (formated) {
                            var minutes =  media.drtn/60 === 0 ? '00' : Math.floor(media.drtn/60);
                            var seconds =  media.drtn%60 === 0 ? '00': Math.floor(media.drtn%60);
                            minutes = (minutes < 10 && minutes !== '00') ? '0' + minutes : minutes;
                            seconds = (seconds < 10 && seconds !== '00') ? '0' + seconds : seconds;
                            return minutes + ':' + seconds;
                        } else {
                            return media.drtn;
                        }
                    },
                    getCaption: function() {
                        return media.ttl;
                    },
                    getStreamUrl: function() {
                      return settings.mediaBase + media.strmURL;
                    },
                    getStreamUrlOnly: function () {
                      return media.strmURL;
                    },
                    getThumb: function() {
                        return media.poster;
                    },
                    getThumbForMedia: function () {
                        if(media.thmbURL===''){
                            return media.mdaT===1 ? 'images/audio-preview.jpg':'images/video-preview.jpg';
                        }else{
                            return media.poster;
                        }
                    },
                    getThumbForMediaOnly: function () {
                        if(media.thmbURL===''){
                            return media.mdaT===1 ? 'images/n-audio.jpg':'images/n-video.jpg';
                        }else{
                            return media.poster;
                        }
                    },
                    feedThumb: function () {
                        return media.feedThumb;
                    },
                    iLiked: function() { // todo  : replace use of this , because all other maps(comment,feed,image) has api of self like is like()
                        return media.il;
                    },
                    like: function(dolike,totalLike) {
                        if(!dolike)return media.il;
                        media.il = media.il ^ 1;
                        if(totalLike){
                            media.lc = totalLike;
                        }else{
                            media.lc = (media.il == 0) ? media.lc-1 : media.lc+1;
                        }
                        return media.il;
                    },
                    getLikes: function() {
                        return media.lc;
                    },
                    getTotalLikes : function(){
                        return media.lc;
                    },
                    // getWhoLikes: function() {
                    //     return media.likeUsers.all();
                    // },
                    setTotalComment: function(cc,ic) {
                        media.cc = cc;
                        if(angular.isDefined(ic)){
                                media.ic = ic;
                            }
                    },
                    selfComment : function(){
                        return media.ic;
                    },
                    getTotalComment: function() {
                        return media.cc;
                    },
                    getTotalShare: function () {
                            return media.ns;
                    },
                    setTotalShare: function (v) {
                       media.ns = v;
                    },
                    share: function (doShare) {

                            if (!doShare) {
                                return media.is;
                            }
                            media.is = media.is ^ 1;
                            media.ns = media.is ? media.ns+1 : media.ns-1;
                            return media.is;
                    },
                    thumbOffset : function(dimension){
                        if (!dimension) {
                            return {width : media.tiw, height : media.tih};
                        } else {
                            return (dimension === 'height') ? media.tih : media.tiw;
                        }
                    },
                    // UPDATE MAP
                    updateMedia: function(obj) {
                        updatemediaObj(obj);
                    },
                    // pushLikes: function(json) {
                    //     var user;
                    //     if(json.likes && json.likes.length > 0) {
                    //         for(var i = 0, l = json.likes.length; i < l; i++) {
                    //             user = User.create(json.likes[i]);
                    //             media.likeUsers.save(user.getKey(), user);
                    //             // check if current user liked or not
                    //             if(media.ilkd === 0 && user.getKey() === Auth.currentUser().getKey()) {
                    //                 media.ilkd = 1;
                    //             }
                    //         }
                    //     }
                    // },
                    addToAlbumData: function() {
                        return {
                            strmURL: media.strmURL,
                            tiw: media.tiw,
                            tih: media.tih,
                            drtn: media.drtn,
                            thmbURL: media.thmbURL,
                            artst: media.artst,
                            ttl: media.ttl.utf8Encode() //fileObj.meta.ttl
                        };
                    },
                    // API CALLS
                    increaseView: function() {
                        var deferred = $q.defer();
                        mediaHttpService.increaseViewCount(media.cntntId).then(function(json) {
                            RingLogger.print(json, RingLogger.tags.MEDIA);
                            if (json.sucs === true) {
                                media.ac++;
                            }
                            deferred.resolve();
                        });
                        return deferred.promise;
                    }
                    // likeMedia: function() {
                    //     media.il = media.il ^ 1; // check if user already liked or not

                    //     mediaHttpService.likeUnlikeContent({cntntId: media.cntntId, lkd: media.il,nfId : media.nfId }).then(function(json) {
                    //         RingLogger.print( 'LIKE RESPONSE', RingLogger.tags.MEDIA);
                    //         RingLogger.print(json, RingLogger.tags.MEDIA);
                    //         if (!json.sucs) {
                    //             media.il = media.il ^ 1;
                    //              RingLogger.print( 'LIKE FAILED: ' + json.mg, RingLogger.tags.MEDIA);
                    //         }else{
                    //             media.lc = json.loc;
                    //         }

                    //     });
                    // },
                };

            }
        };
    }




})();

/*
 * Ipvision
 */


(function(){
    'use strict';
    angular
        .module('ringid.media')
        .factory('$$mediaAlbumMap', $$mediaAlbumMap);

    $$mediaAlbumMap.$inject = ['Ringalert', 'Auth', 'settings', 'fileUploadService', '$$stackedMap', '$$mediaMap', 'APP_CONSTANTS', 'mediaHttpService', 'utilsFactory'];
    function $$mediaAlbumMap (Ringalert, Auth, settings,  fileUploadService, $$stackedMap, $$mediaMap, APP_CONSTANTS, mediaHttpService, utilsFactory) { //jshint ignore:line
        var AC = APP_CONSTANTS;

        function createAlbumKey (obj) {
                //return obj.mdaT + '-' + obj.id;
                return parseInt(obj.id) || parseInt(obj.albId);
        }

        return {
            createKey: function(obj) {
                return createAlbumKey(obj);
            },
            createAlbum: function (obj, user) {
                var album = {
                    albn: '', // album name
                    albId: 0,
                    mc: 0, // total no of content in this album
                    mdc:0,
                    mdaT: 1, // meida time 1=audio, 2=video
                    sts: 0, // do no know
                    utId: 0, // owner user utid
                    imgURL:'',
                    contents: $$stackedMap.createNew(),

                    uniqueKey: utilsFactory.getUniqueID(),
                    // calculated data
                    cover: '',
                    key: 0,
                    type: '',
                    owner: 0
                };


                var updatealbumObj = function(albumObj) {
                    if (angular.isObject(albumObj)) {
                        album = angular.extend({}, album, albumObj);
                        album.albId = parseInt(albumObj.id) || parseInt(albumObj.albId);

                        album.owner = user;
                        album.key = createAlbumKey(albumObj);
                        if (albumObj.imgURL  && albumObj.imgURL.length > 1) {
                            album.cover = settings.imBase + albumObj.imgURL;
                        }else{
                            album.cover = (obj.mdaT === AC.NEWS_FEED_MEDIA_TYPE_AUDIO ) ? 'images/n-audio.jpg' : 'images/n-video.jpg';
                        }
                        album.type= (obj.mdaT === AC.NEWS_FEED_MEDIA_TYPE_AUDIO ) ? 'audio' : 'video';
                    } else {
                        RingLogger.warning('not valid json object album', RingLogger.tags.MEDIA);
                    }
                };

                updatealbumObj(obj);

                function pushContents(contentJson, owner,nfId,tempMediaMap) {
                    var mediaMap, tempMediaMap = tempMediaMap || $$stackedMap.createNew();
                    owner = owner || album.owner;

                    for(var i = 0, l = contentJson.length; i < l; i++) {
                        if(nfId){
                            contentJson[i].nfId = nfId;
                        }
                        mediaMap = $$mediaMap.createMedia(angular.extend(contentJson[i], {albId: album.id}), owner);
                        album.contents.save(mediaMap.getKey(), mediaMap);
                        tempMediaMap.save(mediaMap.getKey(), mediaMap);
                    }
                    RingLogger.print( 'CONTENTS ADDED : ' + album.contents.length(), RingLogger.tags.MEDIA);
                    return tempMediaMap;
                }

                return {
                    getKey: function() {
                        return album.key;
                    },
                    getType: function() {
                        return album.type;
                    },
                    isAudio: function() {
                        return (album.mdaT === AC.NEWS_FEED_MEDIA_TYPE_AUDIO);
                    },
                    isVideo: function() {
                        return (album.mdaT === AC.NEWS_FEED_MEDIA_TYPE_VIDEO);
                    },
                    getId: function() {
                        return album.albId;
                    },
                    getName: function() {
                        return album.albn;
                    },
                    getCover: function() {
                        return album.cover;
                    },
                    getContentCount: function() {
                        return album.mc || album.mdc;
                    },
                    getContents: function() {
                        return album.contents;
                    },
                    updateAlbum: function(obj) {
                        updatealbumObj(obj);
                    },
                    pushContent: function(contentJson, owner,nfId) {
                        return pushContents(contentJson, owner,nfId);
                    },
                    getALbumUtId : function () {
                        return album.utId;
                    },
                    link: function (user, onlyPath) {
                        if( !!user.getUId()|| !!user.getUtId()){
                            var link = utilsFactory.getRingRoute('USER_PROFILE', { uId : user.getUId(), utId : user.getUtId(), subpage: 'media', albumId: album.albId});
                            if (onlyPath) {
                                return link.replace('#', '');
                            } else  {
                                return settings.baseUrl + link;
                            }
                        }else{
                            return '';
                        }
                    },
                    // api calls
                    addNewContent: function(mediaMap) {
                        var index, limit,
                            whichFiles = (album.type === 'audio') ? 'audioFiles' : 'videoFiles',
                            payload = {
                            albId: album.albId,
                            mdaLst: [],
                            mdaT: album.mdaT
                        };

                        // new content from status
                        if (!mediaMap) {
                            for(index = 0, limit = fileUploadService[whichFiles].length; index < limit; index++ ) {
                                RingLogger.print(fileUploadService[whichFiles][index].getAuthData(), RingLogger.tags.MEDIA);
                                payload.mdaLst.push(fileUploadService[whichFiles][index].getAuthData());
                            }
                        } else {
                            // check if media already in the album or not
                            if (album.contents.get(mediaMap.getKey())) {
                                Ringalert.show('Content Already Added', 'warning');
                                return;
                            }
                            // new content from other users album
                             payload.mdaLst.push(mediaMap.addToAlbumData());
                             RingLogger.information('ADDING CONTENT FROM OTHER USER', RingLogger.tags.MEDIA);
                        }
                        mediaHttpService.addMediaToAlbum(payload).then(function(json) {
                            RingLogger.print( angular.toJson(json), RingLogger.tags.MEDIA) ;
                            if(json.sucs === true) {
                                    album.mc += json.mdaIds.length;
                                for(index = 0, limit = json.mdaIds.length; index < limit; index++) {
                                    payload.mdaLst[index].id = json.mdaIds[index];
                                }
                                pushContents(payload.mdaLst);
                                if (mediaMap) {
                                    Ringalert.show('Content Added to album', 'success');
                                }
                            }
                        });
                    },
                    deleteContent: function(mediaMap) {
                        mediaHttpService.deleteAlbumContent(mediaMap.getId()).then(function(json) {
                            RingLogger.print( angular.toJson(json), RingLogger.tags.MEDIA);
                            if(json.sucs === true) {
                                // remove content from contents map
                               album.contents.remove(mediaMap.getKey());
                               //decrease total content count
                               album.mc--;
                            } else {
                                RingLogger.warning( 'MEDIA CONTENT DELETE FAILED: ' + json.mg, RingLogger.tags.MEDIA);
                            }
                        });
                    },
                    fetchContentDetails: function() {
                        var items = album.contents.all();
                        function timedCall(mediaMap, time) {
                            setTimeout(function() {
                                mediaHttpService.likeList(mediaMap.getId()).then(function(json) {
                                    // update mediaMap
                                    RingLogger.print( angular.toJson(json), RingLogger.tags.MEDIA);
                                });
                            }, time);
                        }

                        for(var i = 0, l = items.length; i < l; i++) {
                            (timedCall)(items[i].value, (i * 200 + 200) );
                        }
                    }

                };

            }
        };
    }




})();


/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.media')
        .factory('Media', MediaFactory);


        MediaFactory.$inject = ['mapFilterFilter',  'utilsFactory', 'Ringalert',  'userFactory', 'Auth', '$routeParams','Storage', 'profileFactory', 'OPERATION_TYPES',
            'APP_CONSTANTS', 'mediaHttpService', '$$mediaAlbumMap', '$$mediaMap', '$$stackedMap', '$$q', '$$connector', 'SystemEvents', '$rootScope'];
        function MediaFactory(mapFilterFilter,  utilsFactory, Ringalert, User, Auth, $routeParams, Storage, profileFactory, OPERATION_TYPES,
                              APP_CONSTANTS, mediaHttpService, $$mediaAlbumMap, $$mediaMap, $$stackedMap, $q, $$connector, SystemEvents, $rootScope) { // jshint ignore:line
            var _state = {
                    mediaLoading: false,
                    mediaContentLoading: false,
                    noresultfound:false
                },
                _albumList = {},
                _albums = $$stackedMap.createNew(),
                _userAlbums =  $$stackedMap.createNew(),
                _searchedAlbums = $$stackedMap.createNew(),
                _searchesongs = $$stackedMap.createNew(),
                _albumOwner,
                _utId = 0,
                OTYPES = OPERATION_TYPES.SYSTEM.MEDIA,
                AC = APP_CONSTANTS,
                subscriptionKey,
                searchedTagArr = [],
                contentIdArray = [],
                albumIdArray = [],
                mediaRecent = Storage.getData('mediaRecent');
            //if(!mediaRecent){
            //    mediaRecent = [];
            //    Storage.setData('mediaRecent',mediaRecent);
            //}

            //function getMediaMap(contentId) {
                //var mediaMap,
                    //albumKey;

                //for (albumKey in _albumList) {
                    //if (!_albumList.hasOwnProperty(albumKey)) {
                        //continue;
                    //}

                    //mediaMap = _albumList[albumKey].getContents().get(contentId);
                    //if (mediaMap) {
                        //break;
                    //}
                //}

                //return mediaMap;
            //}

            function _processResponse(json) {
                RingLogger.print(json, RingLogger.tags.MEDIA);
                var album, i, l, obj;
                switch(json.actn) {
                    case OTYPES.ACTION_MEDIA_ALBUM_LIST:
                        _state.mediaLoading = false;
                        if(json.sucs === true && json.mediaAlbumList) {
                            _albumOwner = (Auth.currentUser().getUtId() === json.utId) ? Auth.currentUser() : User.create({utId: json.utId});
                            for(i = 0, l = json.mediaAlbumList.length; i < l; i++) {
                                album = $$mediaAlbumMap.createAlbum(json.mediaAlbumList[i], _albumOwner);
                                if(_albumOwner && _albumOwner.isCurrentUser()) {
                                    RingLogger.information('OWN Album added id:' + album.getKey(), RingLogger.tags.MEDIA);
                                    _albums.save(album.getKey(), album);
                                } else {
                                    RingLogger.information('FRIEND Album added id:' + album.getKey(), RingLogger.tags.MEDIA);
                                    _userAlbums.save(album.getKey(), album);
                                }
                                //_albumList[album.getKey()] = album;
                            }
                        } else {
                            RingLogger.warning('ALBUM LISTFETCH FAIL: '+json.mg, RingLogger.tags.MEDIA);
                        }
                        break;
                    case  OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST:
                        _state.mediaContentLoading = false;
                        if(json.sucs === true && json.mdaCntntLst) {
                            var key = $$mediaAlbumMap.createKey(json);
                            album = _albums.get(key) || _userAlbums.get(key); // || _albumList[key];
                            if(album) {
                                RingLogger.information(json.mdaCntntLst.length + ' CONTENT ADDED to album: ' + album.getKey(), RingLogger.tags.MEDIA);
                                album.pushContent(json.mdaCntntLst);
                            } else {
                                RingLogger.warning('No Albumap Found. You left profile page and useralbum list got reset: ',  RingLogger.tags.MEDIA);
                            }

                        } else {
                            RingLogger.warning('ALBUM CONTENT FETCH FAIL: ' + json.mg, RingLogger.tags.MEDIA);
                        }
                        break;
                    case OTYPES.ACTION_SPECIFIC_MEDIA_RESULT://278
                        _state.noresultfound = false;
                        if ( json.sucs === true ) {
                            for(i=0;i<json.mdaLst.length;i++){
                                if(json.mdaLst[i].sugt===1){
                                    contentIdArray.push(json.mdaLst[i].cntntId);
                                    json.mdaLst[i].viewtime = new Date().getTime();
                                    obj = $$mediaMap.createMedia(json.mdaLst[i]);
                                    _searchesongs.save(obj.getKey(),obj);
                                }
                                if(json.mdaLst[i].sugt===2) {
                                    //json.mdaLst[i].imageurl = settings.imBase + json.mdaLst[i].imgURL;
                                    albumIdArray.push(json.mdaLst[i].albId);
                                    obj = $$mediaAlbumMap.createAlbum(json.mdaLst[i]);
                                    _searchedAlbums.save(obj.getKey(),obj);
                                }
                                if ( json.mdaLst[i].sugt===3 ) {
                                    searchedTagArr.push(json.mdaLst[i]);
                                }
                                //if(json.mdaLst[i].sugt===2) {
                                //    json.mdaLst[i].imageurl = settings.imBase + json.mdaLst[i].imgURL;
                                //    $scope.searchedAlbumArr.push(json.mdaLst[i]);
                                //}
                                //if ( json.mdaLst[i].sugt===3 ) {
                                //    $scope.searchedTagArr.push(json.mdaLst[i]);
                                //}
                            }
                        } else {
                              _state.noresultfound = true;
                        }
                        break;
                    case OTYPES.ACTION_GET_TAGGED_MEDIA_SONGS:
                         _state.noresultfound = false;
                        if(json.sucs===true){
                            for(i=0;i<json.mdaLst.length;i++){
                                obj = $$mediaMap.createMedia(json.mdaLst[i]);
                                _searchesongs.save(obj.getKey(),obj);
                            }
                        } else {
                             _state.noresultfound = true;
                        }
                        break;
                    //case OTYPES.ACTION_MEDIA_SEARCH_RESULT:
                    //    if ( json.sucs === true ) {
                    //        for(i=0;i<json.sgstn.length;i++){
                    //            mediaSearchResult.push(json.sgstn[i]);
                    //        }
                    //    }else{
                    //
                    //    }
                    //    break;

                    //case  OTYPES.ACTION_MEDIA_LIKE_LIST:
                        //if (json.sucs === true && json.likes) {
                            //mediaMap = getMediaMap(json.cntntId);
                            //if(mediaMap) {
                                //mediaMap.pushLikes(json);
                            //} else {
                                //RingLogger.warning('mediaMap not found in albums contents list' + json.mg, RingLogger.tags.MEDIA);
                            //}

                        //} else {
                            //RingLogger.warning('MEDIA LIKE LIST FETCH FAIL: ' + json.mg, RingLogger.tags.MEDIA);
                        //}
                        //break;

                    // case  OTYPES.ACTION_MEDIA_COMMENT_LIST:
                    //     if(json.sucs === true && json.comments) {
                    //         mediaMap = getMediaMap(json.cntntId);
                    //         if(mediaMap) {
                    //             mediaMap.pushComments(json);
                    //         } else {
                    //             RingLogger.information(': mediaMap not found in albums contents list',  RingLogger.tags.MEDIA);
                    //         }
                    //     } else {
                    //         RingLogger.warn('MEDIA COMMENT LIST FETCH FAIL' + json.mg, RingLogger.tags.MEDIA);
                    //     }
                    //     break;
                    default:
                        RingLogger.warning('MEDIA _processResponse json.actn did not match', RingLogger.tags.MEDIA);
                }

            }



            function _subscribeMediaData (actions) {
                if(actions && actions.length > 0) {
                    // return subscription key
                    return  $$connector.subscribe(_processResponse, {
                        action: actions
                    });

                }
                subscriptionKey = $$connector.subscribe(_processResponse, {
                    action:  [
                        //OTYPES.ACTION_MEDIA_ALBUM_LIST,
                        //OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST,
                        OTYPES.ACTION_SPECIFIC_MEDIA_RESULT,
                        OTYPES.ACTION_GET_TAGGED_MEDIA_SONGS,
                        OTYPES.ACTION_MEDIA_SEARCH_RESULT
                    ]
                });

            }

            function fetchAllAlbums (utId) {
                utId = utId || (Auth.currentUser() ? Auth.currentUser().getUtId() : false);
                if (utId) {
                    // fetch audio albums
                    mediaHttpService.fetchMediaAlbums({utId: utId,
                                                      mdaT: AC.NEWS_FEED_MEDIA_TYPE_AUDIO });
                    setTimeout(function() {
                        // fetch video albums
                        mediaHttpService.fetchMediaAlbums({utId: utId,
                                                          mdaT: AC.NEWS_FEED_MEDIA_TYPE_VIDEO });
                    }, 200);

                }
            }

            _subscribeMediaData();
            fetchAllAlbums();
            $rootScope.$on(SystemEvents.AUTH.LOGIN, function() {
                setTimeout(fetchAllAlbums, 5000);
            });

            return {
                state: function() {
                    return _state;
                },
                getAlbum: function(albumId) {
                    albumId = parseInt(albumId);
                    return _albums.get(albumId) || _userAlbums.get(albumId); // || _albumList[albumId]; //_albums.get(albumId) || _userAlbums.get(albumId);
                },
                fetchAllAlbums: function(utId, albumType) {
                     _state.mediaLoading = true;
                    _utId = utId;

                    if (!albumType) {
                        fetchAllAlbums(_utId);
                    }
                    else if (albumType === 'audio') {
                        // fetch only one type i.e. audio / video albums
                        mediaHttpService.fetchMediaAlbums({utId: utId,
                                                          mdaT: AC.NEWS_FEED_MEDIA_TYPE_AUDIO });
                    } else if (albumType === 'video') {
                        // fetch only one type i.e. audio / video albums
                        mediaHttpService.fetchMediaAlbums({utId: utId,
                                                          mdaT: AC.NEWS_FEED_MEDIA_TYPE_VIDEO });
                    }
                },
                createAlbum: function(albumObj, newAlbum) {
                    var albumMap, defer;

                    if (newAlbum) {
                        albumObj.id =  utilsFactory.getUniqueID();
                        defer = $q.defer();
                    }
                    albumMap = $$mediaAlbumMap.createAlbum(albumObj);
                    //_albumList[albumMap.getKey()] = albumMap;
                    _albums.save(albumMap.getKey(), albumMap);

                    if(newAlbum) {
                        mediaHttpService.addMediaAlbum(albumObj).then(function(json) {
                            RingLogger.print(angular.toJson(json), RingLogger.tags.MEDIA);
                            if(json.sucs === true) {
                                albumMap.updateAlbum({id: json.albId});
                                //_albumList[albumMap.getKey()] = albumMap;
                                if (newAlbum) {
                                    defer.resolve(albumMap);
                                }
                            } else {
                                _albums.remove(albumObj.id);
                                RingLogger.warning('CREATE NEW ALBUM FAILED: ' + json.mg, RingLogger.tags.MEDIA);
                                if (newAlbum) {
                                    defer.reject();
                                }
                            }
                        });
                    }
                    if (newAlbum) {
                        return defer.promise;
                    } else {
                        return albumMap;
                    }
                },
                deleteAlbum: function(albumMap) {
                    mediaHttpService.deleteAlbum(albumMap.getId()).then(function(json) {
                        RingLogger.print(angular.toJson(json), RingLogger.tags.MEDIA);
                        if(json.sucs === true) {
                            _albums.remove(albumMap.getKey());
                            //delete _albumList[albumMap.getKey()];
                        } else {
                            RingLogger.warn('Delete Album  Failed: ' + json.mg, RingLogger.tags.MEDIA);
                        }
                    });
                },
                fetchAlbumContents: function(obj) {
                     _state.mediaContentLoading = true;
                    mediaHttpService.fetchAlbumContents(obj);
                },

                fetchAlbumContentsForpopup: function(obj) {
                     _state.mediaContentLoading = true;
                    return mediaHttpService.fetchAlbumContentsForpopup(obj);
                },
                // fetchLikeList: function(mediaMap) {
                //     var deferred = $q.defer();
                //     //var subKey =  _subscribeMediaData([
                //         //OTYPES.ACTION_MEDIA_LIKE_LIST
                //     //]);
                //     //return subKey;

                //     mediaHttpService.likeList(mediaMap.getId(),mediaMap.getFeedKey()).then(function(json) {
                //         if (json.sucs === true) {
                //             deferred.resolve();
                //         } else {
                //             deferred.reject();
                //         }
                //     }, function() {
                //         deferred.reject();
                //     }, function(json) {
                //         RingLogger.print(json, RingLogger.tags.MEDIA);
                //         mediaMap.pushLikes(json);
                //     });
                //     //mediaHttpService.commentList(contentId);

                //     return deferred.promise;
                // },
                resetMediaAlbums: function() {
                    _userAlbums.reset();
                     //$$connector.unsubscribe(subscriptionKey);
                },
                getUserAlbums: function(type) {
                    if (type) {
                        return mapFilterFilter(_userAlbums.all(), {mapApi: 'getType', value: type, compare:'regex'});
                    } else {
                        return _userAlbums;
                    }
                },
                getAlbums: function(type) {
                    if (type) {
                        return mapFilterFilter(_albums.all(), {mapApi: 'getType', value: type, compare:'regex'});
                    } else {
                        return _albums;
                    }
                },
                getSearchedSongs: function () {
                    return _searchesongs;
                },
                getSearchedAlbums: function () {
                    return _searchedAlbums;
                },
                getContentIdArray: function () {
                    return contentIdArray;
                },
                resetContentIdArray: function () {
                    contentIdArray = [];
                },
                getAlbumIdArray: function () {
                    return albumIdArray;
                },
                resetAlbumIdArray: function () {
                    albumIdArray = [];
                },
                getSearchedTagArr : function () {
                    return searchedTagArr;
                },
                resetSearchedSongs: function () {
                    return _searchesongs.reset();
                },
                resetSearchedAlbum: function () {
                    return _searchedAlbums.reset();
                },
                resetSearchedTagArr : function () {
                    searchedTagArr = [];
                },
                getSearchTrends : function () {
                   return mediaHttpService.getSearchTrends();
                },
                getTaggedMedia : function (obj) {
                   mediaHttpService.getTaggedMedia(obj);
                },
                fetchSearchResult: function(param) {
                      return mediaHttpService.fetchSearchResult(param);
                },
                fetchHashtagSuggestion: mediaHttpService.fetchHashtagSuggestion,
                fetchContent: function(param) {
                     _state.noresultfound = false;
                    return mediaHttpService.fetchContent(param);
                },
                fetchContentDetails: function(cntntId, forPopup, user, utid) {
                    // if forPopup is true then need to create album. otherwise in profiles media tab and album is already created
                    var defer = $q.defer(), albumMap, mediaMap,reqData = {cntntId: cntntId};

                    if(user){
                        reqData.utId = user.getUtId();
                    }
                    if(utid) {
                        reqData.utId = utid;
                    }
                    // fetch content detail
                    mediaHttpService.fetchContentDetails(reqData).then(function(json) {
                        RingLogger.print(json, RingLogger.tags.MEDIA);
                        if (!user && Auth.currentUser().getUtId() === json.utId) {
                            user = Auth.currentUser();
                        }

                        if (json.sucs === true) {
                            if ( !!json.mdaCntntDTO ) {
                                var albumid = json.mdaCntntDTO.albId;
                                var mdatype = json.mdaCntntDTO.mdaT;
                                var alname = json.mdaCntntDTO.albn;
                            }else{
                                defer.reject(json);
                                Ringalert.show('Content Not Found','info');
                                return;
                            }
                            // create album

                            //albumMap = _albumList[albumid] || false;
                            if(!albumMap){
                                albumMap = $$mediaAlbumMap.createAlbum({albId: albumid, mdaT: mdatype, albn: alname});
                                _albums.save(albumMap.getKey(), albumMap);
                                //_albumList[albumMap.getKey()] = albumMap;
                            }

                            //RECENT MEDIA SECTION : data saved to localstorage for recent media
                            var t = new Date(), arrIndex;
                            var mediaObj = {
                                ac:json.mdaCntntDTO.ac,
                                albId:json.mdaCntntDTO.albId,
                                albn:json.mdaCntntDTO.albn,
                                cntntId:json.mdaCntntDTO.cntntId,
                                mdaT:json.mdaCntntDTO.mdaT,
                                strmURL:json.mdaCntntDTO.strmURL,
                                thmbURL:json.mdaCntntDTO.thmbURL,
                                ttl:json.mdaCntntDTO.ttl,
                                utId:json.utId,
                                viewtime: t.getTime()
                            };
                            mediaRecent = Storage.getData('mediaRecent');
                            if(mediaRecent.length > 0){

                                for(var i = 0; i < mediaRecent.length; i++) {
                                    if (mediaRecent[i].cntntId === json.mdaCntntDTO.cntntId) {
                                        arrIndex = i;
                                    }
                                }
                                if( arrIndex ) {
                                    mediaRecent.splice(arrIndex,1);
                                    mediaRecent.push(mediaObj);
                                    if(mediaRecent.length > 6){
                                        mediaRecent.shift();
                                    }
                                }else {
                                    mediaRecent.push(mediaObj);
                                }
                            }else{
                                mediaRecent.push(mediaObj);
                            }
                            Storage.setData('mediaRecent',mediaRecent);

                            //RECENT MEDIA SECTION : data saved to localstorage for recent media


                            mediaMap = albumMap.pushContent(
                                [angular.extend(json.mdaCntntDTO, {utId: json.utId, cntntId: json.cntntId})], user);
                                // albumMap.pushContents returnes a stackedmap array of pushed media contents. in this case we are pushing just one and gettting that in the resolve
                            defer.resolve(mediaMap.top());
                        } else {
                            defer.reject(json);
                            Ringalert.show(json.mg,'info');
                        }
                    });

                    return defer.promise;
                    // fetch content likes
                    // fetch content comments
                }
            };
        }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .directive('rgMedia', rgMedia);


        rgMedia.$inject = ['$window', '$document', 'Media', '$routeParams'];
        function rgMedia($window, $document, Media, $routeParams) { // jshint ignore:line

            MediaController.$inject = ['profileFactory', 'Auth', 'fileUploadService', 'SystemEvents', '$rootScope', '$scope', 'Media', '$location',
                'OPERATION_TYPES', '$$connector', 'utilsFactory', 'userFactory', '$$mediaAlbumMap', '$$stackedMap', 'mapFilterFilter'];
            function MediaController (profileFactory, Auth, fileUploadService, SystemEvents, $rootScope, $scope, Media, $location,
                                      OPERATION_TYPES, $$connector, utilsFactory, User, $$mediaAlbumMap, $$stackedMap, mapFilterFilter) { //jshint ignore:line

                var subscriptionKey,
                    _albums = $$stackedMap.createNew(),
                    albumTimeout,
                    contentTimeout,
                    uploadProgress = false,
                    OTYPES = OPERATION_TYPES.SYSTEM.MEDIA,
                    currentUser = profileFactory.getProfile($routeParams.uId);

                $scope.showMediaPreview = false;
                $scope.activeAlbum = null;

                $scope.state = {
                    noresultfound: false,
                    contentsLoading : false,
                    albumsLoading : false
                };

                // INITIALIZE
                // this subscribes and requests data
                subscriptionKey = $$connector.subscribe(function(json) {
                    var i, _albumOwner, l, album;
                    switch(json.actn) {
                        case OTYPES.ACTION_MEDIA_ALBUM_LIST:
                            //setTimeout(function() {
                                if(json.sucs === true && json.mediaAlbumList) {
                                    _albumOwner = (Auth.currentUser().getUtId() === json.utId) ? Auth.currentUser() : User.create({utId: json.utId});
                                    for(i = 0, l = json.mediaAlbumList.length; i < l; i++) {
                                        album = $$mediaAlbumMap.createAlbum(json.mediaAlbumList[i], _albumOwner);
                                        _albums.save(album.getKey(), album);
                                    }
                                } else {
                                    RingLogger.warning('ALBUM LISTFETCH FAIL: '+json.mg, RingLogger.tags.MEDIA);
                                }
                                toggleLoading(false, 'album');
                                RingLogger.information('MEDIAALBUMLOADING DONE', RingLogger.tags.MEDIA);
                            //});
                            break;
                        case OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST:
                            //setTimeout(function() {
                                if(json.sucs === true && json.mdaCntntLst) {
                                    var key = $$mediaAlbumMap.createKey(json);
                                    album = _albums.get(key);  // || _albumList[key];
                                    if(album) {
                                        RingLogger.information(json.mdaCntntLst.length + ' CONTENT ADDED to album: ' + album.getKey(), RingLogger.tags.MEDIA);
                                        album.pushContent(json.mdaCntntLst);
                                    } else {
                                        RingLogger.warning('No Albumap Found. You left profile page and useralbum list got reset: ',  RingLogger.tags.MEDIA);
                                    }
                                } else {
                                    RingLogger.warning('ALBUM CONTENT FETCH FAIL: ' + json.mg, RingLogger.tags.MEDIA);
                                }
                                toggleLoading(false);
                                RingLogger.information('MEDIACCONTENTSLOADING DONE: ' + $scope.activeAlbum.getContents().length(), RingLogger.tags.MEDIA);
                            //}, 400);
                            break;
                    }

                }, {
                    action:  [
                        OTYPES.ACTION_MEDIA_ALBUM_LIST,
                        OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST,
                    ]
                });

                function toggleLoading(bool, type) {
                    if (type === 'album') {
                        clearTimeout(albumTimeout);
                        $scope.state.albumsLoading = bool;
                    } else {
                        clearTimeout(contentTimeout);
                        $scope.state.contentsLoading = bool;
                    }
                    $scope.$digest();
                }

                toggleLoading(true, 'album');
                if(currentUser.isCurrentUser()) { // jshint ignore:line
                    //$scope.getAlbums = Media.getAlbums;
                    Media.fetchAllAlbums();
                } else {
                    Media.fetchAllAlbums(currentUser.getUtId());
                    //$scope.getAlbums = Media.getUserAlbums;
                }
                albumTimeout = setTimeout(function() {
                    toggleLoading(false, 'album');
                }, 5000);

                if ($routeParams.albumId) {
                    toggleLoading(true);
                    $scope.showMediaPreview = false;
                    var albumMap, intervalCount = 0;
                    RingLogger.information('Fetch album details and show album contents: ' + $routeParams.albumId, RingLogger.tags.MEDIA);
                    var interval = setInterval(function() {
                        intervalCount++;
                        albumMap = _albums.get($routeParams.albumId);
                        if (albumMap) {
                            clearInterval(interval);
                            showAlbumContents(albumMap);
                        } else if (intervalCount > 12) {
                            clearInterval(interval);
                        }
                    }, 400);

                    $scope.$rgDigest();
                } else {
                    $scope.showMediaPreview = true;
                }


                $scope.getAlbums = function(type) {
                    if (type) {
                        return mapFilterFilter(_albums.all(), {mapApi: 'getType', value: type, compare:'regex'});
                    } else {
                        return _albums;
                    }
                };

                $scope.deleteMedia =  function(mediaMap) {
                    Media.deleteMedia(mediaMap);
                };

                $scope.goToAlbum = function(event, mediaMap) {
                    event.stopPropagation();
                    //$location.path(mediaMap.link(currentUser, true));
                    window.location = mediaMap.link(currentUser);
                };


                $scope.enableAlbumPreview = function() {
                    window.location = utilsFactory.getRingRoute('USER_PROFILE', { uId : currentUser.getUId(), utId : currentUser.getUtId(), subpage: 'media'});
                    //if (!uploadProgress) {
                        //$scope.showMediaPreview = true;
                        //$scope.activeAlbum = null;
                    //}
                    //$scope.$rgDigest();
                };


                $scope.getMediaData = function(mediaMap, album) {
                    return {
                            data: function () {
                                return {
                                    media: mediaMap,
                                    album: album,
                                    popupForm: 'profile'
                                };
                            },
                            promise: Media.fetchContentDetails(mediaMap.getKey(), true, currentUser)
                        };
                };


                $scope.uploadAction = function() {
                    uploadProgress = true;
                };

                $rootScope.$on(SystemEvents.FILE_UPLOAD.QUEUE_COMPLETE, function() {
                    // add new files to activeAlbum
                    if(uploadProgress) {
                        uploadProgress = false;
                        // post newly uploaded files to album
                        $scope.activeAlbum.addNewContent();
                        $scope.$rgDigest();
                    }
                });

                $scope.loadMoreImage = function() {
                    var contentLength = $scope.activeAlbum.getContents().length();
                    var totalContentLength = $scope.activeAlbum.getContentCount();
                    if ($scope.activeAlbum && contentLength < totalContentLength ) {
                        toggleLoading(true);
                        RingLogger.information('FETCH MORE MEDIA CONTENT: ', RingLogger.tags.MEDIA );
                        Media.fetchAlbumContents({
                            albId: $scope.activeAlbum.getKey(),
                            utId: currentUser.getUtId(), // optional. maybe without utid just own media album list fetch
                            st: contentLength
                        });

                        contentTimeout = setTimeout(function() {
                            toggleLoading(false);
                        }, 5000);
                    } else {
                        toggleLoading(false);
                    }
                };

                function showAlbumContents (albumMap) {
                    if(albumMap && !uploadProgress) {
                        $scope.activeAlbum  = albumMap;
                        $scope.loadMoreImage();
                        $scope.showMediaPreview = false;
                    } else {
                        $scope.showMediaPreview = true;
                        $scope.activeAlbum = null;
                    }
                    // load contents likes, comments etc
                    // disabled cause too many calls. for each media item one for likelist and one for commentList
                    //Media.fetchAlbumContentDetails(albumMap);
                }


                $scope.$on('$destroy', function() {
                    // reset and unsubscribe media albums
                    $$connector.unsubscribe(subscriptionKey );
                    Media.resetMediaAlbums();
                });

            }


            var linkFunc = function(scope) {
                //var contentLength = 0, totalContentLength = 0;
                function handleScroll () {
                    if (!scope.showMediaPreview) {
                        if ( ($window.innerHeight + $window.scrollY) >= $document[0].body.offsetHeight ) {
                            scope.loadMoreImage();
                        }
                    }
                }

                $window.addEventListener('scroll', handleScroll);
                scope.$on('$destroy', function() {
                    $window.removeEventListener('scroll', handleScroll);
                });

            };

            return {
                restrict: 'E',
                controller: MediaController,
                link: linkFunc,
                templateUrl: 'pages/partials/media.html'
            };
        }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .directive('rgMediaSearch', rgMediaSearch);

    rgMediaSearch.$inject = [ '$document', 'Media', '$routeParams' ];
    function rgMediaSearch( $document, Media, $routeParams ) { // jshint ignore:line

        MediaSearchController.$inject = ['$$stackedMap','$$connector','$$mediaMap','settings','Storage', 'OPERATION_TYPES','Auth', '$scope', 'Media','userFactory','$$mediaAlbumMap','$location' ];
        function MediaSearchController ($$stackedMap,$$connector, $$mediaMap,settings ,Storage, OPERATION_TYPES,Auth, $scope, Media,userFactory,$$mediaAlbumMap,$location ) { //jshint ignore:line

            var albumname = [];
            Storage.setData('albumname',albumname);
            $scope.medias = $$stackedMap.createNew(true,'desc');
            $scope.popupmedias = $$stackedMap.createNew(true,'desc');

            var OTYPES = OPERATION_TYPES.SYSTEM.MEDIA;

            $scope.searchedMedia = $$stackedMap.createNew();
            $scope.trendingArr = [];
            $scope.nodatafound = false;
            $scope.noaudiofound = false;

            //var uploadProgress = false;

            var userMap = Auth.currentUser();
            $scope.utId =  userMap.getUtId();
            Media.fetchAllAlbums();

            var mediaArr = Storage.getData('mediaRecent');

            for( var i = 0; i<mediaArr.length; i++ ) {
                var media = $$mediaMap.createMedia(mediaArr[i]);
                $scope.medias.save(media.getKey(),media);
            }

            $scope.getMediaData = function(mediaMap) {
                var albumObj = {
                    albn:mediaMap.getAlbumName(),
                    id:mediaMap.getAlbumId(),
                    //mc:obj.mdc || obj.mc,
                    //mdaT:obj.mdaT,
                    utId:mediaMap.getMediaUtId()
                };
                var mediaObj = {
                    ac: mediaMap.getViewCountOnly(),
                    cntntId: mediaMap.getId(),
                    strmURL: mediaMap.getStreamUrl(),
                    ttl: mediaMap.getCaption()
                };
                var albumowner = userFactory.create({utId: albumObj.utId});
                var useralbum = $$mediaAlbumMap.createAlbum(albumObj,albumowner);
                useralbum.pushContent([mediaObj]);

                return {
                    data: function () {
                        return {
                            media: mediaMap,
                            album: useralbum
                            //popupForm: 'profile'
                        };
                    },
                    promise: Media.fetchContentDetails( mediaMap.getKey(), true, albumowner, mediaMap.getMediaUtId() )
                };
            };

            $scope.recentMedias = function() {
                var mediaArr = Storage.getData('mediaRecent');

                for( var i = 0; i<mediaArr.length; i++ ) {
                    var media = $$mediaMap.createMedia(mediaArr[i]);
                    $scope.medias.save(media.getKey(),media);
                }
                return $scope.medias;
            };

            $scope.getTaggedMedia = function (obj) {
                Media.getTaggedMedia(obj);
            };

            $scope.goToMyAlbums = function (param) {
              var path = 'media/'+param;
                $location.path(path);
            };

            $scope.goToAlbum = function( obj ) {
                var url;
                albumname.push(obj.name);
                albumname.push(obj.mc);
                Storage.setData('albumname',albumname);
                switch ( obj.type ) {
                    case 'audio':
                        url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
                        $location.path(url);
                        break;
                    case 'video':
                        url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
                        $location.path(url);
                        break;
                    default :
                        url = 'media';
                        $location.path(url);
                        break;
                }
            };
            var subscriptionKey = $$connector.subscribe(mediaSearchResult, {
                action:  [OTYPES.ACTION_MEDIA_ALBUM_LIST] // search contact
            });

            var musicArrayMap = {};

            function mediaSearchResult( data ){
                var i;
                switch ( data.actn ) {
                    case OTYPES.ACTION_MEDIA_ALBUM_LIST :
                        if( data.sucs===true ) {
                            for(i = 0; i< data.mediaAlbumList.length; i++){
                                var anMediaAlbumObject = data.mediaAlbumList[i];
                                musicArrayMap[anMediaAlbumObject.id] = anMediaAlbumObject;
                            }
                            var keys = Object.keys(musicArrayMap);
                            var val;
                            var audioArray = [];
                            var videoArray = [];
                            for ( i = 0; i < keys.length; i++) {
                                val = musicArrayMap[keys[i]];
                                if(val.mdaT === 1) {
                                    if(val.imgURL){
                                        val.imgURL=settings.imBase+val.imgURL;
                                    }else{
                                        val.imgURL='';
                                    }
                                    audioArray.push(val);
                                }else{
                                    if(val.imgURL){
                                        val.imgURL=settings.imBase+val.imgURL;
                                    }else{
                                        val.imgURL='';
                                    }
                                    videoArray.push(val);
                                }
                            }
                            $scope.audioAlbum = audioArray;
                            $scope.videoAlbum = videoArray;
                        }else{
                            if( data.mdaT===1 ){
                                $scope.noaudiofound = true;
                            }
                            if( data.mdaT===2 ){
                                $scope.novideofound = true;
                            }
                        }

                        break;
                    //case OTYPES.ACTION_GET_TRENDING_KEYWORDS :
                        //console.log('asbe na');
                        //break;
                    default :
                        break;
                }
                $scope.$rgDigest();

            }

            Media.getSearchTrends().then(function(data){
                if ( data.sucs === true ) {
                    for( i = 0; i < data.sgstn.length; i++) {
                        //console.log(data.sgstn[i]);
                        switch (data.sgstn[i].sugt){
                            case 1 :
                                data.sgstn[i].searchtype = 'songs';
                                break;
                            case 2 :
                                data.sgstn[i].searchtype = 'albums';
                                break;
                            case 3 :
                                data.sgstn[i].searchtype = 'tags';
                                break;
                        }
                        $scope.trendingArr.push(data.sgstn[i]);
                    }
                }
                $scope.$rgDigest();
            });


            $scope.$on('$destroy', function() {
                $scope.trendingArr = [];
                Media.resetMediaAlbums();
                $$connector.unsubscribe(subscriptionKey);
            });
        }

        var linkFunc = function(scope,element) {
            element.bind('click',function(){
               //console.log(scope.medias.all());
            });
            //var input = element.find('input');
            //
            //input.on('keypress', function(event) {
            //    if(event.keyCode === 13) {
            //        event.preventDefault();
            //    }
            //});

        };

        return {
            restrict: 'E',
            controller: MediaSearchController,
            link: linkFunc,
            templateUrl: 'pages/partials/media-search.html'
        };
    }
})();

/**
 * Created by User on 23-Jan-16.
 */
/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .directive('rgMediaSearchDirective', rgMediaSearchDirective);

    rgMediaSearchDirective.$inject = [ '$document', 'Media' ];
    function rgMediaSearchDirective( $document, Media ) { // jshint ignore:line

        searchDirectiveController.$inject = ['OPERATION_TYPES', '$scope', 'Media','$location','rgScrollbarService','GlobalEvents' ];
        function searchDirectiveController (OPERATION_TYPES, $scope, Media,$location,rgScrollbarService,GlobalEvents ) { //jshint ignore:line

            var OTYPES = OPERATION_TYPES.SYSTEM.MEDIA;

            var self = this;

            $scope.showDropdown = false;
            $scope.stoploader = false;

            $scope.searchResult = [];

            $scope.doSearch = function () {
                $scope.searchResult = [];
                $scope.stoploader = false;

                if( !$scope.searchParam ) {
                    $scope.showDropdown = false;
                }else{
                    //Media.fetchSearchResult( $scope.searchParam );
                    Media.fetchSearchResult( $scope.searchParam ).then(mediaSearchResultProcess);
                    $scope.showDropdown = true;
                }
                GlobalEvents.bindHandler('document', 'click', self.closeDropdown);
            };

            $scope.doContentSearch = function ( obj ) {
                var searchurl;
                $scope.showDropdown = false;
                switch ( obj.sugt ) {
                    case 1 :
                        searchurl = 'media/songs/'+obj.sk;
                        $location.path(encodeURI(searchurl));
                        break;
                    case 2 :
                        searchurl = 'media/albums/'+obj.sk;
                        $location.path(encodeURI(searchurl));
                        break;
                    case 3 :
                        searchurl = 'media/tags/'+obj.sk;
                        $location.path(encodeURI(searchurl));
                        break;
                }

            };

            self.closeDropdown = function() {
                // close dropdown
                $scope.searchParam = '';
                $scope.showDropdown = false;
                GlobalEvents.unbindHandler('document', 'click', self.closeDropdown);
                $scope.$rgDigest();
            };



            function mediaSearchResultProcess(data){
                var i;
                switch (data.actn) {

                    case OTYPES.ACTION_MEDIA_SEARCH_RESULT :
                        if ( data.sucs === true ) {
                            $scope.showDropdown = true;
                            for(i=0;i<data.sgstn.length;i++){
                                //console.log(data.sgstn[i]);
                                $scope.searchResult.push(data.sgstn[i]);
                            }
                            //console.log($scope.searchResult);
                            //rgScrollbarService.recalculate();
                        }else{
                            $scope.stoploader = true;
                        }
                        rgScrollbarService.recalculate($scope);
                        break;
                    default :
                        break;

                }
                $scope.$rgDigest();

            }

        }

        var linkFunc = function(scope,element) {
            element.bind('click',function(){
                //console.log(scope.medias.all());
            });
            var input = element.find('input');

            input.on('keypress', function(event) {
                if(event.keyCode === 13) {
                    scope.doSearch();
                }
            });

        };

        return {
            restrict: 'E',
            controller: searchDirectiveController,
            link: linkFunc,
            templateUrl: 'pages/mediasearch/media-search-directive.html'
        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .controller('mSearchResultController',mSearchResultController);

        mSearchResultController.$inject = [ 'Auth','Storage', 'userFactory', '$routeParams', '$$mediaAlbumMap', '$scope', 'Media','$location','$$connector','OPERATION_TYPES'];
        function mSearchResultController (  Auth,Storage, userFactory, $routeParams, $$mediaAlbumMap, $scope, Media,$location,$$connector,OPERATION_TYPES ) {


            var albumname = [];
            Storage.setData('albumname',albumname);
            $scope.stype = $routeParams.stype;
            $scope.searchkey = decodeURI($routeParams.sk);
            var sugt;
            var OTYPES = OPERATION_TYPES.SYSTEM.MEDIA;


            switch ($routeParams.stype) {
                case 'songs':
                    sugt =1;
                    break;
                case 'albums':
                    sugt = 2;
                    break;
                case 'tags':
                    sugt = 3;
                    break;
                default :
                    sugt=1;
                    break;
            }

            $scope.showSearchDropdown = false;

            var userMap = Auth.currentUser();

            $scope.searchsongsection = false;
            $scope.searchalbumsection = false;
            $scope.searchtagsection = false;
            $scope.noresultsection = false;
            Media.resetSearchedSongs();
            Media.resetSearchedAlbum();
            Media.resetSearchedTagArr();


            if ( $scope.stype !== 'tag' ) {
                var obj = {
                    sk:$scope.searchkey,
                    sugt:sugt
                };
                Media.fetchContent( obj );
            }

            switch ( $scope.stype ) {
                case 'songs' :
                    $scope.searchsongsection = true;
                    break;
                case 'albums' :
                    $scope.searchalbumsection = true;
                    break;
                case 'tags' :
                    $scope.searchtagsection = true;
                    break;
                case 'tag' :
                    $scope.searchsongsection = true;
                    if( !isNaN( $scope.searchkey ) ){
                        Media.getTaggedMedia(parseInt($scope.searchkey));
                    }
                    break;
            }


            $scope.searchedSongs = Media.getSearchedSongs;
            $scope.searchedAlbums = Media.getSearchedAlbums;
            $scope.searchedTags = Media.getSearchedTagArr();
            $scope.cntntidarray = Media.getContentIdArray;
            $scope.albumidarray = Media.getAlbumIdArray;
            $scope.state = Media.state();




            $scope.loadMoreSuggestedSongs = function() {
                var reqData = {
                    sk:$scope.searchkey,
                    sugt:sugt,
                    pvtid:$scope.cntntidarray().pop(),
                    scl:2
                };
                Media.fetchContent( reqData );
                Media.resetContentIdArray();
            };

            $scope.loadMoreSuggestedAlbums = function() {
                console.log('load more albums');
                var reqData = {
                    sk:$scope.searchkey,
                    sugt:sugt,
                    pvtid:$scope.albumidarray().pop(),
                    scl:2
                };
                Media.fetchContent( reqData );
                Media.resetAlbumIdArray();
            };




            $scope.getTaggedMedia = function ( obj ) {
                var searchurl = 'media/tag/'+obj.htid;
                $location.path(encodeURI(searchurl));
            };

            $scope.goToAlbum = function( obj ) {
                var url;
                albumname.push(obj.name);
                albumname.push(obj.mc);
                Storage.setData('albumname',albumname);
                switch ( obj.type ) {
                    case 'audio':
                        url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
                        $location.path(url);
                        break;
                    case 'video':
                        url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
                        $location.path(url);
                        break;
                    default :
                        url = 'media';
                        $location.path(url);
                        break;
                }
            };

            $scope.getMediaData = function( mediaMap ) {
                var albumObj = {
                    albn:mediaMap.getAlbumName(),
                    id:mediaMap.getAlbumId(),
                    //mc:obj.mdc || obj.mc,
                    //mdaT:obj.mdaT,
                    utId:mediaMap.getMediaUtId()
                };
                var mediaObj = {
                    ac: mediaMap.getViewCountOnly(),
                    cntntId: mediaMap.getId(),
                    strmURL: mediaMap.getStreamUrl(),
                    ttl: mediaMap.getCaption()
                };
                var albumowner = userFactory.create({utId: albumObj.utId});
                var useralbum = $$mediaAlbumMap.createAlbum(albumObj,albumowner);
                useralbum.pushContent([mediaObj]);
                return {
                    data: function () {
                        return {
                            media: mediaMap,
                            album: useralbum
                            //popupForm: 'profile'
                        };
                    },
                    promise: Media.fetchContentDetails( mediaMap.getKey(), true, albumowner, mediaMap.getMediaUtId() )
                };
            };

            var subscriptionKey = $$connector.subscribe(searchContentProcess, {
                action: [
                    OTYPES.ACTION_SPECIFIC_MEDIA_RESULT,//278
                    OTYPES.ACTION_GET_TAGGED_MEDIA_SONGS//279
                ]
            });

            function searchContentProcess(data) {
                console.log(data);
                if(data.sucs===true){

                }else{
                    console.log('no data found');
                }
                $scope.$rgDigest();
            }

            $scope.$on('$destroy', function() {
                $$connector.unsubscribe(subscriptionKey);
            });

        }



    })();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .controller('allAlbumTypeController',allAlbumTypeController);

    allAlbumTypeController.$inject = ['$$stackedMap','$$mediaMap','$$mediaAlbumMap','Storage','userFactory','Auth','$routeParams','OPERATION_TYPES','$scope','Media','$location','$$connector','$ringbox','Ringalert'];
    function allAlbumTypeController ( $$stackedMap,$$mediaMap,$$mediaAlbumMap,Storage,userFactory, Auth, $routeParams ,OPERATION_TYPES, $scope, Media,$location,$$connector,$ringbox,Ringalert ) {

        $scope.albumName = Storage.getData('albumname')[0];
        $scope.mediaCount = Storage.getData('albumname')[1];
        $scope.albumtype = $routeParams.albumtype;
        $scope.utid = $routeParams.utid;
        $scope.albumid = $routeParams.albumid;
        $scope.songsArray = [];
        $scope.songs = $$stackedMap.createNew();
        $scope.popupmedias = $$stackedMap.createNew();
        $scope.myAlbumsMap = $$stackedMap.createNew();
        var OTYPES = OPERATION_TYPES.SYSTEM.MEDIA;
        $scope.userallalbum = false;
        $scope.showSearchDropdown = false;
        $scope.stoploader = false;
        $scope.loadMoreSong = false;
        var mdaType;

        //var albumOwner = (Auth.currentUser().getUtId() ===  $scope.utid) ? Auth.currentUser() : User.create({utId: json.utId});

        if ( !$routeParams.utid && !$routeParams.albumid ) {

            var currentUser = Auth.currentUser();
            $scope.utid = currentUser.getUtId();
            if($routeParams.albumtype === 'audio'){
                mdaType = 1;
            }else if($routeParams.albumtype === 'video'){
                mdaType = 2;
            }else{
                $location.path('media');
            }
            Media.fetchAllAlbums($scope.utid,$scope.albumtype);
            //$scope.useralbumlist = Media.getAlbums($scope.albumtype);
            $scope.userallalbum = true;
        }
        if ( isNaN($scope.utid) && isNaN($scope.albumid) ) {
            $location.path('media');
        }

        $scope.goToAlbum = function( obj ) {
            var url;
            var albumname = [];
            albumname.push(obj.name);
            albumname.push(obj.mc);
            Storage.setData('albumname',albumname);
            switch ( obj.type ) {
                case 'audio':
                    url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
                    $location.path(url);
                    break;
                case 'video':
                    url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
                    $location.path(url);
                    break;
                default :
                    url = 'media';
                    $location.path(url);
                    break;
            }
        };

        $scope.loadMoreMedia = function (songcount) {
            $scope.loadMoreSong = true;
            Media.fetchAlbumContents({
                albId: $scope.albumid,
                utId: $scope.utid, // optional. maybe without utid just own media album list fetch
                st: songcount
            });
        };

        if( $scope.utid && $scope.albumid ){
            Media.fetchAlbumContents({
                albId: $scope.albumid,
                utId: $scope.utid // optional. maybe without utid just own media album list fetch
            });
            $scope.albumMap = $$mediaAlbumMap.createAlbum({
                albn: $scope.albumName, // album name
                albId: $scope.albumid,
                //mdaT:have to use conditionaly
                utId: $scope.utid // owner user utid
            });
        }

        $scope.mediaPlayerPopup = function (obj,mediaMap) {

            var albumObj = {
                albn:obj.getName(),
                id:mediaMap.getAlbumId(),
                //mc:obj.mdc || obj.mc,
                //mdaT:obj.mdaT,
                utId:mediaMap.getMediaUtId()
            };
            var mediaObj = {
                ac: mediaMap.getViewCountOnly(),
                cntntId: mediaMap.getId(),
                strmURL: mediaMap.getStreamUrl(),
                ttl: mediaMap.getCaption()
            };
            var albumowner = userFactory.create({utId: albumObj.utId});
            var useralbum = $$mediaAlbumMap.createAlbum(albumObj,albumowner);
            useralbum.pushContent([mediaObj]);

             $ringbox.open({

                    type : 'remote',
                    scope:false,
                    controller: 'RingBoxMediaController',
                    resolve : {
                        localData : {
                            media : mediaMap,
                            album : useralbum
                        },
                        remoteData : function(){
                            return Media.fetchContentDetails( mediaMap.getKey(), true, albumowner, mediaMap.getMediaUtId() )
                        }
                    },
                    templateUrl : 'pages/partials/notification/media-popup.html'
             });


        //============================please dont delete/maybe needed later :P====================================
        //    var albumObj = {
        //        albn:$scope.albumName,
        //        id:obj.getId(),
        //        //mc:obj.mdc || obj.mc,
        //        //mdaT:obj.mdaT,
        //        utId:obj.getALbumUtId()
        //    };
        //    console.log(albumObj);
        //    var reqData = {
        //        albId:parseInt(albumObj.id),
        //        utId:parseInt(albumObj.utId)
        //    };
        //    var albumowner = userFactory.create({utId: albumObj.utId});
        //    var albumutid = obj.getALbumUtId();
        //    $scope.popupmedias.reset();
        //    var useralbum = $$mediaAlbumMap.createAlbum(albumObj,albumowner);
        //    Media.fetchAlbumContentsForpopup(reqData).then(function(data){
        //        if( data.sucs===true ) {
        //            for(var i=0;i<data.mdaCntntLst.length;i++) {
        //                data.mdaCntntLst[i].utId = albumutid;
        //                //data.mdaCntntLst[i].viewtime = new Date().getTime();
        //                var obj = $$mediaMap.createMedia(data.mdaCntntLst[i]);
        //                $scope.popupmedias.save(obj.getKey(),obj);
        //            }
        //
        //            if(useralbum) {
        //                useralbum.pushContent(data.mdaCntntLst);
        //            } else {
        //                RingLogger.warning('No Albumap Found. You left profile page and useralbum list got reset: ',  RingLogger.tags.MEDIA);
        //            }
        //
        //            //var mediaMap = $scope.popupmedias.all()[0].value;
        //            var mediaMap = media.value;
        //            var boxInstance = $ringbox.open({
        //
        //                type : 'remote',
        //                scope:false,
        //                controller: 'RingBoxMediaController',
        //                resolve : {
        //                    localData : {
        //                        media : mediaMap,
        //                        album : useralbum
        //                    },
        //                    remoteData : function(){
        //                        return Media.fetchContentDetails( mediaMap.getKey(), true, albumowner, mediaMap.getMediaUtId() )
        //                    }
        //                },
        //                templateUrl : 'pages/partials/notification/media-popup.html'
        //            });
        //        }else{
        //            //Ringalert.show(data.mg, 'info');
        //        }
        //        $scope.$rgDigest();
        //    });
        //=================================================================================================================
        };

        var albumObj = {
            albn:$scope.albumName,
            id:$scope.albumid,
            utId:$scope.utId
        };

        var albumUser = (Auth.currentUser().getUtId() ===  $scope.utid) ? Auth.currentUser() : userFactory.create({utId: $scope.utid});
        var thealbum = $$mediaAlbumMap.createAlbum(albumObj,albumUser);

        var selectedSongAlbum = $$mediaAlbumMap.createAlbum(albumObj,albumUser);

        var selectedSongMap = {};
        var keys;

        $scope.selectSongs = function (obj, status) {

            if (status) {
                var anMediaObject = obj;
                selectedSongMap[anMediaObject.cntntId] = anMediaObject;
                keys = Object.keys(selectedSongMap);
            } else {
                delete selectedSongMap[obj.cntntId];
                keys = Object.keys(selectedSongMap);
            }

        };

        $scope.shouldOpenRingbox = function () {
            if( !keys || keys.length < 1 ){
                return false;
            }else{
                return true;
            }
        };

        $scope.playSelected = function () {
            var selectedArray = [];
            selectedSongAlbum.getContents().reset();
            if( !keys || keys.length < 1 ){
                Ringalert.show('Please select songs first !', 'info');
                return;
            }
            for (var i = 0; i < keys.length; i++) {
                var songobj = selectedSongMap[keys[i]];
                selectedArray.push(songobj);
            }

            selectedSongAlbum.pushContent(selectedArray);
            var topsongMap = selectedSongAlbum.getContents().all()[0].value;
            topsongMap.setIsAutoPlay(true);

            return {
                data: function () {
                    return {
                        media: topsongMap,
                        album: selectedSongAlbum
                        //popupForm: 'profile'
                    };
                },
                promise: Media.fetchContentDetails( topsongMap.getId(), true, albumUser, topsongMap.getMediaUtId() )
            };
        };

        $scope.playallsongs = function (albumsongs) {

            var topmediaMap = albumsongs.getContents().all()[0].value;
            topmediaMap.setIsAutoPlay(true);
            return {
                data: function () {
                    return {
                        media: topmediaMap,
                        album: albumsongs
                    };
                },
                promise: Media.fetchContentDetails( topmediaMap.getKey(), true, albumUser, topmediaMap.getMediaUtId() )
            };

        };


        $scope.$on('$destroy', function() {
            $$connector.unsubscribe(subscriptionKey);
        });

        var subscriptionKey = $$connector.subscribe(albumContentProcess, {
            action: [
                    OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST,//261
                    OTYPES.ACTION_MEDIA_ALBUM_LIST//256
                ]
        });

        function albumContentProcess(data){
            var i;
            switch (data.actn) {
                case OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST:
                    if( data.sucs === true ){

                        for( i=0;i<data.mdaCntntLst.length;i++ ) {

                            thealbum.pushContent(data.mdaCntntLst);

                            data.mdaCntntLst[i].utId = $scope.utid;
                            var media = $$mediaMap.createMedia( data.mdaCntntLst[i] );
                            $scope.songs.save( media.getKey(),media );
                        }
                        $scope.thealbum = thealbum;
                        $scope.loadMoreSong = false;
                    }else{
                        $scope.loadMoreSong = false;
                        $scope.stoploader = true;
                    }
                    break;
                case OTYPES.ACTION_MEDIA_ALBUM_LIST:
                    if ( data.sucs === true ) {
                        for( i = 0; i < data.mediaAlbumList.length; i++ ) {
                            if( data.mediaAlbumList[i].mdaT===mdaType ){
                                var albumMap = $$mediaAlbumMap.createAlbum( data.mediaAlbumList[i] );
                                $scope.myAlbumsMap.save( albumMap.getKey(), albumMap );
                            }
                        }
                    }else{
                        $scope.stoploader = true;
                    }
                    break;
                default :
                    break;
            }
            $scope.$rgDigest();
        }

    }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social', []);
})();


/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social')
        .service('socialUtils', function() {
            var _self = this;

            _self.camelCase = function(name) {
            return name.replace(/([\:\-\_]+(.))/g, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
                });
            };

            _self.parseQueryString = function(keyValue) {
                var obj = {}, key, value;
                angular.forEach((keyValue || '').split('&'), function(keyValue) {
                    if (keyValue) {
                        value = keyValue.split('=');
                        key = decodeURIComponent(value[0]);
                        obj[key] = angular.isDefined(value[1]) ? decodeURIComponent(value[1]) : true;
                    }
                });
                return obj;
            };

            _self.joinUrl = function(baseUrl, url) {
                if (/^(?:[a-z]+:)?\/\//i.test(url)) {
                    return url;
                }

                var joined = [baseUrl, url].join('/');

                var normalize = function(str) {
                    return str
                        .replace(/[\/]+/g, '/')
                        .replace(/\/\?/g, '?')
                        .replace(/\/\#/g, '#')
                        .replace(/\:\//g, '://');
                };

                return normalize(joined);
            };

            _self.merge = function(obj1, obj2) {
                var result = {};
                for (var i in obj1) {
                    if (obj1.hasOwnProperty(i)) {
                        if ((i in obj2) && (typeof obj1[i] === 'object') && (i !== null)) {
                            result[i] = _self.merge(obj1[i], obj2[i]);
                        } else {
                            result[i] = obj1[i];
                        }
                    }
                }
                for (i in obj2) {
                    if (obj2.hasOwnProperty(i)) {
                        if (i in result) {
                            continue;
                        }
                        result[i] = obj2[i];
                    }
                }
            return result;
        };
    });


})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social')
        .constant('socialConfig', {
            providers: {
                facebook: {
                    name: 'facebook',
                    url: '/auth/facebook',
                    clientId:  '477404429103451',  // ringid
                    authorizationEndpoint: 'https://www.facebook.com/v2.5/dialog/oauth',
                    redirectUri: window.location.origin + '/static-index.html',
                    requiredUrlParams: ['access_code'],
                    scope: ['email'],
                    scopeDelimiter: ',',
                    display: 'popup',
                    type: '2.0',
                    popupOptions: { width: 680, height: 500 }
                },
                twitter: {
                    twitterApiURL: 'https://api.twitter.com/1.1/account/verify_credentials.json',
                    name: 'twitter',
                    url: '/auth/twitter',
                    authorizationEndpoint: 'https://api.twitter.com/oauth/authenticate',
                    redirectUri: window.location.origin + '/static-index.html',
                    //function(whatFor) {
                        //return encodeURIComponent(window.location.origin + '/#/' + whatFor + '/twitter/' );
                    //},
                    type: '1.0',
                    //serverUrl: window.location.protocol + '//' + window.location.hostname+ ':9090/TwiteerLoginService',
                    serverUrl: window.location.origin + '/TwiteerLoginService',

                    popupOptions: { width: 595, height: 745 }
                },
            }
        });

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social')
        .factory('socialPopup', socialPopup);

        socialPopup.$inject = ['$$q', '$interval', '$window', 'socialConfig', 'socialUtils', 'utilsFactory'];
        function socialPopup ($q, $interval, $window, socialConfig, socialUtils, utilsFactory) { // jshint ignore:line
            var Popup = {};

            Popup.url = '';
            Popup.popupWindow = null;

            Popup.open = function(url, name, options) {
                Popup.url = url;

                var stringifiedOptions = Popup.stringifyOptions(Popup.prepareOptions(options));
                var UA = $window.navigator.userAgent;
                var windowName = (socialConfig.cordova || UA.indexOf('CriOS') > -1) ? '_blank' : name;

                Popup.popupWindow = $window.open(url, windowName, stringifiedOptions);

                $window.popup = Popup.popupWindow;

                if (Popup.popupWindow && Popup.popupWindow.focus) {
                    Popup.popupWindow.focus();
                }

                return Popup;
            };

            Popup.eventListener = function(redirectUri) {
                var deferred = $q.defer();

                Popup.popupWindow.addEventListener('loadstart', function(event) {
                    if (event.url.indexOf(redirectUri) !== 0) {
                        return;
                    }


                    var parser = document.createElement('a');
                    parser.href = event.url;

                    if (parser.search || parser.hash) {
                        var queryParams = parser.search.substring(1).replace(/\/$/, '');
                        var hashParams = parser.hash.substring(1).replace(/\/$/, '');
                        var hash = socialUtils.parseQueryString(hashParams);
                        var qs = socialUtils.parseQueryString(queryParams);

                        angular.extend(qs, hash);

                        if (!qs.error) {
                            deferred.resolve(qs);
                        }

                        Popup.popupWindow.close();
                    }
                });

                Popup.popupWindow.addEventListener('loaderror', function() {
                    deferred.reject({rc: 0, mg:'Error Loading Authorization URL'});
                });

                Popup.popupWindow.addEventListener('onbeforeunload' , function() {
                    deferred.reject({rc: 0, mg:'Popup closed unexpectedly'});
                });

                return deferred.promise;
            };

            Popup.pollPopup = function() {
                var deferred = $q.defer();

                var polling = $interval(function() {
                    try {
                        var documentOrigin = document.location.host;
                        var popupWindowOrigin = Popup.popupWindow.location.host;

                        if (popupWindowOrigin === documentOrigin  &&
                            (Popup.popupWindow.location.search ||
                            Popup.popupWindow.location.hash)) {

                            RingLogger.information('calback url: ' + Popup.popupWindow.location, RingLogger.tags.AUTH);

                            var queryParams = Popup.popupWindow.location.search.substring(1).replace(/\/$/, '');
                            var hashParams = Popup.popupWindow.location.hash.substring(1).replace(/[\/$]/, '');
                            var hash = socialUtils.parseQueryString(hashParams);
                            var qs = socialUtils.parseQueryString(queryParams);

                            angular.extend(qs, hash);

                            if (qs.error) {
                                deferred.reject(qs);
                            } else {
                                deferred.resolve(qs);
                            }

                            $interval.cancel(polling);

                            Popup.popupWindow.close();
                        }
                    } catch (error) {
                    // Ignore DOMException: Blocked a frame with origin from accessing a cross-origin frame.
                    }

                    if (!Popup.popupWindow || Popup.popupWindow.closed || Popup.popupWindow.closed === undefined) {
                        $interval.cancel(polling);
                    }
                }, 50);

                return deferred.promise;
            };

            Popup.prepareOptions = function(options) {
                options = options || {};
                //var width = (utilsFactory.viewport.y - 600) || options.width || 500;
                //var height = (utilsFactory.viewport.x - 300) || options.height || 500;
                //width  = (width > 1000) ? 1000 : width;
                //height = (height < 500) ? 500 : height;

                var width =  options.width || 500;
                var height =  options.height || 500;


                return angular.extend({
                    width: width,
                    height: height,
                    left: $window.screenX + (($window.outerWidth - width) / 2),
                    top: $window.screenY + (($window.outerHeight - height) / 2.5)
                }, options);
            };

            Popup.stringifyOptions = function(options) {
                var parts = [];
                angular.forEach(options, function(value, key) {
                    parts.push(key + '=' + value);
                });
                return parts.join(',');
            };

            return Popup;

        }
})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social')
        .factory('socialOauth', socialOauth)
        .factory('socialOauth1', socialOauth1)
        .factory('socialOauth2', socialOauth2);

        socialOauth.$inject = ['socialConfig',  'socialOauth1', 'socialOauth2'];
        function socialOauth(socialConfig, socialOauth1, socialOauth2) { //jshint ignore:line
            var Oauth = {};

            Oauth.authenticate = function(name, credentials) {
                var provider = socialConfig.providers[name].type === '1.0' ? new socialOauth1() : new socialOauth2();
                return provider.open(socialConfig.providers[name], credentials);
            };

            return Oauth;
        }


        socialOauth2.$inject = ['$$q', '$window', 'socialUtils','socialConfig','Storage', 'utilsFactory', 'socialPopup', '$ringhttp'];

        function socialOauth2($q, $window, utils, config, Storage, utilsFactory, socialPopup, $ringhttp) { //jshint ignore:line

            return function() {
                function buildQueryString () {
                    var keyValuePairs = [];
                    var urlParams = ['defaultUrlParams', 'requiredUrlParams', 'optionalUrlParams'];

                    angular.forEach(urlParams, function(params) {

                        angular.forEach(defaults[params], function(paramName) {
                            var camelizedName = utils.camelCase(paramName);
                            var paramValue = angular.isFunction(defaults[paramName]) ? defaults[paramName]() : defaults[camelizedName];
                            keyValuePairs.push([paramName, paramValue]);
                        });
                    });

                    return keyValuePairs.map(function(pair) {
                        return pair.join('=');
                    }).join('&');
                }

                var Oauth2 = {};

                var defaults = {
                    defaultUrlParams: ['response_type', 'client_id', 'redirect_uri'],
                    responseType: 'token', // code or token or both
                    responseParams: {
                        token: 'token',
                        //code: 'code',
                        clientId: 'clientId',
                        redirectUri: 'redirectUri'
                    }
                };

                Oauth2.open = function(options, whatFor) {
                    var defer = $q.defer();

                    //defaults = utils.merge(options, defaults);
                    defaults = angular.extend({}, options, defaults);

                    var url;
                    var openPopup;
                    var stateName = defaults.name + '_state';

                    if (angular.isFunction(defaults.state)) {
                      Storage.setData(stateName, defaults.state());
                    } else if (angular.isString(defaults.state)) {
                      Storage.setData(stateName, defaults.state);
                    }

                    url = [defaults.authorizationEndpoint, buildQueryString(whatFor)].join('?');
                    RingLogger.information('authorization url: ' + url, RingLogger.tags.AUTH);


                    openPopup = socialPopup.open(url, defaults.name, defaults.popupOptions, defaults.redirectUri);
                                    //pollPopup();

                    var interval = setInterval(function() {
                        if (openPopup.popupWindow.closed) {
                            clearInterval(interval);
                            defer.reject({sucs: false, mg: 'Popup Closed unexpectedly!'});
                        }
                    }, 1000);

                    openPopup.pollPopup().then(function(authData) {
                        clearInterval(interval);
                        $ringhttp.get('https://graph.facebook.com/me' + '?access_token=' + authData.access_token)
                        .success(function(userData) {
                            RingLogger.information('SOCIAL USER DATA: ', RingLogger.tags.AUTH);
                            RingLogger.print(userData, RingLogger.tags.AUTH);
                            if (userData.id) {
                                defer.resolve({
                                        platform: defaults.name,
                                        id: userData.id,
                                        name: userData.name,
                                        access_token: authData.access_token
                                });
                            } else {
                                defer.reject();
                            }
                        })
                        .error(function() {
                            defer.reject();
                        });
                    }, function() {
                         defer.reject({mg: 'Popup blocked by Browser. Please unblock.'});
                    });

                    return defer.promise;

                };


                return Oauth2;
            };
        }


        socialOauth1.$inject = ['$q', 'socialConfig','socialUtils', 'socialPopup', '$ringhttp'];
        function socialOauth1($q, socialConfig, socialUtils, socialPopup, $ringhttp) { //jshint ignore:line
            return function() {

                function exchangeForToken (data, credentials) {
                    credentials.uId = credentials.uId.toString();
                    var queryString = '?step=3&oauth_token=' + data.oauth_token + '&verifier=' + data.oauth_verifier +
                        ((credentials.uId && credentials.uId.length > 2) ? '&uId=' + credentials.uId : '') +
                            '&time=' + new Date().getTime();

                    RingLogger.information('exhcangeForToken URL: ' + defaults.serverUrl + queryString, RingLogger.tags.AUTH);
                    return $ringhttp.get(defaults.serverUrl + queryString);
                    //return $ringhttp.get(defaults.serverUrl + '?step=3&oauth_token=' + data.oauth_token + '&verifier=' + data.oauth_verifier + '&time=' + new Date().getTime());
                }

                function exchangeForRequest() {
                    RingLogger.information('exchangeForRequest URL: ' + defaults.serverUrl + '?step=1&callback=' + defaults.redirectUri, RingLogger.tags.AUTH);
                    return $ringhttp.get(defaults.serverUrl + '?step=1&callback=' + defaults.redirectUri + '&time=' + new Date().getTime());
                }

                function buildQueryString (obj) {
                    var str = [];

                    angular.forEach(obj, function(value, key) {
                        //str.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
                        str.push(key + '=' + value);
                    });

                    return str.join('&');
                }

                var Oauth1 = {};

                var defaults = {
                        url: null,
                        name: null,
                        popupOptions: null,
                        redirectUri: null,
                        authorizationEndpoint: null
                };

                Oauth1.open = function(options, credentials) {
                    var defer = $q.defer(),
                        popupWindow;

                    angular.extend(defaults, options);

                    RingLogger.print(defaults, RingLogger.tags.AUTH);

                    popupWindow = socialPopup.open('', defaults.name, defaults.popupOptions, defaults.redirectUri);

                    var interval = setInterval(function() {
                        if (popupWindow.popupWindow.closed) {
                            clearInterval(interval);
                            defer.reject({sucs: false, mg: 'Popup Closed unexpectedly!'});
                        }
                    }, 1000);

                    exchangeForRequest().success(function(response) {
                        if (response.sucs === true) {
                            var tokenData = response.data;
                            var auth_url = [defaults.authorizationEndpoint, buildQueryString({'oauth_token': tokenData.token, 'callback_url': defaults.redirectUri})].join('?');
                            if (popupWindow.popupWindow) {
                                popupWindow.popupWindow.location =  auth_url;

                                RingLogger.information('TWITTER authorize url: ' + auth_url, RingLogger.tags.AUTH);
                                RingLogger.print('REQUEST TOKEN DATA: ', tokenData, RingLogger.tags.AUTH);
                                popupWindow.pollPopup().then(function(authData) {
                                    clearInterval(interval);
                                    exchangeForToken(authData, credentials).success(function(response) {
                                        if (response.sucs === true || response.rc === 2) {
                                            var accessData = response.data.members;
                                            RingLogger.print('ACCESS TOKEN DATA: ', authData, accessData, RingLogger.tags.AUTH);
                                            var userDetails = JSON.parse(accessData.userDetails);
                                            var accessToken = JSON.parse(accessData.accessToken);
                                                defer.resolve({
                                                    platform: defaults.name,
                                                    id: userDetails.id_str,
                                                    name: userDetails.name,
                                                    access_token: accessToken.token,
                                                    oauthParameters: accessToken.oauthParameters,
                                                    oauth_token: authData.oauth_token,
                                                    oauth_verifier: authData.oauth_verifier
                                                });
                                        } else {
                                            defer.reject({mg: 'exchangeForRequest failed'});
                                        }
                                    }).error(function() {
                                        defer.reject({mg: 'exchangeForRequest failed. Server error'});
                                    });
                                });

                            } else {
                                 defer.reject({mg: 'Popup blocked by Browser. Please unblock.'});
                            }

                        } else {
                            defer.reject({mg: 'exchangeForRequest failed'});
                        }

                    }).error(function() {
                        RingLogger.alert('twitter oauth request token fetch fail', RingLogger.tags.AUTH);
                        defer.reject({mg: 'exchangeForRequest failed. Server error'});
                    });

                    return defer.promise;
                };


                return Oauth1;
            };
        }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social')
		.provider('$authSocial',['socialConfig', function social(socialConfig) {
          angular.forEach(Object.keys(socialConfig.providers), function(provider) {
            this[provider] = function(params) {
              return angular.extend(socialConfig.providers[provider], params);
            };
          }, this);

          var oauth = function(params) {
            socialConfig.providers[params.name] = socialConfig.providers[params.name] || {};
            angular.extend(socialConfig.providers[params.name], params);
          };

          this.oauth1 = function(params) {
            oauth(params);
            socialConfig.providers[params.name].type = '1.0';
          };

          this.oauth2 = function(params) {
            oauth(params);
            socialConfig.providers[params.name].type = '2.0';
          };

          this.$get = [
            '$$q',
            'socialOauth',
            function($q, oauth) {
                var $authSocial = {};

                $authSocial.login = function(platform) {
                    var deferred = $q.defer();
                    var authData; // = Storage.getData(platform);
                    if (authData) {
                        deferred.resolve(authData);
                    } else {
                        oauth.authenticate(platform, 'login').then(function(authData) {
                            deferred.resolve(authData);
                        }, function(err) {
                            deferred.reject(err);
                        });
                    }
                    return deferred.promise;
                };


                $authSocial.authenticate = function(platform, credentials) {
                    var defer = $q.defer();
                    oauth.authenticate(platform, credentials).then(function(authData) {
                        defer.resolve(authData);
                    }, function(err) {
                        defer.reject(err);
                    });

                    return defer.promise;
                  };

                return $authSocial;
            }];

    	}]);




})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.auth', [
		//	'ngCookies',
			'ringid.config',
			'ringid.connector',
            'ringid.common.services',
            'ringid.common.factories',
            'ringid.utils',
            'ringid.social'
		]);
})();


/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.auth')
		.service('authHttpService', authHttpService);

	authHttpService.$inject = ['$$connector', '$ringhttp', 'settings', 'utilsFactory', 'OPERATION_TYPES'];
	function authHttpService ($$connector, $ringhttp,  settings, utilsFactory, OPERATION_TYPES) { //jshint ignore:line
		/*jshint validthis: true */
		var self = this,
            REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE,
            OTYPES = OPERATION_TYPES.SYSTEM,
			OTYPES_AUTH = OPERATION_TYPES.SYSTEM.AUTH;

            /**
            * @api {request} /APIREQUEST/20 Login
            * @apiVersion 0.1.0
            * @apiDescription Login User
            * @apiName Login
            * @apiGroup Auth
            *
            *
            * @apiParam {Number=20} actn AUTH.TYPE_SIGN_IN
            * @apiParam {Number} [dvc=5] Login Device. for Web it's 5
            * @apiParam {Number=1,2} lt Login Type i.e. 1 is Ringid and 2 is Country Code
            * @apiParam {Number} ringID Ring Id
            * @apiParam {Number} ringId Ring Id
            * @apiParam {Number} tbid Browser Tab Id
            * @apiParam {Number} uId Ring Id
            * @apiParam {Number=1015} vsn Version
            * @apiParam {Number} wk Undefined
            *
            * @apiParamExample {json} Request-Example:
            *   {
            *       actn: 20
            *       dvc: 5
            *       lt: 1
            *       ringID: "2110010091"
            *       ringId: "2110010091"
            *       tbid: 1
            *       uId: "2110010091"
            *       usrPw: "aaaaaa"
            *       vsn: 1015
            *       wk: "1177453575210"
            *   }
            *
            *
            * @apiSuccess {Number=20} actn AUTH.TYPE_SIGN_IN
            * @apiSuccess {String} authServer Auth Server Ip Address
            * @apiSuccess {Number} comPort Auth Server Port Number
            * @apiSuccess {String} el User Email Address
            * @apiSuccess {Number} emVsn Undefined
            * @apiSuccess {String} fn First Name
            * @apiSuccess {Number} iev Undefined
            * @apiSuccess {Number} lsts Undefined
            * @apiSuccess {String} mbl Mobile No
            * @apiSuccess {String} mblDc Country code
            * @apiSuccess {Number} mood Mood of User
            * @apiSuccess {String} oIP Undefined
            * @apiSuccess {Number} oPrt Undefined
            * @apiSuccess {String} prIm Profile Image Url
            * @apiSuccess {Number} prImId Profile Image Id
            * @apiSuccess {Boolean} pstd Undefined
            * @apiSuccess {String} sid Auth Session Id
            * @apiSuccess {Boolean} sucs Success or Failure
            * @apiSuccess {Number} uId User Id/ Ring Id
            * @apiSuccess {Number} utId  User Table Id
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 20
            *       authServer: "38.127.68.50"
            *       comPort: 30091
            *       el: ""
            *       emVsn: 1
            *       fn: "showone"
            *       headerLength: 62
            *       iev: 0
            *       imnv: 0
            *       lsts: 2
            *       mbl: ""
            *       mblDc: ""
            *       mood: 1
            *       oIP: "38.127.68.55"
            *       oPrt: 0
            *       pckId: "1036450626207"
            *       prIm: ""
            *       prImId: 0
            *       pstd: true
            *       sId: "10438420939453842110010091"
            *       sucs: true
            *       uId: "2110010091"
            *       utId: 75
            *     }
            *
            * @apiError Album has no Image
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 200 Not Found
            *     {
            *       "sucs": false
            *     }
            */

		self.login = function(obj){
            var payload = {
                    usrPw: obj.password,
                    actn: OTYPES.AUTH.TYPE_SIGN_IN,
                    lt: 1,
                    vsn: settings.apiVersion, // auth server version
                    wk: utilsFactory.getUniqueID(),
                    dvc: 5,
                    tbid: utilsFactory.tabId,
                    did: obj.did,
                };



            switch(obj.authMethod) {
                //case '+878': // ringid login
                case 'ringid': // ringid login
                    payload.lt = 1;
                    payload.uId = !obj.remember ? '21' + obj.ringid : obj.ringid;
                    break;
                case 'email': // email login
                    payload.lt = 3;
                    payload.el = obj.email.utf8Encode();
                    break;
                case 'facebook':
                    payload.uId = obj.uId;
                    payload.pen = 1;
                    payload.lt = 4;
                    payload.apt = 1;
                    payload.smid = obj.id;
                    payload.it = obj.access_token;
                    delete payload.usrPw;
                    break;
                case 'twitter':
                    payload.uId = obj.uId;
                    delete payload.usrPw;

                    payload.smid = obj.id;
                    //var tokenObj = {
                        //url: 'https://api.twitter.com/1.1/account/verify_credentials.json',
                        //qs: 'oauth_timestamp=' + obj.oauthParameters.oauth_timestamp + '&oauth_version=' + obj.oauthParameters.oauth_version + '&oauth_consumer_key=' + obj.oauthParameters.oauth_consumer_key +
                              //'&oauth_signature=' + obj.oauthParameters.oauth_signature + '&oauth_token=' + obj.access_token + '&oauth_nonce=' + obj.oauthParameters.oauth_nonce + '&oauth_signature_method=' + obj.oauthParameters.oauth_signature_method
                    //};
                    //payload.it = JSON.stringify(tokenObj);
                    //payload.it = 'oauth_token=' + obj.oauth_token +  '&verifier=' + obj.oauth_verifier;
                    payload.it = obj.access_token;
                    payload.lt = 5;
                    break;
                default: // phone login
                    payload.lt = 2;
                    payload.mbl = obj.mbl;
                    payload.mblDc = obj.mblDc;
            }

			/* Remember Me Salt and Previous sID */
			if( !!obj.salt && !!obj.sId ){
				payload.salt = obj.salt;
				payload.sId = obj.sId;
			}

            return $$connector.request(payload, REQTYPE.AUTHENTICATION);

		};


        self.recoverySendCode = function(obj, sendSms) {
            var payload = {
				actn: OTYPES_AUTH.PASSWORD_RECOVER_SEND_CODE,
				wk: utilsFactory.getUniqueID(),
			};

            if(sendSms) {
                payload.lt = 2;
                payload.rb = obj.mbl;
				payload.mbl = obj.mbl;
				payload.mblDc = obj.mblDc;
            } else {
                payload.lt = 3;
                payload.rb = obj.email;
				payload.el = obj.email.utf8Encode();
            }

			return $$connector.request(payload, REQTYPE.AUTHENTICATION);
        };

        self.recoveryVerifyCode = function(obj) {
            var payload = {
				actn : OTYPES_AUTH.PASSWORD_RECOVER_VERIFY_CODE,
				uId : obj.uId,
				vc : obj.vc,
				wk : utilsFactory.getUniqueID(),
                lt : 1 // server dependency sendSms ? 2 : 3
            };

			return $$connector.request(payload, REQTYPE.AUTHENTICATION);
        };

        self.resetPassword = function(obj) {
            var payload = {
				actn : OTYPES_AUTH.PASSWORD_RECOVER,
				uId : obj.uId,
                nPw : obj.password,
				wk : utilsFactory.getUniqueID(),
                lt : 1 // server dependency  sendSms ? 2 : 3
            };

			return $$connector.request(payload, REQTYPE.AUTHENTICATION);
        };

            /**
            * @api {request} /APIREQUEST/21 Logout
            * @apiVersion 0.1.0
            * @apiDescription Logout User
            * @apiName Logout
            * @apiGroup Auth
            *
            *
            * @apiParam {Number=21} actn TYPE_SIGN_OUT
            *
            * @apiParamExample {json} Request-Example:
            *   {
            *       actn: 21
            *   }
            *
            *
            * @apiSuccess {Number=21} actn TYPE_SIGN_OUT
            * @apiSuccess {Number} id Undefined
            * @apiSuccess {Number} rc Undefined
            * @apiSuccess {Boolean} sucs Success or Failure
            * @apiSuccess {Number} uId User Id/ Ring Id
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 22
            *       headerLength: 55
            *       id: 75
            *       pckId: "1409303629847"
            *       rc: 0
            *       sucs: true
            *       uId: "2110010091"
            *     }
            *
            * @apiError Album has no Image
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 200 Not Found
            *     {
            *       "sucs": false
            *     }
            */


		self.logout = function() {
			var payload = {
				actn: OTYPES_AUTH.TYPE_SIGN_OUT
				//request_type: REQTYPE.AUTHENTICATION
			};
			return $$connector.request(payload,REQTYPE.AUTHENTICATION);
		};

		self.isValidSession = function(obj){
			return $$connector.request({
				actn : OTYPES_AUTH.TYPE_SESSION_VALIDATION,
                dvcc: 5,
				utId : obj.utId,
                did: obj.did
			}, REQTYPE.AUTHENTICATION);
		};

		self.signupInit = function(did) {
			return $ringhttp.get(settings.signupInit + 'did=' + did + '&time=' + new Date().getTime()) ;
		};

        self.signupSendCode = function(obj) {
            var emailSignup= (obj.authMethod === 'email') ? true : false;
            var payload  = {
				actn : (emailSignup) ? OTYPES_AUTH.SIGNUP_SEND_CODE_EMAIL : OTYPES_AUTH.SIGNUP_SEND_CODE_PHONE,
				wk : utilsFactory.getUniqueID(),
				uId: obj.uId,
                did: obj.did,
                lt: 1 // server dependency
            };
            if(emailSignup) {
                payload.el = obj.email.utf8Encode();
            } else {
                payload.mbl = obj.mbl;
                payload.mblDc = obj.mblDc;
            }

			return $$connector.request(payload, REQTYPE.AUTHENTICATION);
        };

        self.signupVerifyCode = function(obj) {
            var emailSignup= (obj.authMethod === 'email') ? true : false;
            var payload  = {
				actn : (emailSignup) ? OTYPES_AUTH.SIGNUP_SEND_CODE_EMAIL : OTYPES_AUTH.SIGNUP_SEND_CODE_PHONE,
				wk : utilsFactory.getUniqueID(),
				uId: obj.uId,
                did: obj.did,
                lt: 1 // server dependency
            };
            if(emailSignup) {
                payload.el = obj.email.utf8Encode();
                payload.evc = obj.vc;
            } else {
                payload.mbl = obj.mbl;
                payload.mblDc = obj.mblDc;
                payload.vc = obj.vc;
            }
			return $$connector.request(payload, REQTYPE.AUTHENTICATION);
        };


		self.signup = function(obj) {
            var payload  = {
				actn : OTYPES_AUTH.SIGNUP_REGISTER,
				wk : utilsFactory.getUniqueID(),
				uId: obj.uId,
                did: obj.did,
                nm: obj.name.utf8Encode(),
                usrPw: obj.password,
                lt: 1, // server dependency
                // for all signup mobile no is required these are new params
                ispc: 0, // default for auth server
                mbl : obj.mbl,
                mblDc : obj.mblDc
            };

            switch(obj.authMethod) {
                case 'email':
                    payload.el = obj.email.utf8Encode();
                    payload.evc = obj.vc;
                    break;
                case 'facebook':
                    payload.fb = obj.id;
                    payload.it = obj.access_token;
                    payload.lt = 4;
                    break;
                case 'twitter':
                    payload.twtr = obj.id;
                    //var tokenObj = {
                        //url: 'https://api.twitter.com/1.1/account/verify_credentials.json',
                        //qs: 'oauth_timestamp=' + obj.oauthParameters.oauth_timestamp + '&oauth_version=' + obj.oauthParameters.oauth_version + '&oauth_consumer_key=' + obj.oauthParameters.oauth_consumer_key +
                              //'&oauth_signature=' + obj.oauthParameters.oauth_signature + '&oauth_token=' + obj.access_token + '&oauth_nonce=' + obj.oauthParameters.oauth_nonce + '&oauth_signature_method=' + obj.oauthParameters.oauth_signature_method
                    //};
                    //payload.it = JSON.stringify(tokenObj);
                    //payload.it = 'oauth_token=' + obj.oauth_token +  '&verifier=' + obj.oauth_verifier;
                    payload.it = obj.access_token;
                    payload.lt = 5;
                    break;
                default:
                    // with mobile
                    payload.mbl = obj.mbl;
                    payload.mblDc = obj.mblDc;
                    payload.vc = obj.vc;
                    //payload.lt = 1; // server dependency
            }

			return $$connector.request(payload, REQTYPE.AUTHENTICATION);
		};


        self.validMobileNo = function(obj) {
            return $ringhttp.get(settings.signupSocialInit + 'lt=' + obj.lt + '&mblDc=' + obj.mblDc + '&mbl=' + obj.mbl + '&apt=1&t' + new Date().getTime() );
            //lt={0}&mblDc={1}&mbl={2}&apt={3}&t={4}
        };

        // social signup and authentication part
		self.validSocialId = function(obj) {
            var url;
            if (obj.platform === 'facebook') {
                url = settings.signupSocialInit + 'fb=' + obj.id + '&lt=4';
            } else if (obj.platform === 'twitter') {
                url = settings.signupSocialInit + 'twtr=' + obj.id + '&lt=5';
            }

            return $ringhttp.get(url + '&time=' + new Date().getTime());
		};


	}

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.auth')
        .factory('Auth', AuthFactory);


        AuthFactory.$inject = ['SystemEvents', '$rootScope', 'Storage', 'utilsFactory', '$q', '$ringhttp', 'settings',
                             'userFactory', 'authHttpService', '$ringbox', 'Ringalert', 'profileHttpService', 'countryListService'];
        function AuthFactory(SystemEvents, $rootScope, Storage, utilsFactory, $q, $ringhttp, settings,  // jshint ignore:line
                                 userFactory, authHttpService, $ringbox, Ringalert, profileHttpService, countryListService) {
            var sessionID = Storage.getCookie('sessionID'),
                requestCount = 0,
                _permission = {},
                _countryList = [],
                _countryData  = {
				    login_type     : '+880',
                    countryFlag   :  'b880'
                    },
                _sId = Storage.getCookie('sId'),
                _uId = Storage.getCookie('uId'),
                _utId = Storage.getCookie('utId'),
                _did = utilsFactory.generateUUID();

             $rootScope.$on('ringActive',function(){
                 RingLogger.print("ringactive Fired "+ sessionID,"ringactiveTest");
                 RingLogger.print("ringactive cookie"+Cookies.get('sessionID'),"ringactiveTest");
                if(Cookies.get('sessionID') !== sessionID){
                    RingLogger.print("ringactive reloaded","ringactiveTest");

                    window.location.reload();
                }

             });






            function save(user) {
                Service._currentUser = user;
                //updateLoginData();
                return user;
            }

            //function updateLoginData(){
                //var loginData =  Storage.getData('loginData');
                //if (loginData) {
                    //Service.loginData = loginData;
                //}
            //}

            function updateLocalStorageLoginData(loginData){
                if(!!loginData){
                    Service.loginData = loginData;
                    Storage.setData('loginData', loginData);
                }

            }


            var delete_cookie = function(name) {
                document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;';
            };
            var clearCookies = function(keepSessionId){
                delete_cookie('uId');
                delete_cookie('sId');
                if(!keepSessionId){
                    delete_cookie('sessionID');
                    sessionID = undefined;
                }

                delete_cookie('la'); // last checked for login
                RingLogger.print('cookie deleted : keepSessionId:'+keepSessionId, RingLogger.tags.AUTH);
            };

            var setCookies = function (loginData, days) {
                Storage.setCookie('uId', loginData.uId || '', days);
                Storage.setCookie('sId', loginData.sId || '', days);
                Storage.setCookie('utId', loginData.utId || '', days);
                Storage.setCookie('la', new Date().getTime(), days);

                if (loginData.authServer) {
                    Storage.setCookie('authServer', loginData.authServer || '', days);
                }
                if (loginData.comPort) {
                    Storage.setCookie('comPort', loginData.comPort || '', days);
                }

                //var sessionId = Storage.getCookie('sessionID');
                //Storage.setCookie('sessionID', sessionId, 30);

                };

            var reloadHome = function(timeout, withRand) {

                if (!!timeout) {
                    clearCookies();
                    Storage.reset();
                }

                if(withRand) {
                    setTimeout(function() {
                        window.location = '/?rand=' + utilsFactory.getUniqueID();
                    }, timeout);

                } else {
                    setTimeout(function() {
                        window.location = '/';
                    }, timeout);
                }

            };

            function _saveDataForRememberMe(credentials, loginData, days){

                try {
                    var remData = {
                        eUser : loginData.authEUsername,
                        ePass : loginData.authEPassword,
                        eSalt : loginData.authESalt,
                        sId : loginData.sId,
                        lt : credentials.login_type

                    };

                    Storage.setData('remInfo', remData);

                    var sessionId = Storage.getCookie('sessionID');
                    Storage.setCookie('sessionID', sessionId, days);


                } catch (e) {
                }

            }


            function initializeSignup(credentials, isSocial) {
                var defer = $q.defer();
                // step 1
                authHttpService.signupInit(_did).success(function(response) {
                    if (response.success === true) {
                        // set auth ip and comport
                        setCookies({
                            uId: response.ringID,
                            authServer: response.authServerIP,
                            comPort: response.comPort
                        });
                        // signup step 2
                        //credentials = angular.extend({}, credentials, {uId: response.ringID, did: _did});
                        credentials = angular.extend(credentials, {uId: response.ringID, did: _did});
                        // non social signup
                        if (!isSocial) {
                            authHttpService.signupSendCode(credentials).then(function(json) {
                                defer.resolve(angular.extend(json, {uId: response.ringID}));
                            }, function(errJson) {
                                RingLogger.print(errJson,RingLogger.tags.AUTH);
                                defer.reject(errJson);
                            });
                        } else {
                        // social signup
                            defer.resolve(credentials);
                        }
                    } else {
                        defer.reject(response);
                    }
                }).error(function() {
                    RingLogger.alert('fetching new ringid failed', RingLogger.tags.AUTH);
                    defer.reject();
                });
                return defer.promise;
            }


            function requestLogin(loginRequestData, defer) {
                loginRequestData.did = _did;
                requestCount++;
                var loginTimeout = setTimeout(function() {
                    requestCount = 0;
                    clearTimeout(loginTimeout);
                    defer.reject({sucs: false, mg: 'Reqeust Failed'});
                }, 10000);
                authHttpService.login(loginRequestData).then(function (json) {
                    clearTimeout(loginTimeout);
                    requestCount = 0;
                    if (json.sucs === true) {

                        if (loginRequestData.remember) {
                            _saveDataForRememberMe(loginRequestData, json, 30);
                        }
                        doLoginTasks(json, true);
                        defer.resolve(json);
                    } else {
                        defer.reject(json);
                    }
                }, function () {
                    clearTimeout(loginTimeout);
                    requestCount = 0;
                    defer.reject({sucs: false, mg: 'Reqeust Failed'});
                });
            }





            var Service = {
                // holds current user
                _currentUser: null,

                _validSession: false,

                // template for login/ dashboard page
                indexTemplate: 'pages/index-login.html',
                sendCode: initializeSignup,
                updateLocalStorageLoginData : updateLocalStorageLoginData,
                verifyCode: function(credentials) {
                    credentials = angular.extend({}, credentials, {did: _did});
                    return authHttpService.signupVerifyCode(credentials);
                },
                signup: function(credentials) {
                    var deferred = $q.defer();
                    // TODO BELOW COMMENTED CODE IS NECESSARY. MAKE SURE SERVER SUPPORTS THIS. NOW ALWAYS FALSE IS RETURNED
                    //authHttpService.validMobileNo({mbl: credentials.mbl, mblDc: credentials.mblDc , lt: 1 }).success(function(json) {
                        //if (json.sucs === true) {
                            //RingLogger.print(json, RingLogger.tags.AUTH);
                            angular.extend(credentials, {did: _did});
                            authHttpService.signup(credentials).then(function(json) {
                                RingLogger.print(json, RingLogger.tags.AUTH);
                                deferred.resolve(json);
                            }, function() {
                                deferred.reject();
                            });
                        //} else {
                            //// this mobile no already used in another account. let him signin or change the mobile
                            //deferred.reject({mg: 'This Mobile no is used in another account. If this is yours, try Forgot Password option or change this no'});
                        //}
                    //}).error(function() {
                        //deferred.reject();
                    //});
                    return deferred.promise;
                },
                // facebook and twitter signup
                openSignup: function(socialData, credentials) {
                    var deferred = $q.defer();
                    authHttpService.validSocialId(socialData).success(function(response) {
                        RingLogger.print(response, RingLogger.tags.AUTH);
                        if (response.success === false && response.rc === 2) {
                            // now show signup step 3 in popup
                           $ringbox.open({
                                    type : 'remote',
                                    scope:false,
                                    controller: 'SignUpController',
                                    resolve : {
                                        localData: {
                                            socialData:  socialData,
                                            credentials: credentials
                                        },
                                        remoteData : angular.noop //initializeSignup(socialData, true)
                                    },
                                    templateUrl : 'pages/welcome/ring-signup-popup.html'
                            });
                            deferred.resolve();
                        } else {
                            deferred.reject({rc: 'dologin', mg: 'Already Registered Social ID'});
                            // login anyway
                        }
                    }).error(function() {
                        deferred.reject({rc: 0, mg: 'Request Failed'});
                    });
                    return deferred.promise;
                },

                // login user
                login: function (loginRequestData, isSocial) {
                    var defer = $q.defer();
                    if (isSocial) {
                        authHttpService.validSocialId(angular.extend(loginRequestData, {did: _did})).success(function(json) {
                            RingLogger.print(json, RingLogger.tags.AUTH);
                            if (json.success === true || json.success === 'true')  {
                                setCookies({
                                    uId: json.ringID,
                                    authServer: json.authServerIP,
                                    comPort: json.comPort
                                });
                                // attempt to login
                                loginRequestData.uId = json.ringID;
                                loginRequestData.login_type = loginRequestData.platform;
                                requestLogin(loginRequestData, defer);
                            } else {
                                defer.reject({rc: 'invalidsocialid', mg: 'Unregistered Social ID. Please Register.'});
                            }
                        }).error(function() {
                            defer.reject({rc: 0, mg: 'Request Failed'});
                        });
                    } else {
                        // remove remember data if not checked
                        if(!loginRequestData.remember){
                            Storage.deleteData('remInfo');
                        }
                        // set current user auth method email, ringid or phonenumber for autofill
                        switch(loginRequestData.authMethod) {
                            case 'email':
                                Storage.setData('autoFill', loginRequestData.email);
                                break;
                            case 'ringid':
                                Storage.setData('autoFill', loginRequestData.ringid);
                                break;
                            case 'phone':
                                Storage.setData('autoFill', loginRequestData.mbl);

                        }
                        requestLogin(loginRequestData, defer);
                    }

                    return defer.promise;
                },

                // logout user
                logout: function(force) {
                    if(Service.isLoggedIn()) {
                        $rootScope.$broadcast(SystemEvents.LOADING, true);
                        authHttpService.logout().then(function(response) {
                            $rootScope.$broadcast(SystemEvents.LOADING, false);
                            RingLogger.information(response, RingLogger.tags.AUTH);
                            reloadHome(1);
                        });
                    }

                    if(!!force){
                        reloadHome(1);
                    }else{
                        reloadHome(1000);
                    }


                },
                clearCookies : function(keepSessionId){
                    clearCookies(keepSessionId);
                },

                loginFromLocalData: function () {

                    var defer = $q.defer();

                    var remInfo = Storage.getData('remInfo', true);

                    if (!!remInfo) {
                        var loginRequestParams = {
                            username: remInfo.eUser,
                            password: remInfo.ePass,
                            salt: remInfo.eSalt,
                            remember: true,
                            login_type: remInfo.lt,
                            sId: remInfo.sId,
                            silent : true
                        };

                        Service.login(loginRequestParams).then(function (json) {
                            if(!!json.sucs){
                                RingLogger.print('Auto Login Success',RingLogger.tags.AUTH);
                                defer.resolve(true);
                            }else{
                                RingLogger.print('Auto Login Failed',RingLogger.tags.AUTH);
                                defer.reject(false);
                            }

                        }, function (errData) {
                            RingLogger.print(errData, RingLogger.tags.AUTH);
                            defer.reject(false);
                        });

                    } else {
                        setTimeout(function(){
                            defer.reject(false);
                        });
                    }

                    return defer.promise;

                },

                // get current user
                currentUser: function() {
                    return Service._currentUser;
                },

                // checkes login status
                isLoggedIn: function() {
                    return !!Service._currentUser &&  !!Storage.getCookie('sId') && !!Storage.getCookie('sessionID');
                },
                // check Session Validity
                isValidSession: function(){
                   var defer = $q.defer();
                    if (Service._currentUser) {
                        //return  userLoginFactory.isValidSession(Service._currentUser.getUtId());
                        authHttpService.isValidSession({did: _did, utId: Service._currentUser.getUtId()}).then(function(response) {
                            if(response.sucs) {
                                Service._validSession = true;
                                defer.resolve(true);
                            } else {
                                Service._validSession  = false;
                                defer.reject(false);
                            }
                        },function(){
                            defer.reject(Service._validSession);
                        });
                    } else {
                        //return false;
                        setTimeout(function(){
                            defer.reject(Service._validSession);
                        },100);

                   }
                    return defer.promise;
                },
                reloadHome : reloadHome,
                getCountry: function() {
                    var countryData = Storage.getData('country');
                    if (countryData && countryData.country) {
                        _countryData.login_type = countryData.code;
                        _countryData.countryFlag = countryData.flagcode;
                    }

                    return _countryData;
                },
                getCountryList: function() {
                    return _countryList;
                },
                getPermission: function() {
                    return _permission;
                },
                setAchatPermission: function(param) {
                    _permission.ancht = param;
                }

            };



             // preloading templates
            var preloadTemplates = [
                'pages/dropdowns/notification-dropdown.html',
                'pages/dropdowns/friend-request-dropdown.html',
                'pages/partials/emoticon-window.html',
                'pages/dropdowns/circle-list-dropdown.html',
                'pages/dropdowns/search-dropdown.html',
                'pages/partials/hovercards/profile-hover.html',

                'pages/partials/notification/image-popup.html',
                'pages/partials/notification/media-popup.html',
                'pages/partials/notification/feed-popup_with_image.html',
                'pages/partials/stickers/popups/sticker-market.html'
            ];

            function preLoad(templateUrl) {
                setTimeout(function() {
                    $ringhttp.get(templateUrl).success(function() {
                        RingLogger.information('TEMPLATE PRELOADED: ' + templateUrl, RingLogger.tags.DEFAULT);
                    });
                }, 100);
            }


            function doLoginTasks (loginData, fromLogin) {

                Service.loginData = loginData;
                setCookies(loginData, fromLogin ? 30 : false);

                // save current user
                save(userFactory.create(loginData, true, true));
                // init localStorage
                Storage.init(loginData);

                // preload templates
                setTimeout(preloadTemplates.forEach(preLoad), 2000);
                // pull current user permissions
                profileHttpService.verifyCheck().then(function(json) {
                    _permission = json;
                    RingLogger.information(json, RingLogger.tags.PROFILE);
                    //Service._currentUser.updateUserObj(json);
                }, function() {
                    RingLogger.warning('User Permission fetch fail', RingLogger.tags.PROFILE);
                });

                $rootScope.$broadcast(SystemEvents.AUTH.LOGIN, {silent : !!loginData.silent });
            }

            var loginData =  Storage.getData('loginData');
            if (loginData) {
                doLoginTasks(loginData);
            } else {
                if (_uId && _utId && _sId) {
                    Service._currentUser =  userFactory.create({uId: _uId, utId: _utId}, true, true);
                    profileHttpService.getUserDetails({uId: _uId}).then(function(json) {
                        if (json.sucs === true) {
                            doLoginTasks(angular.extend(json.userDetails, {uId: _uId, sId: _sId, utId: _utId}));
                        }
                    });
                } else {
                    // user is not in logged in state
                    countryListService.getList().success( function(data) {
                        _countryList = data;
                        var country = Storage.getData('country');
                        if (!country || !country.country) {
                            $ringhttp.get(settings.baseUrl + 'country').success(function(country) {
                                if (country && country.length > 0) {
                                    country = country.toLowerCase();
                                    for (var i = 0; i < _countryList.length; i++) {
                                        if (_countryList[i].country.toLowerCase() === country) {
                                            _countryData.login_type = _countryList[i].code;
                                            _countryData.countryFlag = _countryList[i].flagcode;
                                            Storage.setData('country', _countryList[i]);
                                            break;
                                        }

                                    }
                                }
                            });
                        } else {
                            _countryData.login_type = country.code;
                            _countryData.countryFlag = country.flagcode;
                        }
                    });
                }
            }



        return Service;

    }


})();



/* * © Ipvision
 */

(function () {
	'use strict';

	angular
		.module('ringid.auth')
		.controller('AuthController', AuthController);

	AuthController.$inject = ['rgDropdownService', 'Storage', 'Auth', '$scope', '$$connector', 'countryListService','$rootScope', 'Ringalert'];

	function AuthController(rgDropdownService, Storage, Auth, $scope, $$connector, countryListService,$rootScope, Ringalert) { //jshint ignore:line

            $$connector.init();
            $$connector.resume();


            var errMsg = {
                signin: {
                    email: "Login failed. Make sure you're entering your verified email and correct password.",
                    phone: "Login failed. Make sure you're entering your verified phone and correct password.",
                    ringid: "Login failed. Make sure you're entering correct ringID and password.",
                    other: 'Sorry, we are unable to complete your request. Please try again later.'
                },
                signup: {
                    sendcode: "Verification code has been sent to your email. Please check your spam folder also.",
                    verify: "",
                    signup: ''
                },
                recovery: {
                    email: "Sorry! we did not find your email. Make sure you're entering your verified email.",
                    phone: "Sorry! we did not find your phone number. Make sure you're entering your verified phone number."
                },
            };


            $scope.socialRequestFailed = function(errData, which, whichOf) {
                $scope.disableForm = false;
                ga('send', 'event',   location.hostname + ':' + which, whichOf + ' Message:' + errData.mg || 'UNKNOWN');
                Ringalert.show(errData.mg || 'Request Failed', 'error');
                RingLogger.print(errData, RingLogger.tags.AUTH);
                $scope.$rgDigest();
            };


            $scope.requestFailed = function(errData, which, whichOf, showOriginal) {
                var analytics = {
                    signup: {
                        success: {
                            label: 'Signup Success',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        },
                        fail: {
                            label: 'Signup Failed',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        }
                    },
                    signin: {
                        success: {
                            label: 'Signin Success',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        },
                        fail: {
                            label: 'Signin Failed',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        }
                    },
                    recovery: {
                        success: {
                            label: 'Recovery Success',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        },
                        fail: {
                            label: 'Recovery Failed',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        }
                    },
                };

                if (!errData) {
                    // reset form related data
                    $scope.disableForm = true;
                    $scope.requestSuccess = true;
                    $scope.errorMsg = '';
                } else {
                    // success false
                    $scope.disableForm = false;
                    if (errData.sucs === true || errData.sucs === 'true') {
                        // add event for analytics
                        ga('send', 'event', location.hostname + ':' + analytics[whichOf].success.label + ' :' + which, analytics[whichOf].success.value + ' Message:' + errData.mg || 'UNKNOWN');
                        $scope.requestSuccess = true;
                    } else {
                        ga('send', 'event', location.hostname + ':' + analytics[whichOf].fail.label + ' :' + which, analytics[whichOf].fail.value + ' Message:' + errData.mg || 'UNKNOWN');
                        $scope.requestSuccess = false;
                    }
                    if (showOriginal || (errData.hasOwnProperty('sucs') && errData.sucs !== true)) {
                        $scope.errorMsg = errData.mg || 'Request Failed'; //loginData.mg || 'Login Failed';
                    } else {
                        $scope.errorMsg = errMsg[whichOf][which] || errData.mg; //loginData.mg || 'Login Failed';
                    }
                    RingLogger.print(errData, RingLogger.tags.AUTH);
                }

                $scope.$rgDigest();
            };


			//$scope.ddHtml = 'pages/dropdowns/country-list-dropdown.html';
            $scope.ddTemplate =
                     '<div class="country-wrapper" >' +
                        '<ul id="countrylist" class="ringdropdown" rg-scrollbar="scrollbar()">' +
                            '<div class="count-s">' +
                            '<input type="text" ng-model="countryName" placeholder="Search Country">' +
                            '</div>' +
                            '<a ng-repeat="item in ddControl.countryList() | filter:countryName" ><li class="flag {{item.flagcode}}" ng-click="ddAction()({event: $event, item: item})" > ' +
                            '<span> {{ item.country }}</span></li></a>' +
                        '</ul>' +
                      '</div>';

			$scope.ddControl = {
                append: false,
                countryList: Auth.getCountryList
			};

            // auth data
            $scope.activeTab = 'phone';
			$scope.credentials = {
                authMethod     : 'phone',
                uId            : '',
                lt             : 2,
				//username       : '',
                mbl            : '',
                mblDc          : Auth.getCountry().login_type,
                email          : '',
                ringid         : '',
				password       : '',
                remember       : false,
                countryFlag   :  Auth.getCountry().countryFlag, //'c1'
			};


			$scope.errorMsg = '';
            $scope.requestSuccess = false;
			$scope.disableForm   = false;
            $scope.formStyle = {left: '0px'};

            // auth operations
            $scope.activateTab = activateTab;
			$scope.setPrefix = setPrefix;
            $scope.login = login;



            function activateTab (tabName) {
                if(!$scope.disableForm) { // login not in progress
                    $scope.errorMsg = '';
                    $scope.activeTab = tabName;
                    Storage.setData('activeTab', tabName);
                    switch($scope.activeTab) {
                        case 'email':
                            $scope.credentials.authMethod = 'email';
                            $scope.formStyle.left = '-800px';
                            //$scope.credentials.login_type = 'Email';
                            break;
                        case 'ringid':
                            $scope.credentials.authMethod = 'ringid';
                            $scope.formStyle.left = '-400px';
                            //$scope.credentials.login_type = '+878';
                            break;
                        case 'social':
                            $scope.credentials.authMethod = 'social';
                            $scope.formStyle.left = '-1200px';
                            //$scope.credentials.login_type = 'social';
                            break;
                        default:
                        $scope.credentials.authMethod = 'phone';
                        $scope.formStyle.left = '0px';
                        $scope.credentials.login_type = $scope.country ? $scope.country.login_type : '+880';

                    }
                    $scope.$rgDigest();
                }
            }

            // initialize
            var tempActive =  Storage.getData('activeTab');
            if (tempActive) {
                // autofill
                var tempAutofill =  Storage.getData('autoFill');
                switch(tempActive) {
                    case 'phone':
                        $scope.credentials.mbl = tempAutofill;
                        $scope.credentials.lt = 2;
                        break;
                    case 'email':
                        $scope.credentials.lt = 3;
                        $scope.credentials.email = tempAutofill;
                        break;
                    case 'ringid':
                        $scope.credentials.ringid = tempAutofill;
                        $scope.credentials.lt = 1;
                        break;
                }

                activateTab(tempActive);

            }


            function setPrefix(actionObj) {

                if (actionObj.event) {
                    rgDropdownService.close(actionObj.event);
                }

                Storage.setData('country', actionObj.item);
                $scope.credentials.mblDc =  actionObj.item.code;
                $scope.credentials.countryFlag = actionObj.item.flagcode;

                $scope.$rgDigest();
            }


			function login(formValid, event) {
                if(event) {
				    event.preventDefault();
                }
				if (formValid) {
                    $scope.requestFailed(false);
                    Auth.login($scope.credentials).then(function(loginData) {
                        if (loginData.sucs === true || loginData.sucs === 'true'){
                            $rootScope.$rgDigest();
                            $scope.closeAll();
                        }
                        $scope.requestFailed(loginData, $scope.credentials.authMethod, 'signin');
                    }, function(errData) {
                        $scope.requestFailed(errData, $scope.credentials.authMethod, 'signin');
                    });
				}

			}

	}

})();

/* * © Ipvision
 */

(function () {
	'use strict';

	angular
		.module('ringid.auth')
		.controller('SignInController', SignInController);

	SignInController.$inject = ['$authSocial', '$controller', '$scope', '$boxInstance', 'Auth', 'Ringalert', '$rootScope'];

	function SignInController($authSocial, $controller, $scope, $boxInstance, Auth, Ringalert, $rootScope) { // jshint ignore:line

            angular.extend(this, $controller('AuthController', {$scope: $scope}));

            $scope.close = $boxInstance.close;
            $scope.closeAll = $boxInstance.closeAll;

            //signin data
            $scope.signIn = true;


            $scope.noSignupAllowed = function() {
                 Ringalert.alert({
                    title : 'Sign Up',
                    message : 'Please sign up from your iOS, Android, Windows enabled device or Desktop prior to logging in from the Web version.',
                    showCancel : false,
                    okCallback : angular.noop//doLogoutTask
                 });
            };

            function authenticateUser(platform) {
                $authSocial.authenticate(platform, $scope.credentials).then(function(authData) {
                    Auth.login(angular.extend(authData, $scope.credentials), true).then(function() {
                        ga('send', 'event', 'Signin Success. ' , 'Auth Method: ' + platform );
                        // now login
                        $scope.close();
                        $rootScope.$rgDigest();
                    }, function(err) {
                        switch(err.rc) {
                            case 'invalidsocialid':
                                $scope.socialRequestFailed(err, platform, 'Unregistered Social ID');
                                // open signup box
                                $boxInstance.showLoader();
                                Auth.sendCode($scope.credentials, true).then(function() {
                                    $scope.close();
                                    Auth.openSignup(authData, $scope.credentials);
                                });
                                break;
                            default:
                                $boxInstance.hideLoader();
                                $scope.socialRequestFailed(err, platform, 'Something went wrong');
                        }
                    });
                }, function(err) {
                    $boxInstance.hideLoader();
                    $scope.socialRequestFailed(err, platform, 'Authentication Failed');
                });

            }
            //social signin
            $scope.socialLogin = function(platform) {
                $scope.credentials.authMethod = platform;
                $boxInstance.showLoader();
                if (platform === 'twitter') {
                    //Auth.sendCode($scope.credentials, true).then(function() {
                        authenticateUser(platform);
                    //});
                } else {
                    authenticateUser(platform);
                }



            };

	}

})();

/*
 * © Ipvision
 */

(function() {
    'use strict';


    angular.module('ringid.auth')
        .controller('SignUpController', SignUpController);

        SignUpController.$inject = ['countryListService', 'Ringalert', 'Auth', '$scope', '$controller', '$boxInstance', '$authSocial', 'remoteData', 'localData', 'Storage', 'rgDropdownService'];
        function SignUpController(countryListService, Ringalert, Auth, $scope, $controller, $boxInstance, $authSocial, remoteData, localData, Storage, rgDropdownService) { // jshint ignore:line

            angular.extend(this, $controller('AuthController', {$scope: $scope}));

            $scope.close = $boxInstance.close;
            $scope.closeAll = $boxInstance.closeAll;

            // sign up data
            $scope.newUid = '';
            $scope.credentials.repassword = '';
            $scope.credentials.vc = '';
            $scope.credentials.name = '';

            $scope.signupStep = 1;
            // signup operations
            $scope.signupData = signupData;
            $scope.sendCode = sendCode;
            $scope.verifyCode = verifyCode;
            $scope.signup= signup;




            if (localData) {
                // reset from autofill
                $scope.formStyle.left  = '0px';
                $scope.credentials.mbl = '';
                $scope.credentials.email = '';
                $scope.credentials.ringid = '';
                $scope.credentials.password = '';
                if (localData.signupData) {
                    $scope.credentials.authMethod = localData.signupData.signupType;
                    $scope.credentials.countryFlag = localData.signupData.countryFlag;
                }

                if (localData.socialData) {
                    angular.extend($scope.credentials, localData.credentials);
                    //$scope.credentials.authMethod = localData.credentials.authMethod;
                    //$scope.credentials.countryFlag = localData.socialData.countryFlag;
                    $scope.newUid = localData.credentials.uId.toString().substr(2);

                    $scope.credentials.authMethod = localData.socialData.platform;
                    $scope.credentials.id= localData.socialData.id;
                    $scope.credentials.name = localData.socialData.name;
                    $scope.credentials.access_token= localData.socialData.access_token;

                    //$scope.credentials.login_type = remoteData.platform;
                    //$scope.credentials.authMethod = localData..platform;

                    $scope.signupStep = 3;
                    $scope.formStyle.left  = '-700px';
                }

                //$scope.credentials.authMethod = localData.signupType;
                //// reset from autofill
                //$scope.formStyle.left  = '0px';
                ////$scope.activateTab($scope.credentials.authMethod);
                //$scope.credentials.mbl = '';
                //$scope.credentials.email = '';
                //$scope.credentials.ringid = '';
            }

            if (remoteData) {
                $scope.newUid = remoteData.uId.toString().substr(2);
            }

            function signupData(type) {
                return  {
                    data: function () {
                        return {
                            signupType: type,
                            login_type: type === 'phone' ? $scope.credentials.mblDc : 'Email',
                            countryFlag: type === 'phone' ? $scope.credentials.countryFlag : 'remail'
                        };
                    }
                };
            }



            function sendCode(formValid, event) {
                event.preventDefault();
                if(!$scope.disableForm) {
                    $scope.requestFailed(false); // resets form
                    Auth.sendCode($scope.credentials).then(function(json) {
                        if(json.sucs === true) {
                            $scope.credentials.uId = json.uId;
                            $scope.newUid = json.uId.toString().substr(2);
                            $scope.signupStep = 2;
                            $scope.formStyle.left  = '-350px';
                        }
                        $scope.requestFailed(json, 'sendcode', 'signup');
                    }, function(errData) {
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), 'sendcode', 'signup');
                });
                } else {
                    RingLogger.information( 'form already submitted' , RingLogger.tags.AUTH);
                }
            }

            function verifyCode(formValid, event) {
                event.preventDefault();
                if(!$scope.disableForm) {
                    $scope.requestFailed(false); // resets form
                    Auth.verifyCode($scope.credentials).then(function(json) {
                        if(json.sucs === true) {
                            $scope.signupStep = 3;
                            $scope.formStyle.left  = '-700px';
                        }
                        $scope.requestFailed(json, 'verify', 'signup');
                    }, function(errData) {
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), 'verify', 'signup');
                    });
                } else {
                    RingLogger.information('form already submitted' , RingLogger.tags.AUTH);
                }
            }

            function signup(formValid, event) {
                event.preventDefault();
                if(!$scope.disableForm && $scope.credentials.password === $scope.credentials.repassword) {
                    $scope.requestFailed(false);
                    Auth.signup($scope.credentials).then(function(json) {
                        if(json.sucs === true) {
                            $scope.login(true);
                            Ringalert.show('Registraion succesful. You can login now', 'success');
                            $boxInstance.closeAll();
                        }
                        $scope.requestFailed(json, 'sendCode', 'signup');
                    }, function(errData) {
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), 'signup', 'signup');
                    });
                } else {
                    RingLogger.information('form already submitted');
                }

            }
        }


})();

/*
 * © Ipvision
 */

(function() {
    'use strict';


    angular.module('ringid.auth')
        .controller('SignUpSelectController', SignUpSelectController);

        SignUpSelectController.$inject = [ 'Auth', '$scope', '$controller', '$boxInstance', '$authSocial', 'Ringalert',];
        function SignUpSelectController( Auth, $scope, $controller, $boxInstance, $authSocial, Ringalert) { // jshint ignore:line

            angular.extend(this, $controller('AuthController', {$scope: $scope}));

            $scope.close = $boxInstance.close;
            $scope.closeAll = $boxInstance.closeAll;

            // sign up data
            $scope.socialSignup = function(platform) {
                $boxInstance.showLoader();
                // sendCode actually initializes signup and sends code for nonsocial signup
                Auth.sendCode($scope.credentials, true).then(function() {
                    $authSocial.authenticate(platform, $scope.credentials).then(function(authData) {
                        ga('send', 'event', 'Signup Success. ' , 'Auth Method: ' + platform + ' Social Authorization done' );
                        RingLogger.print(authData, RingLogger.tags.AUTH);
                        Auth.openSignup(authData, $scope.credentials).then(angular.noop, function(err) {
                            if (err.rc  === 'dologin') {
                                Ringalert.show("Existing User! Login in as " + authData.name , 'warning');
                                $scope.credentials.authMethod = platform;
                                $boxInstance.showLoader();
                                Auth.login(angular.extend(authData, $scope.credentials), true).then(function() {
                                    ga('send', 'event', 'Signin Success. ' , 'Auth Method: ' + platform );
                                    $scope.closeAll();
                                }, function(err) {
                                    $boxInstance.hideLoader();
                                    $scope.socialRequestFailed(err, platform, 'Social Login Failed');
                                });
                            } else {
                                $boxInstance.hideLoader();
                                $scope.socialRequestFailed(err, platform, 'Authentication Failed');
                            }
                        });
                    }, function(err) {
                        $boxInstance.hideLoader();
                        $scope.socialRequestFailed(err, platform, 'Authentication Failed');
                    });

                }, function(err) {
                    $boxInstance.hideLoader();
                    $scope.socialRequestFailed(err, platform, 'Authentication Failed');
                });
            };

            $scope.signupData  = function(type) {
                return  {
                    data: function () {
                            return {
                                signupData: {
                                    signupType: type,
                                    login_type: type === 'phone' ? Auth.getCountry().login_type : 'Email',
                                    countryFlag: type === 'phone' ? Auth.getCountry().countryFlag : 'remail'
                                }
                            };
                        },
                    promise:  Auth.sendCode($scope.credentials)
                };
            };

        }


})();

/* * © Ipvision
 */

(function () {
	'use strict';

	angular
		.module('ringid.auth')
		.controller('PasswordRecoverController', PasswordRecoverController);

	PasswordRecoverController.$inject = ['$controller', 'Auth', '$scope', '$boxInstance', 'authHttpService', 'Ringalert'];

	function PasswordRecoverController( $controller, Auth, $scope, $boxInstance, authHttpService, Ringalert) { // jshint ignore:line

            angular.extend(this, $controller('AuthController', {$scope: $scope}));

            // initialization
            $scope.close = $boxInstance.close;

            //signin data
            var sendSms;
            $scope.activeTab = 'email'; // ringid, email, phone
            $scope.activeForm = 'sendcode'; // 'sendcode', 'verifycode', 'resetpassword'

            // override method
            $scope.activateTab = activateTab;
            $scope.activateTab($scope.activeTab);
            // disable autofill
            $scope.credentials.email = '';
            $scope.credentials.mbl = '';

            // forgot pass operation
            $scope.sendCode = sendCode;
            $scope.verifyCode = verifyCode;
            $scope.resetPassword = resetPassword;





            function sendCode(formValid, $event, phone) {
                sendSms = phone;
                $event.preventDefault();
                if(!$scope.disableForm) {
                    $scope.requestFailed(false);
                    RingLogger.information($scope.credentials, RingLogger.tags.AUTH);
                    authHttpService.recoverySendCode($scope.credentials, sendSms).then(function(json){
                        if(json.sucs === true) {
                            $scope.activeForm = 'verifycode';
                            $scope.credentials.uId = json.uId;
                        }
                        $scope.requestFailed(json, sendSms ?  'phone' : 'email', 'recovery', true);
                    },function(errData){
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), sendSms ?  'phone' : 'email', 'recovery');
                    });
                }

            }


            function verifyCode(formValid, $event) {
                $event.preventDefault();
                if(!$scope.disableForm) {
                    $scope.requestFailed(false);
                    RingLogger.information( $scope.credentials, RingLogger.tags.AUTH);
                    authHttpService.recoveryVerifyCode($scope.credentials).then(function(json){
                        if(json.sucs === true) {
                            $scope.activeForm = 'resetpassword';
                        }
                        $scope.requestFailed(json, 'verify', 'recovery', true);
                    },function(errData){
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), 'verify', 'recovery', true);
                    });
                }

            }


            function resetPassword(formValid, $event) {
                $event.preventDefault();
                if(!$scope.disableForm && $scope.credentials.password === $scope.credentials.repassword ) {
                    $scope.requestFailed(false);
                    RingLogger.information( $scope.credentials, RingLogger.tags.AUTH);
                    authHttpService.resetPassword($scope.credentials).then(function(json){
                        RingLogger.print( json, RingLogger.tags.AUTH);
                        $scope.disableForm = false;
                        $scope.errorMsg = json.mg;
                        if(json.sucs === true) {
                            Ringalert.show('Reset succesful. You can login now', 'success');
                            $scope.close();
                            RingLogger.print('PASSWORD RESET SUCCESSFUL. YOU CAN LOGIN NOW', RingLogger.tags.AUTH);
                        }
                        $scope.requestFailed(json, 'reset', 'recovery', true);
                    },function(errData){
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), 'reset', 'recovery', true);
                    });
                }

            }

            // overrided method of AuthController
            function activateTab (tabName) {
                if(!$scope.disableForm && $scope.activeForm === 'sendcode') { // login not in progress
                    $scope.activeTab = tabName;
                    if($scope.activeTab === 'email') {
                        $scope.credentials.authMethod = 'email';
                        $scope.formStyle.left = '0px';
                        //$scope.credentials.login_type = 'Email';
                    } else {
                        $scope.credentials.authMethod = 'phone';
                        $scope.formStyle.left = '-350px';
                        //$scope.credentials.login_type = $scope.country ? $scope.country.login_type : '+880';
                    }
                    $scope.$rgDigest();
                }
            }

	}

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.notification', [
			'ringid.common.stacked_map',
			'ringid.config',
			'ringid.utils'
		]);

})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular.
    module('ringid.notification').
    factory('$$notiMap', $$notiMap);

		$$notiMap.$inject = ['circlesManager', 'OPERATION_TYPES', 'utilsFactory', 'settings'];
		function $$notiMap(circlesManager, OPERATION_TYPES, utilsFactory, settings) { //jshint ignore:line
			var OTYPES = OPERATION_TYPES.SYSTEM.NOTIFICATION;


            function setNotiMessage(noti) {
                var gName = '',
                    messageAndPopup = {
                    message: '',
                    popupType: '',
                    mayMerge: 1
                };

                function othersHandler() {
                    //if (noti.othersCounter > 1) {
                        //return ' and ' + noti.othersCounter  + ' others ';
                    //} else if (noti.othersCounter === 1){
                        //return ' and ' + noti.othersCounter  + ' other ';
                    //} else {
                        //return '';
                    //}
                    var counter = noti.uIdList.length - 1;
                    if (counter > 1) {
                        return ' and ' + counter + ' others ';
                    } else if (counter === 1){
                        return ' and ' + counter + ' other ';
                    } else {
                        return '';
                    }
                }

                switch(noti.mt) {
                    case OTYPES.MSG_TYPE_UPDATE_PROFILE_IMAGE: // update profile image
                        messageAndPopup.message = noti.fndN + " updated his profile photo";
                        messageAndPopup.popupType = 'image';
                        messageAndPopup.mayMerge = 2;
                        break;
                    case OTYPES.MSG_TYPE_UPDATE_COVER_IMAGE: // update cover image
                        messageAndPopup.message = noti.fndN + " updated his cover photo";
                        messageAndPopup.popupType = 'image';
                        messageAndPopup.mayMerge = 2;
                        break;
                    case OTYPES.MSG_TYPE_LIKE_IMAGE: // like image
                        messageAndPopup.message = noti.fndN + othersHandler() + " liked your image";
                        messageAndPopup.popupType = 'image';
                        break;
                    case OTYPES.MSG_TYPE_IMAGE_COMMENT: // comment image
                        messageAndPopup.message = noti.fndN + othersHandler() +" commented on your image";
                        messageAndPopup.popupType = 'image';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_IMAGE_COMMENT: // like image comment
                        messageAndPopup.message = noti.fndN + othersHandler() + " liked your comment";
                        messageAndPopup.popupType = 'image';
                        break;

                    case OTYPES.MSG_TYPE_ADD_FRIEND: // add friend request
                        messageAndPopup.message = noti.fndN + " wants to be friends with you";
                        messageAndPopup.popupType = 'profile';
                        break;
                    case OTYPES.MSG_TYPE_ACCEPT_FRIEND: // accept friend
                        messageAndPopup.message = noti.fndN + " has accepted your friend request";
                        messageAndPopup.popupType = 'profile';
                        break;

                    case OTYPES.MSG_TYPE_ADD_GROUP_MEMBER: // add group member
                        //String group_name = "";
                        //int try_count = 0;
                        //while (try_count++ < 3) {
                            //for (Long id : loggedUserProfile.getGroupList().keySet()) {
                                //DTOGroup g = loggedUserProfile.getGroupList().get(id);
                                //if (g.getGroupId() == activity_id) {
                                    //group_name = g.getGroupName();
                                    //break;
                                //}
                            //}
                            //if (group_name.length() > 0) {
                                //break;
                            //} else {
                                //Thread.sleep(500);
                            //}
                        //}
                        if ( circlesManager.getCircle(noti.acId) ) {
                            gName = circlesManager.getCircle(noti.acId).getName();
                        } else {
                            gName = '';
                        }

                        messageAndPopup.message = noti.fndN + " has added you in a group " + gName;
                        messageAndPopup.popupType = 'group';
                        messageAndPopup.mayMerge = 0;
                        break;

                    case OTYPES.MSG_TYPE_ADD_STATUS_COMMENT: // add status comment
                        messageAndPopup.message = noti.fndN + othersHandler() + " commented on your status";
                        messageAndPopup.popupType = 'feed';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_STATUS: // like status
                        messageAndPopup.message = noti.fndN + othersHandler() + " liked your status";
                        messageAndPopup.popupType = 'feed';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_COMMENT: // like comment
                        messageAndPopup.message = noti.fndN + othersHandler() + " liked your comment";
                        messageAndPopup.popupType = 'feed';
                        break;
                    case OTYPES.MSG_TYPE_SHARE_STATUS: // share status
                        messageAndPopup.message = noti.fndN + othersHandler() + " shared your status";
                        messageAndPopup.popupType = 'feed';
                        break;

                    // media type notifications
                    case OTYPES.MSG_TYPE_LIKE_AUDIO_MEDIA :
                        messageAndPopup.message = noti.fndN + othersHandler() + " Liked your audio";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_AUDIO_MEDIA_COMMENT :
                        messageAndPopup.message = noti.fndN + othersHandler() + " commented on your audio";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_AUDIO_MEDIA_COMMENT :
                        messageAndPopup.message = noti.fndN + othersHandler() + " liked your comment on audio";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_AUDIO_MEDIA_VIEW :
                        messageAndPopup.message = noti.fndN + othersHandler() + " viewed you audio";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_VIDEO_MEDIA :
                        messageAndPopup.message = noti.fndN + othersHandler() + " liked your video";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_VIDEO_MEDIA_COMMENT :
                        messageAndPopup.message = noti.fndN + othersHandler() + " commented on your video";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_VIDEO_MEDIA_COMMENT :
                        messageAndPopup.message = noti.fndN + othersHandler() + " like your comment on video";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_VIDEO_MEDIA_VIEW :
                        messageAndPopup.message = noti.fndN + othersHandler() +  " viewed you video";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_YOU_HAVE_BEEN_TAGGED :
                        messageAndPopup.message = noti.fndN + " tagged you in a status";
                        messageAndPopup.popupType = 'feed';
                        break;
                    default:
                        messageAndPopup.popupType = 'nomatch';
                        RingLogger.warn('messageAndPopup.message TYPE NOT FOUND');
                        messageAndPopup.mayMerge = 0;

                }
                return messageAndPopup;
            }

			return {
				getSortIndex: function() {
					return 'ut';
				},
				create: function(obj) {

                    var noti = {
                            acId: 0,
                            cmnId: 0,
                            fndId: 0,
                            fndN: '',
                            id: 0,
                            imgId: 0,
                            loc: 0,
                            mt: 0,
                            nfId: 0,
                            ut: 0,
                            nt: 0,
                            prIm:0,

                            uIdList: [],
                            message: '',
                            updateTime: '',
                            popupType: '',
                            groupId:0,
                            user: null,
							seen: false,
                            // noti merge properties
                            mayMerge: 1, // 0=no merge, 1= merge(increase counter of no of people), 2= (profile/cover update, delete older)
                            othersCounter: 0
                        };
					if (angular.isObject(obj)) {
						noti= angular.extend({}, noti, obj);
						noti.updateTime = utilsFactory.verbalDate(obj.ut) || noti.ut;
						//noti.user = friends.get(noti.friendId) || null;
                        //noti.message = createMessage(noti.mt, noti.fndN, noti.acId);
					}
					// set popupType
                    var msgPopup = setNotiMessage(noti);
                    noti.message = msgPopup.message;
                    noti.popupType = msgPopup.popupType;
                    noti.mayMerge = msgPopup.mayMerge;
                    // this below is needed for properly merging notifications
                    if (noti.fndId) {
                        noti.uIdList.push(noti.fndId);
                    }

					return {
						sortBy: function() {
							return noti.ut;
						},
                        getName: function() {
                            return noti.fndN;
                        },
                        isInUidList: function(uId) {
                             return (noti.uIdList.indexOf(uId) > -1);
                        },
                        uIdList: function(uId) {
                            if (uId && uId.length) {
                                uId.forEach(function(u) {
                                    if (noti.uIdList.indexOf(u) === -1) {
                                        noti.uIdList.push(u);
                                    }
                                });
                            } else {
                                return noti.uIdList;
                            }
                        },
                        getUid: function() {
                            return noti.fndId;
                        },
						getUserAvatar: function() {
							if (noti.user) {
								return noti.user.avatar('thumb');
							} else {
								if(noti.prIm){
									var position = noti.prIm.lastIndexOf('/') + 1;
									return [settings.imBase, noti.prIm.slice(0, position), 'pthumb',  noti.prIm.slice(position)].join('');
								}else{
									return 'images/prof.png';
								}

							}
						},
						getMessage: function() {
							return noti.message;
						},
						getTime: function(original) {
                            if (original) {
							    return noti.ut;
                            } else {
							    return noti.updateTime;
                            }
						},
						updateNotiTime: function () {
							noti.updateTime = utilsFactory.verbalDate(noti.ut);
						},
						getKey: function() {
							return noti.id;
						},
						getPopupType: function() {
							return noti.popupType;
						},
						getMessageType: function() {
							return noti.mt;
						},
						getNotiType: function() {
							return noti.nt;
						},
						getActivityId: function() {
							return noti.acId;
						},
						getNewsFeedId: function() {
							return noti.nfId;
						},
						getLink: function() {
							//var commentTypeNoti = [ MSG_TYPE_ADD_STATUS_COMMENT ,MSG_TYPE_LIKE_COMMENT, MSG_TYPE_ADD_COMMENT_ON_COMMENT ,MSG_TYPE_IMAGE_COMMENT ,MSG_TYPE_LIKE_IMAGE_COMMENT ];
                            var link = '', params = {};
                            switch(noti.popupType) {
                                case 'image':
									params.mediaId = noti.imgId;
									if(!!noti.cmnId){
										params.commentId = noti.cmnId;
									}

							        link = utilsFactory.getRingRoute('SINGLE_IMAGE', params);
                                    break;
                                case 'media':
									params.mediaId = noti.imgId;

                                    if(!!noti.cmnId){
                                        params.commentId = noti.cmnId;
                                    }

                                    link = utilsFactory.getRingRoute('SINGLE_MEDIA', params);
                                    break;
                                case 'profile':
                                    link =  utilsFactory.getRingRoute('USER_PROFILE', { uId : noti.fndId });
                                    break;
                                case 'group':
                                    link =  utilsFactory.getRingRoute('CIRCLE_HOME', { circleId: noti.acId });
                                    break;
                                case 'feed':
									params.feedId = noti.nfId;

									if(!!noti.cmnId){
										params.commentId = noti.cmnId;
									}

							        link = utilsFactory.getRingRoute('SINGLE_FEED', params);
                                    break;
                                default:
                                    link = '';
                            }
                            return link;
						},
						getImgId: function() {
							return noti.imgId;
						},
                        getCommentId: function() {
                            return noti.cmnId;
                        },
						getSeenStatus: function() {
							return noti.seen;
						},
						updateSeenStatus: function(seen) {
							noti.seen = seen;
						},
                        canMerge: function() {
                            return noti.mayMerge;
                        },
                        setNotiMessage: function(mergeCounter) {
                            noti.othersCounter += mergeCounter;
                            var modified = setNotiMessage(noti);
                            noti.message = modified.message;
                        },
                        // ringbox related api
                        getRingboxTemplate: function() {
                            var templatePath = '';
                            switch(noti.popupType) {
                              case 'image' :
                                    templatePath = 'pages/partials/notification/image-popup.html'; // IMPORTANT this template is preloaded inside auth factory
                                    break;
                              case 'media' :
                                    templatePath = 'pages/partials/notification/media-popup.html'; // IMPORTANT this template is preloaded inside auth factory
                                    break;
                              case 'feed' :
                                    templatePath = 'pages/partials/notification/feed-popup_with_image.html'; // IMPORTANT this template is preloaded inside auth factory
                                    break;
                              default:
                                  templatePath = '';
                            }
                            return templatePath;

                        },
                        getControllerName: function(){
                            return (noti.popupType === 'image' && 'RingBoxImagePopupController') ||
                                   (noti.popupType === 'feed' && 'NotiPopupController') ||
                                   (noti.popupType === 'media' && 'RingBoxMediaController');
                        },
                        showRingbox: function (){
                            return noti.popupType === 'feed' || noti.popupType === 'image' || noti.popupType === 'media' ? true : false;
                        }
					};
				}
			};
		}
})();

(function () {

'use strict';

angular
        .module('ringid.notification')
        .service('notificationHttpService', notificationHttpService);

        notificationHttpService.$inject = ['$$connector', 'settings', 'OPERATION_TYPES'];
        function notificationHttpService($$connector, settings, OPERATION_TYPES) { // jshint ignore:line
            var self = this, // jshint ignore:line
                OTYPES = OPERATION_TYPES.SYSTEM.NOTIFICATION,
                REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;

            /**
            * @api {request} /APIREQUEST/111 Get Notification list
            * @apiVersion 0.1.0
            * @apiDescription This Requests list of notification for logged in user.
            * @apiName GetNotifications
            * @apiGroup Notification
            *
            * @apiParam {Number=111} actn action constant for this api call
            * @apiParam {Number{1,2}} scl this dictates if Older or Newer notification
            * @apiParam {Number} ut Update Time in Timestamp
            *
            *
            * @apiSuccess {Number} acId Undefined
            * @apiSuccess {Number=111} actn action constant for this api call
            * @apiSuccess {Number} cmnId  Not needed
            * @apiSuccess {Number} headerLength packet header length
            * @apiSuccess {Number} imgId Not Needed
            * @apiSuccess {Number} loc Undefined
            * @apiSuccess {Object[]{1..5}} nList Notification list
            * @apiSuccess {Number} nfId Not needed
            * @apiSuccess {Number} pckFs Server Packet id
            * @apiSuccess {Number} pckId Packet id
            * @apiSuccess {Number{1,2}} scl this dictates if Older or Newer notification
            * @apiSuccess {Number} seq Packet Sequence number
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} tn total notification
            * @apiSuccess {Number} tr Undefined
            *
            * @apiSuccess (nList) {Number} acId Undefined
            * @apiSuccess (nList) {Number} cmnId Comment Id
            * @apiSuccess (nList) {Number} fndId Friend Id
            * @apiSuccess (nList) {String} fndN Friend Name
            * @apiSuccess (nList) {Number} groupId Group Id
            * @apiSuccess (nList) {Number} id Notification Id
            * @apiSuccess (nList) {Number} imgId Image Id
            * @apiSuccess (nList) {Number} loc Undefined
            * @apiSuccess (nList) {Number{1..13}} mt Message Type
            * @apiSuccess (nList) {Number} nfId Feed Id
            * @apiSuccess (nList) {Number{1..5}} nt Notification type
            * @apiSuccess (nList) {Number} ut Update Time in timestamp
            *
            *
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       acId: 0,
            *       actn: 111,
            *       cmnId: 0,
            *       headerLength: 62,
            *       imgId: 0,
            *       loc: 0,
            *       nList: [
            *           0: {
            *               acId: 0,
            *               cmnId: 0,
            *               fndId: "2000002368",
            *               fndN: "Wasif Islam",
            *               id: 368516,
            *               imgId: 14628,
            *               loc: 0mt: 1,
            *               nfId: 16103,
            *               nt: 5,
            *               ut: 1433832601723
            *           }
            *       ],
            *       nfId: 0,
            *       pckFs: 257739,
            *       pckId: "250085192336",
            *       scl: 1,
            *       seq: "4/7",
            *       sucs: true,
            *       tn: 32,
            *       tr: 32
            *     }
            *
            * @apiError Notification list not found
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 404 Not Found
            *     {
            *       "sucs": false
            *     }
            */

            self.requestNotification = function(obj){
                var payload = {
                    actn: OTYPES.TYPE_MY_NOTIFICATIONS,
                    //from_index: obj.from_index || 0,
                    //to_index: obj.to_index || 10,
                    //ut: obj.ut || -1,
                    //scl: obj.scl || 2
                };
                if (obj && obj.from_index > 0) {
                    payload = angular.extend({}, payload, obj);
                }
                RingLogger.print(payload, RingLogger.tags.NOTIFICATION);
                return $$connector.pull(payload, REQTYPE.REQUEST);
            };

            self.clearNotiCount = function() {
                var d = new Date();
                var t = d.getTime();
                var payload = {
                    actn: OTYPES.CLEAR_NOTIFICATION_COUNTER,
                    ut: t
                };
                RingLogger.print(payload, RingLogger.tags.NOTIFICATION);
                return $$connector.request(payload, REQTYPE.REQUEST);
            };

            self.getNotificationDetails = function (obj) {
                //RingLogger.print(obj, RingLogger.tags.NOTIFICATION);
                 var payload = {
                        actn: OPERATION_TYPES.SYSTEM.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS,
                        nfId: obj.activityId
                };
                RingLogger.print(payload, RingLogger.tags.NOTIFICATION);
                return $$connector.request(payload, REQTYPE.REQUEST);
            };

            self.getImageAlbumDetails = function(obj) {
                var payload = {
                    actn: OPERATION_TYPES.SYSTEM.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS,
                    request_type: REQTYPE.REQUEST,
                    imgId: obj.imgId
                };
                RingLogger.print(payload, RingLogger.tags.NOTIFICATION);
                return $$connector.request(payload, REQTYPE.REQUEST);
            };

        }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.notification')
		.factory('NotificationFactory', NotificationFactory);

		NotificationFactory.$inject = ['$$connector','$q', 'Storage','notificationHttpService', '$$stackedMap', '$$notiMap', 'OPERATION_TYPES', '$rootScope', 'SystemEvents', 'Auth'];
		function NotificationFactory($$connector,$q, Storage, notificationHttpService, $$stackedMap, $$notiMap, OPERATION_TYPES, $rootScope, SystemEvents, Auth) { //jshint ignore:line

			var $notification = $$stackedMap.createNew(true, 'desc'),
                OTYPES = OPERATION_TYPES.SYSTEM.NOTIFICATION,

                from_index = 0,
				updateTime,
			    notiCounter = 0,
                minUpdateTime = -1,
                requestCounter = 0,
                state = {
                    loading: false,
                    noData: false,
                };

            var seenarr = Storage.getData('notiseen');
            if(!seenarr){
                seenarr = [];
                Storage.setData('notiseen',seenarr);
            }

			var process = function(json){
                var noti, saveNewNoti = true;

                function mergeNoti(n) {
                    var mergeCounter = 0;

                    function processMerge(merge) {
                        if (n.value.getTime(true) < noti.getTime(true) ) {
                            RingLogger.information('DELETING OLD NOTIfication: ' + n.value.getMessage() + ' merging: ' + merge, RingLogger.tags.NOTIFICATION);
                            notiCounter = notiCounter > 0 ? notiCounter-1 : 0;
                            // updatee new noti utid list
                            noti.uIdList(n.value.uIdList());

                            //if (merge) {
                            // not same person increase counter
                                noti.setNotiMessage();
                                //mergeCounter == noti.uIdList().length;
                            //}

                            // new noti is latest
                            $notification.remove(n.value.getKey());
                        } else {
                            // new noti is old.
                            saveNewNoti = false;
                            RingLogger.information('not saving new OTIFICATION: '+ noti.getMessage() + ' merging: ' + merge, RingLogger.tags.NOTIFICATION);
                            n.value.uIdList(noti.uIdList());

                            //if (merge) {
                                n.value.setNotiMessage();
                            //}
                            // update old noti utid list
                        }
                    }

                    if (n.value.getMessageType() === noti.getMessageType()) {
                        if (n.value.canMerge() === 1) {
                            switch(n.value.getPopupType()) {
                                case 'feed':
                                    if (n.value.getNewsFeedId() === noti.getNewsFeedId()) {
                                        //if (n.value.getUid() !== noti.getUid()) {
                                        if (!n.value.isInUidList(noti.getUid())) {
                                            processMerge(true);
                                        } else {
                                            processMerge(false);
                                        }
                                    }
                                    break;
                                case 'image':
                                case 'media':
                                    if (n.value.getImgId() === noti.getImgId()) {
                                        //if (n.value.getUid() !== noti.getUid()) {
                                        if (!n.value.isInUidList(noti.getUid())) {
                                            processMerge(true);
                                        } else {
                                            processMerge(false);
                                        }
                                    }
                                    break;
                            }
                        } else if (n.value.canMerge() === 2) {
                            // no need to merge. delete older notification
                            if (n.value.getUid() === noti.getUid()) {
                                processMerge(false);
                            }
                        }
                    }

                    //if (mergeCounter > 0) {
                         //noti.setNotiMessage(mergeCounter);
                    //}
                }

                switch(json.actn) {
                    case OTYPES.TYPE_MY_NOTIFICATIONS:
                        RingLogger.print(json, RingLogger.tags.NOTIFICATION);
                        if (json.sucs === true || json.sucs === 'true' ) {
                            var timeArray = [];

                            from_index += json.nList.length;
                            notiCounter = json.tn;
                            for(var i = 0; i < json.nList.length; i++) {
                                saveNewNoti = true;
                                noti = $$notiMap.create(json.nList[i]);
                                // check if merge needed and do the merge
                                $notification.all().forEach( mergeNoti);
                                updateTime = json.nList[i].ut;
                                timeArray.push(updateTime);

                                if (saveNewNoti) {
                                    for(var j = 0 ; j < seenarr.length ; j++ ){
                                        if( seenarr[j] === json.nList[i].id ){
                                            noti.updateSeenStatus(true);
                                        }
                                    }
                                    $notification.save(noti.getKey(), noti);
                                } else {
                                    notiCounter = notiCounter > 0 ? notiCounter-1 : 0;
                                }
                            }

                            var sortedTime = timeArray.sort();
                            minUpdateTime = sortedTime[0];
                        } else {
                            RingLogger.warning('Notification list request failed', RingLogger.tags.NOTIFICATION);
                        }

                        break;
                    case OTYPES.TYPE_SINGLE_NOTIFICATION:
                        from_index++;
                        saveNewNoti = true;
                        noti = $$notiMap.create(json);
                        // check if merge needed and do the merge
                        $notification.all().forEach( mergeNoti);
                        RingLogger.information('got new notification: ' + noti.getMessage(), RingLogger.tags.NOTIFICATION);
                        if (saveNewNoti) {
                            $notification.save(noti.getKey(), noti);
                            // check if merge needed
                            notiCounter++;
                        }

                        break;
                    default:
                        RingLogger.warning('Notification Subscriber action did not match: ' + json.actn, RingLogger.tags.NOTIFICATION);
                }

			};



            var loadMoreNoti = function(toIndex) {
                toIndex = toIndex || 10;
                var deferred = $q.defer();
                requestCounter++;
                state.noData = requestCounter > 1;

                var obj = {
                    from_index: (from_index > 0) ? from_index : 0,
                    to_index: (from_index > 0) ? from_index+toIndex: toIndex,
                    scl: 2,
                    ut: minUpdateTime
                };

                notificationHttpService.requestNotification(obj).then(function(json) {
                    if (json.sucs === true || json.sucs === 'true') {
                        //process(json);
                        requestCounter = 0;
                        deferred.resolve();
                    } else {
                        state.noData = true;
                        deferred.reject();
                    }
                }, function() {
                    deferred.reject();
                });
                return deferred.promise;
            };


            $$connector.subscribe(process,
                          { action: [
                                OTYPES.TYPE_MY_NOTIFICATIONS,
                                OTYPES.TYPE_SINGLE_NOTIFICATION
                            ]
                          });

            if (Auth.isLoggedIn()) {
                loadMoreNoti();
                //notificationHttpService.requestNotification().then(process);
            } else {
                $rootScope.$on(SystemEvents.AUTH.LOGIN, function() {
                    setTimeout(function() {
                        loadMoreNoti();
                        //notificationHttpService.requestNotification().then(process);
                    }, 5000);
                });
            }

			return {
                state: state,
                loadMoreNoti: loadMoreNoti,
                process: process,
				getNotifications: function() {
					return $notification;
				},
				getNotification: function(key) {
					return $notification.get(key);
				},
				clearCounter: function() {
                    if (notiCounter > 0)  {
					    notificationHttpService.clearNotiCount().then(function(json) {
                            RingLogger.information('NOTIFICATION COUNT CLEAR RESPONSE', RingLogger.tags.NOTIFICATION);
                            RingLogger.print(json, RingLogger.tags.NOTIFICATION);
                            notiCounter = 0;
                        });
                    }
                    // update notification times
                    //var notifications = NotificationFactory.getNotifications();
                        for(var i=0; i < $notification.length(); i++){
                            var timediff = Date.now() - $notification.all()[i].value.sortBy();
                            if(timediff < 3600000) {
                                $notification.all()[i].value.updateNotiTime();
                            }
                        }
				},
				getNotiCount: function() {
                    return  notiCounter > 99 ? '99+' : notiCounter;
				},
                //getNotificationDetails : function(obj) {
                    //var defer =  $q.defer();
                    //notificationHttpService.getNotificationDetails(obj).then(function(json){
                        //if(json.sucs ===true) {
                             //defer.resolve(json);
                        //}else{
                             //defer.reject(json);
                        //}

                    //});
                    //return defer.promise;
                //}

			};
		}

})();


/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.notification')
        .directive('rgNotification', rgNotification);

    rgNotification.$inject = [ '$window', '$document', '$ringhttp', '$compile'];
    function rgNotification( $window, $document, $ringhttp, $compile) { // jshint ignore:line

        NotificationController.$inject = ['NotificationFactory', '$location', 'circlesManager', 'ImageFactory', 'Auth', 'Media', 'rgDropdownService', 'Ringalert', 'Storage', '$scope', 'rgScrollbarService',
                                            'OPERATION_TYPES', '$$connector', 'notificationHttpService'];
        function NotificationController(NotificationFactory, $location, circlesManager, ImageFactory, Auth, Media, rgDropdownService, Ringalert, Storage, $scope, rgScrollbarService,
                                            OPERATION_TYPES, $$connector, notificationHttpService) { //jshint ignore:line

            var requestTimeout,
                loadCount = parseInt($scope.loadCount),
                OTYPES = OPERATION_TYPES.SYSTEM.NOTIFICATION;

            $scope.state = NotificationFactory.state;
            //$scope.notiCount = NotificationFactory.getNotiCount;
            $scope.notifications = NotificationFactory.getNotifications();
            $scope.loadMoreNotification = loadMoreNotification;
            $scope.getRingboxData = getRingboxData;
            $scope.notificationAction = NotificationFactory.notificationAction;


            $scope.getAllNotifications = function () {
                //var notiobj = {};
                //  return {
                //      data:notiobj
                //  };
                //promise:
            };


            function getRingboxData (noti) {
                switch(noti.value.getPopupType()){
                  case 'image' :
                    return notificationAction( { action:'image',noti:noti.value, nfId : noti.value.getNewsFeedId(), imgId: noti.value.getImgId(), templateType : 'image' } );
                  case 'media' :
                    return notificationAction( { action:'media',noti:noti.value, nfId : noti.value.getNewsFeedId(), mediaId: noti.value.getImgId(), templateType : 'media' } );
                  case 'feed' :
                    return notificationAction( {
                        action:'ringbox',
                        nfId : noti.value.getNewsFeedId(),
                        noti:noti.value,
                        templateType : 'feed_with_text'
                      }
                    );
                }
            }

            function notificationAction (actionObj) {
                rgDropdownService.close();
                var seenarr = Storage.getData('notiseen');
                if(seenarr.indexOf(actionObj.noti.getKey()) === -1){
                    seenarr.push(actionObj.noti.getKey());
                    actionObj.noti.updateSeenStatus(true);
                    if(seenarr.length > 150){
                        seenarr.shift();
                    }
                }
                Storage.setData('notiseen',seenarr);
                switch (actionObj.action) {
                        case 'redirect':
                            var circle = circlesManager.getCircle(actionObj.circleId);
                            if(circle){
                                var loc = actionObj.link.slice(1);
                                $location.path(loc);
                            }else{
                                Ringalert.show('Circle does not exist!', 'error');
                            }
                            break;
                        case 'ringbox' :
                              return {
                                 data: function () {
                                   return {notiKey: actionObj.noti.getKey(),noti : actionObj.noti, templateType : actionObj.templateType };
                                 },
                                 promise: notificationHttpService.getNotificationDetails({activityId: actionObj.nfId})
                               };
                        case 'media' :
                          return {
                              data: function() {
                                  return {
                                      notiKey: actionObj.noti.getKey(),
                                      noti : actionObj.noti,
                                      mediaId: actionObj.mediaId,
                                      popupFrom: 'notification',
                                      templateType: actionObj.templateType
                                  };
                              },
                              promise: Media.fetchContentDetails(actionObj.mediaId, true,Auth.currentUser()),
                          };
                        case 'image' :
                            return {
                               data: function() {
                                  return {
                                        notiKey: actionObj.noti.getKey(),
                                        noti : actionObj.noti,
                                        imgId: actionObj.imgId,
                                        popupFrom: 'notification',
                                        templateType: actionObj.templateType
                                  };
                                },
                                promise: ImageFactory.getImageDetails(actionObj.imgId,actionObj.nfId)
                            };
                        default :
                        RingLogger.log('NO MATCHING ACTION');
                }
            }


            function toggleLoading(bool) {
                $scope.state.loading = bool;
                if (!bool) {
                    rgScrollbarService.recalculate($scope);
                }
                $scope.$rgDigest();
            }


            function loadMoreNotification() { // jshint ignore:line
                // no request in progress
                if (!$scope.state.loading && !$scope.state.noData) {
                    clearTimeout(requestTimeout);
                    toggleLoading(true);
                    RingLogger.information('Load Notification', RingLogger.tags.NOTIFICATION);

                    NotificationFactory.loadMoreNoti(loadCount).then(function() {
                        if ($scope.notifications.length() < loadCount) {
                            loadMoreNotification();
                        }
                        toggleLoading(false);
                    }, function() {
                        RingLogger.alert('Notification Fetch Fail', RingLogger.tags.NOTIFICATION);
                        toggleLoading(false);
                    });

                    // in case the promise never resolves or rejects
                    requestTimeout = setTimeout(function() {
                        toggleLoading(false);
                    }, 3000);
                }
            }


            // initialize
            if ($scope.notifications.length() < loadCount) {
                loadMoreNotification();
            }

             var subscriptionKey = $$connector.subscribe(
                            function() {
                                setTimeout(function() {
                                    $scope.$rgDigest();
                                });
                            },
                            { action: [
                                OTYPES.TYPE_MY_NOTIFICATIONS,
                                OTYPES.TYPE_SINGLE_NOTIFICATION
                            ]
                        });

            $scope.$on('$destroy', function() {
                $$connector.unsubscribe(subscriptionKey);
            });

        }

        function linkFunc(scope, element, attr) {
            var templateUrl =  attr.templateUrl ? attr.templateUrl : 'pages/dropdowns/notification-dropdown.html';

            $ringhttp.get(templateUrl).success(function(template) {
                element.append($compile(template)(scope));
                scope.$rgDigest();
            });

        }

        return {
            restrict: 'AE',
            controller: NotificationController,
            //templateUrl: 'pages/dropdowns/notification-dropdown.html', // IMPORTANT template preloaded inside auth factory
            //scope: true,
            scope: {
                 loadCount: '@',
                 templateUrl: '@'
            },
            link: linkFunc

        };

    }
})();

/**
 *
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.notification' )
        .controller('NotiPopupController', NotiPopupController );

    NotiPopupController.$inject =
        ['$$connector', 'OPERATION_TYPES', 'Auth','$scope','localData','remoteData', 'NotificationFactory', '$$feedMap','feedFactory','rgDropdownService','Ringalert','MESSAGES', 'Media'];
    function NotiPopupController($$connector, OPERATION_TYPES,  Auth, $scope,   localData,remoteData, notificationFactory, $$feedMap, feedFactory,rgDropdownService,Ringalert,MESSAGES, Media) { // jshint ignore:line
        var OTYPES = OPERATION_TYPES.SYSTEM,OTYPES_NOTI = OPERATION_TYPES.SYSTEM.NOTIFICATION,showWhoShare=true;
        //console.warn(localData.notification.value.getCommentId());
        // view model
        $scope.currentUser = Auth.currentUser();
        $scope.feed = {};
        $scope.focused = false;
        $scope.showCommentBox = true;

        $scope.nocontent = false;

        // dropdown specific data and methods
        $scope.ddHtml = 'pages/dropdowns/feed-edit-dropdown.html';


        // methods
        //$scope.like = likeFeed;
        $scope.getMediaData = getMediaData;
        // end mothods list



        if (localData && localData.notiKey) {
            $scope.key = localData.notiKey;
            $scope.noti = localData.noti;
            $scope.templateType = localData.templateType;

            // switch(localData.noti.getMessageType()){

            //     case OTYPES_NOTI.MSG_TYPE_LIKE_STATUS:
            //     case OTYPES_NOTI.MSG_TYPE_LIKE_COMMENT:
            //          showWhoShare = false;break;
            //     case OTYPES_NOTI.MSG_TYPE_SHARE_STATUS:

            //     case OTYPES_NOTI.MSG_TYPE_ADD_STATUS_COMMENT:
            //         showWhoShare = true;break;
            // };
        }
        // check what to show using nt, mt value

        $scope.boxIsLoading = false;
        if(remoteData.sucs === false) {
            $scope.nocontent = true;
            Ringalert.show(remoteData,'error');
            $scope.$close();
            return false;
        }else{
              RingLogger.debug(remoteData.newsFeedList, RingLogger.tags.NOTIFICATION);

            var shareData = angular.fromJson(remoteData.newsFeedList)
            //console.log(remoteData.newsFeedList[0]);
            //

             if(showWhoShare && shareData[0] && shareData[0].orgFd){
                $scope.feed = $$feedMap.create(shareData[0]);
                var _d1 = $$feedMap.create(shareData[0].orgFd);
                $scope.feed.shares(_d1);
            }else{
                $scope.feed = $$feedMap.create(remoteData.newsFeedList[0]);
            }
                $scope.keyid = $scope.feed && $scope.feed.getKey();//used in template as keyid

        }


        // like on a comment in feed
        //if($scope.noti.getMessageType() === 8 && $scope.noti.getNotiType() === 2) {

            //  $$connector.subscribe(function(json) {
            //         console.log(commentJson);
            //         $scope.feed.pushComment(commentJson);
            //  },{
            //     action : OTYPES.ACTION_GET_FULL_COMMENT
            //  });
            // // get specific comment and highlight it
            //  feedFactory.fetchCommentById($scope.noti.getNewsFeedId(), $scope.noti.getCommentId()).then(function(commentJson) {
            //         console.log(commentJson);
            //         $scope.feed.pushComment(commentJson);
            //  });
        //}

        if( $scope.feed.hasMedia() || ( $scope.feed.hasSharedFeed() && $scope.feed.getOrginalFeed().getImages().length )){
            $scope.templateType = 'feed_with_image';
        }



        // function likeFeed (feed){

        //      var key = $scope.feed.getKey();
        //             feedFactory.likeUnlikeFeed(key,$scope.feed).then(function(json){
        //                RingLogger.print("done liking feed from popup")
        //             });
        //             if($scope.feed.like()){
        //                 $scope.$broadcast('LikeChange',true);
        //             }
        // }




        if($scope.noti.getCommentId() > 0){
            $scope.activeCommentId = $scope.noti.getCommentId();
        }




        function getMediaData(media,feed) {
            if(!feed)feed = $scope.feed;
            return {
                    data: function () {
                        return {
                            media: media,
                            album: feed.getAlbum(),
                            feedTime: feed.time()
                        };
                    },
                    promise: Media.fetchContentDetails(media.getKey(),true, feed.user())
                };
         }




        $scope.shareMenuDisabled = $scope.shareMenuDisabled ? $scope.shareMenuDisabled : false;

        var commentInitialFetch = false;
        $scope.toggleCommentBox = function (event) {
            event.stopPropagation();
            $scope.showCommentBox = !$scope.showCommentBox;
            if($scope.showCommentBox) {
                $scope.showShareBox = false;
            }
        };

        $scope.toggleShareBox = function(event) {
            event.stopPropagation();
            var f = $scope.feed.hasSharedFeed() ? $scope.feed.getOrginalFeed():$scope.feed;
            var shareablle = f.isShareAble(true);
            if(shareablle.sucs) {
                $scope.showShareBox = !$scope.showShareBox;
                if($scope.showShareBox) {
                    $scope.showCommentBox = false;
                }
            } else {
                Ringalert.show(MESSAGES[shareablle.rc],'warning');
            }
        };
        $scope.getImageData = function (image, feed) {

                return function () {
                            return {
                               image: image,
                               feed: feed
                           };
                        };
            };
        //$scope.singleFeed = true;

    }
})();



/*
* © Ipvision
*/

(function(){
    'use strict';
    angular
        .module('ringid.friend.friends_factory', [
            'ringid.auth',
            'ringid.common.stacked_map',
            'ringid.common.contacts_factory',
            'ringid.common.user_factory',
            'ringid.common.services',
            'ringid.common.factories'
        ])
        .factory('friendsFactory', friendsFactory);

		friendsFactory.$inject = [ '$$q', 'Contacts', 'APP_CONSTANTS', 'Auth', 'Storage',  '$$connector', 'OPERATION_TYPES', 'userFactory', 'friendsHttpService', '$$stackedMap', 'Ringalert'];
        function friendsFactory( $q, Contacts, APP_CONSTANTS, Auth, Storage,  $$connector, OPERATION_TYPES,  userFactory, friendsHttpService, $$stackedMap, Ringalert) { //jshint ignore:line

            var OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS,
                AC = APP_CONSTANTS,
                userFriendsCount = 0,
                userFriendsSt = 0,
                intervalContactList,
                utIdRequest = {
                        totalPacket: 0,
                        complete: false
                };


            var _utIDsToByteArray = function(utIds) {
                var byteArray = [],
                    contactList = [],
                    i,
                    l,
                    index,
                    requestedUtIds = [];

                // filter utid whose request are already made and data already available in localStorage
                for(i = 0, l = utIds.length; i < l; i++) {
                    if(utIds[i] === Auth.currentUser().getUtId()) { //already requested. remove this item
                        continue;
                    } else if(Storage.getContact(utIds[i])) { // set contact from localStorage
                        contactList.push(Storage.getContact(utIds[i]));
                    } else {
                        requestedUtIds.push(utIds[i]);
                    }
                }

                // already got these contacts from localStorage. so add these to friends lists
                if (contactList.lenght > 0) {
                    _setContacts(contactList);
                }

                var buf = new ArrayBuffer(requestedUtIds.length * 8),
                    utIDsArray = new DataView(buf);
                // create byte array
                for(i = 0, index = 0, l = requestedUtIds.length; i < l; i++) {
                    utIDsArray.setInt32(index,0);
                    index += 4;
                    utIDsArray.setInt32(index,requestedUtIds[i]);
                    index += 4;
                }

                for(i = 0; i < utIDsArray.byteLength; i++){
                    byteArray.push(utIDsArray.getInt8(i));
                }

                return byteArray;
            };

            var _clearUtId = function(utId, removeContacts,  removeAll) {
                var success =  Contacts.remove('utIds', utId);
                if (removeContacts) {
                    fFactory.friends.remove(utId);
                }
                if (!success || removeAll) {
                    success = Contacts.remove('incomingUtIds', utId);
                    if (removeContacts) {
                        fFactory.incomingFriends.remove(utId);
                    }
                    if (!success || removeAll) {
                        success = Contacts.remove('outgoingUtIds', utId);
                        if (removeContacts) {
                            fFactory.outgoingFriends.remove(utId);
                        }
                    }
                }
            };

            var _setContacts = function(contactList) {
                var friend, frnS;
                for (var i = 0, l = contactList.length; i < l; i++) {
                    friend = userFactory.create(contactList[i]);
                    frnS = friend.friendshipStatus();

                    //if(contactList[i].deleted && contactList[i].deleted === 1) { // if contact is deleted do not save it
                        //continue;
                    //}

                    if(frnS === AC.FRIEND) { // friend
                        //Contacts.remove('utIds', contactList[i].utId);
                        fFactory.friends.save(friend.getUtId(), friend);
                    } else if (frnS  === AC.INCOMING_FRIEND) { // friend request received
                        //Contacts.remove('incomingUtIds', contactList[i].utId);
                        fFactory.incomingFriends.save(friend.getUtId(), friend);
                    } else if(frnS === AC.OUTGOING_FRIEND){ // friend request sent
                        //Contacts.remove('outgoingUtIds', contactList[i].utId);
                        fFactory.outgoingFriends.save(friend.getUtId(), friend);
                    } else {
                        RingLogger.warning('Friendship Status not matched: ' + friend.getName() + ' frnS: ' + friend.friendshipStatus(), RingLogger.tags.FRIEND);
                        RingLogger.print(contactList[i], RingLogger.tags.FRIEND);
                    }

                    _clearUtId(contactList[i].utId, false, true);
                    //Contacts.remove('utIds', contactList[i].utId);
                    //Contacts.remove('incomingUtIds', contactList[i].utId);
                    //Contacts.remove('outgoingUtIds', contactList[i].utId);

                }


            };



            var processResponse = function(json) {
                var friend, i, l;
                switch(json.actn) {
                    case OTYPES.TYPE_CONTACT_UTIDS:
                        if(json.sucs === true) {
                            clearInterval(intervalContactList); // no more need of requesting utid list
                            if (utIdRequest.totalPacket === 0 &&  !utIdRequest.complete) { // check total response
                                utIdRequest.totalPacket = json.totalPacket;
                            }
                            utIdRequest.totalPacket--;
                            for(i = 0, l = json.utIds.length; i < l; i++) {
                                // save new utids in localstorage;
                                switch(json.utIds[i].value.frnS) {
                                    case AC.FRIEND:
                                        Contacts.add('utIds', json.utIds[i].key, json.utIds[i].value);
                                        break;
                                    case AC.INCOMING_FRIEND:
                                        Contacts.add('incomingUtIds', json.utIds[i].key, json.utIds[i].value);
                                        break;
                                    case AC.OUTGOING_FRIEND:
                                        Contacts.add('outgoingUtIds', json.utIds[i].key, json.utIds[i].value);
                                        break;
                                    default:
                                       RingLogger.information('contact not needed: ' + json.utIds[i].value.frnS, RingLogger.tags.FRIEND);
                                }
                            }

                            if (utIdRequest.totalPacket === 0) { // got all the packets for utid
                                utIdRequest.complete = true;
                                Contacts.initStorage();
                                RingLogger.information('contact friend: ' + Contacts.utIds().length() , RingLogger.tags.FRIEND);
                                RingLogger.information('contact incoming: ' + Contacts.incomingUtIds().length() , RingLogger.tags.FRIEND);
                                RingLogger.information('contact outgoing: ' + Contacts.outgoingUtIds().length() , RingLogger.tags.FRIEND);

                            }
                        } else {
                            RingLogger.warning('Contact List utID Request response fail', RingLogger.tags.FRIEND);
                        }
                        break;

                    //case OTYPES.TYPE_CONTACT_LIST: // fetch own contacts response
                        //fFactory.state.isFriendsLoading = false;
                        //fFactory.state.isRequestsLoading = false;
                        //fFactory.state.noFriends = false;
                        //if (json.sucs === true) {
                            //// get matchby Value and remove this contact from fFactory.utIDs list
                            //for(i = 0; i < json.contacts.length; i++) {
                                //Storage.setContact(json.contacts[i].utId, json.contacts[i]); // store in localStorage
                                //_setContacts(json.contacts[i]);
                            //}
                        //} else {
                            //RingLogger.warning('Contact List Detail Request fail', RingLogger.tags.FRIEND);
                            //RingLogger.print(json, RingLogger.tags.FRIEND);
                        //}
                        //break;
                    //case OTYPES.TYPE_FRIEND_CONTACT_LIST: // fetch friends contacts response
                        //fFactory.state.isUserFriendsLoading = false;
                        //userFriendsCount = json.tf;
                        //if (json.sucs === true) {
                            //for(i = 0; i < json.contactList.length; i++) {
                                //friend = userFactory.create(json.contactList[i]);
                                //fFactory.userFriends.save(friend.getUtId(), friend);
                            //}
                        //}
                        //break;

                    case OTYPES.TYPE_UPDATE_ADD_FRIEND: // 327, //"add_friend"
                        RingLogger.information('TYPE_UPDATE_ADD_FRIEND', RingLogger.tags.FRIEND);
                        if(json.sucs === true) {
                            Contacts.add('incomingUtIds', json.utId, {frns: AC.INCOMING_FRIEND});
                        }
                    break;
                    case OTYPES.TYPE_UPDATE_DELETE_FRIEND: //328, // "delete_friend"
                        RingLogger.information('TYPE_UPDATE_DELETE_FRIEND', RingLogger.tags.FRIEND);
                        if(json.sucs === true) {
                            if(json.utId) {
                                _clearUtId(json.utId, true, true);
                                //if(!fFactory.friends.remove(json.utId)) { // remove from friend list
                                    //if(!fFactory.incomingFriends.remove(json.utId)) { // remove from incoming friends
                                        //Contacts.remove('outgoingUtIds', json.utId); // remove from outgoing utid list
                                    //} else {
                                        //Contacts.remove('incomingUtIds', json.utId); // remove from incoming utid list
                                    //}
                                //} else {
                                    //Contacts.remove('utIds', json.utId); // remove from friend utid list
                                //}
                                // in case user in in search result or current user visiting his/her profile then we
                                // need to update the userMap object too
                                friend = userFactory.create(json);
                                friend.updateUserObj({frnS: AC.NOT_FRIEND});
                            } else {
                                RingLogger.warning('missing utId', RingLogger.tags.FRIEND);
                            }
                        }
                        break;
                    case OTYPES.TYPE_UPDATE_ACCEPT_FRIEND: // 329, //"friend accepts me acknowledgement"
                        RingLogger.information('TYPE_UPDATE_ACCEPT_FRIEND', RingLogger.tags.FRIEND);
                        if(json.sucs === true) {
                            //Contacts.remove('outgoingUtIds', json.utId);
                            //Contacts.add('utIds', json.utId);
                            _clearUtId(json.utId, true);
                            fFactory.friends.add(json.utId, userFactory.create(json));
                        }
                        break;
                    default:
                        RingLogger.warning('Friends Factory subscriber process case missmatch for action: ' + json.actn, RingLogger.tags.FRIEND);
                }

            };

            var getFriends = function(type) {
                switch(type) {
                    case 'friendslist':
                    case 'friends':
                        return fFactory.friends;
                    case 'incoming':
                        return fFactory.incomingFriends;
                    case 'outgoing':
                        return fFactory.outgoingFriends;
                    case 'userfriends':
                        return fFactory.userFriends;
                }
            };

            // when leaving user friends page, empty userFriends
            var resetUserFriends =  function() {
                userFriendsCount = 0;
                fFactory.userFriends.reset();
            };

            // friends contact list of a friend
            var getUserContacts =  function(utId) {
                var defer = $q.defer(), friend;
                friendsHttpService.getUserContacts(utId, userFriendsSt).then(function(json) {
                    userFriendsCount = (userFriendsCount === 0 )? json.tf : userFriendsCount;
                    if (json.sucs === true) {
                        RingLogger.print(json, RingLogger.tags.FRIEND);
                        userFriendsSt += json.contactList.length;
                        for(var i = 0; i < json.contactList.length; i++) {
                            friend = userFactory.create(json.contactList[i]);
                            fFactory.userFriends.save(friend.getKey(), friend);
                        }
                        defer.resolve();
                    } else {
                        RingLogger.alert('FRIENDS FRIENDLIST FETCH FAIL', RingLogger.tags.FRIEND);
                        defer.reject();
                    }
                }, function() {
                    RingLogger.warning('friends friendlist fetch fail', RingLogger.tags.FRIEND);
                });
                return defer.promise;
            };

            //current user friend list
            var getContactDetails =  function(type, getRecord) {
                var i,
                    utidByteArray = [],
                    defer = $q.defer();

                getRecord = getRecord ? getRecord : 20;
                type = type ? type : 'utIds';

                switch(type) {
                    case 'friends':
                    case 'friendslist':
                    case 'utIds':
                        utidByteArray = _utIDsToByteArray(Contacts.utIds().keys().slice(0, getRecord) );
                        fFactory.state.isFriendsLoading = utidByteArray.length > 0 ? true : false;
                        break;
                    case 'userfriends':
                        RingLogger.warning('FETCH USER FRIEND LIST', RingLogger.tags.FRIEND);
                        break;
                    case 'incoming':
                    case 'incomingUtIds':
                        utidByteArray = _utIDsToByteArray( Contacts.incomingUtIds().keys().slice(0, getRecord) );

                        RingLogger.print(utidByteArray, RingLogger.tags.FRIEND);
                        break;
                    case 'outgoing':
                    case 'outgoingUtIds':
                        utidByteArray = _utIDsToByteArray( Contacts.outgoingUtIds().keys().slice(0, getRecord) );
                        break;
                }

                if (utidByteArray.length > 0) {
                    friendsHttpService.getContactListDetails({
                        utIDs: utidByteArray,
                        uo: false
                    }).then( function(json) {
                        RingLogger.information('success data', RingLogger.tags.FRIEND);
                        RingLogger.print(json, RingLogger.tags.FRIEND);

                        if (json.sucs === true) {
                            // get matchby Value and remove this contact from fFactory.utIDs list
                            for(i = 0; i < json.contacts.length; i++) {
                                Storage.setContact(json.contacts[i].utId, json.contacts[i]); // store in localStorage
                            }
                            _setContacts(json.contacts);
                            defer.resolve(json);
                        } else {
                            RingLogger.warning('Contact List Detail Request fail', RingLogger.tags.FRIEND);
                            defer.reject(json);
                        }
                    }, function(errData) {
                        RingLogger.informaiton('error data', RingLogger.tags.FRIEND);
                        RingLogger.print(errData, RingLogger.tags.FRIEND);
                        defer.reject();
                    });
                } else {
                    defer.reject();
                }
                return defer.promise;

            };



            //contact details by UtIds
            var getContactDetailsByUtIds =  function(utIds){
                if(utIds.length > 0) {
                    var utidByteArray =  _utIDsToByteArray(utIds);

                    if(utidByteArray.length > 0) {
                        return friendsHttpService.getContactListDetails({
                            utIDs: utidByteArray,
                            uo: false
                        });
                    }
                }
            };


            var peopleYouMayKnowList =  function(obj) {
                return friendsHttpService.getPeopleYouMayKnow(obj || {});
            };

            var friendAction = function(obj, returnPromise) { // obj= {friend: userObj, action: 'accept', 'addfriend' etc }
                obj.friend.isLoading(true);
                switch(obj.action) {
                    case 'remove':
                    case 'unfriend': // AC.FRIEND :  // unfriend
                        return removeFriend(obj, returnPromise);
                    case 'add':
                    case 'addfriend': //AC.NOT_FRIEND: // send new friend request
                        return addFriend(obj, returnPromise);
                    case 'accept': // accept friend request
                        return acceptFriendRequest(obj, returnPromise);
                    case 'incoming_reject': // reject or cancel incoming or outgoig friend request
                    case 'outgoing_reject': // reject or cancel incoming or outgoig friend request
                    case 'reject': // reject or cancel incoming or outgoig friend request
                        return rejectFriendRequest(obj, returnPromise);
                    case 'block':
                        obj.block = 1;
                        obj.bv = 0;
                        return blockFriend(obj, returnPromise);
                    case 'unblock':
                        obj.block = 0;
                        obj.bv = 1;
                        return blockFriend(obj, returnPromise);
                    default:
                        obj.friend.isLoading(false);
                        RingLogger.warning('FRIEND ACTION DID NO MATCH', RingLogger.tags.FRIEND);
                        return false;
                }

            };

            var addFriend =  function(obj, returnPromise) {
                var defer = returnPromise ? $q.defer(): false;
                var utId = obj.friend.getUtId();
                if(!utId) {
                    RingLogger.warning('missing UtId', RingLogger.tags.FRIEND);
                }
                var timeOut = setTimeout(function() {
                    obj.friend.isLoading(false);
                    if (returnPromise) {
                        defer.reject({sucs: false, mg: 'Reqeust Failed'});
                    }
                }, 5000);
                friendsHttpService.sendFriendRequest({uId: obj.friend.getKey()}).then(function(json){
                    clearTimeout(timeOut);
                    obj.friend.isLoading(false);
                    if(json.sucs === true) {
                        Ringalert.show('Friend request sent', 'success');
                        Contacts.add('outgoingUtIds', utId, {frns: AC.OUTGOING_FRIEND});
                        if(returnPromise) {
                            defer.resolve(json);
                        }
                        obj.friend.updateUserObj( angular.extend({}, json, {frns: AC.OUTGOING_FRIEND}) );
                    }
                }, function(errData) {
                    clearTimeout(timeOut);
                    obj.friend.isLoading(false);
                    Ringalert.show('Friend request sent failed', 'error');
                    if(returnPromise) {
                        defer.reject(errData);
                    }
                });
                if(returnPromise) {
                    return defer.promise;
                }
            };

            var acceptFriendRequest =  function(obj, returnPromise) {
                var defer = returnPromise ? $q.defer(): false;
                var utId = obj.friend.getUtId();
                var timeOut = setTimeout(function() {
                    obj.friend.isLoading(false);
                    if (returnPromise) {
                        defer.reject({sucs: false, mg: 'Reqeust Failed'});
                    }
                }, 5000);
                friendsHttpService.acceptFriendRequest({friendId: obj.friend.getKey(),utId: obj.friend.getUtId()}).then(function(json) {
                    clearTimeout(timeOut);
                    RingLogger.print(json, RingLogger.tags.FRIEND);
                    obj.friend.isLoading(false);
                    if(json.sucs === true) {
                        _clearUtId(utId, true);
                        //fFactory.incomingFriends.remove(utId);
                        //Contacts.remove('incomingUtIds', utId);

                        obj.friend.updateUserObj( angular.extend({}, json, {frnS: AC.FRIEND}) );
                        fFactory.friends.save(utId, obj.friend);

                        Ringalert.show('You have become friends with ' + obj.friend.getName(), 'success');
                        if(returnPromise) {
                            defer.resolve(json);
                        }
                    } else {
                        Ringalert.show('Request failed', 'error');
                        if(returnPromise) {
                            defer.reject();
                        }
                    }
                }, function() {
                    clearTimeout(timeOut);
                    obj.friend.isLoading(false);
                    if (returnPromise) {
                         defer.reject();
                    }
                });

                if(returnPromise) {
                    return defer.promise;
                }
            };

            // remove existing friend
            var removeFriend =  function(obj, returnPromise) {
                var defer = returnPromise ? $q.defer(): false;
                var utId = obj.friend.getUtId();
                var timeOut = setTimeout(function() {
                    obj.friend.isLoading(false);
                    if (returnPromise) {
                        defer.reject({sucs: false, mg: 'Reqeust Failed'});
                    }
                }, 5000);
                 friendsHttpService.unFriend({friendId: obj.friend.getKey()}).then(function(json){
                     clearTimeout(timeOut);
                     RingLogger.print(json, RingLogger.tags.FRIEND);
                     obj.friend.isLoading(false);
                     if (json.sucs === true) {
                         Ringalert.show('Friend removed succesfully', 'success');
                         _clearUtId(utId, true, true);
                         //fFactory.friends.remove(utId); // remove from friend list
                         //Contacts.remove('utIds', utId);
                         obj.friend.updateUserObj( angular.extend({}, json, {frnS: AC.NOT_FRIEND}) );
                        if(returnPromise) {
                            defer.resolve(json);
                        }
                     } else {
                        Ringalert.show('Friend remove Failed', 'error');
                        if(returnPromise) {
                            defer.reject();
                        }
                     }
                 }, function() {
                     clearTimeout(timeOut);
                     obj.friend.isLoading(false);
                    if(returnPromise) {
                        defer.reject();
                    }
                 });
                if(returnPromise) {
                    return defer.promise;
                }
            };


            // remove request incoming,outgoing both
            var rejectFriendRequest = function(obj, returnPromise) {
                var defer = returnPromise ? $q.defer(): false;
                var utId = obj.friend.getUtId();
                if(!utId) {
                    RingLogger.warning('missing UtId', RingLogger.tags.FRIEND);
                }
                var timeOut = setTimeout(function() {
                    obj.friend.isLoading(false);
                    if (returnPromise) {
                        defer.reject({sucs: false, mg: 'Reqeust Failed'});
                    }
                }, 5000);
                friendsHttpService.unFriend({friendId: obj.friend.getKey()}).then(function(json) {
                    clearTimeout(timeOut);
                     obj.friend.isLoading(false);
                    if (json.sucs === true) {
                        Ringalert.show('Rejected succesfully', 'success');
                        obj.friend.updateUserObj( angular.extend({}, json, {frnS: AC.NOT_FRIEND}) );
                        _clearUtId(utId, true, true);
                        //Contacts.remove('incomingUtIds', utId);
                        //fFactory.incomingFriends.remove(utId);
                        //Contacts.remove('outgoingUtIds', utId);
                        if(returnPromise) {
                            defer.resolve(json);
                        }
                    } else {
                         Ringalert.show('Reqeust Failed', 'error');
                        if(returnPromise) {
                            defer.reject();
                        }
                    }
                }, function() {
                    clearTimeout(timeOut);
                    if(returnPromise) {
                        defer.reject();
                    }
                     obj.friend.isLoading(false);
                });

                if(returnPromise) {
                    return defer.promise;
                }
            };
            var blockFriend =  function(obj, returnPromise) {
                var defer = returnPromise ? $q.defer(): false;
                var timeOut = setTimeout(function() {
                    obj.friend.isLoading(false);
                    if (returnPromise) {
                        defer.reject({sucs: false, mg: 'Reqeust Failed'});
                    }
                }, 5000);
                friendsHttpService.blockFriend(obj).then(function (json) {
                    clearTimeout(timeOut);
                     obj.friend.isLoading(false);
                    if (json.sucs === true){
                        Ringalert.show('Friend ' + (obj.bv === 0 ? 'blocked' : 'unblocked') + ' successfully', 'success');
                        obj.friend.setBlock(obj.block);
                    } else {
                        Ringalert.show('Friend ' + (obj.bv === 0 ? 'blocked' : 'unblocked') + ' successfully', 'error');
                    }
                    if(returnPromise) {
                        defer.resolve();
                    }
                }, function() {
                    clearTimeout(timeOut);
                     obj.friend.isLoading(false);
                    if(returnPromise) {
                        defer.reject();
                    }
                });
                if(returnPromise) {
                    return defer.promise;
                }
            };


            var getIds =  function() {
                var keys = '';
                for(var i = 0; i < fFactory.friends.size(); i++) {
                    keys = keys + ','.fFactory.friends[i].getKey();
                }
                return keys;
            };


            var searchContact = function(searchVal, friendOnly) {
                if (friendOnly) {
                    var defer = $q.defer();
                    friendsHttpService.searchContact(searchVal, friendOnly).then(function(json) {
                        if (json.sucs) {
                            defer.resolve();
                        } else {
                            RingLogger.alert('FRIEND SEARCH RETURNED false', RingLogger.tags.FRIEND);
                            defer.reject();
                        }
                    }, function() {
                        RingLogger.alert('FRIEND SEARCH RETURNED error', RingLogger.tags.FRIEND);
                        defer.reject();
                    }, function(json) {
                        // process json
                        if(json.sucs === true) {
                            for (var i = 0; i < json.searchedcontaclist.length; i++) {
                                Storage.setContact(json.searchedcontaclist[i].utId, json.searchedcontaclist[i]); // store in localStorage
                            }
                            _setContacts(json.searchedcontaclist);
                        } else {
                            RingLogger.alert('FRIEND SEARCH RETURNED false', RingLogger.tags.FRIEND);
                            defer.reject();
                        }
                    });

                    return defer.promise;

                } else {
                    return friendsHttpService.searchContact(searchVal, false);
                }

            };

            /// initialize friend list and people you may know
            function initFriends(scope) {
                //var intervalContactDetails;

                $$connector.subscribe(fFactory.process, {
                    action: [
                        OTYPES.TYPE_CONTACT_UTIDS,
                        //OTYPES.TYPE_CONTACT_LIST,
                        //OTYPES.TYPE_FRIEND_CONTACT_LIST,
                        OTYPES.TYPE_UPDATE_ADD_FRIEND,
                        OTYPES.TYPE_UPDATE_DELETE_FRIEND,
                        OTYPES.TYPE_UPDATE_ACCEPT_FRIEND,
                        //OTYPES.ACTION_FRIEND_SEARCH
                    ],
                    scope: scope
                });

                // restore Data from LocalStorage if any
                Contacts.init();

                // initial contact list utids request
                friendsHttpService.getContactList() ;
                var retryCount = 0;
                var interval = setInterval(function() {
                    retryCount++;
                    if (Contacts.utIds().length() === 0 && retryCount < 30) {
                        friendsHttpService.getContactList() ;
                    } else {
                        clearInterval(interval);
                    }
                }, 2000);

            }



            function addToUtIdList(which, utid) {
                switch(which) {
                    case 'utIds':
                        Contacts.utIds().save(utid, {frnS: AC.FRIEND});
                        break;
                    case 'incomingUtIds':
                        Contacts.incomingUtIds().save(utid, {frnS: AC.INCOMING_FRIEND});
                        break;
                    case 'outgoingUtIds':
                        Contacts.outgoingUtIds().save(utid, {frnS: AC.OUTGOING_FRIEND});
                        break;
                }
            }



            var fFactory = {
            // api data
                state : {
                    noFriends : false,
                    isFriendsLoading : false,
                    isUserFriendsLoading : false,
                    isRequestsLoading: false
                },
                getRequestCount: function() {
                    var count =  Contacts.incomingUtIds().length() + fFactory.incomingFriends.length();
                    return  count > 99 ? '99+' : count;
                },
                getPendingCount: function() {
                    return Contacts.outgoingUtIds().length() + fFactory.outgoingFriends.length();
                },
                totalFriends: function(friendType) {
                    if (friendType === 'userfriends' ) {
                        return userFriendsCount;
                    } else {
                        return  Contacts.utIds().length() + fFactory.friends.length();
                    }
                },
                totalUserFriends: function() {
                    return userFriendsCount;
                },
                friends : $$stackedMap.createNew(),
                userFriends : $$stackedMap.createNew(),
                incomingFriends : $$stackedMap.createNew(),
                outgoingFriends : $$stackedMap.createNew(),

            // api methods

                process : processResponse, // processes server response regarding contacts(add, updated, fetch etc)
                getFriends : getFriends, // returns friends, outgoing requests, incoming requests etc
                resetUserFriends : resetUserFriends, // emptyis contacts friendlist once use leaves that users profile page and friends tab
                getUserContacts : getUserContacts, // returns conjtact's friendlist
                getContactDetails : getContactDetails, // fetch given or 20 friends details
                getContactDetailsByUtIds : getContactDetailsByUtIds, // fetch contacts detail of given utIds
                peopleYouMayKnowList : peopleYouMayKnowList, // fetch people you may know list
                removeFriend : removeFriend, // remove friend from contact list
                friendAction: friendAction, // add friend, accept friend request, reject friend request etc
                addFriend : addFriend, // send friend request
                rejectFriendRequest : rejectFriendRequest, // reject friend request
                acceptFriendRequest : acceptFriendRequest, // accept friend request
                searchContact: searchContact,
                initFriends : initFriends, // initialize friends factory
                addToUtIdList: addToUtIdList,
                // below apis may not be needed anymore
                blockFriend : blockFriend, // block friend
                getIds : getIds, // get friends uids comma seperated list
                getCurrentUser : function(){
                    return Auth.currentUser;
                },

                utIDsToByteArray : _utIDsToByteArray


            };


            return fFactory;


		}
        //merging tool testing

})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

	angular
		.module('ringid.friend.friends_factory')
		.service('friendsHttpService', friendsHttpService);

		friendsHttpService.$inject = [ '$$connector', 'OPERATION_TYPES', 'APP_CONSTANTS'];
		function friendsHttpService( $$connector, OPERATION_TYPES, APP_CONSTANTS) {
			var self = this,
                firstRequestForContact = false,
				OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS,
                AC = APP_CONSTANTS,
                REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;


            /**
            * @api {request} /APIREQUEST/34 Search Contacts
            * @apiVersion 0.1.0
            * @apiDescription Search Contacts by Name, phone, email, ringid, location or all
            * @apiName SearchContacts
            * @apiGroup Friends
            *
            * @apiParam {Number=34} actn TYPE_CONTACT_SEARCH
            * @apiParam {Number{0..5}} scat=0 Search By Category(i.e. Name, Phone, Email, Roingid, Location or all)
            * @apiParam {String} Search Value. i.e. name or phone or email or ringid or location or anything
            */

			self.searchContact = function(obj, friendOnly) {

            //TYPE_SEARCH_BY_ALL : 0,
            //TYPE_SEARCH_BY_NAME : 1,
            //TYPE_SEARCH_BY_PHONE : 2,
            //TYPE_SEARCH_BY_EMAIL : 3,
            //TYPE_SEARCH_BY_RINGID : 4,
            //TYPE_SEARCH_BY_LOCATION : 5,
                var payload = {
					actn: friendOnly ? OTYPES.ACTION_FRIEND_SEARCH : OTYPES.TYPE_CONTACT_SEARCH,
                    scat: AC.TYPE_SEARCH_BY_ALL,
					schPm: obj.schPm.utf8Encode(),
                    st: obj.st || 0
				};
                var regexEmail = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i,
                    regexRingid =  /^10\d{6}/,
                    regexNumber = /^\d{5,}$/i;
                    //regexName = /^[A-Za-z\s]+$/i;

                if (regexEmail.test(obj.schPm)) {
                    // search by email
                    payload.scat = AC.TYPE_SEARCH_BY_EMAIL;
                }
                //else if (regexRingid.test(obj.schPm)) {
                    //// search by ringid
                    //payload.scat = AC.TYPE_SEARCH_BY_RINGID;
                //} else  if (regexNumber.test(obj.schPm)) {
                    //// search by mobile no
                    //payload.scat = AC.TYPE_SEARCH_BY_PHONE;
                //} else {
                    //// search by name
                    //payload.scat = AC.TYPE_SEARCH_BY_NAME;
                //}

				return $$connector.pull(payload, REQTYPE.REQUEST, true);
			};


            /**
            * @api {request} /APIREQUEST/29 Get Friends Utids
            * @apiVersion 0.1.0
            * @apiDescription This Requests list of Friends  utids for logged in user.
            * @apiName GetFriendsUtids
            * @apiGroup Friends
            *
            * @apiParam {Number=29} actn TYPE_CONTACT_UTIDS
            * @apiParam {Number} cut=-1 Undefined
            * @apiParam {Number} ut=-1 Update Time in Timestamp
            */

            self.getContactList = function(ut) {
				var payload = {
					actn: OTYPES.TYPE_CONTACT_UTIDS,
					cut: -1, //timestamp,
					ut: ut || -1 //timestamp
				};
                return $$connector.send(payload, REQTYPE.REQUEST);
            };



            /**
            * @api {request} /APIREQUEST/23 Get Friends Details
            * @apiVersion 0.1.0
            * @apiDescription This Requests Gets Friends  Details i.e. name, profileImage etc for logged in user.
            * @apiName GetFriendsDetails
            * @apiGroup Friends
            *
            * @apiParam {Number=23} actn TYPE_CONTACT_LIST
            * @apiParam {Number{0,1}} uo=0 First time request or not
            * @apiParam {Object[]} utIDs Byte array of utids. i.e. 10 utids becomes 10 * 8(per utid) no of bytes and so 80 items array. each item represends an 8 bit integer
            */
			self.getContactListDetails = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_CONTACT_LIST,
                    uo: obj.uo || false, // TRUE=only Update, FALSE=Fresh Details //firstRequestForContact ? true : false,
                    utIDs: obj.utIDs
				};
                return $$connector.pull(payload, REQTYPE.REQUEST, true);
			};

			self.getUserContacts = function(utId, st){
				var payload = {
					actn:OTYPES.TYPE_FRIEND_CONTACT_LIST,//107,
					utId:utId,
					st: st || 0
				};
				return $$connector.pull(payload, REQTYPE.REQUEST);

			};

            //self.getMutualContacts = function(uId) {
                //var params = {
                    //actn: REQPRF.FETCH_FRIEND_MUTUAL_FRIEND_LIST,
                    //uId: uId
                //};
                //return $$connector.request(params, REQTYPE.REQUEST)
            //}

            /**
            * @api {request} /APIREQUEST/128 Delete Friend
            * @apiVersion 0.1.0
            * @apiDescription This Requests To Unfriend an existing Friends.
            * @apiName FriendDelete
            * @apiGroup Friends
            *
            * @apiParam {Number=128} actn TYPE_DELETE_FRIEND
            * @apiParam {Number} friendId Friend uid
            */
			self.unFriend = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_DELETE_FRIEND,
					uId: obj.friendId
				};
				return $$connector.request(payload, REQTYPE.UPDATE, true);
			};


            /**
            * @api {request} /APIREQUEST/244 Change Friend Type
            * @apiVersion 0.1.0
            * @apiDescription This Requests To Change Friend Type from Full to Call&Chat only and viceversa
            * @apiName FriendChangeType
            * @apiGroup Friends
            *
            * @apiParam {Number=244} actn TYPE_ACTION_CHANGE_FRIEND_ACCESS
            * @apiParam {Number{1,2}} ct Contact type
            * @apiParam {Number} utId Friend utid
            */
			self.changeFriendType = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_ACTION_CHANGE_FRIEND_ACCESS,
					ct: obj.ct ,
                    utId: obj.utId
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};



            /**
            * @api {request} /APIREQUEST/127 New Friend Request
            * @apiVersion 0.1.0
            * @apiDescription This Sends New Friend request
            * @apiName FriendAdd
            * @apiGroup Friends
            *
            * @apiParam {Number=127} actn TYPE_ADD_FRIEND
            * @apiParam {Number{1,2}} ct Contact type
            * @apiParam {Number} uId Contact uId
            */
			self.sendFriendRequest = function(obj) {
				var payload = {
                    actn: OTYPES.TYPE_ADD_FRIEND,
                    uId: obj.uId
                    //ct: obj.ct
				};
                return $$connector.request(payload, REQTYPE.UPDATE, true);
			};




            /**
            * @api {request} /APIREQUEST/243 Block Unblock Friend
            * @apiVersion 0.1.0
            * @apiDescription This Sends Block Friend request
            * @apiName FriendBlockUnblock
            * @apiGroup Friends
            *
            * @apiParam {Number=243} actn TYPE_ACTION_BLOCK_UNBLOCK_FRIEND
            * @apiParam {Number} utid Friend utid
            * @apiParam {Boolean} block Friend Block/Unblock
            */
			self.blockFriend = function(obj) {
				//console.log(obj);
				var payload = {
					actn: OTYPES.TYPE_ACTION_BLOCK_UNBLOCK_FRIEND,
					idList: [
						obj.friend.getUtId()
					],
					bv: obj.bv
				};
				return $$connector.request(payload, REQTYPE.REQUEST);
			};

			self.saveCallPvcEdit = function (obj) {
				var payload = {
					actn:obj.actn,
					sn:obj.callsn,
					sv:obj.sv,
					utId:obj.friend.getUtId()
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.saveChatPvcEdit = function (obj) {
				var payload = {
					actn:obj.actn,
					sn:obj.chatsn,
					sv:obj.sv,
					utId:obj.friend.getUtId()
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.saveFeedPvcEdit = function (obj) {
				var payload = {
					actn:obj.actn,
					sn:obj.feedsn,
					sv:obj.sv,
					utId:obj.friend.getUtId()
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};




            /**
            * @api {request} /APIREQUEST/129 Friend Request Accept
            * @apiVersion 0.1.0
            * @apiDescription This Sends New Friend request Acceptance
            * @apiName FriendAccept
            * @apiGroup Friends
            *
            * @apiParam {Number=129} actn TYPE_ACCEPT_FRIEND
            * @apiParam {Number{1,2}} ct Contact type
            * @apiParam {Number} friendId Friend uid
            */
			self.acceptFriendRequest = function(obj) {
				//console.log(obj);
				var payload = {
                    actn: OTYPES.TYPE_ACCEPT_FRIEND,//129,
                    //ct: obj.contactType,
					utId:obj.utId
				};
				return $$connector.request(payload, REQTYPE.UPDATE, true);
			};




		}
})();

/* 
 * © Ipvision 
 */

(function() {
	'use strict';

	angular
		.module('ringid.friend', [
			'ringid.config',
			'ringid.friend.friends_factory',
		]);

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.friend')
        .directive('rgFriends', rgFriends);

    rgFriends.$inject = ['friendsFactory', '$ringhttp', '$compile',  '$routeParams', '$window', '$document', 'Contacts', 'APP_CONSTANTS'];
    function rgFriends(friendsFactory, $ringhttp, $compile,  $routeParams, $window, $document, Contacts, APP_CONSTANTS) { // jshint ignore:line


        FriendsController.$inject = ['$scope', '$attrs', 'profileFactory', '$document', 'InviteFactory', 'rgScrollbarService', 'Contacts', 'userFactory', '$$stackedMap', 'rgDropdownService', '$$connector', 'OPERATION_TYPES', 'Ringalert'];
        function FriendsController($scope, $attrs, profileFactory, $document, InviteFactory, rgScrollbarService, Contacts, User, $$stackedMap, rgDropdownService, $$connector, OPERATION_TYPES, Ringalert) { //jshint ignore:line
            var OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS,
                intervalCount = 0,
                mutualFriends = [],
                timeOut,
                intervalTrack;

            $scope.isOwner = false;
            $scope.showMutual = false;
            $scope.showPending = false;
            $scope.friendName = '';

            $scope.state = {
                loading: false,
                noData: false
            };

            $scope.friends = friendsFactory.getFriends($scope.rgFriendsType);
            $scope.totalFriends = friendsFactory.totalFriends;
            $scope.getPendingCount  = friendsFactory.getPendingCount;

            function setDropdown() {
                // settings dropdown data
                //$scope.ddHtml = 'pages/dropdowns/friend-settings-dropdown.html';
                $scope.ddTemplate =
                    '<div class="action friend-settings-dropdown float-right">' +
                        '<a  ng-if="ddControl.friendshipStatus()==0 && !ddControl.isCurrentUser()" rg-click="ddAction()({ action: \'addfriend\', friend: ddControl})" href="#"><span class="icon-addf f-16"></span><span class="txt">{{consType.add_friend}}</span></a>' +
                        '<a  ng-if="ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'unfriend\', friend: ddControl})" href="#"> <span class="icon-into-border f-Block"></span><span class="txt">{{consType.unfriend}}</span></a>' +
                        '<a  ng-if="ddControl.friendshipStatus()==2" rg-click="ddAction()({ action: \'accept\', friend: ddControl})" href="#"><span class="icon-incoming f-16"></span><span class="txt">{{consType.accept}}</span></a>' +
                        '<a  ng-if="ddControl.friendshipStatus()==3" rg-click="ddAction()({ action: \'remove\', friend: ddControl})" href="#"><span class="icon-minus-cr f-14"></span><span class="txt">{{consType.remove}}</span></a>' +
                        '<a  ng-if="ddControl.isBlocked()===0 && !ddControl.isCurrentUser() && ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'block\', friend: ddControl})" class="border-0" href="#"><span class="icon-block"></span><span class="txt">{{consType.block}}</span></a>' +
                        '<a  ng-if="ddControl.isBlocked()===1 && !ddControl.isCurrentUser() && ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'unblock\', friend: ddControl})" class="border-0" href="#"><span class="icon-right f-Block"></span><span class="txt">{{consType.unblock}}</span></a>' +
                    '</div>';
                $scope.ddAction = function(actionObj) {
                    if (!actionObj.friend.isLoading()) {
                        friendsFactory.friendAction(actionObj, true).then(function() {
                            $scope.$rgDigest();
                        }, function() {
                            $scope.$rgDigest();
                        });
                        rgDropdownService.close();
                    }
                };
            }

            switch($scope.rgFriendsType) {
                case 'friendslist':
                    friendsFactory.initFriends($scope);
                    // ensure there are at least 20 friends
                    intervalTrack = setInterval(function() {
                        intervalCount++;
                        if (Contacts.utIds().length() > 0) {
                            RingLogger.warning('FRIEND LOAD INTERVAL.....', RingLogger.tags.FRIEND);
                            loadMoreFriends(true);
                            clearInterval(intervalTrack);
                        } else if (intervalCount > 30) {
                            RingLogger.warning('FRIEND LOAD INTERVAL LIMIT REACHED...', RingLogger.tags.FRIEND);
                            $scope.state.noData = true;
                            toggleLoading(false);
                            clearInterval(intervalTrack);
                        } else {
                            RingLogger.warning('CAN NOT LOAD INTERVAL. EMPTY utid list', RingLogger.tags.FRIEND);
                            toggleLoading(true);
                        }
                    }, 2000);
                    break;
                case 'friends':
                    $scope.isOwner = true;
                    $scope.pendingRequests = friendsFactory.getFriends('outgoing');
                    setDropdown();
                    var retryCount = 0;
                    // just to ensure friends load no matter what
                    if ($scope.friends.length() < 5) {
                        toggleLoading(true);
                        intervalTrack =  setInterval( function() {
                            retryCount++;
                            if ($scope.friends.length() < 20 && Contacts.utIds().length() > 1) {
                                loadMoreFriends(true);
                            } else if (retryCount > 30){
                                toggleLoading(false);
                                clearInterval(intervalTrack);
                            }
                        }, 2000);
                    }
                    break;
                case 'userfriends':
                    toggleLoading(true);
                    setDropdown();
                    $scope.profileObj = profileFactory.getProfile($routeParams.uId); //.commonFriends();
                    friendsFactory.getUserContacts($scope.profileObj.getUtId()).then(function() {
                        toggleLoading(false);
                    });
                    $scope.totalUserFriends = friendsFactory.totalUserFriends;

                    // fetch mutual friend utid list
                    InviteFactory.getMutualFriend($scope.profileObj).then(function(json) {
                        RingLogger.print(json, RingLogger.tags.FRIEND);
                        $scope.profileObj.updateUserObj({nmf: json.mfIDs.length});
                        mutualFriends = json.mfIDs;
                        $scope.$rgDigest();
                    });
                    break;
                default:
                    RingLogger.alert('Friend type not found ', RingLogger.tags.FRIEND);
            }


            $scope.toggleShowMutual = function(bool) {
                $scope.showMutual = !!bool;
                if ($scope.showMutual) {

                    loadMutualFriends();
                }
                $scope.$rgDigest();
            };

            $scope.toggleShowPending = function(bool) {
                $scope.showPending = !!bool;
                if ($scope.showPending) {
                    $scope.friends = friendsFactory.getFriends('outgoing');
                    toggleLoading(true);
                    friendsFactory.getContactDetails('outgoing').then(function() {
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                    });
                } else {
                    $scope.friends = friendsFactory.getFriends($scope.rgFriendsType);
                }
                $scope.$rgDigest();
            };


            function loadMutualFriends() {
                var friend;
                if (mutualFriends.length > 0) {
                    toggleLoading(true);
                    friendsFactory.getContactDetailsByUtIds(mutualFriends.splice(0, 10), true).then(function(json) {
                        RingLogger.print(json, RingLogger.tags.FRIEND);
                        if (json.sucs === true) {
                            for(var i=0;i< json.contacts.length;i++){
                                friend = User.create(json.contacts[i]);
                                $scope.friends.save(friend.getKey(), friend);
                            }
                        }
                        toggleLoading(false);
                    });
                }
            }


            $scope.loadMoreFriends = loadMoreFriends;
            $scope.getMutualFriend = getMutualFriend;
            $scope.searchContact = searchContact;
            $scope.showComingSoon = function($event) {
                $event.preventDefault();
                Ringalert.show('Coming soon', 'info');
            };

            function toggleLoading(bool) {
                clearTimeout(timeOut);
                $scope.state.loading = !!bool;
                if (!bool) {
                    rgScrollbarService.recalculate($scope);
                    //$scope.friends = friendsFactory.getFriends($scope.rgFriendsType);
                }
                if ($scope.state.loading) {
                    RingLogger.warning('FRIENDS LOADING.........', RingLogger.tags.FRIEND);
                } else {
                    RingLogger.warning('END FRIENDS LOADING.........', RingLogger.tags.FRIEND);
                }
                $scope.$rgDigest();
            }


            function searchContact() {
                if (($scope.rgFriendsType === 'friends' ||  $scope.rgFriendsType === 'friendslist') && $scope.friendName && $scope.friendName.length > 0) {
                    toggleLoading(true);
                    friendsFactory.searchContact({schPm: $scope.friendName}, true).then(function() {
                        //$scope.friends = friendsFactory.getFriends($scope.rgFriendsType);
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                    });
                }
            }

            function loadMoreFriends(force) {
                var whatToCall, param;
                // no request in progress
                if ($scope.showMutual) {
                    loadMutualFriends();
                } else if ($scope.showPending) {
                    toggleLoading(true);
                    friendsFactory.getContactDetails('outgoing').then(function() {
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                    });
                } else if (force || (!$scope.state.loading && $scope.friends.length() !== $scope.totalFriends($scope.rgFriendsType)) )  {
                    toggleLoading(true);
                    if ($scope.rgFriendsType === 'userfriends') {
                        whatToCall = friendsFactory.getUserContacts;
                        param = $scope.profileObj.getUtId();
                    } else {
                        whatToCall = friendsFactory.getContactDetails;
                    }
                    whatToCall(param).then(function() {
                        //$scope.friends = friendsFactory.getFriends($scope.rgFriendsType);
                        RingLogger.information('FRIENDS LENGTH: ' + $scope.friends.length(), RingLogger.tags.FRIEND);
                        if ($scope.friends.length() < 20 && $scope.friends.length() < $scope.totalFriends($scope.rgFriendsType)) {
                            RingLogger.warning('NEED TO PULL MORE FRIENDS', RingLogger.tags.FRIEND);
                            loadMoreFriends();
                        } else {
                            toggleLoading(false);
                        }
                    }, function() {
                        toggleLoading(false);
                        RingLogger.alert('friend Details fetch fail', RingLogger.tags.FRIEND);
                    });

                    // in case the promise never resolves or rejects
                    timeOut = setTimeout(toggleLoading, 5000);
                }
            }

            function getMutualFriend(user) {

                return{
                    data: function() {
                        return {
                            target: user
                        };
                    },
                    promise: InviteFactory.getMutualFriend(user)

                };
            }

            var subscriptionKey = $$connector.subscribe(function() {
                setTimeout(function() {
                    $scope.state.noData = $scope.friends.length() === 0;
                    $scope.$rgDigest();
                }, 200);

            }, {
                action: [
                    OTYPES.TYPE_UPDATE_ADD_FRIEND,
                    OTYPES.TYPE_UPDATE_DELETE_FRIEND
                ]
            });

            $scope.$on('$destroy', function() {
                 $$connector.unsubscribe(subscriptionKey);
            });



        }

        function linkFunc(scope, element, attrs) {
            var utids;

            $ringhttp.get(attrs.rgFriendsTpl).success(function(template) {
               element.append( $compile(template)(scope) );
                scope.$rgDigest();
            });

            function loadMore() {
                if ( ($window.innerHeight + $window.scrollY) >= $document[0].body.offsetHeight ) {
                    scope.loadMoreFriends();
                }
            }

            if (scope.rgFriendsType === 'friends' || scope.rgFriendsType === 'userfriends') {
                RingLogger.information('enable scroll event:', RingLogger.tags.FRIEND);
                angular.element($window).on('scroll', loadMore);
            }


            scope.$on('$destroy', function() {
                // empty friend list of other user when leaving friends page of other user
                if (scope.rgFriendsType === 'userfriends') {
                    friendsFactory.resetUserFriends();
                }

                switch(scope.rgFriendsType) {
                    case 'friends':
                        // put outgoing utids back to utid list and reset outgoing friends
                        utids =  friendsFactory.outgoingFriends.keys();
                        for(var i = 0; i < utids.length; i++) {
                             Contacts.add('outgoingUtIds', utids[i], {frnS: APP_CONSTANTS.INCOMING_FRIEND});
                        }
                        friendsFactory.outgoingFriends.reset();
                    case 'userFriends':
                        angular.element($window).off('scroll', loadMore);
                }


            });

        }

        return {
            restrict: 'AE',
            scope: {
                rgFriendsType: '@'
            },
            controller: FriendsController,
            link: linkFunc
        };

    }
})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.friend')
        .directive('rgRequests', rgRequests);

    rgRequests.$inject = ['friendsFactory', '$compile',  '$routeParams', '$window', '$document', '$ringhttp'];
    function rgRequests(friendsFactory,  $compile,  $routeParams, $window, $document, $ringhttp) { // jshint ignore:line

        RequestsController.$inject = ['$scope', 'profileFactory',  'InviteFactory', 'rgScrollbarService', 'Contacts', 'OPERATION_TYPES', '$$connector', 'userFactory', 'Ringalert'];
        function RequestsController($scope, profileFactory,  InviteFactory, rgScrollbarService, Contacts, OPERATION_TYPES, $$connector, userFactory, Ringalert) { //jshint ignore:line
            var OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS,
                loadCount = parseInt($scope.loadCount),
                subscriptionKey,
                intervalCount = 0,
                intervalTrack;

            $scope.state = {
                loading: false,
                noData: false,
            };

            $scope.requests = friendsFactory.getFriends('incoming');
            $scope.friendAction = function(actionObj) {
                if (!actionObj.friend.isLoading()) {
                    friendsFactory.friendAction(actionObj, true).then(function() {
                        //$scope.requests = friendsFactory.getFriends('incoming');
                        if ($scope.requests.length() < loadCount) {
                            loadMoreRequests();
                        }
                        $scope.$rgDigest();
                    }, function() {
                        //$scope.requests = friendsFactory.getFriends('incoming');
                        if ($scope.requests.length() < loadCount) {
                            loadMoreRequests();
                        }
                        $scope.$rgDigest();
                    });
                }
            };
            $scope.loadMoreRequests = loadMoreRequests;
            $scope.getMutualFriend = getMutualFriend;
            $scope.getRequestCount = friendsFactory.getRequestCount;

           $scope.getIncomingRequest = function () {

                var testobj={};
                return{
                    data: function() {
                        return {
                            target: testobj
                        };
                    },
                    promise: friendsFactory.getContactDetails('incoming', 30)
                };
           };


            // initialization everytime dropdown opens
            subscriptionKey = $$connector.subscribe(function() {
                setTimeout(function() {
                    //$scope.requests = friendsFactory.getFriends('incoming');
                    $scope.state.noData = $scope.requests.length() > 0;
                    $scope.$rgDigest();
                }, 500);

            }, {
                action: [
                    OTYPES.TYPE_UPDATE_ADD_FRIEND,
                    OTYPES.TYPE_UPDATE_DELETE_FRIEND
                ]
            });
            // ensure there are at least 10 friend requests
            if ($scope.requests.length() < loadCount) {
                toggleLoading(true);
                intervalTrack = setInterval(function() {
                    intervalCount++;
                    if (Contacts.incomingUtIds().length() > 0) {
                        loadMoreRequests(true);
                        clearInterval(intervalTrack);
                    } else if (intervalCount > 6) {
                        toggleLoading(false);
                        $scope.state.noData = (Contacts.incomingUtIds().length() === 0);
                        $scope.$rgDigest();
                        clearInterval(intervalTrack);
                    }
                }, 500);
                // end initialize
            }

            function toggleLoading(bool) {
                $scope.state.loading = bool;
                //if (!bool) {
                    rgScrollbarService.recalculate($scope);
                //}
                $scope.$rgDigest();
            }


            function loadMoreRequests(force) { // jshint ignore:line
                var timeout;
                // no request in progress
                if (force || (!$scope.state.noData && !$scope.state.loading)) {
                    toggleLoading(true);
                    friendsFactory.getContactDetails('incoming', loadCount).then(function() {
                        clearTimeout(timeout);
                        //$scope.requests = friendsFactory.getFriends('incoming');
                        RingLogger.information('FRIENDS LENGTH: ' + $scope.requests.length(), RingLogger.tags.FRIEND);
                        toggleLoading(false);
                    }, function() {
                        clearTimeout(timeout);
                        $scope.state.noData = (Contacts.incomingUtIds().length() === 0);
                        toggleLoading(false);
                        RingLogger.warning('friend Details fetch fail', RingLogger.tags.FRIEND);
                    });

                    // in case the promise never resolves or rejects
                    timeout = setTimeout(function() {
                        toggleLoading(false);
                    }, 3000);
                }
            }

            function getMutualFriend(user) { //jshint ignore:line
                return{
                    data: function() {
                        return {
                            target: user
                        };
                    },
                    promise: InviteFactory.getMutualFriend(user)

                };
            }




            $scope.$on('$destroy', function() {
                 $$connector.unsubscribe(subscriptionKey);
            });


        }


        function linkFunc(scope, element, attr) {
            var templateUrl =  attr.templateUrl ? attr.templateUrl : 'pages/dropdowns/friend-request-dropdown.html';

            $ringhttp.get(templateUrl).success(function(template) {
                element.append($compile(template)(scope));
                scope.$rgDigest();
            });

        }

        return {
            restrict: 'AE',
            //templateUrl: 'pages/dropdowns/friend-request-dropdown.html', // IMPORTANT this template is preloaded from auth factory
            //template:
                    //'<li  rg-dropdown="dropdown()" dd-html="header.freq.ddHtml"' +
                         //' dd-control="header.freq.ddControl" dd-action="header.freq.ddAction"' +
                         //' dd-opened="header.freq.ddOpened()" dd-before-close="header.freq.ddBeforeClose()"' +
                         //' ng-class="{ active : header.getActiveMenu() == \'friend_request\' }" >' +
                        //' <a  class="showpointer" title="Friend Request">' +
                            //' <div class="tm-ico  icon-contact-b">' +
                                //' <div ng-bind="header.freq.ddControl.friendsFactory.getFriends(\'incoming\').length()" ng-show="header.freq.ddControl.friendsFactory.getFriends(\'incoming\').length() > 0"' +
                                     //' class="ng-cloak counter-not"></div>' +
                            //' </div>' +
                        //' </a>'+
                    //' </li>',
            scope: {
                loadOnScroll: '@',
                loadCount: '@',
                templateUrl: '@'
            },
            link: linkFunc,
            controller: RequestsController
            //transclude: true
        };

    }
})();

/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
 * * Copyright : Ipvision
 * _._._._._._._._._._._._._._._._._._._._._.*/

(function() {
    'use strict';

    angular
            .module('ringid.common.rgupload_directive', ['ringid.common.services', 'ringid.common.factories'])
            .directive('rgUpload', rgUpload);

    rgUpload.$inject = ['$compile', 'fileUploadService', 'Media'];
    function rgUpload($compile, fileUploadService, Media) { // jshint ignore:line

        UploadController.$inject = ['Auth', '$scope', 'mediaMetadata', 'imageQuality', 'APP_CONSTANTS', 'SystemEvents', 'Ringalert', '$$q', '$rootScope', 'rgDropdownService'];
        function UploadController(Auth, $scope, mediaMetadata, imageQuality, APP_CONSTANTS, SystemEvents, Ringalert, $q, $rootScope, rgDropdownService) { // jshint ignore:line
            var AC = APP_CONSTANTS,
                totalFileSize = 0;


            $scope.uploadProgress = fileUploadService.uploadProgress;
            $scope.previewStartAt = 0;
            $scope.statusMediaCount = fileUploadService.statusMediaCount;
            $scope.tagList = fileUploadService.tagList;

            // album list dropdown
            $scope.ddHtml = 'pages/dropdowns/album-dropdown.html';
            $scope.ddControl = {
                Media: Media,
                uploadWhat: 'image',
                createAlbum: false,
                albumName: '',
                selectedAlbum: 0
            };
            $scope.ddAction = selectAlbum;



            $scope.getMedia_ = getMedia;
            $scope.removeMedia = removeMedia;
            $scope.loadPrevious = loadPrevious;
            $scope.loadNext = loadNext;

            $scope.disableUpload = disableUpload;

            $scope.uploadAudio = uploadAudio;
            $scope.uploadVideo = uploadVideo;
            $scope.uploadImage = uploadImage;


            function resetUpload() {
                totalFileSize = 0;
                $scope.previewStartAt = 0;
                $scope.ddControl.uploadWhat = 'image';
                $scope.ddControl.createAlbum = false;
                $scope.ddControl.albumName = '';
                $scope.ddControl.selectedAlbum = 0;
                fileUploadService.resetUpload();
                $scope.tagList = fileUploadService.tagList;
                $scope.$rgDigest();
            }


            //$rootScope.$on(SystemEvents.FILE_UPLOAD.QUEUE_COMPLETE, resetUpload);
            $rootScope.$on(SystemEvents.FILE_UPLOAD.UPLOADS_POSTED, resetUpload);

            // PREVIEW RELATED CODE
            function getMedia() { // jshint ignore:line
                return fileUploadService[$scope.ddControl.uploadWhat + 'Files'].slice($scope.previewStartAt, $scope.previewStartAt + 3);
            }

            function removeMedia(index) { // jshint ignore:line
                RingLogger.warning('REMOVING MEDIA FROM UPLOAD: ' + fileUploadService[$scope.ddControl.uploadWhat + 'Files'][index].cptn());
                // abort upload request if queued or remove from queuelist
                if (fileUploadService[$scope.ddControl.uploadWhat + 'Files'][index].getQueued()) {
                    fileUploadService[$scope.ddControl.uploadWhat + 'Files'][index].cancelUpload();
                } else {
                    fileUploadService[$scope.ddControl.uploadWhat + 'Files'].splice($scope.previewStartAt + index, 1);
                }

                if (fileUploadService[$scope.ddControl.uploadWhat + 'Files'].length === 0) { // all images removed from upload queue
                    RingLogger.information('All media files removed from status', RingLogger.tags.UPLOAD);
                    $scope.resetUpload();
                    //$scope.uploadProgress = false;
                } else {
                    $scope.previewStartAt = $scope.previewStartAt > 0 ? $scope.previewStartAt - 1 : $scope.previewStartAt;
                }
            }

            function loadPrevious() { // jshint ignore:line
                $scope.previewStartAt = ($scope.previewStartAt - 3 > 0) ? $scope.previewStartAt - 3 : 0;
                RingLogger.information('previewStart: ' + $scope.previewStartAt, RingLogger.tags.UPLOAD);
            }

            function loadNext() { // jshint ignore:line
                $scope.previewStartAt = ($scope.previewStartAt + 3 <= fileUploadService[$scope.ddControl.uploadWhat + 'Files'].length - 4) ?
                $scope.previewStartAt + 3 : fileUploadService[$scope.ddControl.uploadWhat + 'Files'].length - 3;

                RingLogger.information('previewStart: ' + $scope.previewStartAt, RingLogger.tags.UPLOAD);
            }
            // END PREVIEW CODE


            function selectAlbum(actionObj) { // jshint ignore:line
                switch (actionObj.action) {
                    case 'select':
                        // select which album to upload
                        $scope.ddControl.selectedAlbum = actionObj.albumMap;
                        fileUploadService.setUploadAlbum(actionObj.albumMap.getId());
                        RingLogger.information('Selected Album: ' + $scope.ddControl.selectedAlbum.getName(), RingLogger.tags.UPLOAD);
                        rgDropdownService.close();
                        $scope.$rgDigest();
                        break;
                    case 'toggleCreate':
                        $scope.ddControl.createAlbum = !$scope.ddControl.createAlbum;
                        $scope.$rgDigest();
                        break;
                    case 'create':
                        if ($scope.ddControl.albumName.length === 0) {
                            break;
                        }
                        $scope.ddControl.createAlbum = false;
                        RingLogger.information('Create Album: ' + $scope.ddControl.albumName, RingLogger.tags.UPLOAD);
                        Media.createAlbum({
                            albn: $scope.ddControl.albumName,
                            mdaT: $scope.ddControl.uploadWhat === 'audio' ? AC.NEWS_FEED_MEDIA_TYPE_AUDIO : AC.NEWS_FEED_MEDIA_TYPE_VIDEO
                        }, true).then(function(albumMap) {
                                $scope.ddControl.createAlbum = false;
                                $scope.ddControl.albumName = '';
                                $scope.selectedAlbum = albumMap.getName();
                                $scope.ddControl.selectedAlbum = albumMap;
                                fileUploadService.setUploadAlbum(albumMap.getId());
                                rgDropdownService.close();
                                $scope.$rgDigest();
                        });
                        break;
                }
            }
            function disableUpload(uploadType) {
                if ($scope.uploadProgress) {
                    if ($scope.ddControl.uploadWhat !== uploadType) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    if ($scope.ddControl.uploadWhat !== uploadType && getMedia().length > 0) {
                        return true;
                    } else {
                        return false;
                    }
                }

                $scope.$rgDigest();

            }

            function uploadAudio() { // jshint ignore:line
                fileUploadService.videoFiles = [];
                fileUploadService.imageFiles = [];
                var i,
                        l,
                        input = this; // jshint ignore:line

                // upload size limit check
                for(i = 0; i < input.files.length; i++) {
                    totalFileSize += input.files[i].size;
                }

                if ((input.files.length + fileUploadService.audioFiles.length) > AC.AUDIO_UPLOAD_LIMIT) {
                    Ringalert.show('Maximum upload limit ' + AC.AUDIO_UPLOAD_LIMIT, 'warning');
                } else if ( totalFileSize > AC.MEDIA_UPLOAD_SIZE_LIMIT ) {
                    Ringalert.show('Maximum allowed total upload files size 500MB!', 'warning');
                    // remove new uploaded file sizes
                    for(i = 0; i < input.files.length; i++) {
                        totalFileSize -= input.files[i].size;
                    }
                } else {

                    if ($scope.hasOwnProperty('rgUploadAction')) {
                        $scope.rgUploadAction('audio');
                    }
                    // if fresh new upload
                    if (fileUploadService.audioFiles.length === 0) {
                        $scope.ddControl.uploadWhat = 'audio';
                        //$scope.uploadProgress = true;
                        $scope.ddControl.selectedAlbum = null;
                        fileUploadService.setUploadAlbum(-1);
                    }
                    //for every file.push to upload Queue
                    var startIndex = fileUploadService.audioFiles.length;
                    for (i = 0, l = input.files.length; i < l; i++) {
                        if (validateUpload('audio', input.files[i])) {
                            fileUploadService.queueFile('audio', input.files[i]);
                        } else {
                            Ringalert.show('Invalid Audio File: ' + input.files[i].name, 'error');
                        }
                    }
                    RingLogger.information('UPLOAD QUEUE', RingLogger.tags.UPLOAD);
                    $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.QUEUE_START);
                    // now upload images queue
                    fileUploadService.uploadQueue('audio', startIndex);
                }
                input.value = null;
                $scope.$rgDigest();
            }

            function uploadVideo() {  // jshint ignore:line

                var i, l,
                        input = this; // jshint ignore:line
                //thumbsUploadPromises = [];

                // upload size limit check
                for(i = 0; i < input.files.length; i++) {
                    totalFileSize += input.files[i].size;
                }

                if ((input.files.length + fileUploadService.videoFiles.length) > AC.VIDEO_UPLOAD_LIMIT) {
                    Ringalert.show('Maximum upload limit ' + AC.VIDEO_UPLOAD_LIMIT, 'warning');
                } else if ( totalFileSize > AC.MEDIA_UPLOAD_SIZE_LIMIT ) {
                    Ringalert.show('Maximum allowed total upload files size 500MB!', 'warning');
                    // remove new uploaded file sizes
                    for(i = 0; i < input.files.length; i++) {
                        totalFileSize -= input.files[i].size;
                    }
                } else {

                    // if fresh new upload
                    if (fileUploadService.videoFiles.length === 0) {
                        $scope.ddControl.uploadWhat = 'video';
                        //$scope.uploadProgress = true;
                        $scope.ddControl.selectedAlbum = null;
                        fileUploadService.setUploadAlbum(-1);
                    }
                    if ($scope.hasOwnProperty('rgUploadAction')) {
                        $scope.rgUploadAction('video');
                    }
                    //for every file.push to upload Queue
                    var startIndex = fileUploadService.videoFiles.length;
                    for (i = 0, l = input.files.length; i < l; i++) {
                        if (validateUpload('video', input.files[i])) {
                            fileUploadService.queueFile('video', input.files[i]);
                        } else {
                            Ringalert.show('Invalid Video File: ' + input.files[i].name, 'error');
                        }
                    }

                    RingLogger.information('UPLOAD QUEUE', RingLogger.tags.UPLOAD);

                    // now upload videos queue
                    fileUploadService.uploadQueue('video', startIndex);
                    $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.QUEUE_START);
                }
                input.value = null;
                $scope.$rgDigest();
            }


            function uploadImage() { // jshint ignore:line
                $scope.ddControl.uploadWhat = 'image';

                var input = this; // jshint ignore:line
                switch ($scope.rgUploadType) {
                    case 'coverphoto':
                    case 'profilephoto':
                    case 'tagchatimage':
                    case 'chatimage':
                        if (validateUpload('image', input.files[0])) {
                            var uploadFile = fileUploadService.queueFile($scope.rgUploadType, input.files[0]);
                            if ($scope.hasOwnProperty('rgUploadAction')) {
                                $scope.rgUploadAction()({action: $scope.rgUploadType, uploadFile: uploadFile});
                            }

                        } else {
                            Ringalert.show('Invalid Image File: ' + input.files[0].name, 'error');
                        }
                        input.value = null;
                        break;
                    case 'status':
                        // check maximum no of files upload
                        if (input.files.length + fileUploadService.imageFiles.length > AC.IMAGE_UPLOAD_LIMIT) {
                            Ringalert.show('Maximum upload limit ' + AC.IMAGE_UPLOAD_LIMIT, 'warning');
                            break;
                        }

                        var startIndex = fileUploadService.imageFiles.length;
                        for (var i = 0; i < input.files.length; i++) {
                            //reduce size if necessary and put to queue for upload
                            if (validateUpload('image', input.files[i])) {
                                fileUploadService.queueFile('image', input.files[i]);
                            } else {
                                Ringalert.show('Invalid Image File: ' + input.files[i].name, 'error');
                            }
                        }

                        RingLogger.information('UPLOAD QUEUE', RingLogger.tags.UPLOAD);
                        $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.QUEUE_START);
                        // now upload images queue
                        fileUploadService.uploadQueue('image', startIndex);
                        input.value = null;
                        break;
                }
                $scope.$rgDigest();
                // empty element
            }

            function validateUpload(fileType, inputFile) {
                var regEx;
                switch (fileType) {
                    case 'image':
                        regEx = new RegExp('image\/*');
                        break;
                    case 'audio':
                        regEx = new RegExp('audio\/mp3*');
                        break;
                    case 'video':
                        regEx = new RegExp('video\/mp4');
                        break;
                    case 'default':
                        RingLogger.warning('VALIDATE UPLOAD TYPE DID NOT MATCH', RingLogger.tags.UPLOAD);

                }

                return regEx.test(inputFile.type);
            }


            $scope.$on('$destroy', function() {
                var i, l;
                switch ($scope.rgUploadType) {
                    case 'coverphoto':
                        if (fileUploadService.coverImageFile) {
                            fileUploadService.coverImageFile.cancelUpload();
                            fileUploadService.coverImageFiles = null;
                        }
                        break;
                    case 'profilephoto':
                        if (fileUploadService.profileImageFile) {
                            fileUploadService.profileImageFile.cancelUpload();
                            fileUploadService.profileImageFiles = null;
                        }
                        break;
                    case 'tagchatimage':
                    case 'chatimage':
                        if (fileUploadService.chatImageFiles[$scope.rgUploadBoxValue]) {
                            fileUploadService.chatImageFiles[$scope.rgUploadBoxValue].cancelUpload();
                            delete  fileUploadService.chatImageFiles[$scope.rgUploadBoxValue];
                        }
                        break;
                    case 'status':
                        if (fileUploadService.imageFiles.length > 0) {
                            for (i = 0, l = fileUploadService.imageFiles.length; i < l; i++) {
                                fileUploadService.imageFiles[i].cancelUpload();
                            }
                            fileUploadService.imageFiles = [];
                        } else if (fileUploadService.videoFiles.length > 0) {
                            for (i = 0, l = fileUploadService.videoFiles.length; i < l; i++) {
                                fileUploadService.videoFiles[i].cancelUpload();
                            }
                            fileUploadService.videoFiles = [];
                        } else if (fileUploadService.audioFiles.length > 0) {
                            for (i = 0, l = fileUploadService.audioFiles.length; i < l; i++) {
                                fileUploadService.audioFiles[i].cancelUpload();
                            }
                            fileUploadService.audioFiles = [];
                        }
                        break;
                }
            });

        }

        var linkFunc = function(scope, element, attr) {

            var
                tagDropdownElement,
                hashTagTimeout,
                uploadType = attr.rgUploadType,
                    tagInputElement,
                    imgPreviewElem,
                    template = '',
                    inputFile = '',
                    inputVideo,
                    inputAudio,
                    imgPreviewTmpl =
                    '<div class="to-add" ng-show="ddControl.uploadWhat !== \'image\' && statusMediaCount(ddControl.uploadWhat) > 0" >' +
                        '<span rg-dropdown dd-html="ddHtml" dd-control="ddControl" dd-action="ddAction"><a data-tooltip-post="Add to Album"><label class="icon-play-list"></label></a></span>' +
                    '</div>' +
                    '<div class="media-tag">' +
                        '<div ng-show="tagList.length" >' +
                            '<ul class="tag-fnd-lst">' +
                                '<li ng-repeat="tag in tagList" ><span class="tag-title" ng-bind="tag.sk" ></span>&nbsp;<span class="icon-close f-11" rg-click="removeTag($event, $index)"></span></li>' +
                            '</ul>' +
                        '</div>'+
                    '</div>' +
                    '<textarea id="add-hashtag" ng-model="tagName" ng-show="ddControl.uploadWhat !== \'image\' && statusMediaCount(ddControl.uploadWhat) > 0" type="text"  class="media-tags"  placeholder="Add Hashtag" ></textarea>' +
                    '<div id="hashtag-dropdown" class="m-s-height tag-dd active" style="display:none;">' +
                        '<div class="loader-s" ng-show="tagLoading">' +
                            '<div class="lr1"></div>' +
                            '<div class="lr2"></div>' +
                            '<div class="lr3"></div>' +
                        '</div>' +
                        '<div class="ringscroll" style="position:relative;width:auto;overflow:hidden;height:100%;">' +
                            '<ul class="m-s-result" rg-scrollbar="true" style="overflow: hidden;">' +
                                '<li ng-repeat="tag in tagSuggestions track by tag.ukey"  class="ng-scope m-t-icon" rg-click="addHashTag({sk: tag.sk, ukey: tag.ukey})">' +
                                    '<a href="javascript:void(0)" title="{{tag.sk}}" ng-bind="tag.sk" > abc</a>' +
                                '</li>' +
                            '</ul>' +
                        '</div>' +
                    '</div>' +
                    '<div class="status-photo-view" style="border-bottom:1px solid #ebebeb;margin:0;padding:0;margin-bottom:10px;" id="img-height" ng-show="statusMediaCount(ddControl.uploadWhat) > 0">' +
                        '<div id="sts-img-preview" style="text-align:center;" class="scroll">' +
                            '<div ng-show="previewStartAt+3 < statusMediaCount(ddControl.uploadWhat)" class="np-box icon-right-arrow"  style="right:0;margin-top:60px;" rg-click="loadNext()"></div>' +
                            '<div ng-show="previewStartAt > 0" class="np-box icon-left-arrow" style="left:0;margin-top:60px;"  rg-click="loadPrevious()"></div>' +
                            '<div style="margin-top:3px;" class="status-photo-view-thumb" ng-repeat="image in getMedia()">' +
                                '<div ng-show="image.getProgress() !== 100" class="progress-bar-placement" style="position:absolute;width:100%;text-align:center;">' +
                                    '<div class="percent">{{image.getProgress()}}%</div>' +
                                    '<div class="progress-bar">' +
                                        '<div class="uploaded" ng-style="{\'width\': image.getProgress()+ \'%\'}"></div>' +
                                    '</div>' +
                                '</div>' +
                            '<div  id="singleImage{{$index}}"  style="position:absolute;width:100%;text-align:center;">' +
                                '<input class="add-title" ng-model="image.cptn" ng-model-options="{ getterSetter: true }" type="text" name="" placeholder="Add Photo Title" ng-show="!image.progressVisible" />' +
                                '<div class="photo-view" style="background-image: url({{image.getPreview()}}); background-position:50% 50%; background-size:100% 100%; background-repeat:no-repeat; cursor: pointer;">' +
                                    '<div class="status-photo-view-thumb-hover">' +
                                        '<span id="closebtn0" class="close" style="display: block;" rg-click="removeMedia($index)" inc="0">' +
                                            '<div class="icon-close up-p"></div>' +
                                        '</span>' +
                                    '</div>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                    //'</div>' +
                    '</div>';



            switch (uploadType) {
                case 'coverphoto':
                case 'profilephoto':
                    template = '<input  id="' + uploadType + '" type="file" name="' + uploadType + '"  accept="image/*" >';
                    element.append($compile(template)(scope));
                    break;
                case 'tagchatimage':
                case 'chatimage':
                    template = '<label  class="icon-camera ico-sty ng-binding ng-scope">' +
                            '<input  id="' + uploadType + '" type="file" style="display:none;" accept="image/*" ></label>';
                    element.append($compile(template)(scope));
                    break;
                case 'audio':
                    template = '<a data-tooltip-post="Add Audios" href="javascript:void(0)"><label  class="audio-ico ng-binding ng-scope" ng-show="rgUploadEnabled">' +
                            '<input ng-disabled="uploadProgress" id="audio" type="file" style="display:none;" multiple="multiple" accept="audio/mp3"></label></a>';
                    element.append($compile(template)(scope));
                    break;
                case 'video':
                    template = '<a data-tooltip-post="Add Videos" href="javascript:void(0)"><label  class="video-ico ng-binding ng-scope" ng-show="rgUploadEnabled">' +
                            '<input ng-disabled="uploadProgress" id="video" type="file" style="display:none;" multiple="multiple" accept="video/mp4"></label></a>';
                    element.append($compile(template)(scope));
                    break;
                case 'status':
                    template =
                            '<div ng-show="rgUploadEnabled" class="post-b-ico m-l-10"><a data-tooltip-post="Add Photos"  href="javascript:void(0)" class="p-ab"><label  class="camera-ico ng-binding ng-scope" >' +
                            '<input ng-disabled="disableUpload(\'image\')" id="' + uploadType + '" type="file" style="display:none;" multiple="multiple" accept="image/*"></label></a></div>' +
                            '<div ng-show="rgUploadEnabled "class="post-b-ico m-l-10"><a data-tooltip-post="Add Videos" href="javascript:void(0)" class="p-ab"><label  class="video-ico ng-binding ng-scope" >' +
                            '<input ng-disabled="disableUpload(\'video\')" id="video"type="file" style="display:none;" multiple="multiple" accept="video/mp4"></label></a></div>' +
                            '<div ng-show="rgUploadEnabled" class="post-b-ico m-l-10"><a data-tooltip-post="Add Audios" href="javascript:void(0)" class="p-ab"><label  class="audio-ico ng-binding ng-scope" >' +
                            '<input ng-disabled="disableUpload(\'audio\')" id="audio" type="file" style="display:none;" multiple="multiple" accept="audio/mp3"></label></a></div>';
                    element.append($compile(template)(scope));

                    imgPreviewElem = element.parent().prepend($compile(imgPreviewTmpl)(scope)); // image preview template added for status
                    break;
            }



            scope.removeTag = function(event, index) {
                event.preventDefault();
                RingLogger.information('remove tag index: ' + index, RingLogger.tags.UPLOAD);
                fileUploadService.tagList.splice(index, 1);
                //if (scope.tagList.length === 0) {
                //tagDropdownElement.style.display = 'none';
                //}

                scope.$rgDigest();
            };


            scope.addHashTag = function(tag) {
                //tagDropdownElement.style.display = 'none';
                scope.tagList.push(tag);
                tagDropdownElement.style.display = 'none';

                scope.tagSuggestions = [];
                tagInputElement.value = '';
                scope.$rgDigest();
            };


            function toggleTagVisibility(bool) {
                tagDropdownElement.style.display = bool ? 'block': 'none';
                if (!bool) {
                    fileUploadService.tagSuggestions = [];
                }
            }

            function handleHashTag(event) {
                var key = event.keyCode || event.which;
                if (key && (key === 27 || key === 13)) {
                    // escape or enter pressed. add hashtag
                    event.preventDefault();
                    // add hashtag
                    scope.addHashTag({
                        sk: tagInputElement.value,
                        ukey: 0
                    });
                    toggleTagVisibility(false);
                    scope.tagLoading = false;
                } else if (tagInputElement.value.length > 0) {
                    clearTimeout(hashTagTimeout);
                    hashTagTimeout = setTimeout(fetchTags, 200);
                } else if (tagInputElement.value.length === 0) {
                    clearTimeout(hashTagTimeout);
                    toggleTagVisibility(false);
                }
                scope.$rgDigest();
            }

            function fetchTags() {
                // pull tag suggestion and show in dropdown
                scope.tagLoading = true;
                Media.fetchHashtagSuggestion(tagInputElement.value).then(function(json) {
                    if (scope.tagLoading) {
                        clearTimeout(hashTagTimeout);
                        scope.tagLoading = false;
                        RingLogger.information('HASH TAG SUGGESTION');
                        RingLogger.print(json, RingLogger.tags.UPLOAD);
                        if (json.sucs === true) {
                            toggleTagVisibility(true);
                            scope.tagSuggestions = json.sgstn;
                        } else {
                            toggleTagVisibility(false);
                        }
                        scope.$rgDigest();
                    }
                });
                scope.$rgDigest();
            }


            //inputFile = angular.elementent( element[0].querySelector('input#' + uploadType) );
            inputFile = element[0].querySelector('input#' + uploadType);

            if (uploadType === 'status') {
                inputFile.addEventListener('change', scope.uploadImage);
                // grab video input element
                //inputVideo = angular.element( element[0].querySelector('input#video') );
                inputVideo = element[0].querySelector('input#video');
                inputVideo.addEventListener('change', scope.uploadVideo);

                //inputAudio = angular.element( element[0].querySelector('input#audio') );
                inputAudio = element[0].querySelector('input#audio');
                inputAudio.addEventListener('change', scope.uploadAudio);

                // add hashtag
                scope.tagSuggestions = [];
                scope.tagLoading = false;
                tagInputElement = element[0].parentNode.querySelector('textarea#add-hashtag');
                tagDropdownElement = element[0].parentNode.querySelector('div#hashtag-dropdown');
                tagInputElement.addEventListener('keyup', handleHashTag);
            } else if (uploadType === 'audio') {
                inputFile.addEventListener('change', scope.uploadAudio);
            } else if (uploadType === 'video') {
                inputFile.addEventListener('change', scope.uploadVideo);
            } else {
                // image, chatimage, tagchatimage upload
                inputFile.addEventListener('change', scope.uploadImage);
            }

            scope.$rgDigest();

            scope.$on('$destroy', function() {
                switch (uploadType) {
                    case 'status':
                        inputFile.removeEventListener('change', scope.uploadImage);
                        inputAudio.removeEventListener('change', scope.uploadAudio);
                        inputVideo.removeEventListener('change', scope.uploadVideo);
                        tagInputElement.removeEventListener('keyup', handleHashTag);
                        break;
                    case 'image':
                        inputFile.removeEventListener('change', scope.uploadImage);
                        break;
                    case 'audio':
                        inputFile.removeEventListener('change', scope.uploadAudio);
                        break;
                    case 'video':
                        inputFile.removeEventListener('change', scope.uploadVideo);
                        break;
                }

                fileUploadService.removeScope(scope);
            });



            fileUploadService.setScopeForDigest(scope);

            // ##DIGEST_DEBUG_START##
                  if(RingLogger.tags.DIGEST){
                      scope.$watch(function(){
                           RingLogger.info("from rgUpload Directive",RingLogger.tags.DIGEST);
                       });
                  }
            // ##DIGEST_DEBUG_END##

        };  // LINK function END

        return {
            restrict: 'AE',
            scope: {
                rgUploadEnabled: '=',
                rgUploadType: '@',
                rgUploadAction: '&',
                rgUploadBoxValue: '='
            },
            link: linkFunc,
            controller: UploadController
        };
    }

})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
            .module('ringid.common.rgdropdown_directive', ['ringid.config','ringid.language', 'ringid.common.rgscrollbar_directive'])
            .service('rgDropdownService', rgDropdownService)
            .directive('rgDropdown', rgDropdown);


    rgDropdownService.$inject = ['GlobalEvents'];
    function rgDropdownService(GlobalEvents) { //jshint ignore:line
        var self = this, // jshint ignore:line
            _scope = false,
            _detachTemplate = false;


        var closeDropdown = function() {
            if(_scope && angular.isFunction(_scope.ddBeforeClose)){
                _scope.ddBeforeClose();
            }
            _detachTemplate();
            GlobalEvents.unbindHandler('document', 'click', self.close);
        };

        var openDropdown = function() {
            _scope.ddOpened();
            GlobalEvents.bindHandler('document', 'click', self.close);
        };

        self.open = function(detachTemplate, scope) {
            if (_detachTemplate) {
                closeDropdown();
            }
            _detachTemplate = detachTemplate;
            _scope = scope;
            openDropdown();
        };

        self.close = function() {
            if (_detachTemplate) {
                closeDropdown();
            }
            _detachTemplate = false;
            _scope = false;

        };

    }


    rgDropdown.$inject = ['$ringhttp', 'settings', '$compile', 'rgDropdownService', 'languageConstant'];
    function rgDropdown($ringhttp, settings, $compile, rgDropdownService, languageConstant) { //jshint ignore:line

        function linkFunc(scope, element) {
            var template,
                templateHtml,
                dropdownOpen = false,
                onDropdown = false;

            scope.consType = languageConstant.get();

            var stopPropagation = function(event) {
                event.stopPropagation();
            };

            var handleDropdown = function(event) {
                if (!dropdownOpen) {
                    attachTemplate();
                    rgDropdownService.open(detachTemplate, scope);
                } else {
                    rgDropdownService.close();
                }
                stopPropagation(event);
            };

            var handleHover = function(event) {
                setTimeout(function() {
                    if (!onDropdown) {
                        RingLogger.information('NOT ON DROPDOWN', RingLogger.tags.DROPDOWN);
                        handleDropdown(event);
                    } else {
                        RingLogger.information('IS ON DROPDOWN', RingLogger.tags.DROPDOWN);
                    }
                }, 500);
            };



            element.on('click', handleDropdown);

            if( !scope.ddHtml && !scope.ddTemplate){
                RingLogger.error('Please set ddHtml for rg-dropdown.', RingLogger.tags.DROPDOWN);
            }else{
                if (scope.ddTemplate) {
                    //template = $compile(scope.ddTemplate)(scope);
                    templateHtml = scope.ddTemplate;
                } else {
                    $ringhttp.get(settings.baseUrl + scope.ddHtml).success(function(response) {
                        //template = $compile(templateHtml)(scope);
                        templateHtml = response;
                    })
                    .error(function() {
                        RingLogger.warning('DROPDOWN TEMPLATE missing: ' + scope.ddHtml, RingLogger.tags.DROPDOWN);
                        scope.$rgDigest();
                    });
                }
            }



            var handleMouseEnter = function(event) {
                RingLogger.information('Mouse Enter', RingLogger.tags.DROPDOWN);
                onDropdown = true;
                element.off('mouseleave', handleHover);
            };

            var handleMouseLeave = function(event) {
                RingLogger.information('Mouse Leave', RingLogger.tags.DROPDOWN);
                onDropdown = false;
                handleHover(event);
                element.on('mouseleave', handleHover);
            };

            function attachTemplate() {
                RingLogger.information('DROPDOWN OPEN', RingLogger.tags.DROPDOWN);
                dropdownOpen = true;
                template = $compile(templateHtml)(scope);
                if (scope.ddControl && scope.ddControl.hasOwnProperty('append') && !scope.ddControl.append) {
                    element.after(template);
                } else {
                    element.append(template);
                }
                //stopPropagation
                for(var i = 0; i < template.length; i++) {
                    template[i].addEventListener('click', stopPropagation);
                }

                if (scope.ddControl && scope.ddControl.showOnHover) {
                    element[0].addEventListener('mouseleave', handleHover);

                    template[template.length-1].addEventListener('mouseenter', handleMouseEnter);
                    template[template.length-1].addEventListener('mouseleave', handleMouseLeave);

                }
                scope.$rgDigest();
            }

            function detachTemplate() {
                setTimeout(function() {
                    RingLogger.information('DROPDOWN CLOSE', RingLogger.tags.DROPDOWN);
                    dropdownOpen = false;

                    for(var i = 0; i < template.length; i++) {
                        template[i].removeEventListener('click', stopPropagation);
                    }
                    if (scope.ddControl && scope.ddControl.showOnHover) {
                         element[0].removeEventListener('mouseleave', handleHover);
                         template[template.length-1].removeEventListener('mouseenter', handleMouseEnter);
                         template[template.length-1].removeEventListener('mouseleave', handleMouseLeave);
                    }
                    //template[template.length-1].parentNode.removeChild(template[template.length-1]);
                    for(var i = 0; i < template.length; i++) {
                        template[i].parentNode.removeChild(template[i]);
                    }
                    //template[template.length-1].parentNode.removeChild(template);
                    scope.$parent.$rgDigest();
                });
            }

            scope.$on('$destory', function() {
                element[0].removeEventListener('click', handleDropdown);
                detachTemplate();
            });


        }


        return {
            restrict: 'AE',
            link: linkFunc,
            scope: {
                ddHtml: '=',
                ddControl: '=',
                ddTemplate: '=',
                ddAction: '&',
                ddOpened: '&',
                ddBeforeClose: '&'
            }
        };
    }

})();




/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.common.rgsearch_directive', [
			'ringid.config',
			'ringid.common.user_factory',
			'ringid.friend.friends_factory'
		])
		.service('rgSearchService', rgSearchService)
		.directive('rgSearch', rgSearch);

		rgSearchService.$inject = ['GlobalEvents'];
		function rgSearchService(GlobalEvents) {
			var self = this, // jshint ignore:line
                _scope = false,
                _template = false;

			self.close= function() {
                RingLogger.information('CLOSE SEARCH DROPDOWN', RingLogger.tags.SEARCH);
                if (_template) {
                    _scope.searchText = '';
                    _template.style.display = 'none';
                    _scope.$rgDigest();
                    _template = false;
                    _scope = false;
                    GlobalEvents.unbindHandler('document', 'click', self.close);
                }
			};
			self.open= function(template, scope) {
                _template = template;
                _scope = scope;
                _template.style.display = 'block';
                GlobalEvents.bindHandler('document', 'click', self.close);
			};

		}

		rgSearch.$inject = [ 'rgSearchService'];
		function rgSearch( rgSearchService) {
			var	linkFunc = function(scope, element) {
                var input = element.find('input');

                scope.template = element[0].querySelector('#search-dropdown');
                scope.template.style.display = 'none';

                input.on('keypress', function(event) {
                    if(event.keyCode === 13) {
                        event.preventDefault();
                    }
                });

                // show search bar and search result box before search result bound to input ng-change attr
                scope.doTheSearch = function() {
                    if( scope.searchText.length > 0 ) {
                        RingLogger.information('NEW SEARCH STRING', RingLogger.tags.SEARCH);
                        // before every new search string change reset no of result
                        //scope.resetSearch();
                        scope.doSearch();
                    } else {
                        rgSearchService.close();
                    }
                };

                function stopPropagate(event) {
                    if (event.target.tagName.toLowerCase() !== 'a') {
                        event.preventDefault();
                    }
                    event.stopPropagation();
				}


                // this is to prevent clicking on search dropdown and closing it. unless it links to user profile
				element.on('click', stopPropagate);
                scope.$on('$destroy', function() {
                    element.off('click', stopPropagate);
                });

            };

		SearchController.$inject = [ '$scope', '$$stackedMap', 'userFactory', 'friendsFactory','InviteFactory', 'friendsHttpService', '$timeout', 'rgScrollbarService'];
        function SearchController( $scope,  $$stackedMap, userFactory, friendsFactory,InviteFactory, friendsHttpService,  $timeout, rgScrollbarService) {
                var user,
                    searchFailCount = 0,
                    schPm = '',
                    timeOut;

                // initiate dropdown with data
                $scope.searchText = '';
                $scope.gotAllResult = false;
                $scope.showLoadbar = false;
                $scope.noResult = true;
                $scope.listData = $$stackedMap.createNew();

                $scope.resetSearch = function() {
                    searchFailCount = 0;
                    $scope.noResult = false;
                    $scope.gotAllResult = false;
                    //$scope.showLoadbar = false;
                    $scope.listData.reset();

                    $scope.$rgDigest();
                };


                $scope.contactListAction = function(actionObj) {
                    if (!actionObj.friend.isLoading()) {
                        friendsFactory.friendAction(actionObj, true).then(function() {
                            $scope.$rgDigest();
                        }, function() {
                            $scope.$rgDigest();
                        });
                        $scope.$rgDigest();
                    }
                };
                $scope.doSearch = doSearch;

                $scope.getMutualFriend = function(user) {

                    return{
                        data: function() {
                            return {
                                target: user
                            };
                        },
                        promise: InviteFactory.getMutualFriend(user)

                    };
                };



                function checkIfNewSearch() {
                    if ( schPm !== $scope.searchText) {
                        $scope.resetSearch();
                        searchFailCount = 0;
                    }
                }

                function searchFail(){
                    RingLogger.warning('inside TIMEOUT: ' , RingLogger.tags.SEARCH);
                    $scope.noResult = ($scope.listData.length() === 0);
                    $scope.gotAllResult = ($scope.listData.length() > 0 ) ? true : false;
                    $scope.showLoadbar = false;
                    $scope.$rgDigest();
                }

                function doSearch (force) {
                    checkIfNewSearch();
                    if (force || (!$scope.showLoadbar && !$scope.gotAllResult))   {
                        RingLogger.warning('clear TIMEOUT: ' + timeOut, RingLogger.tags.SEARCH);
                        clearTimeout(timeOut);
                        $scope.showLoadbar = true;
                        if(!$scope.showDropdown) {
                            rgSearchService.open($scope.template, $scope);
                        }
                        schPm = $scope.searchText;
                        RingLogger.information('start search: ' + schPm, RingLogger.tags.SEARCH);
                        friendsHttpService.searchContact({schPm: $scope.searchText, st: $scope.listData.length()})
                        .then(getSearchResult, getSearchResult );

                        RingLogger.warning('set TIMEOUT: ' + timeOut, RingLogger.tags.SEARCH);
                        timeOut = setTimeout(searchFail, 8000);
                        $scope.$rgDigest();
                    }
                }

                function getSearchResult (json) {
                    RingLogger.warning('clear TIMEOUT: ' + timeOut, RingLogger.tags.SEARCH);
                    clearTimeout(timeOut);
                    if ( json.sucs === true)
                    {
                        RingLogger.information('total search result: ' + json.searchedcontaclist.length, RingLogger.tags.SEARCH);
                        for (var i = 0, l = json.searchedcontaclist.length; i < l; i++) {
                            user = userFactory.create(json.searchedcontaclist[i]);
                            if (user) {
                                $scope.listData.save(user.getKey(), user);
                            }
                        }
                        if (json.searchedcontaclist.length > 0) {
                            rgScrollbarService.recalculate($scope);
                        }

                        $scope.showLoadbar = false; // hide loader
                        $scope.noResult = ($scope.listData.length() === 0);
                        $scope.$rgDigest();
                    } else {
                        RingLogger.information('SEARCH FAILED: ' + json.mg, RingLogger.tags.SEARCH);
                        searchFailCount++;
                        if(searchFailCount < 3) {
                            RingLogger.warning('RETRY SEARCH', RingLogger.tags.SEARCH);
                            doSearch(true);
                        } else {
                            RingLogger.warning('SEARCH FAILED RETRY END', RingLogger.tags.SEARCH);
                            RingLogger.warning('clear TIMEOUT: ' + timeOut, RingLogger.tags.SEARCH);
                            clearTimeout(timeOut);
                            searchFail();
                        }
                    }
                }


            }

			return {
				restrict: 'E',
				scope: {
					placeholder: '@'
				},
				templateUrl: 'pages/dropdowns/search-dropdown.html', // IMPORTANT this tempalte is preloaded inside auth factory
				link: linkFunc,
				controller: SearchController
			};

		}

})();


/* 
 * © Ipvision 
 */
 
(function() {
	'use strict';

	angular
		.module('ringid.common.rgscrollbar_directive', [])
		.directive('rgScrollbar', rgScrollbar)
				.factory('rgScrollbarService', rgScrollbarService);
				
				function rgScrollbar() {
						
						function linkFunc(scope, element, attr) {

										// Configuration
										var config = {
												scrollbarWidth: 6,
												scrollbarAlways: false,
												dragSpeedModifier : 5,
												minThumbHeight: 10
										};

										 
										if(attr.disabled == "true" || attr.disabled ==true) {
											return;
										} 
										var scrollbarContainer = null,
												scrollbarMousedown = false,
												scrollbarVisible = false,
												display = 'none',
												scrollHeight =0,
												offsetHeight = 0,
												hiddenHeight = 0,
												visibleHeight = 0,
												thumbHeight = 0,
												scrollbar = angular.element(document.createElement('div')),
												scrollbarThumb = angular.element(document.createElement('div')),
												doc = angular.element(document);
												
										element.wrap('<div class="ringscroll" style="position:relative;width:auto;overflow:hidden;height:100%;"></div>'); 
										element.css({
											 overflow: 'hidden'   
										}); 
		
										scrollbarContainer = element.parent();  
										scrollbarContainer.append(scrollbar[0]);
										scrollbarContainer.append(scrollbarThumb[0]);
										scrollbar.addClass('scrollbar');
										scrollbarThumb.addClass('thumb');
										
										fastdom.write(function() {
											    if(!scrollbar) return;
												scrollbar[0].style.width = config.scrollbarWidth+'px';
												scrollbar[0].style.height = '100%';
												scrollbar[0].style.right = '1px';
												scrollbar[0].style.top = 'px';
												scrollbar[0].style.position = 'absolute';
												scrollbar[0].style.zIndex = 1;
											 
												scrollbarThumb[0].style.width = config.scrollbarWidth+'px';
												scrollbarThumb[0].style.right = '1px';
												scrollbarThumb[0].style.top = 'px';
												scrollbarThumb[0].style.position = 'absolute';
												scrollbarThumb[0].style.zIndex = 1;
						 				});
										
										function scroll(pos) {
										
												 	var ratio;
												 	fastdom.read(function() {

												            if(!scrollbar) return;

															hiddenHeight = element[0].scrollHeight - (element[0].offsetHeight);
															visibleHeight = element[0].offsetHeight - thumbHeight; 
															ratio = pos/visibleHeight;
															pos= Math.min(Math.max(pos, 0), visibleHeight);
															 
															fastdom.write(function(){
																	element[0].scrollTop = hiddenHeight * ratio;
																	scrollbarThumb[0].style.top = pos+'px';
															});
																
															 /*call bottom reach*/
															if(pos==visibleHeight && angular.isFunction(scope.bottomReached)) {
																	scope.bottomReached();
															}  

														  //if(scrollbarThumb.hasClass('thumb-animation')) scrollbarThumb.removeClass('thumb-animation');
								 					});
						
										}
										
		
										function reCalculate() {
										
													 var ratio, pos, newScrollHeight;
													 
														fastdom.read(function() {

														        if(!element) return;
														        
																newScrollHeight = element[0].scrollHeight;
																
																//if(newScrollHeight != scrollHeight) {
																
																			offsetHeight = element[0].offsetHeight;
																			scrollHeight = newScrollHeight;
																			hiddenHeight = scrollHeight - offsetHeight;
																			visibleHeight = offsetHeight - thumbHeight; 
																			thumbHeight = Math.max((offsetHeight/scrollHeight) * offsetHeight, config.minThumbHeight);
																			ratio = visibleHeight/hiddenHeight;
																			pos = element[0].scrollTop * ratio;
																		
																			if(isNaN(thumbHeight) || thumbHeight=='Infinity') thumbHeight = 0;
																			display = (thumbHeight>=offsetHeight) ? 'none' : 'block';
												 
																			fastdom.write(function(){
																					if( !!scrollbar[0]){
																						scrollbar[0].style.display = display;
																						scrollbarThumb[0].style.height = thumbHeight + 'px';
																						scrollbarThumb[0].style.display = display;
																						scrollbarThumb[0].style.top = pos+'px';															
																						//scrollbarThumb.addClass('thumb-animation');	
																					}
																			});
															//	} 
									 				});
										 }
										 
											
										function hideScrollbar() {
										
											 if(config.scrollbarAlways) return ;
											 
											 if(!scrollbarMousedown) {
													 scrollbar.css('opacity', 0); 
													 scrollbarThumb.css('opacity', 0); 
													 scrollbarVisible = false;
												}
										}
										
										function showScrollbar() {
												reCalculate();
												scrollbarVisible = true;
												scrollbar.css('opacity', 1); 
												scrollbarThumb.css('opacity', 1);
										} 

										// Scroll on MouseWheel
										var mousewheel = (typeof InstallTrigger !== 'undefined')?'DOMMouseScroll':'mousewheel';
										element.on(mousewheel, function(event) {
										
												if(display=='none') return;
												event.preventDefault();
												if(!scrollbarVisible) showScrollbar();
												var barTop = parseFloat(scrollbarThumb.css('top'));
												var delta = (event.wheelDelta)? - 1/40 * event.wheelDelta : event.detail*3;
												var modifier = Math.max(parseInt((offsetHeight*2 / scrollHeight) * config.dragSpeedModifier),1);
												var newPos = barTop + (delta * modifier);
												scroll( newPos );
										});
										

										// Scroll on Drag
										scrollbarThumb.on('mousedown', function(event) {
										
												event.preventDefault();
												event.stopPropagation();
				
												if(!scrollbarVisible) showScrollbar();
												scrollbarMousedown = true;
												var mouseY= event.pageY;
												var barTop = parseFloat(scrollbarThumb.css('top'));

												doc.on('mousemove', function(event) {
														var newPos = barTop+event.pageY-mouseY;
														scroll( newPos );
												});

												doc.on('mouseup', function(event) {
														event.stopPropagation();
														scrollbarMousedown = false;
														doc.off('mousemove');
														doc.off('mouseup');
												});

										});
										
										// Show scrollbar on hover
										scrollbarContainer.on('mouseenter', showScrollbar);
										scrollbarContainer.on('mouseleave', hideScrollbar);
										
										// event listner
										scope.$on('scrollTop', function(event) {
											 if (event.stopPropagation) {
													event.stopPropagation();
											 }  
												setTimeout(function() {
														scroll(0);
												}, 100);
										});
										
										scope.$on('scrollTo', function(event,percent, dir) { // percent e.g 10, 50, 100
										
												 if (event.stopPropagation) {
													 event.stopPropagation();
												 }
											 
											 	switch (typeof percent) {
													case 'string':
														var elm = element[0].querySelector(percent);
														percent = 0;
														if(elm) {
															var elemHeight = (dir && dir=='bottom')? elm.offsetHeight:0;
															percent = parseInt(((elm.offsetTop+elemHeight) * 100) / scrollHeight);
														}
												 	break;
													case 'number':
														percent = parseInt(percent);
												 	break;
											 		default:
													 	percent = parseInt(percent);
												}
											 
											  var pos =  (percent * visibleHeight) / 100;
											  setTimeout(function() {
														 scroll(pos);
												}, 10);
										 });
										 
										 scope.$on('recalculate', function(event) {
										
												if (event.stopPropagation) {
													event.stopPropagation();
												}
												 reCalculate();
										 });

										 scope.$on('hasScroll', function(event, $scope) {
										
												if (event.stopPropagation) {
													event.stopPropagation();
												}
												$scope.scroll = (display=='none')?false:true;
										 });
										 
										scope.$on("$destroy", function(){
										 /*clear DOM reference*/
											  scrollbarContainer = null;
											  scrollbar = null;
											  scrollbarThumb = null;
									  }); 
										
						}

						return {
								restrict: 'A',
								scope: {
									bottomReached: '&'
								},
								link: linkFunc
						};

				}

				/*perf: bypass broadcast, think different*/
				function rgScrollbarService() {
						return {
								scrollTop: function(scope) {
										scope.$broadcast('scrollTop');
								},
								scrollTo: function(scope,percent, dir) {
										scope.$broadcast('scrollTo',percent, dir);
								},
								recalculate: function(scope) {
										scope.$broadcast('recalculate');
								},
								hasScroll: function(scope) {
								     scope.$broadcast('hasScroll', scope);
								}
						};
				}
})();

/**
 * © Ipvision
 */



(function() {
    'use strict';

    angular
        .module('ringid.common.rginvite_directive', [
            'ringid.common.invite_factory',
            'ringid.friend.friends_factory'
        ]).directive('rgInvite', rgInvite);


    function rgInvite() {

        InviteController.$inject = ['$scope', 'InviteFactory', 'friendsFactory', '$$connector', 'OPERATION_TYPES'];
        function InviteController($scope, InviteFactory, friendsFactory, $$connector, OPERATION_TYPES) {
            var changePeopleInterval,
                OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS,
                deleteFromSuggList = false;

            $scope.people = null;
            $scope.friendRequestAction = function(actionObj) {
                if (!actionObj.friend.isLoading()) {
                    friendsFactory.friendAction(actionObj, true).then(function() {
                        InviteFactory.removeSuggestion(actionObj.friend.getUtId()).then(function(json){
                            if(json.sucs===true){
                                deleteFromSuggList = true;
                                $scope.stopChanging = false;
                            }
                            $scope.$rgDigest();
                        });
                        $scope.$rgDigest();
                    }, function() {
                        $scope.stopChanging = false;
                        $scope.$rgDigest();
                    });
                    $scope.$rgDigest();
                }
            };
            $scope.changePeople = changePeople;
            $scope.contactLength = InviteFactory.noOfSuggestions;
            $scope.stopChanging = false;

            $scope.removeOutGoingFriends = function () {
                var outGoingUtid = [];
                var findOutGoing = InviteFactory.suggestionFriends.all();
                var loopLength = InviteFactory.suggestionFriends.length();

                for( var i = 0; i < loopLength; i++ ){
                    if(findOutGoing[i].value.friendshipStatus() !== 0) {
                        outGoingUtid.push(findOutGoing[i].value.getUtId());
                    }
                }
                for(var j=0;j<outGoingUtid.length;j++){
                    InviteFactory.suggestionFriends.remove(outGoingUtid[j]);
                }
            };

            $scope.getSuggestions = function(){

                $scope.users = InviteFactory.suggestionFriends;

                return{
                    data: function() {
                        return {
                            target: $scope.users
                        };
                    }
                };

            };

            $scope.removeSugg = function(obj,action) {
                //obj.event.preventDefault();
                InviteFactory.removeSuggestion(obj.getUtId(),action).then(function(data){
                    //RingLogger.print(data, RingLogger.tags.INVITE);
                    if(data.sucs===true){
                        deleteFromSuggList = true;
                        changePeople();
                    }
                });
            };

            // $scope.inviteHover = function(){
            //     //RingLogger.print('hover', RingLogger.tags.INVITE);
            //     stopChangePeopleInterval();
            // };
            // $scope.inviteLeave = function(){
            //     //RingLogger.print('leave', RingLogger.tags.INVITE);
            //     startChangePeopleInterval();
            // };

            $scope.getMutualFriend = function(user) {

                return{
                    data: function() {
                        return {
                            target: user
                        };
                    },
                    promise: InviteFactory.getMutualFriend(user)

                };
            };

            startChangePeopleInterval();


            function startChangePeopleInterval() {
                changePeopleInterval = setInterval( changePeople, 5000 );
            }

            function stopChangePeopleInterval() {
                clearInterval(changePeopleInterval);
            }

            function changePeople () {
                if($scope.stopChanging && !deleteFromSuggList){
                    return;
                }

                if(!$scope.people){
                    $scope.people = InviteFactory.suggestionFriends.bottom();
                }else{
                    var userToRemove = $scope.people.getUtId();
                    $scope.people = InviteFactory.suggestionFriends.next($scope.people.getUtId());
                    if(deleteFromSuggList){
                        InviteFactory.suggestionFriends.remove(userToRemove);
                        deleteFromSuggList = false;
                    }
                    if(!$scope.people) {
                        $scope.people = InviteFactory.suggestionFriends.bottom();
                    }
                }
                $scope.$rgDigest();

            }
                    // ##DIGEST_DEBUG_START##
                    if(RingLogger.tags.DIGEST){
                        $scope.$watch(function(){
                             RingLogger.info("from rgInvite",RingLogger.tags.DIGEST);
                        });
                    }
                    // ##DIGEST_DEBUG_END##

            function youMayKnowContacts(response){

                if(response.sucs===true && response.actn===OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS){
                //
                //    for(var i=0;i<response.contactList.length;i++) {
                //        peoplesYouMayKnow.push(response.contactList[i]);
                //
                //    }
                    $scope.contactLength = InviteFactory.noOfSuggestions;
                    changePeople();
                }
                //peoplesYouMayKnow = response.contactList;

            }

            $$connector.subscribe(youMayKnowContacts,{
                action: [OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS]
            });
            $scope.$on("$destroy",function(){
                stopChangePeopleInterval();
            });
        }


        return {
            restrict: 'A',
            controller: InviteController,
            templateUrl: 'pages/partials/friend-invite.html',
            link : function(scope,element) {
                function stopChange(){
                    scope.stopChanging = true;
                }
                function startChange(){
                    scope.stopChanging = false;
                }
                element.on("mouseenter",stopChange);
                element.on("mouseleave",startChange);

                scope.$on("$destroy",function(){
                    element.off("mouseenter",stopChange);
                    element.off("mouseleave",startChange);
                });
            }
        };


    }

})();



/**
 * Copyright @ 2015 by RingID Inc.
 *
 */


(function () {
    'use strict';

    angular
            .module('ringid.common.rgemoticon_directive', [])
            .directive('rgEmoticon', rgEmoticon);
            //.directive('rgEmoticonList', rgEmoticonList);



    rgEmoticon.$inject = ['$compile', '$timeout', '$document', 'utilsFactory', 'StickerFactory', 'rgScrollbarService', '$templateCache', '$ringhttp'];
    function rgEmoticon($compile, $timeout, $document, utilsFactory, StickerFactory, rgScrollbarService, $templateCache, $ringhttp) { //jshint ignore:line
        var linkFunc = function (scope, element, attrs) {
            var
                emoticonListTemplate = 'pages/partials/emoticon-window.html',
                showEmoticon = false,
                emoBoxLimit = 400,
                emoBoxWidth = 300,
                emoBoxHeight = (attrs.showSticker == 'true') ? 300 : 260, //jshint ignore:line
                compiledDom,
                openEmoticonEvent;

            scope.emoWindowStyle = {
                height: emoBoxHeight + 'px',
                width: emoBoxWidth + 'px'
            };

            scope.showsticker = (attrs.showSticker == 'true') ? true : false; // jshint ignore:line
            scope.selectedStickerCatId = 0;

            function safeDigest(){
                if(scope.$parent && scope.$parent.$id !==1){
                    scope.$parent.$rgDigest();
                }else{
                    scope.$rgDigest();
                }
            }

            function handleClick(event) {
                // event.stopImmediatePropagation();
                event.preventDefault();
                //if (!showEmoticon) {
                    showEmoticon = !showEmoticon;
                    if (showEmoticon) {
                        openEmoticonPopUp(event);
                    } else {
                        closeEmoticonPopup();
                    }
                    //safeDigest();
                //}
            }

            element[0].addEventListener('click', handleClick);



            function closeEmoticonPopup(e) {
                if(e && e.type === "click"){
                    if(e.target !== element[0] &&
                        e.target.parentNode &&
                        e.target.parentNode !== element[0] &&
                        e.target.parentNode.parentNode !== element[0] &&
                        e.target.className !== 'pt-top') {

                    }else{
                        return;
                    }
                }
                showEmoticon = false;
                document.removeEventListener('click', closeEmoticonPopup);
                document.removeEventListener('scroll', closeEmoticonPopup);
                element[0].removeEventListener('resize', calculatePosition);
                compiledDom[0].parentNode.removeChild(compiledDom[0]);
            }


            function attachTemplate(templateHtml) {
                compiledDom = $compile(templateHtml)(scope);
                element.append(compiledDom);
                calculatePosition();

                document.addEventListener('click', closeEmoticonPopup);
                document.addEventListener('scroll', closeEmoticonPopup);
                window.addEventListener('resize', calculatePosition);
            }

            function openEmoticonPopUp(event) {
                openEmoticonEvent = event; // catch the event for window resize recalculation of position

                if ($templateCache.get( emoticonListTemplate )) {
                    attachTemplate($templateCache.get(emoticonListTemplate));
                } else {
                    $ringhttp.get(emoticonListTemplate).then(function(templateHtml) {
                        attachTemplate(templateHtml);
                    });
                }
            }

            scope.selectEmoOrSticker = selectEmoOrSticker;

            function calculatePosition() {
                console.info('Calculate Emo Position');
                var elemD = 0,
                    elemRect = element[0].getBoundingClientRect(),
                    availWidth = utilsFactory.viewport.x - elemRect.width,
                    availHeight = utilsFactory.viewport.y;
                elemD = Math.floor(elemRect.width / 2);

                if (openEmoticonEvent.clientX + emoBoxLimit < availWidth && openEmoticonEvent.clientY + emoBoxLimit < availHeight) {
                    //console.info('bottom right');
                    scope.emoWindowStyle.top = elemRect.top + (elemD+15) + 'px';
                    scope.emoWindowStyle.left = elemRect.left + (elemD+5) + 'px';
                } else if (openEmoticonEvent.clientX + emoBoxLimit > availWidth && openEmoticonEvent.clientY + emoBoxLimit > availHeight) {
                    //console.info('top left');
                    scope.emoWindowStyle.top = (elemRect.top - emoBoxHeight) + (elemD-5) + 'px';
                    scope.emoWindowStyle.left = (elemRect.left - emoBoxWidth) + (elemD-5) + 'px';
                } else if (openEmoticonEvent.clientX + emoBoxLimit > availWidth) {
                     //console.info('bottom left');
                    scope.emoWindowStyle.top = elemRect.top + (elemD+5) + 'px';
                    scope.emoWindowStyle.left = (elemRect.left - emoBoxWidth) + (elemD-5) + 'px';
                } else if (openEmoticonEvent.clientY + emoBoxLimit > availHeight) {
                    //console.info('top right');
                    scope.emoWindowStyle.top = (elemRect.top - emoBoxHeight) + (elemD-5) + 'px';
                    scope.emoWindowStyle.left = elemRect.left + (elemD+5) + 'px';
                }
                safeDigest();
            }

            function selectEmoOrSticker(emo, $event) {
                $event.stopPropagation();
                //scope.$broadcast('insertEmoji', emo);
                //scope.$emit('insertEmoji', emo); /* don't need broadcast, expensive rather than callback*/
                if(attrs.clicked) {
                  scope.$eval(attrs.clicked)(emo, $event);
                }
                closeEmoticonPopup(); // close emoticon
                safeDigest();
            }

            scope.selectStickerCatId = function (e, stickerKey) {
                e.stopPropagation();
                scope.selectedStickerCatId = stickerKey;
                StickerFactory.getStickerMapByCatId(stickerKey).then(function(data){
                    scope.emoticonMap = data;
                    safeDigest();

                });
                rgScrollbarService.scrollTop(scope);
                safeDigest();
            };

            // most likely not needed
            //scope.selectSticker = function(stickerKey){
                //scope.selectStickerCatId(stickerKey);
                //closeEmoticonPopup(); // close emoticon
                ////safeDigest();
            //};

            scope.showEmoticons = function(e){
                e.stopPropagation();
                scope.emoticonMap = StickerFactory.getEmoticonMap();
                safeDigest();
            };

            scope.$on('$destroy', function() {
                document.removeEventListener('click', closeEmoticonPopup);
                document.removeEventListener('scroll', closeEmoticonPopup);
                element[0].removeEventListener('resize', calculatePosition);
            });

        };

        EmoticonController.$inject = ['$scope'];
        function EmoticonController($scope) {

            function safeDigest(){
                if($scope.$parent && $scope.$parent.$id !==1){
                    $scope.$parent.$rgDigest();
                }else{
                    $scope.$rgDigest();
                }
            }
            $scope.startAt = 0;
            $scope.getMyStickers = function() {
                return $scope.myStickerCatIds().slice($scope.startAt, $scope.startAt+4);
            };
            $scope.getTopStickers = function() {
                RingLogger.information(StickerFactory.getStickerCategories('top'), RingLogger.tags.STICKER);
                return StickerFactory.getStickerCategories('top').slice(0, 4);
            };

            $scope.loadPrevious = function($event) {
                $scope.startAt = ($scope.startAt > 0) ? $scope.startAt-1 : 0;
                $event.stopPropagation();
                safeDigest();
            };
            $scope.loadNext = function($event) {
                $scope.startAt = ( $scope.startAt+3 < $scope.myStickerCatIds().length - 1 ) ? $scope.startAt+1 : $scope.startAt;
                $event.stopPropagation();
                safeDigest();
            };

            $scope.myStickerCatIds = StickerFactory.getMyStickerCatIds;
            $scope.getSticker = StickerFactory.getStickerCategoryObject;
            $scope.emoticonMap = StickerFactory.getEmoticonMap();

            // ##DIGEST_DEBUG_START##
                  if(RingLogger.tags.DIGEST){
                      $scope.$watch(function(){
                           RingLogger.info("from rgEmoticon",RingLogger.tags.DIGEST);
                       });
                  }
            // ##DIGEST_DEBUG_END##
        }

        return {
            restrict: 'A',
            link: linkFunc,
            controller: EmoticonController
        };
    }

    //function rgEmoticonList() {
        //return {
            //link:function(scope, element) {
                //var stopPropagation = function($event) {
                    //console.warn('inside emoticon box clicked');
                    //$event.stopPropagation();
                //};

                //element.on('click', stopPropagation);
                //scope.$on('$destroy', function() {
                    //element.off('click', stopPropagation);
                //});
               //scope.$rgDigest();
            //},
            //restrict: 'E',
            //templateUrl: 'pages/partials/emoticon-window.html'
        //};
    //}


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.rgclick_directive', [])
        .directive('rgImgLoad', rgImgLoad)
        .directive('rgClick', rgClick)
        .directive('rgConditionalClick', rgConditionalClick);

        rgConditionalClick.$inject = [];

        function rgConditionalClick(){

            return function(scope,elem,attrs){
                if(angular.isFunction(attrs.rgConditionalClick)){
                    elem.bind("click", function(e){
                        attrs.rgConditionalClick();
                    });

                    scope.$on('$destroy',function(){
                        elem.unbind("click");
                    });
                }
            };

        }

        rgClick.$inject = ['$parse'];
        function rgClick($parse) {
            return {
                restrict: 'A',
                link: function(scope, element, attrs) {
                    var fn = $parse(attrs['rgClick']);
                    var noapply = attrs['rgClickNoapply'];
                    function clickfn(event) {
                        event.preventDefault();
                        //event.stopPropagation();

                        fn(scope, {$event:event});
                        scope.$rgDigest();

                        // if (!noapply) {
                        //     scope.$apply(function() {
                        //         fn(scope, {$event:event});
                        //     });
                        // } else {
                        //     fn(scope, {$event:event});
                        //     scope.$digest();
                        // }

                    }
                    element.bind('click', clickfn);
                    scope.$on('$destroy', function(){
                        element.unbind('click',clickfn);
                    });
                }
            };
        }

        function rgImgLoad() {
            return {
                restrict: 'A',
                transclude: true,
                link: function(scope, element, attrs) {
                    //var imgSrc = element[0].attr('src');
                    //console.log('image source: ' + imgSrc);
                    //element[0].attr('src', '');
                    element.on('load', function () {
                        console.log('image loaded');
                    });
                }
            };
        }



})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.rgimg_directive', [])
        .directive('rgImg', rgImg)
        .directive('rgImgChange', rgImgChange);

    function rgImgChange(){ //jshint ignore:line
        return {
            restrict : 'A',
            controller: ['$scope','$element',function($scope, $element) {
                this.setPopupStyle = function(height, width) {
                    $element[0].style.height = height + 'px';
                    $element[0].style.width = width + 'px';
                };
            }]
        };
    }

    rgImg.$inject = ['$compile', 'utilsFactory'];
    function rgImg($compile, utilsFactory) { //jshint ignore:line
        return {
            restrict: 'A',
            require: '^rgImgChange',
            scope: {
                rgImgObj: '='
            },
            link: function(scope, element, attr, rgImgChangeCntrl) {
                var dH= 500,
                    dW = 500,
                    minW = 0,
                    minH = 0,
                    leftbarW = 300,
                    imgPadding = 60,
                    maxW = 0,
                    maxH = 0,
                    resizedW = 0,
                    resizedH = 0,
                    image = $compile('<img src="' + scope.rgImgObj.src() + '" />')(scope);


                maxW = utilsFactory.viewport.x - 40 - leftbarW - imgPadding;
                maxH = utilsFactory.viewport.y - 40 - imgPadding;
                minW = (maxW - dW) > dW? maxW-dW : dW;
                minH =  (maxH - dH) > dH? maxH-dH : dH;

                //element.html(image[0].outerHTML);
                element.append(image);
                //calculateImgSize(scope.rgImgObj.getIh(), scope.rgImgObj.getIw());

                attr.$observe('rgImg', function(newVal) {
                    image[0].setAttribute('src', '');
                    image[0].setAttribute('src', newVal);
                    calculateImgSize(scope.rgImgObj.getIh(), scope.rgImgObj.getIw());
                });

                function calculateImgSize(imgH, imgW) {
                    if (imgH > maxH || imgW > maxW) {
                        if ( (imgW/maxW) >= (imgH/maxH) ) {
                            resizedW = maxW;
                            resizedH = Math.floor( (maxW/imgW) * imgH );
                        } else {
                            resizedH = maxH;
                            resizedW = Math.floor( (maxH/imgH) * imgW );
                        }
                    } else {
                        // set to image actual height, width
                        resizedH = imgH;
                        resizedW = imgW;
                    }

                    image[0].style.width = resizedW + "px";
                    image[0].style.height = resizedH + "px";

                    RingLogger.information('imgW: ' + imgW + ' resizedW: ' + resizedW + ' maxW: ' + maxW, RingLogger.tags.IMAGE);
                    RingLogger.information('imgH: ' + imgH + 'resizedH: ' + resizedH + ' maxH: ' + maxH, RingLogger.tags.IMAGE);

                    // below recalculation is for ringbox resize
                    //fix height,width to minimum
                    if (resizedW < minW) {
                        resizedW = minW;
                    }
                    if (resizedH < minH) {
                        resizedH = minH;
                    }

                    resizedW = resizedW + leftbarW + imgPadding;
                    resizedH = resizedH + imgPadding;

                    rgImgChangeCntrl.setPopupStyle(resizedH, resizedW);
                    //scope.$broadcast('ringbox.content.changed', {width:resizedW,height:resizedH} );
                }


            }

        };
    }
})();


/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.rgphotos_directive', [
            'ringid.profile',
            'ringid.ringbox'
        ])
        .directive('rgPhotos', rgPhotos);


        rgPhotos.$inject = ['$window', '$document', 'utilsFactory'];
        function rgPhotos($window, $document, utilsFactory) { //jshint ignore:line

           PhotosController.$inject = ['rgScrollbarService', '$timeout', '$scope', '$rootScope', 'AlbumFactory', '$routeParams', 'profileFactory', 'fileUploadService', 'SystemEvents', 'Auth'];
           function PhotosController (rgScrollbarService, $timeout, $scope, $rootScope, AlbumFactory, $routeParams, profileFactory, fileUploadService, SystemEvents, Auth) { //jshint ignore:line
                $scope.showAlbumPreview = true;
                $scope.activeAlbum = null;

                var profileObj = profileFactory.getProfile($routeParams.uId);
                $scope.state = {
                    imagesLoading : true,
                    albumsLoading : true
                };
                $scope.albums =  AlbumFactory.albums($routeParams.uId);

                function toggleLoading(bool, type) {
                    if (type === 'album') {
                        $scope.state.albumsLoading = bool;
                    } else {
                        $scope.state.imagesLoading = bool;
                        rgScrollbarService.recalculate($scope);
                    }

                    $scope.$digest();
                }

                toggleLoading(true, 'album');
                AlbumFactory.getAllAlbums($routeParams.uId, $scope).then(function() {
                    $scope.albums =  AlbumFactory.albums($routeParams.uId);
                    toggleLoading(false, 'album');
                    //$scope.loadMoreImage();
                }); // request data

                $scope.loadMoreImage = function() {
                    if (!AlbumFactory.imagesLoading() && $scope.activeAlbum.getImages().length() < $scope.activeAlbum.getTotalImageCount()) {
                        toggleLoading(true, 'image');
                        AlbumFactory.loadMoreImage($scope.activeAlbum.getKey(), $routeParams.uId).then(function() {
                            toggleLoading(false, 'image');
                        }, function() {
                            toggleLoading(false, 'image');
                        });
                    }
                };


                $scope.getImageData = function(imageMap) {
                    return function() {
                        return {
                            image: imageMap,
                            popupFrom: 'profile'
                        };
                    };
                };

                $scope.deleteImage =  function(imageMap) {
                    AlbumFactory.deleteImage(imageMap);
                };

                $scope.showAlbumImages = function(album) {
                    $scope.activeAlbum  = album;
                    $scope.showAlbumPreview = false;
                    // load more image
                    $scope.loadMoreImage();
                    if ($scope.activeAlbum.getImages().length() < 20) {
                        $scope.loadMoreImage();
                    }
                };

                $scope.enableAlbumPreview = function() {
                    $scope.showAlbumPreview = true;
                    $scope.activeAlbum = null;
                    $scope.$rgDigest();
                };


                $scope.selectPhoto = function(image){
                    RingLogger.print('selected: ' + image.src(), RingLogger.tags.IMAGE);
                    if ($scope.forSelection) {
                        $rootScope.$broadcast(SystemEvents.IMAGE.DO_REPOSITION, { image : image.src() });
                    }

                };

                $scope.$on('$destroy', function() {
                    AlbumFactory.resetUserImages(profileObj.isCurrentUser());
                     //RingLogger.print("destroyed scope",'RgPhotos');
                });

            }


            var linkFunc = function(scope, element) {

                function handleScroll() {
                    if (!scope.showAlbumPreview) {
                        if ( ($window.innerHeight + $window.scrollY) >= $document[0].body.offsetHeight ) {
                            scope.loadMoreImage();
                        }
                    }
                }

                if (scope.hasOwnProperty('forSelection') && (scope.forSelection === true || scope.forSelection === 'true') ) { //jshint ignore:line
                    // add maxheight from utilsfactory
                    element[0].children[0].children[0].style.overflow = 'hidden';
                    element[0].children[0].children[0].style.maxHeight = utilsFactory.viewportsize().y - 200 + 'px';

                } else {
                    scope.forSelection = false;
                    // load more image on scroll
                    $window.addEventListener('scroll', handleScroll);

                }

                scope.$on('$destroy', function() {
                    $window.removeEventListener('scroll', handleScroll);
                });

                scope.$rgDigest();
            };

            return {
                restrict: 'E',
                controller: PhotosController,
                link: linkFunc,
                templateUrl: 'pages/partials/photos.html',
                scope: {
                    forSelection: '@forSelection',
                    $close : '&boxClose'
                }
            };
        }


})();

(function() {
    'use strict';

    angular
        .module('ringid.common.rghref_directive', [])
        .directive('rgHref', ['$location', '$route','$rootScope',
            function($location, $route,$rootScope) {
                function clickHandler(value,attrs) {
                            var match = /#/g.exec(value);
                            if(match){
                                match = value.substr(match.index+1);
                            }else{
                                match = value;
                            }
                            if($location.path() == match && attrs.reloadpage === 'true') {
                                $route.reload();
                            }
                            $rootScope.$coreDigest();
                        }
                return function(scope, element, attrs) {
                    var fn;
                    attrs.$observe('rgHref', function(value) {
                        if(fn){
                            element.unbind('click',clickHandler);    
                        }
                        
                        if (!value) {
                            element.removeAttr('href');
                            return;
                        }
                        fn = angular.bind(null,clickHandler,value,attrs);
                        element.attr('href', value);
                        element.bind('click',fn);

                    });

                    scope.$on('$destroy',function(){
                        if(fn){
                            element.unbind('click',fn);
                        }
                        
                    });
                }
            }]);


})();

/*
 * © Ipvision
 */

(function() {
    'use strict';
      angular.module('ringid.common.rgslider_directive', [] )

       .directive('rgSlider', function () {

    return {

        link: function (scope, element, atrr) {

            var nextSlide = 0,
                autoSlide = false,
                sliderTimer = null,
                navs = [],
                i;


            var slider_dom = element[0];

            var nav_selector = atrr.navClass || '';
            var slide_selector = atrr.slideClass || '';
            var desc_selector = atrr.descClass || '';
            var delay = parseInt(atrr.delay) * 1000 || 3000;

            var slides = angular.element(slider_dom.querySelectorAll('.' + slide_selector));
            var desc = angular.element(slider_dom.querySelectorAll('.' + desc_selector));
            var nav_dom = slider_dom.querySelectorAll('.' + nav_selector) || {};

            /* vars for carousel*/
            var crsl_distance = 120;
            var crsl_distance_multiplier = 0.6;
            var crsl_size_multiplier = 0.6;
            var crsl_opacity_multiplier = 0.8;

            var crsl = slider_dom.querySelector('.nav-carousel');
            var crsl_items = crsl.querySelectorAll('img');
            crsl_items = Array.prototype.slice.call(crsl_items);
            var crsl_data = [];
            var crls_width = crsl.clientWidth;
            var crls_height = crsl.clientHeight;
            var center = Math.floor(crsl_items.length/2);
            /* end of carousel*/

            setupEvent();
            playSlide();

            function playSlide() {

                slides.removeClass('active');
                slides.eq(nextSlide).addClass('active');

                desc.removeClass('active');
                desc.eq(nextSlide).addClass('active');

                for (i = 0; i < navs.length; i++) {
                    navs[i].find('li').removeClass('active');
                    navs[i].find('li').eq(nextSlide).addClass('active');
                }

                /* Move carousel*/
                if(crsl_data[0]) {
                    playCarousel(findMappedItem(nextSlide));
                }


                if (autoSlide) {
                    nextSlide = (nextSlide + 1 == slides.length) ? 0 : nextSlide + 1;
                    setTimer();
                }

            }

            function setTimer() {

                sliderTimer = setTimeout(function () {
                    playSlide();
                }, delay);
            }

            function clearTimer() {
                clearTimeout(sliderTimer);
            }

            function index(node) {

                var children = node.parentNode.childNodes;
                var num = 0;
                for (var i = 0; i < children.length; i++) {

                    if (children[i] == node) return num;
                    if (children[i].nodeType == 1) num++;

                }
                return -1;
            }

            function setupEvent() {
                var nav;
                for (i = 0; i < nav_dom.length; i++) {

                    nav = angular.element(nav_dom[i]);
                    navs.push(nav);
                    nav.find('li').on('click', function (e) {
                        nextSlide = index(this);
                        clearTimer();
                        playSlide();
                    });
                }

                slides.on('mouseenter', function (e) {
                    e.stopPropagation();
                    autoSlide = false;
                    clearTimer();
                });

                slides.on('mouseleave', function (e) {
                    e.stopPropagation();
                    autoSlide = false;
                    setTimer();
                });

                desc.on('mouseenter', function (e) {
                    e.stopPropagation();
                    autoSlide = false;
                    clearTimer();
                });

                desc.on('mouseleave', function (e) {
                    e.stopPropagation();
                    autoSlide = false;
                    setTimer();
                });

            }

             /*function for carousel*/
            function initCarousel() {

                var item_w, item_h, item_opacity, item_left, item_top, depth, separation;

            	/*for centered item*/
            	item_w= crsl_items[0].clientWidth;
            	item_h= crsl_items[0].clientHeight;
            	item_opacity= 1;
            	item_left = Math.round(crls_width/2)-Math.round(item_w/2);
            	item_top = Math.round(crls_height/2)-Math.round(item_h/2);
            	crsl_data[center]={
                 	'w':item_w,
                 	'h':item_h,
                 	'o':item_opacity,
                 	'l':item_left,
                 	't':item_top,
                 	'z':center,
                 	'i':0
                 };

                /* calculate position for right items*/
            	separation = crsl_distance;
            	depth = center;
            	for(i=center+1;i<crsl_items.length;i++) {

               		separation = separation*crsl_distance_multiplier;
              		item_w =	crsl_size_multiplier * crsl_data[i-1].w;
               		item_h =	crsl_size_multiplier * crsl_data[i-1].h;
               		item_opacity = crsl_opacity_multiplier * crsl_data[i-1].o;
               		item_left = crsl_data[i-1].l+crsl_data[i-1].w+separation-item_w;
                	--depth;
                	item_top = Math.round(crls_height/2)-Math.round(item_h/2);

                	crsl_data[i]={
                 		'w':item_w,
                 		'h':item_h,
                 		'o':item_opacity,
                 		'l':item_left,
                 		't':item_top,
                 		'z':depth,
                 		'i':i
                 	};
                }

              /* calculate position for left items*/
               separation = crsl_distance;
               depth = center;
               for(i=center-1;i>=0;i--) {

               		separation = separation*crsl_distance_multiplier;
               		item_w =	crsl_size_multiplier * crsl_data[i+1].w;
               		item_h =	crsl_size_multiplier * crsl_data[i+1].h;
               		item_opacity = crsl_opacity_multiplier * crsl_data[i+1].o;
               		item_left = crsl_data[i+1].l-separation;
                	--depth;
                	item_top = Math.round(crls_height/2)-Math.round(item_h/2);

                	crsl_data[i]={
                 		'w':item_w,
                 		'h':item_h,
                 		'o':item_opacity,
                 		'l':item_left,
                 		't':item_top,
                 		'z':depth,
                 		'i':i
                 	};
               }


             /* set initial position and enable event*/
              for(i=0;i<crsl_items.length;i++) {

                  crsl_items[i].orgPos = i;
                  crsl_items[i].crslPos = i;
                  crsl_items[i].addEventListener('click', function (e) {
                     if (this.crslPos==center) return ;

                     nextSlide = this.orgPos;
                     clearTimer();
                     playSlide();
                     playCarousel(this);


                  });
               }

           }

           function playCarousel(item) {
             moveItem(item);
             setItemPosition();
           }

           function moveItem (item) {

                   var temp, direction = item.crslPos < center ? 'forward' : 'backward';

                   while (item.crslPos != center) {
                        if( direction == 'forward') {
                        	temp = crsl_items.pop();
                        	crsl_items.unshift(temp);
                        } else {
                            temp = crsl_items.shift();
                            crsl_items.push(temp);
                        }

                        //update position
                        for(i=0;i<crsl_items.length;i++) {
                            crsl_items[i].crslPos = i;
                            crsl_items[i].className = '';
                        }
                   }
                 item.className= 'active';
           }


         function setItemPosition() {

             	for(i=0;i<crsl_items.length;i++) {
                	crsl_items[i].style.width =  crsl_data[i].w+'px';
                	crsl_items[i].style.height =  crsl_data[i].h+'px';
                	crsl_items[i].style.opacity =  crsl_data[i].o;
                	crsl_items[i].style.left =  crsl_data[i].l+'px';
                	crsl_items[i].style.top =  crsl_data[i].t+'px';
                	crsl_items[i].style.zIndex =  crsl_data[i].z;
                	crsl_data[i].i = i;
               }

               //console.log(crsl_items);
          }

         function findMappedItem(position) {

            for(i=0;i<crsl_items.length;i++) {
               if(position ==crsl_items[i].orgPos ) {
                  return crsl_items[i];
               }
            }
         }
        
         crsl_items[0].src = crsl_items[0].src; // loading cache issue 
         crsl_items[0].addEventListener('load', function() {
            initCarousel();
            playCarousel(crsl_items[0]);
            
            setTimeout(function(){
               crsl.style.visibility =  'visible'; 
              }, 800);
         });

         /* End of carousel*/

        }
    }
});
})();


(function () {
    'use strict';

    angular
        .module('ringid.common.rg_friend_dropdown',['ringid.friend.friends_factory'])
        .filter('userListFilter', userListFilter)
        .directive('rgFriendDropdown', rgFriendDropdown);


        function userListFilter() {
                return function(items, name, tagItems) {
                    if (items) {
                        var filtered = [], tempu;
                        var nameMatch = new RegExp(name, 'i');
                        for (var i = 0; i < items.length; i++) {
                            if (filtered.length > 10)
                                return filtered;
                            tempu = items[i].value.getLiteUser();
                            if (nameMatch.test(tempu.getName()) && tagItems.indexOf(tempu) === -1) {
                                filtered.push(tempu);
                            }
                        }
                        return filtered;
                    }
                };
            }

    rgFriendDropdown.$inject = ['friendsFactory', '$filter'];
    function rgFriendDropdown(friendsFactory, $filter) {
        return {
            scope: {
                filterText: '=filterText',
                focusFilter: '=',
                onSelect: '&',
                onClose: '&',
                tagItems: '=',
            },
            templateUrl: function(elem,attrs) {
                  return attrs.templateUrl || 'pages/dropdowns/tag-friend-dropdown.html'
            },
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink(scope, iElement, iAttrs, controller) {
                        var sentRequest = false;
                        scope.users = [];
                        function setUser() {
                            scope.users = $filter('userListFilter')(friendsFactory.friends.all(), scope.filterText, scope.tagItems);
                            //scope.loading = !!scope.users.length;
                        }
                        function searchRequest() {
                            if (sentRequest)
                                return;
                            friendsFactory.searchContact({schPm: scope.filterText}, true).then(function(){
                                scope.$rgDigest();
                            });
                            scope.loading = true;
                            sentRequest = true;
                        }
                        scope.$watch(friendsFactory.friends.length, function(newValue, oldValue) {
                            setUser();
                            if (sentRequest) {
                                scope.loading = false;
                                sentRequest = false;
                            }
                        });

                        scope.$watch('filterText', function(newValue, oldValue) {
                            setUser();
                            
                            sentRequest = false
                            if (scope.users.length < 5 && oldValue.length < newValue.length) { // oldVal.length < newval.length is for making sure not to send request while backspacing
                                searchRequest();
                            }
                        });
                        scope.$watch('users.length', function(newval, oldVal) { // users is poped from users after selecting and no feed text is set so requesting for more contact
                            if (newval < 5 && newval < oldVal) {
                                if (scope.filterText.length > 0) {
                                    searchRequest();
                                } else {
                                    friendsFactory.getContactDetails();
                                }
                            }
                            if(newval > 5 && !sentRequest){
                              scope.loading = false;
                            }

                        });
                        scope.loading = !!scope.users.length;
                        scope.choose = function(item, event) {
                            scope.onSelect()(item, event);
                            setUser();
                             scope.$rgDigest();
                        }
                        scope.close = angular.isFunction(scope.onClose) ? scope.onClose() : angular.noop;
                        scope.processKeyup = function($event){
                             if($event.which === 13 && scope.users.length){
                                scope.choose(scope.users[0],$event);
                                scope.filterText = "";
                                scope.$rgDigest();
                             }
                        }
                        
                        scope.activeId = 0;
                        scope.setActiveId = function(i){
                          scope.activeId = i;
                        }
                       iElement.bind("keydown",function(e,keyCode){
                           if(keyCode=== 13){
                              scope.choose(scope.users[scope.activeId],e);
                           }else if(keyCode === 38){
                             scope.activeId = Math.max(scope.activeId - 1,0);
                           }else if(keyCode === 40){
                              scope.activeId = Math.min(scope.activeId+1,scope.users.length-1);
                           }
                           RingLogger.print("keup from dropdown : "+keyCode,'STSTAG');
                           scope.$rgDigest();
                       });
                       iElement.bind("mouseleave",function(){
                        scope.activeId = 0;
                       })
                    },
                    post: function postLink(scope, iElement, iAttrs, controller) {
                        iElement.on("click", function(event) {
                            event.stopPropagation();
                        });
                        scope.$rgDigest();

                    }
                }
            }
        }
    }


})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
            .module('ringid.common.rgeditor_directive', [])
            .directive('rgEditor', rgEditor);

    rgEditor.$inject = ['$rootScope', '$document','$compile','utilsFactory'];
    function rgEditor($rootScope, $document,$compile,utilsFactory) {

        /* Insert html node into editor*/
        function insertAtCaret(node, container) {

            var sel = window.getSelection();
            if (sel.getRangeAt && sel.rangeCount) {
                var range = sel.getRangeAt(0);
                if (range.endContainer != container && range.endContainer.parentElement != container && range.endContainer.firstElementChild != container) {
                    container.appendChild(node);
                    setCaretAtTheEnd(container);
                    return;
                }
                container.focus();
                range.deleteContents();
                range.insertNode(node);
                sel.removeAllRanges();
                range = document.createRange();
                range.collapse(true);
                range.setStartAfter(node);
                sel.addRange(range);

            } else {
                container.appendChild(node);
                setCaretAtTheEnd(container);
            }

        }

        function setCaretAtTheEnd(container) {
            var range, sel;
            container.focus();
            range = document.createRange();
            range.selectNodeContents(container);
            range.collapse(false);
            sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }
        function getCaretCharacterOffsetWithin(element) {
            var caretOffset = 0;
            var doc = element.ownerDocument || element.document;
            var win = doc.defaultView || doc.parentWindow;
            var sel;
            if (typeof win.getSelection != "undefined") {
                sel = win.getSelection();
                if (sel.rangeCount > 0) {
                    var range = win.getSelection().getRangeAt(0);
                    var preCaretRange = range.cloneRange();
                    preCaretRange.selectNodeContents(element);
                    preCaretRange.setEnd(range.endContainer, range.endOffset);
                    caretOffset = preCaretRange.toString().length;
                }
            } else if ( (sel = doc.selection) && sel.type != "Control") {
                var textRange = sel.createRange();
                var preCaretTextRange = doc.body.createTextRange();
                preCaretTextRange.moveToElementText(element);
                preCaretTextRange.setEndPoint("EndToEnd", textRange);
                caretOffset = preCaretTextRange.text.length;
            }
            return caretOffset;
        }
        function link(scope, element, attrs) {


            var editor_container = element.find('div'),
                    isError = false,
                    isDisabled = false,
                    disableTime = 0,
                    isClicked = false,
                    placeholder = element.find('span'),
                    currentTagObject,
                    DropdownFriendElement;
                    scope.filterFriend = "";
                    scope.editorContent = "";

           scope.placeholder = attrs['placeholder'];

           // ##DIGEST_DEBUG_START##
                    if(RingLogger.tags.DIGEST){
                        scope.$watch(function(){
                             RingLogger.info("from RgEditor",RingLogger.tags.DIGEST);
                        });
                    }
            // ##DIGEST_DEBUG_END##

           scope.updateContent = function () {
                var editorContent = editor_container.html().replace('class="feed_emo" ', '');
                editorContent = editorContent.replace('&lt;','<');
                editorContent = editorContent.replace('&gt;','>');
                editorContent = editorContent.replace(/<img\s(\S+)?\s?title="(\S+)"\s?(\S+)?>/gi, '$2');
                editorContent = editorContent.replace(/<\/p>/g, '<br>');
                editorContent = editorContent.replace(/<p>/g, '');
                editorContent = editorContent.replace(/<br>/g, '\n');
                editorContent = editorContent.replace(/&nbsp;/g, ' ');
                editorContent = editorContent.replace(/<a[^>]+data-link="([^"]+)[^>]+>([^<]+)<\/a>/g,function(match,$1,$2){
                    return '##'+$1+'##';
                });
                editorContent = editorContent.replace(/\u200B/g, '');
                scope.editorContent = editorContent.trim();

                if(scope.$parent && scope.$parent.$id !==1){
                    scope.$parent.$rgDigest();
                }else{
                    scope.$rgDigest();
                }

            }


            /* this is basically making editor empty when post a feed*/
            scope.$on('cleareditor', function () {
                $rootScope.unloadWarn = false;
                if (!attrs['editMode']) {
                    editor_container.html('');
                    setCaretAtTheEnd(editor_container[0]);
                }

            });

            scope.$on('seteditor', function () {
                editor_container.html(scope.editorContent);
            });



            /* It is a scope properties. It will make editor disabled from typing */
            scope.$watch('isDisabled', function (value) {
                if (isDisabled) {
                    editor_container.removeClass('disabled');
                    isDisabled = false;
                }
            });

            /*on focus*/
            if (attrs['focus']) {
                scope.$watch('focus', function (value) {
                    if (value) {
                        setTimeout(function () {
                            setCaretAtTheEnd(editor_container[0]);
                        }, 0);
                    }
                });

            }

            scope.insertEmoji = scope.$parent.insertEmoji = function(emoticon) {

                var img = document.createElement('img');
                img.src = emoticon.src();
                img.setAttribute('title', emoticon.symbol());
                insertAtCaret(img, editor_container[0]);
                scope.updateContent();
            }

          function editorKeyup($event) {
            RingLogger.print("keyup fired : "+keyCode,"STSTAG");
                $event.stopPropagation();
                var keyCode = $event.which || $event.keyCode || $event.key;


                if(attrs.tagFriend === "true"){
                    processAtTagFriend();
                }

                if (keyCode == 27 && attrs['onEscape']) {

                    $rootScope.unloadWarn = false;

                    if(DropdownFriendElement){closeDropdownFriend();return;}
                     scope.onEscape()();
                    return;
                }

                scope.updateContent();

                if(editor_container.html() == " " || editor_container.html() == '<br>' || editor_container.html() == '<p>' || editor_container.html() =='<p>&nbsp;</p>'){
                  editor_container.html('');
                  setCaretAtTheEnd(editor_container[0]);
                }

                if(editor_container.html() == ""){
                   $rootScope.unloadWarn = false;
                }
                else {
                  $rootScope.unloadWarn = false; // for now, will fix later
                }



            }

            scope.closeDropdownFriend = function(){
                if(DropdownFriendElement){
                        DropdownFriendElement.remove();
                        DropdownFriendElement = undefined;
                }
            }

            scope.chooseFriend = function(user, $event) {//user is user lite object
                var aEl,linkText,content,range;
                    if(currentTagObject && currentTagObject.word){

                        aEl = document.createElement('a');
                        aEl.innerHTML = user.getName();
                        aEl.title = user.getName();
                        aEl.href = '#';
                        aEl.setAttribute("data-link",user.getUtId());
                        aEl.setAttribute("contenteditable", "false");

                        linkText = document.createTextNode("\u200B");
                         var range = document.createRange();
                        range.selectNodeContents(editor_container[0]);
                        var sel = window.getSelection();
                        sel.removeAllRanges();
                        range.setStart(currentTagObject.range.startContainer,currentTagObject.stof);
                        range.setEnd(currentTagObject.range.endContainer,currentTagObject.endof);
                        sel.addRange(range);

                        insertAtCaret(aEl, editor_container[0]);
                        insertAtCaret(linkText, editor_container[0]);
                        //content = editor_container.html();
                        //content = content.slice(0,currentTagObject.startOffset) + content.slice(currentTagObject.endOffset);
                        //editor_container.html(content);
                        scope.closeDropdownFriend();
                        scope.updateContent();
                    }
             };


            function processAtTagFriend(){

                 scope.filterFriend = findAtCharWord(getCaretCharacterOffsetWithin(editor_container[0])).word
                 RingLogger.print("at tag friend called : "+scope.filterFriend,'STSTAG');
                if(scope.filterFriend === false && DropdownFriendElement){
                    scope.filterFriend = "";
                    scope.closeDropdownFriend();
                }
                if(scope.filterFriend && !DropdownFriendElement){
                    DropdownFriendElement = $compile('<rg-friend-dropdown template-url="pages/dropdowns/tag-editor-dropdown.html" tag-items="[]" filter-text="filterFriend" focus-filter="" on-close="closeDropdownFriend" on-select="chooseFriend"></rg-friend-dropdown>')(scope);
                        element.after(DropdownFriendElement);
                }
            }
            function findAtCharWord(offset){
                var space_counter=0,ch,returnValue = false,content=editor_container.html();
                    content = content.replace(/<a[^>]+>([^<]+)<\/a>/g, '$1');
                    content = content.replace(/<img[\w\W]+?\/?>/g, '');
                for(var i=offset-1;i>=0;i--){
                    ch = content[i];
                    if(/\s/.test(ch)){
                        space_counter++;
                    }
                    if(space_counter > 1){
                        break;
                    }
                    if(/@/.test(ch)){
                        if(i==0 || /\s/.test(content[i-1])){
                            returnValue = content.substr(i+1,(offset-1 -i));
                        }
                      break;
                    }

                }
                var range = window.getSelection().getRangeAt(0);
                    var offset = getCaretCharacterOffsetWithin(range.endContainer);


                currentTagObject = {word : returnValue,startOffset : i,endOffset : offset,range : range,stof : offset - (returnValue && (returnValue.length + 1)||0),endof : offset };
                return currentTagObject;
            }

            function editorContainerOnKeyDown(e){
                var keyCode = e.which || e.keyCode || e.key;
                 RingLogger.print("keydown fired : "+keyCode,"STSTAG");
                if(DropdownFriendElement){
                    if(keyCode === 38 || keyCode === 40){
                        e.preventDefault();e.stopPropagation();
                          DropdownFriendElement.triggerHandler(e,keyCode);
                        return;
                    }else if(keyCode === 13){
                        e.stopPropagation();e.preventDefault();
                        DropdownFriendElement.triggerHandler(e,keyCode);
                    }
                }
            }
             function editorContainerOnKeyPress(e) {
                e.stopPropagation();
                var keyCode = e.which || e.keyCode || e.key;
                // drop down friend skip processing for these keys
                RingLogger.print("kpress fired : "+keyCode,"STSTAG");


                if (isDisabled) {
                    var currentTime = new Date().getTime();
                    if ((currentTime - disableTime) > 3000) {
                        isDisabled = false;
                        editor_container.removeClass('disabled');
                    }
                    e.preventDefault();
                    return;
                }

                if (keyCode == 13) {
                    scope.editorContent = scope.editorContent.trim();
                    if (attrs['onEnter'] && (attrs['newLine'] != 'ctrl' || (!e.shiftKey && !e.ctrlKey))) {
                        e.preventDefault();

                        if (scope.editorContent == '') {
                            editor_container.addClass('error');
                            isError = true;
                            editor_container.html('');
                            setCaretAtTheEnd(editor_container[0]);
                            return;
                        }

                        if (scope.isDisabled) {
                            isDisabled = true;
                            disableTime = new Date().getTime();
                            editor_container.addClass('disabled');
                        }
                        scope.onEnter()(scope.onEnterArg);
                        if (!attrs['editMode']) {
                            editor_container.html('');
                            setCaretAtTheEnd(editor_container[0]);
                        }
                        $rootScope.unloadWarn = false;
                        return;
                    }

                    if (attrs['newLine'] == 'off') {
                        e.preventDefault();
                        return;
                    }
                    if (attrs['newLine'] == 'ctrl' && !e.shiftKey && !e.ctrlKey) {
                        e.preventDefault();
                        return;
                    }
                }

                /* error class in next keypress*/
                if (isError) {
                    editor_container.removeClass('error');
                    isError = false;
                }

            }

            /* Copy paste issue fixing*/
            function editorContainerOnPaste(e){
                e.stopPropagation();
                e.preventDefault();
                var text = '';
                if (e.clipboardData) {
                    text = e.clipboardData.getData('text/plain');
                }
                else if (window.clipboardData) {
                    try {
                        text = window.clipboardData.getData('Text');
                    } catch (e) {
                        console.log('clipboard copy error');
                    }
                }
                insertAtCaret(document.createTextNode(text), editor_container[0]);
                scope.updateContent();
            }

            function elementClickCallback(e) {
                e.stopImmediatePropagation();
                setCaretAtTheEnd(editor_container[0]);
            }
            function containerClickCallback(e) {
               e.stopPropagation();
            }

            scope.showEmoji = false;
            if (attrs['showEmoji']) {
                scope.showEmoji = true;
            }

            /* Initialise data in edit mode */
            if (attrs['editMode']) {
                editor_container.html(scope.editMode()().toString().replace(/<a(?![\w\W]+data-link)[^>]+>([^<]+?)<\/a>/ig, '$1'));
                scope.updateContent();
            }

            element.on('click',elementClickCallback);
            editor_container.on('click',containerClickCallback );
            editor_container.on('paste',editorContainerOnPaste);
            editor_container.on("keyup",editorKeyup);
            editor_container.on('keypress',editorContainerOnKeyPress);
            editor_container.on('keydown',editorContainerOnKeyDown);

            scope.$on("$destroy",function(){
                element.off("click",elementClickCallback);
                editor_container.off("click",containerClickCallback);
                editor_container.off('paste',editorContainerOnPaste);
                editor_container.off("keyup",editorKeyup);
                editor_container.off('keypress',editorContainerOnKeyPress);
                editor_container.on('keydown',editorContainerOnKeyDown);

                editor_container = null;
            });

        }

        return {
            scope: {
                editorContent: '=',
                onEnter: '&',
                onEscape: '&',
                onEnterArg: '=',
                isDisabled: '=',
                focus: '=',
                editMode: '&'
            },
            restrict: 'E',
            template: '<div placeholder="{{::placeholder}}" contenteditable="true" class="editor"></div><a ng-if="showEmoji" href="javascript:void(0)"><i class="icon-emoticon ico-sty" rg-emoticon="" clicked="insertEmoji" show-sticker="false"></i></a>',
           // template: '<span class="placeholder">{{placeholder}}</span><div placeholder="{{::placeholder}}" contenteditable="true" ng-keyup="editorKeyup($event)" class="editor"></div><a ng-if="showEmoji" href="javascript:void(0)"><i class="icon-emoticon ico-sty" rg-emoticon="" show-sticker="false"></i></a>',
            link: link
        }
    }
})();

/**
 * Copyright @ 2015 by RingID Inc.
 *
 */


(function () {
    'use strict';

    angular
        .module('ringid.common.emotion_directives', ['ringid.common.emotion_factory'])
        .directive('rgEmotion', rgEmotionDirective)
        .directive('rgEmotionDropdown', rgEmotionDropDOwn);

    rgEmotionDirective.$inject = ['$compile','$document','EmotionFactory'];
    function rgEmotionDirective($compile,$document,EmotionFactory) { // jshint ignore:line


        //function controllerFn($scope,$element){
        //
        //    var emotionDropdownElement;
        //    $scope.emotions = [];
        //    $scope.initEMotionList = function(){
        //        if(!emotionDropdownElement){
        //            emotionDropdownElement = $compile('<rg-emotion-dropdown filter-text='emotionFilterText' on-select='choose'></rg-emotion-dropdown>')($scope);
        //            $element.append(emotionDropdownElement);
        //        }
        //    };
        //    $scope.choose = function(subCat){
        //        $scope.emotions.length = 0;//note : now we only support one media at a limt
        //        $scope.emotions.push(subCat);
        //        $scope.showEmotion = false;
        //        $scope.emotionFilterText = '';
        //    };
        //
        //}
        return {
            restrict : 'A',
            scope : {
            //showWhen : '=',
                onSelect : '&'
            },
            //template : '',
            //controller : controllerFn,
            link : function(scope, element){
                var emotionDropdownElement;
                scope.active=false;
                scope.emotionFilterText = '';
                   function safeDigest(){
                        if(scope.$parent && scope.$parent.$id !==1){
                            scope.$parent.$rgDigest();
                        }else{
                            scope.$rgDigest();
                        }
                    }
                scope.initEMotionList = function(display){
                     EmotionFactory.init();
                    if(!emotionDropdownElement){
                        emotionDropdownElement = $compile('<rg-emotion-dropdown filter-text="emotionFilterText" focus-filter="active" on-close="close" on-select="choose"></rg-emotion-dropdown>')(scope);
                        element.after(emotionDropdownElement);
                        //emotionDropdownElement.css({
                        //    top : (event.pageY+10) +'px',
                        //    left : (event.pageX+10) + 'px'
                        //});
                    }

                    emotionDropdownElement.css('display',display);
                };
                scope.choose = function(subCat,$event){
                    scope.onSelect({item:subCat});
                    scope.emotionFilterText = '';
                    scope.initEMotionList('none',$event);
                    scope.active = false;
                    //document on lick will close the box so no need to close
                    safeDigest();
                };
               // scope.$watch('showWhen',function(newVal){
               //     var display = 'none';
               //     if(newVal){
               //         display = 'block';
               //         scope.initEMotionList(display);
               //     }
               //     //element.css('display',display);
               //});
                function showBox(event){
                    event.preventDefault();
                    //event.stopPropagation();
                    if(scope.active){
                        scope.initEMotionList('none',event);
                    }else{
                        scope.initEMotionList('block',event);
                    }
                    scope.active = !scope.active;
                    safeDigest();
                }
                element.on('click',showBox);
                function checkToHide(e){
                     if(e.target !== element[0] &&
                        e.target.parentNode &&
                        e.target.parentNode !== element[0] &&
                        e.target.parentNode.parentNode !== element[0] &&
                        e.target.className !== 'pt-top') {
                        scope.close(e);
                    }
                }
                $document.on('click',checkToHide);
                scope.close = function(event){
                    if(scope.active){
                        scope.initEMotionList('none',event);
                        scope.active = false;
                    }
                    safeDigest();
                };
                // ##DIGEST_DEBUG_START##
                      if(RingLogger.tags.DIGEST){
                          scope.$watch(function(){
                               RingLogger.info("from rgEmotionDir",RingLogger.tags.DIGEST);
                           });
                      }
                // ##DIGEST_DEBUG_END##
                scope.$on('$destroy',function(){
                    element.off('click',showBox);
                    $document.off('click',checkToHide);
                    emotionDropdownElement = undefined;
                });

            }
           // template : 'pages/common/emotion-dropdown.html'
        };
    }



    rgEmotionDropDOwn.$inject = ['EmotionFactory'];
    function rgEmotionDropDOwn(EmotionFactory){ // jshint ignore:line
        function bindClick(event){
            event.stopPropagation();
        }
        return {
            scope : {
                filterText: '=filterText',
                focusFilter : '=',
                onSelect : '&',
                onClose : '&onClose'
            },
            templateUrl : 'pages/dropdowns/emotion-dropdown.html',
            compile: function compile() {
                return {
                    pre: function preLink(scope) {
                        scope.emotions={};
                        scope.emotions[0] = EmotionFactory.getEmotions();
                        scope.setEmotion = function(emotions){
                            scope.emotions[0] = emotions;
                            scope.$rgDigest();
                        };
                        EmotionFactory.setScopeForDigest(scope);
                        scope.updateModel = function(e){
                            scope.filterText = e.target.value;
                            scope.$parent.$rgDigest();
                        }
                        scope.loading = !!scope.emotions.length;
                        scope.choose = angular.isFunction(scope.onSelect)? scope.onSelect() : angular.noop;
                        scope.close = angular.isFunction(scope.onClose)? scope.onClose() : angular.noop;
                        // scope.filterName = function(items) { //no use
                        //     var result = {};
                        //     angular.forEach(items, function(value, key) {
                        //         if (!value.hasOwnProperty('secId')) {
                        //             result[key] = value;
                        //         }
                        //     });
                        //     return result;
                        // }
                        // ##DIGEST_DEBUG_START##
                              if(RingLogger.tags.DIGEST){
                                  scope.$watch(function(){
                                       RingLogger.info("from rgEmotionDropdownDir",RingLogger.tags.DIGEST);
                                   });
                              }
                        // ##DIGEST_DEBUG_END##
                        scope.$on('$destroy',function () {
                            EmotionFactory.removeScope(scope);
                        });
                    },
                    post: function postLink(scope, iElement) {
                        iElement.on('click',bindClick);
                        scope.$on("$destroy",function(){
                            iElement.off("click",bindClick);
                        });
                        scope.$rgDigest();
                    }
                };
            }
        };
    }

})();


(function() {
	'use strict';

	angular
		.module('ringid.common.rghover_card_directive', [])
		.directive('rgHovercard', rgHovercard);

		rgHovercard.$inject = ['$ringhttp', '$templateCache','$compile','$window'];

		function rgHovercard($ringhttp, $templateCache,$compile,$window){
				var bodyEl = angular.element(document.querySelector('body'));
				return {
					scope : true,
					link: function($scope, iElm, iAttrs) {
						var hoverEl;
							function initiateHover(data){
									var mouseoutFlag = false,timer;
									function closeHoverELement(){
										//console.log("closed called");
										if(mouseoutFlag && hoverEl){
													hoverEl.off('mouseenter',hoverElementMouseEnter);
											    hoverEl.off('mouseleave',hoverElementMouseLeave);
													//hoverEl.css("display",'none');
                            hoverEl.remove();
                            hoverEl = undefined;
													//console.log("close done");
										}
									   mouseoutFlag = false;
									}
									function hoverElementMouseEnter(){
									//	console.log("hover element mouse enter");
										mouseoutFlag = false;
									}
									function hoverElementMouseLeave(){
										//console.log("hover element mouse leave");
										  mouseoutFlag = true;
											closeHoverELement();
									}
									function directiveElMouseEnter(e){
										  if(mouseoutFlag){
                          return;
                      }
											if(!hoverEl){
												hoverEl = angular.element('<div class="fr-menu"></div>');
												hoverEl.html(data);
												iElm.after(hoverEl);
											}
											if(iAttrs.onHoverStart && typeof $scope[iAttrs.onHoverStart] === 'function'){
													$scope[iAttrs.onHoverStart]();
											}

											$compile(hoverEl)($scope);
											//var rect = iElm[0].getBoundingClientRect();
											hoverEl.css({
												display : 'block'
												//left : rect.left +'px',
												//top : rect.bottom + 'px'
											});
											hoverEl.on('mouseleave',hoverElementMouseLeave);
											hoverEl.on('mouseenter',hoverElementMouseEnter);
											$scope.$rgDigest();
									}

									function directiveElMouseLeave(e){
											mouseoutFlag = true;
											window.setTimeout(closeHoverELement,500);
											//console.log("directive element mouse leave");
                      window.clearTimeout(timer);
                      timer = false;
                      iElm.off('mouseleave',directiveElMouseLeave);
									}
                  function initiate(e){
                      if(!timer){
                        timer = window.setTimeout(directiveElMouseEnter.bind(this,e),1200);
                      }
                      iElm.on("mouseleave",directiveElMouseLeave);
                  }
									iElm.on("mouseenter",initiate);
									
									$scope.$on('$destroy', function(){
										  directiveElMouseLeave();
											iElm.off('mouseenter',directiveElMouseEnter);
											iElm.off('mouseleave',directiveElMouseLeave);

									});
							}



							if(iAttrs.rgHovercard !== "false"){
                   $ringhttp.get(iAttrs.hoverTemplateUrl).success(function(result) {
                            initiateHover(result);
                  });
							}
							// ##DIGEST_DEBUG_START##
							      if(RingLogger.tags.DIGEST){
							          $scope.$watch(function(){
							               RingLogger.info("from rgHovercard",RingLogger.tags.DIGEST);
							           });
							      }
							// ##DIGEST_DEBUG_END##


					}
				}



		}


})();

(function() {
    'use strict';
    angular.module('ringid.common.rg_tag_friend', ['ringid.common.rg_friend_dropdown'])
            .directive('rgTagFriend', rgTagFriend);
            // .filter('userListFilter', userListFilter)
            // .directive('rgTagFriendDropdown', rgTagFriendDropdown);
        
        // function userListFilter() {
        //         return function(items, name, tagItems) {
        //             if (items) {
        //                 var filtered = [], tempu;
        //                 var nameMatch = new RegExp(name, 'i');
        //                 for (var i = 0; i < items.length; i++) {
        //                     if (filtered.length > 10)
        //                         return filtered;
        //                     tempu = items[i].value.getLiteUser();
        //                     if (nameMatch.test(tempu.getName()) && tagItems.indexOf(tempu) === -1) {
        //                         filtered.push(tempu);
        //                     }
        //                 }
        //                 return filtered;
        //             }
        //         };
        //     }
    rgTagFriend.$inject = ['$compile', '$document'];
    function rgTagFriend($compile, $document) {
      return {
            restrict : 'A',
            scope : {
                onSelect : '&',
                tagItems : '='
            },
            //template : '',
            //controller : controllerFn,
            link : function(scope,element,attr){
                  if(attr.rgTagFriend === "false"){
                    element.parent().remove();
                    return;
                  }
                var DropdownElement;
                scope.active=false;
                scope.filterText = "";
                scope.init = function(display, event) {
                    if (!DropdownElement) {
                        DropdownElement = $compile('<rg-friend-dropdown tag-items="tagItems" filter-text="filterText" focus-filter="active" on-close="close" on-select="choose"></rg-friend-dropdown>')(scope);
                        element.after(DropdownElement);
                        //DropdownElement.css({
                        //    top : (event.pageY+10) +'px',
                        //    left : (event.pageX+10) + 'px'
                        //});
                    }
                    scope.active = true;
                };
                scope.choose = function(subCat, $event) {
                    scope.onSelect({item: subCat});
                    if(scope.$parent && scope.$parent.$id !==1){
                        scope.$parent.$rgDigest();
                    }else{
                        $scope.$rgDigest();
                    }
                    // scope.FilterText = "";
                    //  scope.init("none",$event);
                    //scope.active = false;
                    //document on lick will close the box so no need to close
                };
                // scope.$watch('showWhen',function(newVal){
                //     var display = 'none';
                //     if(newVal){
                //         display = 'block';
                //         scope.init(display);
                //     }
                //     //element.css('display',display);
                //});
                
                function bindFn(event) {
                    event.preventDefault();
                    //event.stopPropagation();
                    if (scope.active) {
                        scope.close(event);
                        $document.off("click", bindDocumentClicktoControlClose);
                    } else {
                        scope.init(event);
                        $document.on("click", bindDocumentClicktoControlClose);
                    }

                }
                function bindDocumentClicktoControlClose (e) {
                    if (e.target != element[0] && e.target.parentNode != element[0] && e.target.parentNode !=null && e.target.parentNode.parentNode != element[0] && e.target.className != 'pt-top') {
                        scope.close(e);
                    }

                }
                element.on("click", bindFn);

                
                scope.close = function(event) {
                    if (scope.active) {
                        DropdownElement.remove();
                        DropdownElement = undefined;
                        scope.active = false;
                    }
                }
                // ##DIGEST_DEBUG_START##
                      if(RingLogger.tags.DIGEST){
                          scope.$watch(function(){
                               RingLogger.info("from rgTagFriendDirective",RingLogger.tags.DIGEST);
                           });
                      }
                // ##DIGEST_DEBUG_END##
                scope.$on("$destroy", function() {
                    element.off("click",bindFn);
                    $document.off("click",bindDocumentClicktoControlClose);
                    DropdownElement = undefined;
                });

            }
            // template : 'pages/common/emotion-dropdown.html'
        }
    }

})();

/*
 * © Ipvision
 */

angular.module('ringid.common.rg_column', [])
.directive('rgColumn', ['$document','Storage','utilsFactory',
    function ($document,Storage,utilsFactory) {
        return {
            restrict: "A",
            controller : ['utilsFactory','$scope','SystemEvents','$rootScope',function(utilsFactory,$scope,SystemEvents,$rootScope){
                $scope.spans = utilsFactory.feedColumn();
                $scope.defaultSpan = utilsFactory.getDefaultColumn();
                $scope.choose = function(val){

                    utilsFactory.resetScroll();
                    utilsFactory.animateScroll();    

                    utilsFactory.setFeedColumn(val);
                    $scope.spans = val;
                    $rootScope.$broadcast(SystemEvents.COMMON.COLUMN_CHANGED, val);
                };
                $scope.$watch(utilsFactory.feedColumn, function(newValue) {
                    $scope.spans = newValue;
                    $rootScope.$broadcast(SystemEvents.COMMON.COLUMN_CHANGED, newValue);
                });
                $scope.$on(SystemEvents.COMMON.WINDOW_RESIZED,function(){
                    $scope.defaultSpan = utilsFactory.getDefaultColumn();
                });

            }],//l-act
            template : '<span></span>\
                        <span></span>\
                        <span></span>\
                        <div class="col-area">\
                        <div class="col-area-wrapper">\
                            <div data-tooltip-post="3 Column" ng-click="choose(3)" class="list-ico width-26" ng-if="defaultSpan > 2" ng-class="{\'list-act\' : spans == 3 }">\
                                <span></span>\
                                <span></span>\
                                <span></span>\
                            </div>\
                            <div data-tooltip-post="2 Column" ng-click="choose(2)" class="list-ico width-17" ng-if="defaultSpan > 1" ng-class="{\'list-act\' : spans == 2 }">\
                                <span></span>\
                                <span></span>\
                            </div>\
                            <div data-tooltip-post="1 Column" ng-click="choose(1)" class="list-ico width-9" ng-class="{\'list-act\' : spans == 1 }">\
                                <span></span>\
                            </div>\
                            </div>\
                        </div>',
            link: function (scope, element, attrs, ctrls) {
                var dropEl;


                function bindFn(event) {
                    event.preventDefault();
                    if(!dropEl){
                        dropEl = angular.element(element.find('div')[0]);
                        $document.on("click", bindDocumentClicktoControlClose);
                    }
                    dropEl.toggleClass('colshow');
                }
                function bindDocumentClicktoControlClose (e) {
                    if (e.target != element[0] && e.target.parentNode != element[0] && e.target.parentNode !=null && e.target.parentNode.parentNode != element[0] && e.target.className != 'pt-top') {
                        closeColumnSelector(e);
                    }

                }
                element.on("click", bindFn);

                function closeColumnSelector (event) {
                    dropEl.removeClass('colshow');
                }

                scope.$on("$destroy", function() {
                    element.off("click",bindFn);
                    $document.off("click",bindDocumentClicktoControlClose);
                    dropEl = undefined;
                });

            }
        };
    }
]);

(function() {
    'use strict';

    angular
        .module('ringid.common.rgsrc_directive', [])
        .directive('rgSrc', rgSrc);

    function rgSrc(){ //jshint ignore:line
        return {
            restrict : 'A',
            link : function(scope,element,attr){
                if(attr.rgSrc){
                    scope.$watch(attr.rgSrc, function(newValue) {
                        if (newValue === null || newValue === undefined) {
                            element.removeAttr('src');
                        } else {
                            element.attr('src', newValue);
                        }
                    });
                }
            }
        };
    }

    })();

/**
 * © Ipvision
 */

(function () {
    'use strict';

    angular.module('ringid.common.rgrepeat_directive', [])
    .directive('rgRepeat', rgRepeat);

    rgRepeat.$inject = ['$parse', '$rootScope', '$animate','SystemEvents'];

    function rgRepeat($parse, $rootScope, $animate, SystemEvents) {

        function compile(element, attr) {


            return function ($scope, $element, $attr, ctrl, $transclude) {

                var expression = $attr.rgRepeat;
                var match = expression.match(/^\s*(.+)\s+in\s+(.*?)\s+track\s+by\s+(.+)\s*$/),
                    index, lhs, rhs, trackByExp, valueIdentifier, cell, cells = [],
                    lastBlockMap = Object.create(null);

                if (!match) {
                    throw "Expected expression in form of '_item_ in _collection track by _key_'";
                }
                
                var rgRepeatEndComment = document.createComment(' end rgRepeat: ' + expression + ' ');

                lhs = match[1];
                rhs = match[2];

                /* find getter function by parsing track by*/
                var getTrackID = $parse(match[3]);

                valueIdentifier = match[1];
                
                $scope.$watchCollection(rhs, update);

                function update(collection) {

                    var index, i, length = collection.length,
                        value, childScope, cellIndex, trackID, block, getterLocals, prevNode = $element[0],
                        nextNode, nextBlockMap = Object.create(null), parent, clone, temp;
                        
                        
                        $rootScope.$$postDigest(function() {
                         	 var index, value, block;
                         	 
                 	   		 for (index = 0; index < collection.length; index++) {
                       			value = collection[index];
                       			if(!lastBlockMap[value.$TrackID]) continue;
                       			block = lastBlockMap[value.$TrackID];
                 	     		if(block.childHead) block.scope.$$childHead = block.childHead;
                 	      	 }
                         }); 

                    /* Find next Blocks that are going to added*/
                    for (index = 0; index < length; index++) {
                    
                        value = collection[index];
                        getterLocals = {};
                        getterLocals[valueIdentifier] = value;
                        trackID = getTrackID($scope, getterLocals);
                    
                        if (lastBlockMap[trackID]) {
                            block = lastBlockMap[trackID];
                            /* found it and it is going to be processed in next blockmap so deleted it from last block map */
                            delete lastBlockMap[trackID];
                        } 
                        else {
                        
                            childScope = $scope.$new();
                            childScope[valueIdentifier] = value;
                            block = {};
                            block.clone = null;
                            block.scope = childScope;
                        }

                        collection[index]['$TrackID'] = trackID;
                        nextBlockMap[trackID] = block;
                    }
                    
                    /* Remove blocks from existing which are not going to process*/
                    for (trackID in lastBlockMap) {
                        if (lastBlockMap[trackID]) {

                            block = lastBlockMap[trackID];
                            for (i = 0; i < block.clone.length; i++) {
                                prevNode.parentNode.removeChild(block.clone[i]);
                            }
                            block.scope.$destroy();
                        }
                    }

                    /* Build DOM now*/
                    for (index = 0; index < length; index++) {

                        value = collection[index];
                        trackID = value['$TrackID'];
                        block = nextBlockMap[trackID];
                        block.scope.$index = index;
                        clone = block.clone;

                        if (clone) {
                        
                            nextNode = prevNode;
                            
                            if (block.startNode != nextNode) {
                                $animate.move(block.clone, null, angular.element(prevNode));
                            }
                            
                            prevNode = block.clone[block.clone.length-1];
                            
                            block.childHead = block.scope.$$childHead;
                            block.scope.$$childHead = null;
                            
                        } 
                        else {

                            $transclude(block.scope, function rgRepeatTransclude(clone) {
                                
                                var endNode = rgRepeatEndComment.cloneNode(false);  
                                clone[clone.length++] = endNode;
                                $animate.enter(clone, null, angular.element(prevNode));
                                prevNode = endNode;
                               
                                block.clone = clone;
                                block.startNode = clone[0];
                            });
                        }
                        
                   }
                   
                   /*broadcast feed-height change*/
                   if($scope.target && $scope.target.getMapKey) {
                      $scope.$emit(SystemEvents.FEED.HEIGHT, $scope.target.getMapKey());
                   }
                   
                    /* Updating last blockmap from current block map*/
                    lastBlockMap = nextBlockMap;
                }
            }
        }

        return {
            restrict: 'A',
            transclude: 'element',
            priority: 1000,
            terminal: true,
            compile: compile
        };
    }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
            .module('ringid.common.directives', [
                'ringid.common.rgfocus_directive',
                'ringid.common.rgsearch_directive',
                'ringid.common.rgdropdown_directive',
                'ringid.common.rgscrollbar_directive',
                'ringid.common.rground_progress_directive',
                'ringid.common.rginvite_directive',
                'ringid.common.rgemoticon_directive',
                'ringid.common.rgclick_directive',
                'ringid.common.rgimg_directive',
                'ringid.common.rgupload_directive',
                'ringid.common.rgphotos_directive',
                'ringid.common.rg_friend_dropdown',
                'ringid.common.rgeditor_directive',
     //           'ringid.common.rgselectoption_directive',

                'ringid.common.rghref_directive',
                'ringid.common.rgslider_directive',
                'ringid.common.emotion_directives',
                'ringid.common.rghover_card_directive',
                'ringid.common.rg_tag_friend',
                'ringid.common.rgplayer_directive',
                'ringid.common.rgrepeat_directive',
                'ringid.common.rg_column',
                'ringid.common.rgsrc_directive',
                'ringid.common.rgloading_directive',
                'ringid.common.rgRecorder'
            ]);
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.profile.http_service', ['ringid.config'])
        .service('profileHttpService', profileHttpService);

    profileHttpService.$inject = [ '$$connector','OPERATION_TYPES', 'utilsFactory'];
    function profileHttpService( $$connector, OPERATION_TYPES, utilsFactory) { //jshint ignore:line
        var self = this, //jshint ignore:line
            OTYPES = OPERATION_TYPES.SYSTEM.PROFILE,
            REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;


        /**
         * @api {request} /APIREQUEST/21 Get profile info
         * @apiVersion 0.1.0
         * @apiDescription Profile INfo for logged in user.
         * @apiName GetProfileInfo
         * @apiGroup Profile
         *
         * @apiParam {Number=21} actn action constant for this api call
         *
         *
         * @apiSuccess {Number=21} actn action constant for this api call
         * @apiSuccess {Number} bDay  timestamp
         * @apiSuccess {Number} mDay  timestamp
         * @apiSuccess {Number} cIm cover image
         * @apiSuccess {Number} cImId cover image id
         * @apiSuccess {string} cc current city
         * @apiSuccess {string} cnty country
         * @apiSuccess {string} fn Fullname
         * @apiSuccess {string} gr gender
         * @apiSuccess {string} prIm Profile Image
         * @apiSuccess {string} hc home city
         * @apiSuccess {array} pvc Privacy setting
         * @apiSuccess {Boolean} sucs Request successfully processed or not
         * @apiSuccess {Number} uId User Id
         *
         *
         *
         *
         *
         * @apiSuccessExample Success-Response:
         *     HTTP/1.1 200 OK
         *     {
            *       acId: 0,
            *       actn: 111,
            *       cmnId: 0,
            *       headerLength: 62,
            *       imgId: 0,
            *       loc: 0,
            *       nList: [
            *           0: {
            *               acId: 0,
            *               cmnId: 0,
            *               fndId: "2000002368",
            *               fndN: "Wasif Islam",
            *               id: 368516,
            *               imgId: 14628,
            *               loc: 0mt: 1,
            *               nfId: 16103,
            *               nt: 5,
            *               ut: 1433832601723
            *           }
            *       ],
            *       nfId: 0,
            *       pckFs: 257739,
            *       pckId: "250085192336",
            *       scl: 1,
            *       seq: "4/7",
            *       sucs: true,
            *       tn: 32,
            *       tr: 32
            *     }
         *
         * @apiError Notification list not found
         *
         * @apiErrorExample Error-Response:
         *     HTTP/1.1 404 Not Found
         *     {
            *       "sucs": false
            *     }
         */


        // dependonUtId
        self.basicAndPrivacy = function (utId,iscurrent) {
            var payload;
            if (!iscurrent) {
                payload = {
                    actn: OTYPES.TYPE_ACTION_OTHER_USER_BASICINFO,
                    utId: utId
                };
            } else {
                payload = {
                    actn : OTYPES.TYPE_ACTION_CURRENT_USER_BASICINFO
                };
            }

            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.getUserDetails = function (obj,withMutualFriendCount) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_GET_USER_DETAILS,//204
                wmfc : !!withMutualFriendCount
            };
            angular.extend(payload, obj);

            return $$connector.request(payload, REQTYPE.REQUEST, true);// flooding true
        };


        /**
        * @api {request} /APIREQUEST/136 Check Presence of user
        * @apiVersion 0.1.0
        * @apiDescription Check Presence(i.e. online, away, offline ) of user/users
        * @apiName FriendPresence
        * @apiGroup Friends
        *
        * @apiParam {Number=136} actn
        * @apiParam {Number[]} uIds
        */
        self.fetchPresence = function(uIds) {
            var payload = {
                actn: OTYPES.ACTION_USERS_PRESENCE_DETAILS,
                uIds: uIds
            };
            return $$connector.send(payload, REQTYPE.REQUEST);
        };

        self.fetchPresenceAndMood = function(fndId) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_USER_MOOD_PRESENCE,
                fndId: fndId
            };
            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.changeMood = function(mood){
            var payload = {
                actn: OTYPES.TYPE_ACTION_USER_MOOD,
                mood: mood
            };
            return $$connector.request(payload, REQTYPE.AUTHENTICATION);
        };

        self.getMutualFriends = function(friendId) {
            var payload = {
                actn: OTYPES.FETCH_FRIEND_MUTUAL_FRIEND_LIST,
                uId: friendId
            };

            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        //requesting other users profile data
        //dependonUtId
        self.getUserProfileData =function(utId) {
            var payload;
            if(utId){
                payload = {
                    actn:OTYPES.TYPE_ACTION_LIST_WORK_AND_EDUCATIONS,//230 :Work-education-skill list
                    utId:utId
                };
            }else{
                payload = {
                    actn:OTYPES.TYPE_ACTION_LIST_WORK_AND_EDUCATIONS//230 :Work-education-skill list
                };
            }
            return $$connector.send(payload, REQTYPE.REQUEST);

        };


        self.updateProfile = function (userId,obj,dateObj,mobj) {

            if(mobj!==1){
                mobj = mobj.getTime();
            }
            var payload = {
                actn: OTYPES.TYPE_ACTION_MODIFY_USER_PROFILE,
                //gr: obj.gr,
                nOfHd: 7,
                fn: obj.fn.utf8Encode(),
                hc: obj.hc ? obj.hc.utf8Encode() : ' ',
                cc: obj.cc ? obj.cc.utf8Encode() : ' ',
                gr: obj.gr,
                am: obj.am.utf8Encode(),
                bDay: dateObj ? dateObj.getTime() : 1,
                mDay: mobj
            };
            return $$connector.request(payload, REQTYPE.UPDATE);

        };


        self.updateProfilePrivacy = function () {
            var payload = {
                actn: OTYPES.TYPE_ACTION_MODIFY_PRIVACY_SETTINGS,
                pvc:[
                    3,3,3,3,3
                ]
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        //self.frndSuggestion = function(obj){
            //var payload = {
                //actn:OTYPES.ACTION_UPDATE_LOGIN_SETTINGS,
                //sn:obj.sn,
                //sv:obj.sv
            //};
            //return $$connector.request(obj, REQTYPE.REQUEST);
        //};

        self.submitNewEducation = function(obj) {

            var payload = {
                actn: OTYPES.TYPE_ACTION_ADD_EDUCATION,
                request_type:REQTYPE.UPDATE,
                edu : {
                    af : 1,
                    cntn : obj.cntn? obj.cntn.utf8Encode() : '',
                    desc : obj.desc ? obj.desc.utf8Encode() : '',
                    dgr :  obj.dgr ? obj.dgr.utf8Encode() : '',
                    grtd : obj.grtd,
                    iss : obj.iss,
                    scl : obj.scl.utf8Encode(),
                    ft : obj.ft ? obj.ft : 1,
                    tt : obj.tt ? obj.tt : 1,
                    ut : 0
                }
            };
            return $$connector.request(payload, REQTYPE.UPDATE);

        };

        self.deleteEducation = function(id) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_REMOVE_EDUCATION,
                id : id
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.updateEducationById = function (obj) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_UPDATE_EDUCATION,
                edu:{
                    id: obj.id,
                    scl: obj.scl.utf8Encode(),
                    ft: obj.ft ? obj.ft : 1,
                    tt: obj.tt ? obj.tt : 1,
                    desc: obj.desc ? obj.desc.utf8Encode() : "",
                    af: obj.af,
                    grtd: obj.grtd,
                    iss: obj.iss,
                    cntn: obj.cntn ? obj.cntn.utf8Encode() : "",
                    dgr: obj.dgr ? obj.dgr.utf8Encode() : ""
                }
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.getAllSkill = function() {
            var payload = {
                actn: 230
            };
            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.submitNewSkill = function(obj) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_ADD_SKILL,
                skill:
                {
                    skl : obj.skl.utf8Encode(),
                    desc: obj.desc.utf8Encode()
                }
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.updateSkill = function(obj) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_UPDATE_SKILL,
                skill:{
                    id  : obj.id,
                    skl : obj.skl.utf8Encode(),
                    desc: obj.desc.utf8Encode()
                }

            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.deleteSkill = function(sid) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_REMOVE_SKILL,
                id  : sid
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };


        self.submitNewWork = function(obj) {
            var payload = {
                actn     : OTYPES.TYPE_ACTION_ADD_WORK,
                request_type:REQTYPE.UPDATE,
                wrk      :{
                    pstn  :obj.pstn ? obj.pstn.utf8Encode() : '',
                    desc  :obj.desc ? obj.desc.utf8Encode() :'',
                    //ct    :obj.ct ? obj.ct.utf8Encode() :'',
                    cnm   :obj.cnm.utf8Encode(),
                    tt    :obj.tt || 1,
                    ft    :obj.ft || 1
                }
            };
            return $$connector.request(payload, REQTYPE.UPDATE);

        };

        self.updateWork = function (obj) {
            var payload = {
                actn     : OTYPES.TYPE_ACTION_UPDATE_WORK,
                wrk:{
                    id       : obj.id,
                    pstn     : obj.pstn.utf8Encode(),
                    cnm      : obj.cnm.utf8Encode(),
                    desc     : obj.desc.utf8Encode(),
                    //ct       : obj.ct.utf8Encode(),
                    tt       :obj.tt || 1,
                    ft       :obj.ft || 1
                }

            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.deleteWork = function (workid) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_REMOVE_WORK,
                id  : workid
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.changeProfilePicture = function(obj) {
            var payload = {
                    actn: OTYPES.TYPE_CHANGE_PROFILE_PIC,
                    type: 1,
                    imT: 2,
                    pimX : obj.pimX,
                    pimY : obj.pimY,
                    ih: obj.ih,
                    iw: obj.iw,
                    iurl: obj.iurl,
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.changeCoverPicture = function(obj) {
            var payload = {
                    actn: OTYPES.TYPE_CHANGE_COVER_PIC, // 103
                    type: 1,
                    imT: 3,
                    cimX : obj.cimX,
                    cimY : obj.cimY,
                    ih: obj.ih,
                    iw: obj.iw,
                    iurl: obj.iurl
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };


        self.removeProfilePicture = function (prIm) {
            var payload  = {
                actn: OTYPES.TYPE_REMOVE_PROFILE_IMAGE,
                prIm: prIm
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.removeCoverPicture = function (cIm) {
            var payload = {
                actn: OTYPES.TYPE_REMOVE_COVER_IMAGE,
                cIm: cIm
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.changePassword = function (oldPass,newPass) {
            var payload = {
                actn: OTYPES.CHANGE_PASSWORD,
                oPw:oldPass,
                nPw:newPass
            };
            return $$connector.request(payload, REQTYPE.UPDATE);

        };

        self.sendCode = function(obj){
            var payload = {
                actn: OTYPES.SEND_VERIFICATION_CODE_TO_MAIL,//221
                el: obj.email
            };

            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.sendCodeToPhn = function(obj){
            var payload = {
                actn: OTYPES.SEND_VERIFICATION_CODE_TO_PHONE,//212,
                mbl : obj.phone,
                mblDc :obj.countryCode
            };
            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.verifyCode = function (obj) {
            var payload = {
                actn:OTYPES.SEND_VERIFICATION_CODE_TO_MAIL,//221,
                el:obj.email,
                vc:obj.code
            };
            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.verifyPhnCode = function (obj) {
            var payload = {
                actn:OTYPES.SEND_VERIFICATION_CODE_TO_PHONE,//212,
                uId: obj.uId,
                mbl: obj.phone,
                mblDc:obj.mblDc,
                vc:obj.code
            };
            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.verifyCheck = function(){
            var payload = {
                actn:OTYPES.PHN_MAIL_VERIFICATION_CHECK//28
            };
            return $$connector.request(payload, REQTYPE.REQUEST);
        };


        self.changePrivacy = function(obj) {
            var payload = {
                actn: obj.utId,
                sn:obj.sn,
                sv:obj.sv
            };

            if (obj.hasOwnProperty('utId')) {
                payload.utId = obj.utId;
            }
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.saveCallPvcEdit = function (obj) {
            var payload = {
                actn:obj.actn,
                sn:obj.sn,
                sv:obj.sv
            };
            if(!obj.isCurrent){
                payload.utId = obj.utId;
            }
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.saveChatPvcEdit = function (obj) {
            var payload = {
                actn:obj.actn,
                sn:obj.sn,
                sv:obj.sv
            };
            if(!obj.isCurrent){
                payload.utId = obj.utId;
            }
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.saveFeedPvcEdit = function (obj) {
            var payload = {
                actn:obj.actn,
                sn:obj.sn,
                sv:obj.sv
            };
            if(!obj.isCurrent){
                payload.utId = obj.utId;
            }
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.addSocialAccount = function(obj) {
            var payload = {
                actn: OTYPES.ADD_SOCIAL_NETWORK,
                it : obj.access_token,
                smid: obj.id,
                wk: utilsFactory.getUniqueID() // webserver dependency
            };

            if (obj.platform === 'facebook') {
                payload.smt = 4;
            } else if (obj.platform === 'twitter') {
                payload.smt = 5;
            }

            return $$connector.request(payload, REQTYPE.AUTHENTICATION);

        };

        self.saveAchatSetting = function (obj) {
            var payload = {
                actn:OTYPES.TYPE_CHANGE_PRIVACY,
                sn:obj.sn,
                sv:obj.sv
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

    }
})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.profile', [
            'ringid.auth',
            'ringid.profile.http_service',
            'ringid.common.user_factory',
			'ringid.friend.friends_factory',
            'ringid.media',
			'ui.bootstrap',
            'ringid.common.services',
			'angular-svg-round-progress'
		]);
})();


/**
 * Copyright 2015 by RingID Inc.
 *
 */


(function () {
    'use strict';

    angular.module("ringid.profile")
            .directive('rgImgReposition', rgImgReposition);

    rgImgReposition.$inject = ['imageQuality', 'fileUploadService', '$document', 'APP_CONSTANTS', 'Ringalert'];
    function rgImgReposition(imageQuality, fileUploadService, $document, APP_CONSTANTS, Ringalert) {

        // Helper function to guarantee a value between low and hi unless bool is false
        var limit = function (low, hi, value, bool) {
            //console.log('low: ' + low + ' hi: ' + hi+ ' value: ' + value);
            if (arguments.length === 3 || bool) {
                if (value < low) {
                    return low;
                }
                if (value > hi) {
                    return hi;
                }
            }
            return value;
        };


        function linkFunc(scope, element, attrs) {
            var elementWidth = element[0].clientWidth,
                elementHeight = element[0].clientHeight,
                cropWidth = (scope.imgType === 'profilephoto') ? APP_CONSTANTS.PROFILE_PIC_CROP_WIDTH : APP_CONSTANTS.COVER_PIC_CROP_WIDTH,
                cropHeight = (scope.imgType === 'profilephoto')? APP_CONSTANTS.PROFILE_PIC_CROP_WIDTH : APP_CONSTANTS.COVER_PIC_CROP_HEIGHT,
                cropToImageRatio = 1,
                bgSrc = '',
                xPos,
                yPos,
                x0,
                y0,
                repositionScale = 1,
                calculate = false,
                options = {"bound": true},
                imageDimensions = {
                    width: 0,
                    height: 0
                };

            scope.selectFromAlbum = fileUploadService.selectFromAlbum;



            if (scope.imgType === 'coverphoto') {
                var adjustedHeight = Math.ceil(
                    ( (APP_CONSTANTS.COVER_PIC_CROP_HEIGHT * elementWidth ) / APP_CONSTANTS.COVER_PIC_CROP_WIDTH )
                                              );
                scope.elemStyle.height =  adjustedHeight + "px";
                elementHeight = adjustedHeight;
            }



            scope.$watch('enabled', function(newVal, oldVal){
                if (newVal) {
                    if (scope.repositionExisting) { // put existing image in file upload queue
                        imageQuality.resizeImage(
                            (scope.elemStyle.backgroundImage.match(/^url\(['"]?(.*?)['"]?\)$/i) || [])[1],
                            scope.imgType
                        ).then(function() {
                            checkImageDimensions(); // initialize image dimension
                        });
                    } else {
                        checkImageDimensions(); // initialize image dimension

                    }

                } else {
                    toggleReposition(false);
                }
            });


            function toggleReposition(enable) {
                if (enable || scope.enabled) {
                    RingLogger.information('ENABLE REPOSITION', RingLogger.tags.PROFILE);
                    element.bind('mousedown', mouseDown);
                    element.bind('mouseup', mouseUp);
                } else {
                    RingLogger.information('DISABLE REPOSITION', RingLogger.tags.PROFILE);
                    element.unbind('mousedown', mouseDown);
                    element.unbind('mouseup', mouseUp);
                }
                scope.$rgDigest();
            }

            function mouseDown(e) {
                //console.log('MOUSE DOWN');
                if (scope.enabled) {
                    if (e.which === 1) {
                        x0 = e.clientX;
                        y0 = e.clientY;
                        calculate = true;
                    }
                    //angular.element($document).bind('mousemove', mouseMove);
                    element.bind('mousemove', mouseMove);
                }
            }

            function mouseMove(e) {
                var pos, x, y;
                //console.log('MOUSE MOVE');
                if (scope.enabled && calculate) {
                    pos = scope.elemStyle.backgroundPosition.match(/(-?\d+).*?\s(-?\d+)/) || [];
                    x = e.clientX;
                    y = e.clientY;
                    xPos = parseInt(pos[1]) || 0;
                    yPos = parseInt(pos[2]) || 0;

                    xPos = limit(elementWidth - imageDimensions.width, 0, xPos + x - x0, options.bound);
                    yPos = limit(elementHeight - imageDimensions.height, 0, yPos + y - y0, options.bound);

                    element.css({
                        'backgroundPosition': xPos + 'px ' + yPos + 'px'
                    });
                }
            }

            function mouseUp(e) {
                //console.log('MOUSE UP');
//                e.stopPropagation();
                if (scope.enabled && calculate) {
                    if (xPos !== undefined && yPos !== undefined) {
                        scope.elemStyle.backgroundPosition = xPos + 'px ' + yPos + 'px';
                        // reset position with respect to original image dimensions;
                        //xPos = xPos / scale;
                        //yPos = yPos / scale;
                        // set x,y and imh, imw in fileuploader service
                        console.log('%c: ' + 'yPos: ' + yPos + ' xpos: ' + xPos, 'color:red');
                        console.log('%c: ' + 'REPOSITION SCALE: ' + repositionScale, 'color:red');
                        fileUploadService.setReposition({
                            cimX: Math.ceil( Math.abs(xPos) / repositionScale) || 0,
                            cimY: Math.ceil( Math.abs(yPos) / repositionScale ) || 0,
                        }, scope.imgType);
                    }

                    // reset reposition
                    calculate = false;
                    xPos = undefined;
                    yPos = undefined;

                    element.unbind('mousemove', mouseMove);
                }

            }


            var checkImageDimensions = function () {

                var src = scope.elemStyle.backgroundImage;
                bgSrc = (src.match(/^url\(['"]?(.*?)['"]?\)$/i) || [])[1];

                if (!bgSrc) {
                    return;
                }

                var image = new Image();
                image.onload = setDimensions;
                image.src = bgSrc;
            };



            function setDimensions() {
                // disable resize progress show
                scope.toggleResizeShow()(scope.imgType, false);
                var self = this;
                imageDimensions.width = self.width;
                imageDimensions.height = self.height;

                // set width to elementWidth and adjust height
                if ( (imageDimensions.width / cropWidth) <= (imageDimensions.height / cropHeight) ) {
                //if ( Math.abs(elementWidth - imageDimensions.width) < Math.abs(elementHeight - imageDimensions.height) ) {
                    repositionScale = elementWidth / imageDimensions.width;
                    imageDimensions.width = elementWidth;
                    imageDimensions.height = Math.floor(imageDimensions.height * repositionScale);


                    cropToImageRatio = self.width / cropWidth;
                    fileUploadService.setReposition({
                        iw: Math.ceil(self.width),
                        ih: Math.ceil(cropHeight * cropToImageRatio)
                        //scale: repositionScale
                    }, scope.imgType);
                } else {   // set height to elementheight and adjust width
                    repositionScale = elementHeight / imageDimensions.height;
                    imageDimensions.height = elementHeight;
                    imageDimensions.width = Math.floor(imageDimensions.width * repositionScale);

                    cropToImageRatio = self.height / cropHeight;
                    fileUploadService.setReposition({
                        ih: Math.ceil(self.height),
                        iw: Math.ceil(cropWidth * cropToImageRatio)
                        //scale: repositionScale
                    }, scope.imgType);
                }

                // bind events and remove loadder class
                toggleReposition(true);
                //angular.element(element).removeClass('p-loader');
                console.log('repositionScale: ' + repositionScale);
                console.log('elementW: ' + elementWidth + ' elementH: ' + elementHeight);
                console.log('cropMinW: ' + cropWidth + ' cropMinH: ' + cropHeight);
                console.log('imageW: ' + imageDimensions.width + ' imageH: ' + imageDimensions.height );
            }



        }

        return {
            restrict: 'A',
            replace: false,
            scope: {
                elemStyle: "=",
                enabled: "=",
                imgType: "@",
                repositionExisting: '=',
                toggleResizeShow: '&'
            },
            link: linkFunc
        };
    }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfile', rgProfile);


        function rgProfile()  {

            ProfileController.$inject = ['$ringbox', '$scope', 'Notification', 'Storage', 'friendsFactory', '$routeParams', 'Auth', 'profileFactory', 'fileUploadService',
                'imageQuality', 'ImageFactory', 'SystemEvents', 'utilsFactory', 'Ringalert', 'languageConstant', '$rootScope'];
            function ProfileController ($ringbox, $scope, Notification, Storage, friendsFactory, $routeParams, Auth, profileFactory, fileUploadService,
                                          imageQuality, ImageFactory, SystemEvents, utilsFactory, Ringalert, languageConstant, $rootScope) {
                /* INITIALIZATION */
                var uId =  $routeParams.uId,
                    newCoverpic,
                    newPropic;

                $scope.isOwner = Auth.currentUser().getKey() === uId ? true : false;

                $scope.consType = languageConstant.get();

                $scope.profilePicDragEnable = false;
                $scope.coverPicDragEnable = false;

                $scope.processing = false;

                $scope.profileDdControl = {
                    showOnHover : true,
                    enableCoverReposition: true,
                    enableProfileReposition: true
                };
                $scope.showCoverDD = false; // show or hide cover setting dropdown
                $scope.coverPhotoStyle = {
                    "backgroundSize": "cover"
                };
                $scope.profilePhotoStyle = {
                    "backgroundSize": "cover"
                };

                $scope.link = utilsFactory.getRingRoute('USER_PROFILE', { uId : uId});


                if ($routeParams.subpage === undefined) {
                    $scope.subPage = 'post';
                } else {
                    $scope.subPage = $routeParams.subpage;
                    if ($scope.subPage === 'about') {
                        $scope.activeNav = 'basic';
                    }
                }
                $scope.subPageLink = 'pages/profile/profile.' + $scope.subPage + '.html';

                $scope.profileObj = profileFactory.getProfile(uId);
                RingLogger.warning('got user utid: ' + $scope.profileObj.getUtId(), RingLogger.tags.PROFILE);

                // get profile details
                profileFactory.init($scope.profileObj).then(function() {
                    updateStyle('coverphoto');
                    updateStyle('profilephoto');

                });


                var updateStyle = function(type) {
                    if (type === 'profilephoto') {
                        $scope.profilePhotoStyle.backgroundImage = "url(" + $scope.profileObj.avatar('thumb')  + ")";
                        $scope.profilePhotoStyle.backgroundPosition = '50% 50%';
                        if($scope.profilePhotoStyle.backgroundImage.indexOf('prof.png') > -1) {
                            $scope.profileDdControl.enableProfileReposition = false;
                        } else {
                            $scope.profileDdControl.enableProfileReposition = true;
                        }
                    } else {
                        $scope.coverPhotoStyle.backgroundImage = "url(" + $scope.profileObj.getCover()  + ")";
                        $scope.coverPhotoStyle.backgroundPosition = '0px 0px';
                        if($scope.coverPhotoStyle.backgroundImage.indexOf('default_cover') > -1) {
                            $scope.profileDdControl.enableCoverReposition = false;
                        } else {
                            $scope.profileDdControl.enableCoverReposition = true;
                        }
                    }
                    $scope.$rgDigest();
                };
                updateStyle('coverphoto');
                updateStyle('profilephoto');

                $scope.frndAction = function(actionObj) {
                    if (!actionObj.friend.isLoading()) {
                        friendsFactory.friendAction(actionObj,true).then(function() {
                            $scope.$rgDigest();
                        }, function() {
                            $scope.$rgDigest();
                        });
                        $scope.$rgDigest();
                    }
                };
                /* END OF INITIALIZATION */


                /* cover photo dropdown */
                $scope.repositionExisting = false; // reposition existing pro pic or cover.

                $scope.coverDdHtml = 'pages/dropdowns/coverphoto-dropdown.html'; //$templateCache.get('coverphoto-dropdown.html');
                $scope.coverDdAction = function(actionObj) {
                    switch(actionObj.action) {
                        case 'coverphoto':
                            $scope.toggleResizeShow('coverphoto', true);
                            $scope.uploadAction(actionObj); // new cover photo selected
                            break;
                        case 'toggleReposition':
                            $scope.repositionExisting = true;
                            $scope.toggleResizeShow('coverphoto', true);

                            $scope.uploadAction({
                                action: 'coverphoto',
                                uploadFile: fileUploadService.queueFile('coverphoto', $scope.profileObj.getCover('original'))
                            });
                            break;
                        case 'popupData':
                            fileUploadService.uploadType = 'coverphoto';
                            return function() {
                                return {
                                    popupType: 'coverphoto'
                                };
                            };
                        default :
                            console.warn('Cover Photo Dropdown Action did not Match');
                    }
                    $scope.$rgDigest();
                };

                /* end cover photo dropdown */

                /* Profile photo Dropdown */

                $scope.profileDdHtml = 'pages/dropdowns/profilephoto-dropdown.html'; //$templateCache.get('profilephoto-dropdown.html');
                //$scope.frndActionHtml = 'pages/dropdowns/friend-settings-dropdown.html'; //$templateCache.get('profilephoto-dropdown.html');
                $scope.frndActionTemplate =
                    '<div class="action friend-settings-dropdown float-right">' +
                        '<a  ng-if="ddControl.friendshipStatus()==0 && !ddControl.isCurrentUser()" rg-click="ddAction()({ action: \'addfriend\', friend: ddControl})" href="#"><span class="icon-addf pro-f"></span><span class="txt">{{consType.add_friend}}</span></a>' +
                        '<a  ng-if="ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'unfriend\', friend: ddControl})" href="#"> <span class="icon-into-border f-Block"></span><span class="txt">{{consType.unfriend}}</span></a>' +
                        '<a  ng-if="ddControl.friendshipStatus()==2" rg-click="ddAction()({ action: \'accept\', friend: ddControl})" href="#"><span class="icon-incoming pro-f"></span><span class="txt">{{consType.accept}}</span></a>' +
                        '<a  ng-if="ddControl.friendshipStatus()==3" rg-click="ddAction()({ action: \'remove\', friend: ddControl})" href="#"><span class="icon-minus-cr f-14"></span><span class="txt">{{consType.remove}}</span></a>' +
                        '<a  ng-if="ddControl.isBlocked()===0 && !ddControl.isCurrentUser() && ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'block\', friend: ddControl})" class="border-0" href="#"><span class="icon-block"></span><span class="txt">{{consType.block}}</span></a>' +
                        '<a  ng-if="ddControl.isBlocked()===1 && !ddControl.isCurrentUser() && ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'unblock\', friend: ddControl})" class="border-0" href="#"><span class="icon-right f-Block"></span><span class="txt">{{consType.unblock}}</span></a>' +
                    '</div>';
                $scope.profileDdAction = function (actionObj) {
                    switch(actionObj.action) {
                        case 'profilephoto': // dropdown image selected for new profile photo
                            $scope.toggleResizeShow('profilephoto', true);
                            $scope.uploadAction(actionObj);
                            break;
                        case 'toggleReposition':
                            $scope.toggleResizeShow('profilephoto', true);
                            $scope.repositionExisting = true;

                            $scope.uploadAction({
                                action: 'profilephoto',
                                uploadFile: fileUploadService.queueFile('profilephoto', $scope.profileObj.avatar('original'))
                            });
                            break;
                        case 'popupData':
                            fileUploadService.uploadType = 'profilephoto';
                            return function() {
                                return {
                                    popupType: 'profilephoto'
                                };
                            };
                        default :
                            console.warn('Cover Photo Dropdown Action did not Match');
                    }
                    $scope.$rgDigest();
                };
                /* END Profile photo dropdown */

                $scope.toggleResizeShow = function(type, value) {
                    if(type === 'coverphoto') {
                        $scope.cvResizeProgressShow = value || false;
                    } else {
                        $scope.ppResizeProgressShow = value || false;
                    }
                    $scope.$rgDigest();
                };

                // photo selected from album for propic or coverpic
                $scope.$on(SystemEvents.IMAGE.DO_REPOSITION, function(event, args){
                    $scope.toggleResizeShow(fileUploadService.uploadType, true);
                    $scope.uploadAction({action: fileUploadService.uploadType, uploadFile: fileUploadService.queueFile(fileUploadService.uploadType, args.image)});
                    $ringbox.closeAll();
                });

                // cover photo, profile photo upload events handler
                $scope.uploadAction = function(actionObj) {
                    var fileToUpload;
                    $scope.repositionExisting = false;

                    if (actionObj.action === 'coverphoto') {
                        newCoverpic = actionObj.uploadFile;
                        fileToUpload = newCoverpic;
                    } else {
                        newPropic = actionObj.uploadFile;
                        fileToUpload = newPropic;
                    }

                    if (fileToUpload) {
                        $rootScope.$broadcast(SystemEvents.LOADING, true);
                        fileToUpload.fetchMeta(function(result) {
                            $rootScope.$broadcast(SystemEvents.LOADING, false);
                            if (result.success) {
                                if (actionObj.action === 'coverphoto') {
                                    $scope.toggleCoverPhotoReposition(fileToUpload.getPreview());
                                } else {
                                    $scope.toggleProfilePhotoReposition(fileToUpload.getPreview());
                                }
                            } else {
                                $scope.toggleResizeShow(actionObj.action, false);
                                Ringalert.show(result.message, 'error');
                            }
                            $scope.$rgDigest();
                        });
                    }
                    $scope.$rgDigest();
                };


                // set reposition and upload cover photo new/old
                $scope.uploadPicture = function(type,event) {
                    var fileToUpload;
                    if (type === 'coverphoto') {
                        $scope.cvUploadProgressShow = true;
                        $scope.coverPicDragEnable = false;
                        fileToUpload = newCoverpic;
                    } else if(type === 'profilephoto' ) {
                        $scope.ppUploadProgressShow = true;
                        $scope.profilePicDragEnable = false;
                        fileToUpload = newPropic;
                    }

                    $rootScope.$broadcast(SystemEvents.LOADING, true);
                    // upload file to image server and set cover or profile picture in auth server
                    //fileUploadService.uploadFile(type).then(function(response) {
                    fileToUpload.initUpload().then(function(response) {
                        $scope.cvUploadProgressShow = false;
                        $scope.ppUploadProgressShow = false;
                        if (response.sucs === true) {
                            if (type === 'profilephoto' ) {
                                profileFactory.changeProfilePicture(response).then(function() {
                                    $rootScope.$broadcast(SystemEvents.LOADING, false);
                                    $rootScope.$rgDigest();
                                    updateStyle(type);
                                });
                            } else if (type === 'coverphoto') {
                                profileFactory.changeCoverPicture(response).then(function() {
                                    $rootScope.$broadcast(SystemEvents.LOADING, false);
                                    $rootScope.$rgDigest();
                                    // in case of profile pic update localStorage
                                    updateStyle(type);
                                });
                            }

                        } else {
                            updateStyle(type);
                            RingLogger.warning(response);
                            $rootScope.$broadcast(SystemEvents.LOADING, false);
                        }

                    }, function(errorData) {
                        RingLogger.warning(errorData);
                        updateStyle(type);
                    });

                    if (event) {
                        event.stopPropagation();
                    }
                    $scope.$rgDigest();

                };


                // enable or disalbe cover pic reposition
                $scope.toggleCoverPhotoReposition = function (src, event) {
                    var originalSrc = '',
                        coverXY = $scope.profileObj.getCoverXY(),
                        imageFile;

                    if ($scope.coverPicDragEnable) {
                        $scope.coverPicDragEnable = false;
                        updateStyle('coverphoto');
                        //$scope.coverPhotoStyle.backgroundImage = "url(" + $scope.currentUser.getCover() + ")";
                    } else {
                        if (!src) {

                            src = $scope.profileObj.getCover();
                            imageFile = src.slice(src.lastIndexOf('/') + 1, src.length);
                            originalSrc = src.replace(imageFile, imageFile.replace('crp', '') );

                        } else {
                            originalSrc = src;
                        }
                        $scope.coverPhotoStyle.backgroundImage = "url(" + originalSrc + ")";

                        //$scope.coverPhotoStyle.backgroundPosition =  '0px ' + '0px';
                        $scope.coverPhotoStyle.backgroundPosition =  (-coverXY.x) + 'px ' + (-coverXY.y) + 'px';
                        $scope.coverPicDragEnable = true;
                        $scope.$rgDigest();
                    }

                    if (event) {
                        event.stopPropagation();
                    }

                };

                $scope.$watch('profilePicDragEnable', function(newVal) {
                    if(! newVal && !$scope.ppUploadProgressShow) {
                        updateStyle('profilephoto');
                    }
                });

                $scope.$watch('coverPicDragEnable', function(newVal) {
                    if(!newVal && !$scope.cvUploadProgressShow) {
                        updateStyle('coverphoto');
                    }
                });



                // enable or disalbe cover pic reposition

                $scope.toggleProfilePhotoReposition = function (src,event) {
                    var originalSrc = '',
                        imageFile,
                        prefix;

                    if ($scope.profilePicDragEnable) {
                        $scope.profilePicDragEnable = false;
                        updateStyle('profilephoto');

                    } else {

                        if (!src) {
                            src = $scope.profileObj.avatar('original');
                            imageFile = src.slice(src.lastIndexOf('/') + 1, src.length);
                            originalSrc = src.replace(imageFile, imageFile.replace(prefix, '') );
                        } else {
                            originalSrc = src;
                        }

                        $scope.profilePhotoStyle.backgroundImage = "url(" + originalSrc + ")";
                        $scope.profilePhotoStyle.backgroundPosition = '0px 0px';
                        $scope.profilePicDragEnable = true;
                        $scope.$rgDigest();
                    }
                    if (event) {
                        event.stopPropagation();
                    }
                };


                $scope.getImageData = function (imageId) {
                    return {
                        data: function() {
                            return {
                                imgId: imageId
                            };
                        },
                        promise: ImageFactory.getImageDetails(imageId)
                    };
                };


//--------------------------------- profile pic round-progress-bar (start) -------------
                $scope.cvUploadProgressShow = false;
                $scope.cvResizeProgressShow = false;
                $scope.ppResizeProgressShow = false;

                $scope.uploadStyle =  function() {
                    return {
                        width: fileUploadService.progress + '%'
                    };
                };

                $scope.roundProgressBarStyle = {
                    "dataRoundProgressWidth": "200",
                    "dataRoundProgressHeight": "200",
                    "dataRoundProgressOuterCircleWidth": "4",
                    "dataRoundProgressInnerCircleWidth": "8",
                    "dataRoundProgressOuterCircleRadius": "85",
                    "dataRoundProgressInnerCircleRadius": "85",
                    "dataRoundProgressLabelFont": '24',
                    "dataRoundProgressOuterCircleBackgroundColor": "#fff",
                    "dataRoundProgressOuterCircleForegroundColor": "#f47727",
                    "dataRoundProgressInnerCircleColor": "#fff",
                    "dataRoundProgressLabelColor": "#fff"
                };

                $scope.ppUploadProgressShow = false;
                $scope.uploadImageFileSize = function() {
                    return fileUploadService.currentUploadImageSize;
                };

                $scope.getRoundedProgressTextStyle = function(){
                    return {
                        'top': '50%',
                        'bottom': 'auto',
                        'left': '50%',
                        'transform': 'translateY(-50%) ' + 'translateX(-50%)',
                        'font-size': 100/3.5 + 'px',
                        'position' : 'absolute'
                    };
                };

                $scope.roundProgressData = function(){
                    return {
                        label: fileUploadService.progress + '%',
                        percentage: fileUploadService.progress,
                        dataLoaded : fileUploadService.dataLoaded
                    };
                };

                $scope.openRingbox = function(type){
                    if (type === 'cover') {
                        return !$scope.coverPicDragEnable && !$scope.cvResizeProgressShow && !$scope.cvUploadProgressShow && $scope.profileDdControl.enableCoverReposition;
                    } else {
                        return !$scope.profilePicDragEnable && !$scope.ppResizeProgressShow && !$scope.ppUploadProgressShow && $scope.profileDdControl.enableProfileReposition;
                    }
                };


                $scope.$on(SystemEvents.FILE_UPLOAD.PROGRESS_UPDATE, function(){
                    $scope.$rgDigest();
                });

                //profile about menu section for smaller device start
                $scope.showMenuItems = false;
                $scope.toggleMenuItem = function () {
                    $scope.showMenuItems = !$scope.showMenuItems;
                    $scope.$rgDigest();
                };
                $scope.closeDropdown = function () {
                    $scope.showMenuItems = false;
                    $scope.$rgDigest();
                };
                //profile about menu section for smaller device end

//--------------------------------- profile pic round-progress-bar (end) ---------------

                $scope.$on('$destroy', function() {
                    // remove all redundant data
                    RingLogger.warning('$scope destroy');
                    if ($routeParams.subPage === 'about') {
                        // remove about data like education, skill etc
                        profileFactory.removeProfileData($scope.profileObj.getUtId());
                    }
                });


            } // END CONTROLLER FUNC

            var linkFunc = function(scope, element) {
                function handleMouse(event) {
                    // event mouseenter=true, mouseleave=false
                    scope.showCoverDD = !scope.showCoverDD;
                    scope.$rgDigest();
                }

                element.on('mouseenter', handleMouse);
                element.on('mouseleave', handleMouse);

                scope.$on('$destroy', function() {
                    element.off('mouseenter', handleMouse);
                    element.off('mouseleave', handleMouse);
                });
            };

            return {
                restrict: 'E',
                scope: true,
                templateUrl: 'pages/profile/profile-header.html',
                controller: ProfileController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileBasic', rgProfileBasic);


    function rgProfileBasic()  {

        ProfileBasicController.$inject = ['Storage', '$scope','utilsFactory', 'profileFactory','Ringalert', '$rootScope'];
        function ProfileBasicController (Storage, $scope,utilsFactory, profileFactory,Ringalert, $rootScope) { //jshint ignore:line

            $scope.isEditProfile = false;
            $scope.processing = false;

            //$scope.$watch('tmpBasic.fn', function (newval, oldval) {
            //    var rexpression =/(!?[\.\-\_\!\@\#\$\%\&\*\{\}\(\)\[\]\:\;\~\,\\\^\/\<\>\?\'\"\|\=\+\`])+/;
            //
            //    $scope.fullnameRegex = rexpression.test(newval);
            //});

            $scope.enableEditBasic = enableEditBasic;
            $scope.updateMyBasicInfo = updateMyBasicInfo;
            $scope.cancelUpdateMyBasicInfo = cancelUpdateMyBasicInfo;

            function enableEditBasic(event) {
                event.preventDefault();
                $scope.tmpBasic = angular.copy($scope.profileObj.getBasicInfo());
                if ($scope.tmpBasic.mDay === 1 || $scope.tmpBasic.mDay === '1') {
                    $scope.tmpBasic.marriageDay = null;
                }
                if ($scope.tmpBasic.birthDay === 1 || $scope.tmpBasic.birthDay === '1') {
                    $scope.tmpBasic.birthday = null;
                }
                //if ($scope.isEditProfile === false) {
                $scope.isEditProfile = true;
                $scope.$rgDigest();
                //}
            }

            function cancelUpdateMyBasicInfo() {
                //$scope.tmpBasic = $scope.tmpBasic;
                $scope.isEditProfile = false;
                $scope.$rgDigest();
                //$scope.isOwner = true;
            }
            function updateMyBasicInfo() {
                $scope.processing = true;
                var mdateobj = $scope.tmpBasic.marriageDay;
                if (mdateobj==null){
                    mdateobj = 1;
                }
                var dateobj;

                var datetype = typeof($scope.tmpBasic.birthday);
                var mdatetype = typeof(mdateobj);
                RingLogger.print(datetype, RingLogger.tags.PROFILE);
                if (datetype==='string') {
                    var data = $scope.tmpBasic.birthday.split('-');
                    var bdDate = parseInt(data[0])+','+parseInt(data[1])+','+parseInt(data[2]);
                    dateobj = new Date(bdDate);
                } else {
                    dateobj = $scope.tmpBasic.birthday;
                    if($scope.tmpBasic.birthDay !== 1){
                        if($scope.tmpBasic.birthDay !== '1'){
                            var frTime = utilsFactory.profileVerbalDate($scope.tmpBasic.birthDay);
                            $scope.tmpBasic.birthday = frTime;
                        }

                    }

                }

                if(mdatetype === 'string'){
                    var mdata = mdateobj.split('-');
                    var mDate = parseInt(mdata[0])+','+parseInt(mdata[1])+','+parseInt(mdata[2]);
                    mdateobj = new Date(mDate);
                }


                profileFactory.updateUserProfile($scope.uId,$scope.tmpBasic,dateobj,mdateobj).then(function(data){
                    RingLogger.print(data, RingLogger.tags.PROFILE);
                    if(data.sucs===true){
                        $scope.tmpBasic.birthDay = dateobj ? dateobj.getTime() : '1';
                        if( typeof(dateobj) ==='object' ){
                            $scope.currentUser.setBirthday($scope.tmpBasic.birthDay);
                        }else{
                            $scope.currentUser.setBirthday('1');
                        }
                        if( mdatetype ==='object' ){
                            $scope.currentUser.setMarriageday(mdateobj.getTime());
                        }else{
                            $scope.currentUser.setMarriageday('1');
                        }


                        $scope.profileObj.getBasicInfo().birthDay = $scope.tmpBasic.birthDay;

                        $scope.currentUser.setName($scope.tmpBasic.fn);
                        $scope.currentUser.setHomeCity($scope.tmpBasic.hc);
                        $scope.currentUser.setCurrentCity($scope.tmpBasic.cc);
                        $scope.currentUser.setAboutMe($scope.tmpBasic.am);
                        Storage.updateLoginData('fn', $scope.tmpBasic.fn);
                        $scope.currentUser.setGender($scope.tmpBasic.gr);

                        Ringalert.show('Successfully updated','success');
                        $scope.isEditProfile = false;
                        //$scope.isOwner = true;
                    }else{
                        $scope.isEditProfile = false;
                        Ringalert.show(data.mg,'error');
                        RingLogger.print('something went wrong', RingLogger.tags.PROFILE);
                    }
                    $scope.processing = false;
                    $rootScope.$rgDigest();
                });
            }



            //datepicker
            $scope.isDatePickerOpen = false;
            $scope.model = {};

            $scope.open = function($event, elementOpened) {
                RingLogger.print(elementOpened, RingLogger.tags.PROFILE);
                $event.preventDefault();
                $event.stopPropagation();
                switch(elementOpened){
                    case 'wcalendar':
                        $scope.model.wcalendarTo = false;
                        break;
                    case 'wcalendarTo':
                        $scope.model.wcalendar = false;
                        break;
                    case 'ecalendar':
                        $scope.model.ecalendarTo = false;
                        break;
                    case 'ecalendarTo':
                        $scope.model.ecalendar = false;
                        break;
                    case 'mcalendar':
                        $scope.model.mcalendar = false;
                        break;
                }
                $scope.model[elementOpened] = !$scope.model[elementOpened];

            };
            $scope.dateOptions = {
                showWeeks:'false',
                startingDay: 1
            };

            var today = new Date();
            today.setMonth(today.getMonth()+6);
            $scope.minDate = new Date();

            $scope.maxDate = new Date(today.getFullYear(),today.getMonth() , today.getDate());


        } // END CONTROLLER FUNC


        return {
            restrict: 'E',
            //scope: true,
            templateUrl: 'pages/profile/profile.about-basic.html',
            controller: ProfileBasicController
        };

    }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfilePrivacy', rgProfilePrivacy);


        function rgProfilePrivacy()  {

            ProfilePrivacyController.$inject = ['Storage', 'rgDropdownService', '$timeout', '$scope','utilsFactory', 'friendsFactory', 'profileFactory','languageConstant'];
            function ProfilePrivacyController (Storage, rgDropdownService, $timeout, $scope,utilsFactory, friendsFactory, profileFactory, languageConstant) { //jshint ignore:line

                $scope.isEditProfilePrivacy = false;
                $scope.callPvcEdit = false;
                $scope.chatPvcEdit = false;
                $scope.feedPvcEdit = false;

                //default settings
                $scope.fPrivacyInfo = {
                    callPrivacy : 0,
                    chatPrivacy : 0,
                    feedPrivacy : 0
                };

                $scope.enablePrivacyEditMode = enablePrivacyEditMode;
                $scope.savePvcEdit = savePvcEdit;
                $scope.cancelPvcEdit = cancelPvcEdit;

                if($scope.profileObj.isCurrentUser()){
                    profileFactory.verifyCheck().then(function(data){
                        if(data.sucs===true){
                            //$scope.emailVerified = data.iev;
                            //$scope.phoneVerified = data.imnv;

                            $scope.fPrivacyInfo.callPrivacy = data.cla;
                            $scope.fPrivacyInfo.chatPrivacy = data.chta;
                            $scope.fPrivacyInfo.feedPrivacy = data.fda;
                            //$scope.chatsettings.achat = data.ancht;

                            //if($scope.emailVerified){$scope.emailValue = 'Verified Email';$scope.emailTitle = 'Your Email is verified.';}
                            //if($scope.phoneVerified){$scope.phoneValue = 'Verified Phone';$scope.phoneTitle = 'Your Phone is verified.';}

                        }
                        $scope.$rgDigest();
                    });
                }else{
                    $scope.access = $scope.profileObj.getAccess;
                    $scope.fPrivacyInfo.callPrivacy = $scope.profileObj.getAccess().cla;
                    $scope.fPrivacyInfo.chatPrivacy = $scope.profileObj.getAccess().chta;
                    $scope.fPrivacyInfo.feedPrivacy = $scope.profileObj.getAccess().fda;
                    if( !$scope.fPrivacyInfo.callPrivacy && !$scope.fPrivacyInfo.chatPrivacy && !$scope.fPrivacyInfo.feedPrivacy ) {
                        $scope.profileObj.setBlock(1);
                    }
                    $scope.$rgDigest();
                }


                function  enablePrivacyEditMode ($event) {
                    $event.preventDefault();
                    $scope.isEditProfilePrivacy = true;
                    $scope.$rgDigest();
                }


                 function savePvcEdit(fPrivacyInfo) {
                    var callobj;
                    $scope.isEditProfilePrivacy = false;
                    // TODO REFACTOR API CALL FOR SAVING PRIVACY CHANGE
                    //var obj = {
                        //sv: 0,
                        //sn: 0,
                    //};
                    //if (!$scope.profileObj.isCurrentUser()) {
                        //obj.utId = $scope.profileObj.getUtId();
                    //}

                    //$scope.isFrndsPrivacyEdit=false;
                    //call privacy settings
                    if($scope.profileObj.isCurrentUser()){
                        callobj = {
                            actn:216,
                            sv:fPrivacyInfo.callPrivacy,
                            sn:6,
                            isCurrent:true
                        };
                    }else{
                        callobj = {
                            actn:82,
                            sv:fPrivacyInfo.callPrivacy,
                            sn:6,
                            utId:$scope.profileObj.getUtId(),
                            isCurrent:false
                        };
                    }
                    $scope.fPrivacyInfo.callPrivacy = fPrivacyInfo.callPrivacy;
                    $timeout(function(){
                        profileFactory.saveCallPvcEdit(callobj).then(function(data){
                            //RingLogger.print('call response', RingLogger.tags.PROFILE);
                            //RingLogger.print(data, RingLogger.tags.PROFILE);
                            if(data.sucs===true){
                                $scope.fPrivacyInfo.callPrivacy = fPrivacyInfo.callPrivacy;
                            }else{
                                $scope.fPrivacyInfo.callPrivacy = 0;
                            }

                            //$scope.callPvcEdit = false;
                        });
                    },100);

                    //chat privacy settings
                    var chatobj;
                    if($scope.profileObj.isCurrentUser()){
                        chatobj = {
                            actn:216,
                            sv:fPrivacyInfo.chatPrivacy,
                            sn:7,
                            isCurrent:true
                        };
                    }else{
                        chatobj = {
                            actn:82,
                            sv:fPrivacyInfo.chatPrivacy,
                            sn:7,
                            utId:$scope.profileObj.getUtId(),
                            isCurrent:false
                        };
                    }
                    $scope.fPrivacyInfo.chatPrivacy = fPrivacyInfo.chatPrivacy;
                    $timeout(function(){
                        profileFactory.saveChatPvcEdit(chatobj).then(function(data){
                            //RingLogger.print('chat response', RingLogger.tags.PROFILE);
                            //RingLogger.print(data, RingLogger.tags.PROFILE);
                            if(data.sucs===true){
                                $scope.fPrivacyInfo.chatPrivacy = fPrivacyInfo.chatPrivacy;
                            }else{
                                $scope.fPrivacyInfo.chatPrivacy = 0;
                            }

                            //$scope.chatPvcEdit = false;
                        });
                    },200);

                    //feed privacy settings
                    var feedObj;
                    if($scope.profileObj.isCurrentUser()){
                        feedObj = {
                            actn:216,
                            sv:fPrivacyInfo.feedPrivacy,
                            sn:8,
                            isCurrent:true
                        };
                    }else{
                        feedObj = {
                            actn:82,
                            sv:fPrivacyInfo.feedPrivacy,
                            sn:8,
                            utId:$scope.profileObj.getUtId(),
                            isCurrent:false
                        };
                    }
                    $scope.fPrivacyInfo.feedPrivacy = fPrivacyInfo.feedPrivacy;
                    $timeout(function(){
                        profileFactory.saveFeedPvcEdit(feedObj).then(function(data){
                            //RingLogger.print('feed response', RingLogger.tags.PROFILE);
                            //RingLogger.print(data, RingLogger.tags.PROFILE);
                            if(data.sucs===true){
                                $scope.fPrivacyInfo.feedPrivacy = fPrivacyInfo.feedPrivacy;
                            }else{
                                $scope.fPrivacyInfo.feedPrivacy = 0;
                            }

                            //$scope.feedPvcEdit = false;
                        });
                    },300);
                     $scope.$rgDigest();

                }

                function cancelPvcEdit() { // profile-privacy
                    $scope.isEditProfilePrivacy = false;
                    //$scope.isFrndsPrivacyEdit = false;
                    $scope.$rgDigest();
                }



            } // END CONTROLLER FUNC

            var linkFunc = function() {
            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-privacy.html',
                controller: ProfilePrivacyController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileEducation', rgProfileEducation);


        function rgProfileEducation()  {

            ProfileEducationController.$inject = [ 'Ringalert', '$scope','utilsFactory', 'profileFactory','$routeParams','rgDropdownService' ];
            function ProfileEducationController ( Ringalert, $scope,utilsFactory, profileFactory, $routeParams,rgDropdownService ) { //jshint ignore:line
                var tmpEducation,contentIndex;

                if($scope.profileObj.isCurrentUser()){
                    $scope.isOwner = true;
                }else{
                    $scope.isOwner = false;
                }

                var tempEduList;

                // initialization
                profileFactory.getUserProfileData({uId:$routeParams.uId}, $scope.profileObj.isCurrentUser());
                $scope.getProfileData = profileFactory.getProfileData;
                $scope.educationlist = $scope.getProfileData('educationList', $scope.profileObj.getUtId());


                $scope.edusclerror = false;
                $scope.edudgrerror = false;
                $scope.educntnerror = false;

                $scope.$watch('eduObjInfo.scl', function (newval,oldval) {
                    if(newval){
                        $scope.edusclerror = false;
                    }
                });
                $scope.$watch('eduObjInfo.dgr', function (newval,oldval) {
                    if(newval){
                        $scope.edudgrerror = false;
                    }
                });
                $scope.$watch('eduObjInfo.cntn', function (newval,oldval) {
                    if(newval){
                        $scope.educntnerror = false;
                    }
                });


                // dropdown
                $scope.ddActionHtml = 'pages/dropdowns/action-dropdown.html';//$templateCache.get('action-dropdown.html');
                $scope.actionEduDropdown = function(actionObj) {
                    actionObj.event.preventDefault();
                    rgDropdownService.close();
                    switch(actionObj.action) {
                        case 'edit':
                            enableEducationEditMode(actionObj.data.index,actionObj.data.obj);

                            break;
                        case 'delete':
                            deleteEducation(actionObj.data.index);

                            break;
                        default:
                    }
                };

                // models and methods
                $scope.isaddNewEducation = false;
                $scope.isEditEducation = -1;
                $scope.eduObjInfo = {}; // profile education

                $scope.addNewEducation = addNewEducation;
                $scope.submitNewEducation = submitNewEducation;
                $scope.updateEducation = updateEducation;
                $scope.cancelAddEducation = cancelAddEducation;
                $scope.cancelUpdateEducation = cancelUpdateEducation;

                function addNewEducation(){ // profile-education
                    if(tmpEducation){
                        $scope.educationlist[contentIndex] = tmpEducation;
                    }
                    $scope.isEditEducation = -1;
                    $scope.eduObjInfo.scl='';
                    $scope.eduObjInfo.dgr='';
                    $scope.eduObjInfo.cntn='';
                    $scope.eduObjInfo.toTimeE='';
                    $scope.eduObjInfo.fromTimeE='';
                    $scope.isaddNewEducation = true;

                    $scope.$rgDigest();
                }

                function enableEducationEditMode(index,object) {
                    contentIndex = index;
                    $scope.eduObjInfo = $scope.educationlist[index];
                    tmpEducation = angular.copy($scope.educationlist[index]);

                    if ($scope.eduObjInfo.tt === 1) {
                        $scope.eduObjInfo.toTimeE = null;
                    }
                    if ($scope.eduObjInfo.ft === 1) {
                        $scope.eduObjInfo.fromTimeE = null;
                    }
                    $scope.isaddNewEducation = false;
                    $scope.isEditEducation = index;

                    $scope.$rgDigest();

                }

                function cancelAddEducation(){
                    if(tmpEducation){
                        $scope.educationlist[contentIndex] = tmpEducation;
                    }
                    //$scope.educationlist = $scope.getProfileData('educationList', $scope.profileObj.getUtId());
                    //$scope.eduObjInfo.scl='';
                    //$scope.eduObjInfo.dgr='';
                    //$scope.eduObjInfo.cntn='';
                    //$scope.eduObjInfo.toTimeE='';
                    //$scope.eduObjInfo.fromTimeE='';

                    $scope.isaddNewEducation = false;
                    $scope.isEditEducation = -1;

                    $scope.$rgDigest();
                }

                function cancelUpdateEducation() {
                    $scope.educationlist[contentIndex] = tmpEducation;
                    $scope.isEditEducation = -1;
                    //$scope.isaddNewEducation = false;
                    //$scope.showAddButton = true;
                    $scope.$rgDigest();

                }


                function updateEducation() {

                    if( !$scope.eduObjInfo.scl ){
                        $scope.edusclerror = true;
                        $scope.$rgDigest();
                    }

                    if( !$scope.eduObjInfo.dgr ) {
                        $scope.edudgrerror = true;
                        $scope.$rgDigest();
                    }

                    if( !$scope.eduObjInfo.cntn ) {
                        $scope.educntnerror = true;
                        $scope.$rgDigest();
                    }

                    if( $scope.edusclerror || $scope.edudgrerror || $scope.educntnerror ){
                        return;
                    }

                    $scope.processing = true;
                    //$scope.eduObjInfo.ft = new Date($scope.eduObjInfo.fromTimeE).getTime();//will alert something like 1330192800000
                   // $scope.eduObjInfo.tt = new Date($scope.eduObjInfo.toTimeE).getTime();//will alert something like 1330192800000

                    if($scope.eduObjInfo.fromTimeE){
                        $scope.eduObjInfo.ft = new Date($scope.eduObjInfo.fromTimeE).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.eduObjInfo.ft = 1;
                    }
                    if($scope.eduObjInfo.toTimeE){
                        $scope.eduObjInfo.tt = new Date($scope.eduObjInfo.toTimeE).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.eduObjInfo.tt = 1;
                    }

                    profileFactory.updateEducation($scope.eduObjInfo).then(function(json){
                        if(json.sucs===true){
                            if($scope.eduObjInfo.fromTimeE){
                                $scope.eduObjInfo.fromTimeE = utilsFactory.profileVerbalDate($scope.eduObjInfo.ft);
                            }else{
                                $scope.eduObjInfo.ft = 1;
                                $scope.eduObjInfo.fromTimeE = '';
                            }
                            if($scope.eduObjInfo.toTimeE){
                                $scope.eduObjInfo.toTimeE = utilsFactory.profileVerbalDate($scope.eduObjInfo.tt);
                            }else{
                                $scope.eduObjInfo.tt = 1;
                                $scope.eduObjInfo.toTimeE = '';
                            }
                            $scope.isEditEducation = -1;

                            Ringalert.show('Successfully updated','success');
                        }else{
                            $scope.isEditEducation = -1;
                            Ringalert.show('Request did not process successfully','error');
                            RingLogger.print(json, RingLogger.tags.PROFILE);
                        }
                        $scope.processing = false;
                        $scope.$rgDigest();

                    });
                }


                function submitNewEducation() {

                    if( !$scope.eduObjInfo.scl ){
                        $scope.edusclerror = true;
                        $scope.$rgDigest();
                    }

                    if( !$scope.eduObjInfo.dgr ) {
                        $scope.edudgrerror = true;
                        $scope.$rgDigest();
                    }

                    if( !$scope.eduObjInfo.cntn ) {
                        $scope.educntnerror = true;
                        $scope.$rgDigest();
                    }

                    if( $scope.edusclerror || $scope.edudgrerror || $scope.educntnerror ){
                        return;
                    }

                    $scope.processing = true;
                    if($scope.eduObjInfo.fromTimeE){
                        $scope.eduObjInfo.ft = new Date(utilsFactory.profileVerbalDate($scope.eduObjInfo.fromTimeE)).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.eduObjInfo.ft = 1;
                    }
                    if($scope.eduObjInfo.toTimeE){
                        $scope.eduObjInfo.tt = new Date(utilsFactory.profileVerbalDate($scope.eduObjInfo.toTimeE)).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.eduObjInfo.tt = 1;
                    }

                    $scope.eduObjInfo.ut = new Date().getTime();
                    $scope.eduObjInfo.af = 1;
                    $scope.eduObjInfo.grtd = false;//have to add in ui
                    $scope.eduObjInfo.iss = true;

                    profileFactory.submitNewEducation($scope.eduObjInfo).then(function(json) {
                        if (json.sucs === true) {
                            // new education
                            $scope.eduObjInfo.id = json.id;
                            var obj = angular.copy($scope.eduObjInfo);
                            profileFactory.setProfileData('educationList', obj, $scope.profileObj.getUtId());
                            Ringalert.show('Education info added successfully','success');
                            $scope.isaddNewEducation = false;
                            $scope.isEditEducation = -1;
                        }else{
                            Ringalert.show('Request did not process successfully','error');
                            $scope.isaddNewEducation = false;
                            $scope.isEditEducation = -1;
                        }
                        $scope.isaddNewEducation = false;
                        $scope.isEditEducation = -1;
                        $scope.processing = false;
                        $scope.$rgDigest();
                    });
                }


                function deleteEducation(index) {
                    var eduId = $scope.getProfileData('educationList', $scope.profileObj.getUtId())[index].id;
                    $scope.isEditEducation = -1;
                    profileFactory.deleteEducation(eduId).then(function(data){
                        if(data.sucs===true){
                            $scope.getProfileData('educationList', $scope.profileObj.getUtId()).splice(index, 1);
                            Ringalert.show('Successfully deleted','success');
                        }else{
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.$rgDigest();

                    });
                }

                $scope.$on('$destroy', function() {
                    //profileFactory.setProfileData('educationList', [], $scope.profileObj.getUtId());
                });

            } // END CONTROLLER FUNC

            var linkFunc = function() {
            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-education.html',
                controller: ProfileEducationController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileWork', rgProfileWork);


        function rgProfileWork()  {

            ProfileWorkController.$inject = [  '$scope','utilsFactory', 'profileFactory','$routeParams','rgDropdownService','Ringalert' ];
            function ProfileWorkController (  $scope,utilsFactory, profileFactory, $routeParams,rgDropdownService,Ringalert ) { //jshint ignore:line

                // initialization
                if($scope.profileObj.isCurrentUser()){
                    $scope.isOwner = true;
                }else{
                    $scope.isOwner = false;
                }

                profileFactory.getUserProfileData({uId:$routeParams.uId}, $scope.profileObj.isCurrentUser());
                $scope.getProfileData = profileFactory.getProfileData;
                $scope.worklist = $scope.getProfileData('workList', $scope.profileObj.getUtId());

                // dropdown
                $scope.ddActionHtml = 'pages/dropdowns/action-dropdown.html';//$templateCache.get('action-dropdown.html');
                $scope.actionWorkDropdown = actionWorkDropdown;

                // models and methods
                $scope.isAddNewWork = false;
                $scope.isEditWork = -1;
                $scope.workObjInfo = {};
                var tmpWork,contentIndex;

                $scope.addNewWork = addNewWork;
                $scope.cancelNewWork = cancelNewWork;
                $scope.submitNewWork = submitNewWork;
                $scope.cancelUpdateWork = cancelUpdateWork;
                $scope.updateWork = updateWork;

                $scope.workcnmerror = false;
                $scope.workpstnerror = false;

                $scope.$watch('workObjInfo.cnm', function (newval,oldval) {
                    if(newval){
                        $scope.workcnmerror = false;
                    }
                });
                $scope.$watch('workObjInfo.pstn', function (newval,oldval) {
                    if(newval){
                        $scope.workpstnerror = false;
                    }
                });

                function addNewWork () {
                    if(tmpWork){
                        $scope.worklist[contentIndex] = tmpWork;
                    }
                    $scope.isEditWork = -1;
                    $scope.workObjInfo.cnm = '';
                    $scope.workObjInfo.pstn = '';
                    $scope.workObjInfo.desc = '';
                    $scope.workObjInfo.fromTimeE = '';
                    $scope.workObjInfo.toTimeE = '';
                    $scope.workObjInfo.ft = '';
                    $scope.workObjInfo.tt = '';
                    $scope.isAddNewWork = true;
                    $scope.$rgDigest();
                }


                function cancelNewWork () {
                    if(tmpWork){
                        $scope.worklist[contentIndex] = tmpWork;
                    }
                    //$scope.workObjInfo.cnm = '';
                    //$scope.workObjInfo.pstn = '';
                    //$scope.workObjInfo.ct = '';
                    //$scope.workObjInfo.desc = '';
                    //$scope.workObjInfo.ft = '';
                    //$scope.workObjInfo.tt = '';
                    $scope.isAddNewWork = false;
                    $scope.$rgDigest();
                }

                function submitNewWork() {

                    if( !$scope.workObjInfo.cnm ){
                        $scope.workcnmerror = true;
                        $scope.$rgDigest();

                    }

                    if( !$scope.workObjInfo.pstn ) {
                        $scope.workpstnerror = true;
                        $scope.$rgDigest();

                    }

                    if( $scope.workcnmerror || $scope.workpstnerror ){
                        return;
                    }

                    $scope.processing = true;

                    //var fromTime = $scope.workObjInfo.ft;
                    //var toTime = $scope.workObjInfo.tt;

                    //var fDate = utilsFactory.profileVerbalDate(fromTime);
                    //$scope.workObjInfo.ft = new Date(fDate).getTime();//will alert something like 1330192800000

                    //to date
                    if($scope.workObjInfo.status === true){
                        $scope.workObjInfo.tt = '0';
                        $scope.workObjInfo.status = true;
                        $scope.workObjInfo.date_info = 'Present';
                        //toTime = 0;

                    }else{

                        if($scope.workObjInfo.toTimeE){
                            $scope.workObjInfo.tt = new Date($scope.workObjInfo.toTimeE).getTime();//will alert something like 1330192800000
                        }else{
                            $scope.workObjInfo.tt = 1;
                        }
                    }

                    if($scope.workObjInfo.fromTimeE){
                        $scope.workObjInfo.ft = new Date($scope.workObjInfo.fromTimeE).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.workObjInfo.ft = 1;
                    }

                    profileFactory.submitNewWork($scope.workObjInfo).then(function(data) {

                        if(data.sucs === true){
                            $scope.workObjInfo.id = data.id;
                            if($scope.workObjInfo.ft){
                                $scope.workObjInfo.fromTimeE = utilsFactory.profileVerbalDate($scope.workObjInfo.ft);
                            }else{
                                $scope.workObjInfo.ft = 1;
                            }
                            if($scope.workObjInfo.tt){
                                $scope.workObjInfo.toTimeE = utilsFactory.profileVerbalDate($scope.workObjInfo.tt);
                            }else{
                                $scope.workObjInfo.tt = 1;
                            }
                            var obj = angular.copy($scope.workObjInfo);
                            profileFactory.setProfileData('workList', obj, $scope.profileObj.getUtId());
                            Ringalert.show('Career info added successfully','success');
                            $scope.isAddNewWork = false;
                            $scope.isEditWork = -1;

                        }else{
                            Ringalert.show('Request did not process successfully','error');
                            $scope.isAddNewWork = false;
                            $scope.isEditWork = -1;
                        }
                        $scope.processing = false;
                        $scope.$rgDigest();

                    });
                }

                function actionWorkDropdown(actionObj) {

                    actionObj.event.preventDefault();

                    switch(actionObj.action) {
                        case 'edit':
                            enableWorkEditMode( actionObj.data.index );
                            rgDropdownService.close();
                            break;
                        case 'delete':
                            deleteWork(actionObj.data.index);
                            rgDropdownService.close();
                            break;
                        default:
                    }
                }

                function enableWorkEditMode(index) {
                    contentIndex = index;
                    $scope.workObjInfo = $scope.worklist[index];
                    tmpWork =  angular.copy($scope.worklist[index]);


                    if ($scope.workObjInfo.tt === 1 || $scope.workObjInfo.tt === '0' || $scope.workObjInfo.tt === 0) {
                        $scope.workObjInfo.toTimeE = null;
                    }
                    if ($scope.workObjInfo.ft === 1) {
                        $scope.workObjInfo.fromTimeE = null;
                    }
                    $scope.isAddNewWork = false;
                    $scope.isEditWork = index;
                    $scope.$rgDigest();

                }

                function updateWork() {

                    if( !$scope.workObjInfo.cnm ){
                        $scope.workcnmerror = true;
                        $scope.$rgDigest();

                    }

                    if( !$scope.workObjInfo.pstn ) {
                        $scope.workpstnerror = true;
                        $scope.$rgDigest();

                    }

                    if( $scope.workcnmerror || $scope.workpstnerror ){
                        return;
                    }

                    $scope.processing = true;
                    if($scope.workObjInfo.fromTimeE){
                        $scope.workObjInfo.ft = new Date($scope.workObjInfo.fromTimeE).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.workObjInfo.ft = 1;
                    }
                    if($scope.workObjInfo.toTimeE){
                        $scope.workObjInfo.tt = new Date($scope.workObjInfo.toTimeE).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.workObjInfo.tt = 1;
                    }
                    if($scope.workObjInfo.status === true){
                        $scope.workObjInfo.tt = '0';
                        $scope.workObjInfo.status = true;
                        $scope.workObjInfo.date_info = 'Present';

                    }

                    profileFactory.updateWork($scope.workObjInfo).then(function(data){
                        RingLogger.print(data, RingLogger.tags.PROFILE);
                        if(data.sucs === true){
                            
                            if($scope.workObjInfo.ft){
                                $scope.workObjInfo.fromTimeE = utilsFactory.profileVerbalDate($scope.workObjInfo.ft);
                            }else{
                                $scope.workObjInfo.ft = 1;
                            }
                            if($scope.workObjInfo.tt){
                                $scope.workObjInfo.toTimeE = utilsFactory.profileVerbalDate($scope.workObjInfo.tt);
                            }else{
                                $scope.workObjInfo.tt = 1;
                            }
                            if( $scope.workObjInfo.status === true ) {
                                $scope.workObjInfo.tt = 0;
                                $scope.date_info = 'Present';
                            }
                            Ringalert.show('Updated successfully','success');
                            $scope.isEditWork = -1;
                        }else{
                            $scope.isEditWork = -1;
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.processing = false;
                        $scope.$rgDigest();

                    });
                }

                function cancelUpdateWork() {
                    $scope.worklist[contentIndex] = tmpWork;
                    $scope.isEditWork = -1;
                    $scope.$rgDigest();
                }

                function deleteWork(index) {
                    $scope.isEditWork = -1;
                    var workId = $scope.getProfileData('workList', $scope.profileObj.getUtId())[index].id;
                    profileFactory.deleteWork(workId).then(function(data){
                        if(data.sucs===true){
                            $scope.getProfileData('workList', $scope.profileObj.getUtId()).splice(index, 1);
                            Ringalert.show('Successfully deleted','success');
                        }else{
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.$rgDigest();
                    });
                }

                $scope.$on('$destroy', function() {
                    //profileFactory.setProfileData('workList', [], $scope.profileObj.getUtId());
                });

            } // END CONTROLLER FUNC

            var linkFunc = function() {
            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-work.html',
                controller: ProfileWorkController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileSkill', rgProfileSkill);


        function rgProfileSkill()  {

            ProfileSkillController.$inject = [ '$scope', 'profileFactory','$routeParams','rgDropdownService','Ringalert' ];
            function ProfileSkillController ( $scope, profileFactory, $routeParams,rgDropdownService,Ringalert ) { //jshint ignore:line


                if($scope.profileObj.isCurrentUser()){
                    $scope.isOwner = true;
                    //$scope.showAddButton = true;
                }else{
                    $scope.isOwner = false;
                }

                $scope.skillsklerror = false;
                $scope.skilldescerror = false;

                $scope.$watch('skillObjInfo.skl', function (newval,oldval) {
                    if(newval){
                        $scope.skillsklerror = false;
                    }
                });
                $scope.$watch('skillObjInfo.desc', function (newval,oldval) {
                    if(newval){
                        $scope.skilldescerror = false;
                    }
                });
                // initialize
                profileFactory.getUserProfileData({uId:$routeParams.uId}, $scope.profileObj.isCurrentUser());
                $scope.getProfileData = profileFactory.getProfileData;
                $scope.skilllist = $scope.getProfileData('skillList', $scope.profileObj.getUtId());
                var tmpSkill,contentIndex;

                $scope.addNewSkill = addNewSkill;
                $scope.submitNewSkill = submitNewSkill;
                $scope.cancelNewSkill = cancelNewSkill;
                $scope.updateSkill = updateSkill;
                $scope.cancelUpdateSkill = cancelUpdateSkill;
                $scope.skillObjInfo = {};

                $scope.ddActionHtml = 'pages/dropdowns/action-dropdown.html';
                $scope.actionSkillDropdown = function(actionObj) {
                    actionObj.event.preventDefault();
                    switch(actionObj.action) {
                        case 'edit':
                            enableSkillEditMode(actionObj.data.index);
                            rgDropdownService.close();
                            break;
                        case 'delete':
                            deleteSkill(actionObj.data.index);
                            rgDropdownService.close();
                            break;
                        default:
                    }
                };

                $scope.isAddNewSkill = false;

                function addNewSkill() {
                    if(tmpSkill){
                        $scope.skilllist[contentIndex] = tmpSkill;
                    }
                    $scope.isEditSkill = -1;
                    $scope.skillObjInfo.skl = '';
                    $scope.skillObjInfo.desc = '';
                    $scope.isAddNewSkill = true;
                    $scope.$rgDigest();
                }

                function submitNewSkill() {

                    if( !$scope.skillObjInfo.desc ){
                        $scope.skilldescerror = true;
                        $scope.$rgDigest();

                    }

                    if( !$scope.skillObjInfo.skl ) {
                        $scope.skillsklerror = true;
                        $scope.$rgDigest();

                    }

                    if( $scope.skillsklerror || $scope.skilldescerror ){
                        return;
                    }



                    $scope.processing = true;
                    profileFactory.submitNewSkill($scope.skillObjInfo).then(function(data) {
                        var obj;
                        if( data.sucs===true ) {
                            $scope.skillObjInfo.id = data.id;
                            obj = angular.copy($scope.skillObjInfo);
                            profileFactory.setProfileData('skillList', obj, $scope.profileObj.getUtId());
                            Ringalert.show('Skill info added successfully','success');
                            $scope.isAddNewSkill = false;
                        }else{
                            $scope.isAddNewSkill = false;
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.processing = false;
                        $scope.$rgDigest();

                    });
                }

                function cancelNewSkill() {
                    if(tmpSkill){
                        $scope.skilllist[contentIndex] = tmpSkill;
                    }
                    //$scope.skillObjInfo.skl = '';
                    //$scope.skillObjInfo.desc = '';
                    $scope.isAddNewSkill = false;
                    $scope.$rgDigest();
                }



                function updateSkill() {

                    if( !$scope.skillObjInfo.desc ){
                        $scope.skilldescerror = true;
                        $scope.$rgDigest();

                    }

                    if( !$scope.skillObjInfo.skl ) {
                        $scope.skillsklerror = true;
                        $scope.$rgDigest();

                    }

                    if( $scope.skillsklerror || $scope.skilldescerror ){
                        return;
                    }

                    $scope.processing = true;
                    profileFactory.updateSkill($scope.skillObjInfo).then(function(data){
                        if(data.sucs===true){
                            $scope.isEditSkill = -1;
                            Ringalert.show('Successfully updated','success');
                        }else{
                            $scope.isEditSkill = -1;
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.processing = false;
                        $scope.$rgDigest();
                    });
                }

                function deleteSkill(index) {
                    var sid = $scope.getProfileData('skillList', $scope.profileObj.getUtId())[index].id;
                    $scope.isEditSkill = -1;
                    profileFactory.deleteSkill(sid).then(function(data){
                        if(data.sucs===true){
                            $scope.getProfileData('skillList', $scope.profileObj.getUtId()).splice(index, 1);
                            Ringalert.show('Successfully deleted','success');
                        }else{
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.$rgDigest();
                    });
                }

                function enableSkillEditMode(index) {
                    contentIndex = index;
                    $scope.skillObjInfo = $scope.skilllist[index];
                    tmpSkill = angular.copy($scope.skilllist[index]);
                    $scope.isAddNewSkill = false;
                    $scope.isEditSkill = index;
                    $scope.$rgDigest();
                    //$scope.showAddButton = false;
                }

                function cancelUpdateSkill() {
                    $scope.skilllist[contentIndex] = tmpSkill;
                    $scope.isEditSkill = -1;
                    $scope.$rgDigest();
                    //$scope.isAddNewSkill = false;
                    //$scope.showAddButton = true;
                }


                $scope.$on('$destroy', function() {
                    //profileFactory.setProfileData('skillList', [], $scope.profileObj.getUtId());
                });

            } // END CONTROLLER FUNC

            var linkFunc = function() {

            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-skill.html',
                controller: ProfileSkillController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfilePassword', rgProfilePassword);


        function rgProfilePassword()  {

            ProfilePasswordController.$inject = [ '$scope','Ringalert', 'profileFactory'];
            function ProfilePasswordController ( $scope,Ringalert, profileFactory) { //jshint ignore:line

                $scope.enablePassEdit = enablePassEdit;
                $scope.updatePassword = updatePassword;
                $scope.cancelUpdatePassword = cancelUpdatePassword;
                $scope.showMessage = true;
                $scope.showPassEdit = false;
                $scope.IsMatch=false;
                $scope.oldError = false;

                function enablePassEdit(event) {
                    event.preventDefault();
                    if ($scope.showPassEdit === false) {
                        $scope.showPassEdit = true;
                        $scope.showMessage = false;
                    }
                    $scope.$rgDigest();
                }

                function cancelUpdatePassword() {
                    $scope.showPassEdit = false;
                    $scope.showMessage = true;
                    $scope.$rgDigest();
                }

                function updatePassword(obj) {
                    if(obj.newpassword != obj.repassword){
                        $scope.IsMatch=true;
                    }else if(obj.newpassword == obj.repassword){
                        $scope.IsMatch=false;
                        $scope.oldError = false;
                        profileFactory.changePassword(obj.oldpassword, obj.newpassword).then(function(data) {
                            RingLogger.print(data, RingLogger.tags.PROFILE);
                            if(data.sucs===true) {
                                obj = {
                                    oldpassword : '',
                                    newpassword : '',
                                    repassword : ''
                                };
                                $scope.showPassEdit = false;
                                $scope.showMessage = true;
                                Ringalert.show('Password Changed Successfully', 'info');
                            }else{
                                Ringalert.show(data.mg, 'info');
                            }


                        },function(data){
                            $scope.oldError = true;
                        });
                    }
                    $scope.$rgDigest();
                }

            } // END CONTROLLER FUNC

            var linkFunc = function() {
            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-password.html',
                controller: ProfilePasswordController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileRecovery', rgProfileRecovery);


        function rgProfileRecovery()  {

            ProfileRecoveryController.$inject = [ 'rgDropdownService','countryListService', '$scope','Ringalert', 'profileFactory','$routeParams' , 'Auth'];
            function ProfileRecoveryController ( rgDropdownService, countryListService, $scope,Ringalert, profileFactory, $routeParams, Auth) { //jshint ignore:line

                $scope.emailVerified = false;
                $scope.phoneVerified = false;
                $scope.countryList = {};

                $scope.isAddEmail = false;
                $scope.isAddPhone = false;
                $scope.addEmail = addEmail;
                $scope.addPhone = addPhone;
                $scope.isAddCode = false;
                $scope.showAddEmailButton = true;
                $scope.showAddPhoneButton = true;
                $scope.cancelAddEmail = cancelAddEmail;
                $scope.cancelAddPhone = cancelAddPhone;
                $scope.sendCode = sendCode;
                $scope.sendCodeToPhn = sendCodeToPhn;
                $scope.verifyCode = verifyCode;
                $scope.verifyPhoneCode = verifyPhoneCode;

                //$scope.resendCodeToMailOption = false;
                //$scope.resendCodeToPhoneOption = false;

                var verifyEmail;
                var mblDc;
                var phoneNumber;
                var uid = $routeParams.uId;
                $scope.emailValue = 'Verify Email';
                $scope.emailTitle = 'Click here to verify your Email';
                $scope.phoneValue = 'Verify Phone';
                $scope.phoneTitle = 'Click here to verify your Phone';

                var countryList = [];
                //$scope.ddHtml = 'pages/dropdowns/country-list-dropdown.html';
                $scope.ddTemplate =
                         '<div class="country-wrapper" >' +
                            '<ul id="countrylist" class="ringdropdown" rg-scrollbar="scrollbar()">' +
                                '<div class="count-s">' +
                                '<input type="text" ng-model="countryName" placeholder="Search Country">' +
                                '</div>' +
                                '<a ng-repeat="item in ddControl.countryList() | filter:countryName" ><li class="flag {{item.flagcode}}" ng-click="ddAction()({event: $event, item: item})" > ' +
                                '<span> {{ item.country }}</span></li></a>' +
                            '</ul>' +
                          '</div>';
                $scope.ddControl = {
                    countryList: function() {
                        return countryList;
                    }
                };

                $scope.phone = {
                    countryCode     : Auth.getCountry().login_type, //'+93'
                };
                $scope.countryFlag   = Auth.getCountry().countryFlag; //'a93';

                $scope.setPrefix = setPrefix;

                countryListService.getList().success(function (data) {
                    countryList = data;
                    $scope.$rgDigest();
                });

                //if($scope.profileObj.isCurrentUser()){
                profileFactory.verifyCheck().then(function(data){
                    if(data.sucs===true){
                        $scope.emailVerified = data.iev;
                        $scope.phoneVerified = data.imnv;
                        $scope.vemail = data.el;
                        $scope.vnumber = data.mblDc+data.mbl;

                            if($scope.emailVerified){$scope.emailValue = 'Verified Email';$scope.emailTitle = 'Your Email is verified.';}
                            if($scope.phoneVerified){$scope.phoneValue = 'Verified Phone';$scope.phoneTitle = 'Your Phone is verified.';}

                        }
                        $scope.$rgDigest();

                    });
                //}

                $scope.cancelVerification = function(){
                    $scope.isAddCode = false;
                    $scope.isAddPhnCode  = false;
                    $scope.showAddEmailButton  = true;
                    $scope.showAddPhoneButton  = true;
                    $scope.$rgDigest();
                };

                $scope.resendCodeToMail = function () {
                    profileFactory.sendCode({email:verifyEmail}).then(function(data){
                        if(data.sucs===true){
                            verifyEmail = data.el;
                            Ringalert.show(data.mg,'info');
                        }else{
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();
                    });
                };

                $scope.resendCodeToPhone = function () {
                    profileFactory.sendCodeToPhn({phone:$scope.phoneNumber,countryCode:mblDc}).then(function(data){
                        if(data.sucs===true){
                            $scope.phoneNumber = data.mbl;
                            mblDc = data.mblDc;
                            Ringalert.show(data.mg,'info');
                        }else{
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();
                    });
                };

                function setPrefix(actionObj) { //jshint ignore:line
                    actionObj.event.preventDefault();
                    $scope.phone.countryCode = actionObj.item.code;
                    $scope.countryFlag = actionObj.item.flagcode;
                    rgDropdownService.close();
                }

                function addEmail(){
                    $scope.isAddEmail = true;
                    $scope.showAddEmailButton = false;
                    $scope.$rgDigest();
                }

                function addPhone(){
                    $scope.isAddPhone = true;
                    $scope.showAddPhoneButton = false;
                    $scope.$rgDigest();
                }

                function cancelAddEmail(){
                    $scope.isAddEmail = false;
                    $scope.showAddEmailButton = true;
                    $scope.$rgDigest();
                }

                function cancelAddPhone(){
                    $scope.isAddPhone = false;
                    $scope.showAddPhoneButton = true;
                    $scope.$rgDigest();
                }

                function sendCode(email) {
                    profileFactory.sendCode(email).then(function(data){
                        if(data.sucs===true){
                            verifyEmail = data.el;
                            $scope.isAddEmail = false;
                            $scope.isAddCode = true;
                            $scope.vemail = '';
                            $scope.emailVerified = false;
                            $scope.emailTitle = 'Click here to verify your Email';
                            email.email='';
                            //$scope.resendCodeToMailOption = true;
                        }else{
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();
                    });
                }

                function sendCodeToPhn(phone) {
                    var theNumber = '';
                    if(phone.countryCode === '+880' && phone.phone.charAt(0) === '0'){
                        theNumber = phone.phone.substr(1);
                    }else{
                        theNumber = phone.phone;
                    }
                    $scope.phone.phone = theNumber;
                    profileFactory.sendCodeToPhn($scope.phone).then(function(data){
                        if(data.sucs===true){
                            $scope.phoneNumber = data.mbl;
                            mblDc = data.mblDc;
                            $scope.isAddPhone = false;
                            $scope.isAddPhnCode = true;
                            $scope.phoneVerified = false;
                            $scope.phoneTitle = 'Click here to verify your Phone';
                            phone.phone='';
                            //$scope.resendCodeToPhoneOption = true;
                            Ringalert.show(data.mg,'info');
                        }else{
                            //$scope.isAddPhone = false;
                            //$scope.isAddPhnCode = false;
                            //$scope.showAddPhoneButton = true;
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();

                    });
                }

                function verifyCode(obj) {
                    obj.email = verifyEmail;
                    profileFactory.verifyCode(obj).then(function(data){
                        if(data.sucs===true){
                            $scope.isAddEmail = false;
                            $scope.isAddCode = false;
                            $scope.showAddEmailButton = true;
                            $scope.emailVerified = true;
                            $scope.emailValue = 'Verified Email';
                            $scope.emailTitle = 'Your Email is verified.';
                            $scope.vemail = data.el;
                            obj.code = '';
                            obj.email = '';
                            Ringalert.show(data.mg,'success');
                        }else{
                            $scope.isAddEmail = false;
                            $scope.isAddCode = false;
                            $scope.showAddEmailButton = true;
                            $scope.emailVerified = false;
                            $scope.vemail = '';
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();

                    });
                }

                function verifyPhoneCode(obj) {
                    var phnObj = {};
                    phnObj.phone = $scope.phoneNumber;
                    phnObj.uId = uid;
                    phnObj.mblDc = mblDc;
                    phnObj.code = obj.code;
                    profileFactory.verifyPhnCode(phnObj).then(function(data){
                        if(data.sucs===true){
                            $scope.isAddPhone = false;
                            $scope.isAddPhnCode = false;
                            $scope.showAddPhoneButton = true;
                            $scope.phoneVerified = true;
                            $scope.phoneValue = 'Verified Phone';
                            $scope.phoneTitle = 'Your Phone is verified.';
                            obj.code ='';
                            Ringalert.show(data.mg,'success');
                        }else{
                            $scope.isAddPhone = false;
                            $scope.isAddPhnCode = false;
                            $scope.showAddPhoneButton = true;
                            $scope.phoneVerified = false;
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();

                    });
                }

            } // END CONTROLLER FUNC

            var linkFunc = function() {
            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-recovery.html',
                controller: ProfileRecoveryController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileAchat', rgProfileAchat);


    function rgProfileAchat()  {

        ProfileAchatController.$inject = [ '$scope', 'profileFactory','Auth' ];
        function ProfileAchatController ( $scope, profileFactory,Auth ) {

            $scope.isEditAchat = false;

            $scope.chatsettings = {
                achat : Auth.getPermission().ancht
            };

            $scope.enableAchatEditMode = enableAchatEditMode;
            $scope.saveAchatSettings = saveAchatSettings;
            $scope.cancelAchatSettings = cancelAchatSettings;

            function  enableAchatEditMode ($event) {
                $event.preventDefault();
                $scope.isEditAchat = true;
                $scope.$rgDigest();
            }




            function saveAchatSettings(chatsettings) {
                $scope.isEditAchat = false;

                var achatobj;
                if($scope.profileObj.isCurrentUser()){
                    achatobj = {
                        sv:chatsettings.achat,
                        sn:10
                    };
                }
                $scope.chatsettings.achat = chatsettings.achat;
                profileFactory.saveAchatSetting(achatobj).then(function(data){
                    if(data.sucs===true){
                        $scope.chatsettings.achat = chatsettings.achat;
                        Auth.setAchatPermission(chatsettings.achat);
                    }else{
                        $scope.chatsettings.achat = 0;
                    }
                });
                $scope.$rgDigest();

            }

            function cancelAchatSettings() {
                $scope.isEditAchat = false;
                $scope.$rgDigest();
            }



        } // END CONTROLLER FUNC

        var linkFunc = function() {
        };

        return {
            restrict: 'E',
            //scope: true,
            templateUrl: 'pages/profile/profile.about-achat.html',
            controller: ProfileAchatController,
            link: linkFunc
        };

    }
})();

(function(){
    'use strict';
    angular.module('ringid.profile')
        .directive('rgRelocateTemplate', function() {
            return {
                restrict: 'E',
                template: '<ng-include src="template"></ng-include>',
                link: function(scope, elem, attr) {
                    var twocol = attr.twocol;
                    var threecol = attr.threecol;
                    scope.template = threecol;


                    if (window.innerWidth > 1800 || window.innerWidth <1200 && scope.template != threecol) {
                        scope.template = threecol;
                    }
                    else if (window.innerWidth > 1200 && window.innerWidth <1800 && scope.template != twocol) {
                        scope.template = twocol;
                    }

                    window.onresize = function() {
                        if (window.innerWidth > 1800 || window.innerWidth <1200 && scope.template != threecol) {
                            scope.template = threecol;
                            scope.$apply();
                        }
                        else if (window.innerWidth > 1200 && window.innerWidth <1800 && scope.template != twocol) {
                            scope.template = twocol;
                            scope.$apply();
                        }
                    }
                }
            }
        });

})();







/*
 * © Ipvision
 */
(function() {
    'use strict';
    angular
        .module('ringid.profile')
        .service('profileFactory', profileFactory);

    profileFactory.$inject = ['$routeParams', 'Storage', 'Auth', '$$connector','$$q', 'Ringalert',
        'profileHttpService','userFactory','OPERATION_TYPES', 'fileUploadService', 'utilsFactory'];

    function profileFactory($routeParams, Storage, Auth, $$connector, $q, Ringalert, // jshint ignore:line
                            profileHttpService, userFactory,OPERATION_TYPES, fileUploadService, utilsFactory) {

        var OTYPES = OPERATION_TYPES.SYSTEM.PROFILE,
            _profile = Auth.currentUser(),
            _otherProfile = {},
            _profileData = {};


        function _addEducation(education, utId) {
            var educationObj = education;

            educationObj.fromTime = new Date(educationObj.ft);
            educationObj.toTime = new Date(educationObj.tt);

            educationObj.fromTimeE = utilsFactory.profileVerbalDate(educationObj.ft);

            educationObj.toTimeE = utilsFactory.profileVerbalDate(educationObj.tt);
            _profileData[utId].educationList.push(educationObj) ;
        }

        function _addWork(work, utId) {
            var workObj = work;
            workObj.fromTime = new Date(workObj.ft);
            workObj.toTime = new Date(workObj.tt);

            if(workObj.tt===0){
                workObj.status = true;
                workObj.date_info = 'Present';
            }else{
                workObj.toTimeE = utilsFactory.profileVerbalDate(workObj.tt);
            }
            workObj.fromTimeE = utilsFactory.profileVerbalDate(workObj.ft);
            _profileData[utId].workList.push(workObj);
        }

        function _addSkill(skill, utId) {
            var skillObj = skill;

            _profileData[utId].skillList.push(skillObj);

        }

        function _setProfileData(type, data, utId) {
            if (_profileData.hasOwnProperty(utId)) {
                switch(type) {
                    case 'educationList':
                        _addEducation(data, utId);
                         break;
                    case 'workList':
                        _addWork(data, utId);
                        break;
                    case 'skillList':
                        _addSkill(data, utId);
                        break;
                    default:
                        RingLogger.warning('could not decide what PROFILE DATA to set', RingLogger.tags.PROFILE);
                }
                //_profileData[utId][type].push(data);
            }
        }

        function _getProfileData(whatData, utId) {
            if (_profileData.hasOwnProperty(utId)) {
                return _profileData[utId][whatData];
            } else {
                return [];
            }
        }

        function _removeProfileData(utId) {
            delete _profileData[utId];
        }


        var _processResponse = function(json) {
            var i;
            switch(json.actn) {
                case OTYPES.ACTION_USERS_PRESENCE_DETAILS_DATA:
                    // update user presence detail
                    RingLogger.information('PRESENCE DETAIL', RingLogger.tags.PROFILE);
                    RingLogger.print(json, RingLogger.tags.PROFILE);
                    if(json.sucs === true) {
                        userFactory.create(json); //{psnc: json.psnc, lot: json.lot, uId: json.uId, dvc: json.dvc};
                    }
                    break;
                case OTYPES.TYPE_ACTION_GET_WORK:
                    if (json.sucs === true) {
                        for(i=0; i<json.workList.length; i++) {
                            _addWork(json.workList[i], json.workList[i].utId);
                        }
                    } else {
                        RingLogger.warning('FAILED TO FETCH ANY WORK', RingLogger.tags.PROFILE);
                        RingLogger.log(json, RingLogger.tags.PROFILE);
                    }
                    break;
                case OTYPES.TYPE_ACTION_GET_EDUCATION:
                    if (json.sucs === true) {
                        for(i=0; i<json.educationList.length; i++) {
                            _addEducation(json.educationList[i], json.educationList[i].utId);
                        }
                    } else {
                        RingLogger.warning('failed to get education list for user :' + json.utId, RingLogger.tags.PROFILE);
                        RingLogger.log(json, RingLogger.tags.PROFILE);
                    }
                    break;
                case OTYPES.TYPE_ACTION_GET_SKILL:
                    if (json.sucs === true) {
                        for(i=0; i<json.skillList.length; i++) {
                            _addSkill(json.skillList[i], json.skillList[i].utId);
                        }
                    } else {
                        RingLogger.warning('failed to get skill list for user :' + json.utId, RingLogger.tags.PROFILE);
                        RingLogger.log(json, RingLogger.tags.PROFILE);
                    }
                    break;
                default:
                    RingLogger.warning('action: ' + json.actn + ' did not match in profile factory', RingLogger.tags.PROFILE);
            }
        };

        $$connector.subscribe(_processResponse, {
            action: [
                //OTYPES.ACTION_USERS_PRESENCE_DETAILS,
                OTYPES.ACTION_USERS_PRESENCE_DETAILS_DATA,
                OTYPES.TYPE_ACTION_GET_WORK,
                OTYPES.TYPE_ACTION_GET_EDUCATION,
                OTYPES.TYPE_ACTION_GET_SKILL
            ]
        });

        function getProfile (uId) {
            if( !_profile ) {
                _profile = Auth.currentUser();
            }
            if (uId === _profile.getKey()) {
                return _profile;
            } else {
                _otherProfile = userFactory.create({uId: uId});
                return _otherProfile;
            }

        }

        function init(user) {

            var defer = $q.defer();

            //if (!user.isCurrentUser()) {
                // request for presence details
                //profileHttpService.fetchPresence([user.getKey()]);
            //}
            profileHttpService.basicAndPrivacy(user.getUtId(), user.isCurrentUser()).then(function(response) {
                RingLogger.information(response, RingLogger.tags.PROFILE);
                if (response.sucs === true) {
                    if (user.isCurrentUser()) {
                        _profile = userFactory.create(angular.extend({}, response, {uId: user.getKey()}), true, true);
                        RingLogger.information(_profile.getKey() +  ': USER PROFILE OF : ' + _profile.getName(), RingLogger.tags.PROFILE);
                    } else {
                        _otherProfile = userFactory.create(response.userDetails, true, false);
                        profileHttpService.fetchPresenceAndMood(user.getKey()).then(function(json) {
                            _otherProfile.updateUserObj(json);
                        });
                        RingLogger.information(_otherProfile.getKey() +  ': OTHER USER PROFILE OF : ' + _otherProfile.getName(), RingLogger.tags.PROFILE);
                    }
                    defer.resolve();
                } else {
                    defer.reject();
                }
            });

            return defer.promise;
        }


        function getUserDetailsByUId (uId){
            var deferred = $q.defer(),
                user = userFactory.getUser(uId);
            uId = uId || $routeParams.uId;
            RingLogger.information('Requesting user detail by UID: ' + uId, RingLogger.tags.PROFILE);
            if( !user ){

                RingLogger.information('REQUESTING: ', RingLogger.tags.PROFILE);
                var userObj = userFactory.create({uId : uId});
                profileHttpService.getUserDetails({uId : uId}).then(function(response){
                    RingLogger.information('User Fetched'+ angular.toJson(response),  RingLogger.tags.PROFILE);
                    if(!!response.sucs){
                        userObj = userFactory.create(response.userDetails);
                        deferred.resolve(userObj);
                    }else{
                        RingLogger.warning(response, RingLogger.tags.PROFILE);
                        //deferred.resolve(false);
                        deferred.reject(false);
                    }
                });

            }else{
                RingLogger.warning('getUserDetailsByUId: utid: ' + user.getUtId());
                deferred.resolve(user);
            }

            return deferred.promise;
        }

        function getUserObjectByUId(uId, callback){

            var userObj = userFactory.getUser(uId);

            if( !userObj){

                userObj = userFactory.create({uId : uId});

                profileHttpService.getUserDetails({uId : uId}).then(function(response){
                    if(!!response.sucs){
                        userFactory.create(response.userDetails);
                        if( !!callback){
                            callback.call(this);
                        }
                    }
                });
            }


            return userObj;
        }

        function getMutualFriends(friendId) {
            profileHttpService.getMutualFriends(friendId).then(function(response) {
                if(response.sucs === true) {
                    _otherProfile.updateUserObj({nmf: response.mfIDs.length});
                    RingLogger.information('MUTUAL FRIEND: ' + response.mfIDs.length, RingLogger.tags.PROFILE);
                    //for(var i=0;i< json.mfIDs.length;i++){
                        //friend = User.createByUtId({utId: json.mfIDs[i]});
                        //$scope.friends.add(friend.getKey(), friend);
                    //}
                }
            },function() {
                RingLogger.warning('MUTUAL FRIEND FETCH FAIL', RingLogger.tags.PROFILE);
            });
        }

        // get user profile details i.e. skill, work, edu etc
        function getUserProfileData(obj, isCurrent) {
            var user;
            if(isCurrent) {
                user = _profile;
            }else{
                user = userFactory.create(obj);
            }

            // only call for details if not called already
            if (!_profileData.hasOwnProperty(user.getUtId()) ) {
                _profileData[user.getUtId()] = {
                    workList: [],
                    educationList : [],
                    skillList: []
                };
                if (isCurrent) {
                    profileHttpService.getUserProfileData();
                } else {
                    profileHttpService.getUserProfileData(user.getUtId());
                }
            }
        }



        function changeProfilePicture  (obj) {
            var defer = $q.defer();
            if (!obj) {
                // existing image
                obj = {
                    iurl: _profile.avatar('iurl')
                };
            }
            // for getting cimx and cimy
            obj = angular.extend({}, obj, fileUploadService.getReposition('profilephoto'));
            RingLogger.print('log', obj, RingLogger.tags.PROFILE);
            profileHttpService.changeProfilePicture(obj).then(function (data) {
                if (data.sucs === true) {
                    Storage.updateLoginData('prIm', obj.iurl);
                    Storage.updateLoginData('prImId', data.imgId);
                    _profile.setProfileImage(obj.iurl, data.imgId);

                    defer.resolve(data);
                } else {
                    defer.reject(data);
                    RingLogger.warning('Profile picture change info sent failed!', RingLogger.tags.PROFILE);
                }
            }, function(errData) {
                defer.reject(errData);
                RingLogger.print(errData, RingLogger.tags.PROFILE);
            });
            return defer.promise;
        }

        function changeCoverPicture  (obj) {
            var defer = $q.defer();
            if (!obj) {
                // existing image
                obj = {
                    iurl: _profile.getCover('iurl')
                };
            }
            // for getting cimX and cimY
            obj = angular.extend({}, obj, fileUploadService.getReposition('coverphoto'));
            profileHttpService.changeCoverPicture(obj).then(function (data) {
                RingLogger.print(data, RingLogger.tags.PROFILE);
                if (data.sucs) {
                    RingLogger.information('change cover photo to : ' + obj.iurl, RingLogger.tags.PROFILE);
                    _profile.setCover(angular.extend(obj, {cImId: data.imgId}));
                    defer.resolve();
                } else {
                    RingLogger.information('Cover picture change info sent failed!', RingLogger.tags.PROFILE);
                    defer.reject();
                }
            }, function(errData) {
                  RingLogger.warning(errData, RingLogger.tags.PROFILE);
                  defer.reject();
            });
            return defer.promise;
        }



        function removeProfilePicture  () {
            var deferred = $q.defer();
            _profile.resetAvatar();
            profileHttpService.removeProfilePicture(_profile.avatar('iurl')).then(function (data) {
                if (data.sucs) {
                    deferred.resolve();
                }
            }, function(errData) {
                RingLogger.warning(errData, RingLogger.tags.PROFILE);
                deferred.reject('Profile picture removal failed');
            });
            return deferred.promise;
        }

        function removeCoverPicture  () {
            var deferred = $q.defer();
            _profile.resetCover();
            profileHttpService.removeCoverPicture(_profile.getCover('iurl')).then(function (data) {
                if (data.sucs) {
                    // reset cover to default cover
                    deferred.resolve();
                } else {
                    deferred.reject('Cover picture removal failed');
                }
            });
            return deferred.promise;
        }



        return {
            // api
            init: init,
            getProfile: getProfile,
            getUserDetailsByUId: getUserDetailsByUId,
            getUserObjectByUId : getUserObjectByUId,
            getMutualFriends: getMutualFriends,
            getUserProfileData: getUserProfileData,

            changeProfilePicture: changeProfilePicture,
            changeCoverPicture: changeCoverPicture,
            removeProfilePicture: removeProfilePicture,
            removeCoverPicture: removeCoverPicture,

            updateUserProfile: profileHttpService.updateProfile,
            savePvcEdit: profileHttpService.updateUserPrivacy,
            submitNewEducation: profileHttpService.submitNewEducation,

            saveAchatSetting:profileHttpService.saveAchatSetting,

            getProfileData: _getProfileData,
            setProfileData: _setProfileData,
            removeProfileData: _removeProfileData,
            deleteEducation: profileHttpService.deleteEducation,
            getAllEducation: profileHttpService.getEducationData,
            updateEducation: profileHttpService.updateEducationById,

            submitNewSkill: profileHttpService.submitNewSkill,
            updateSkill: profileHttpService.updateSkill,
            deleteSkill: profileHttpService.deleteSkill,

            submitNewWork: profileHttpService.submitNewWork,
            updateWork: profileHttpService.updateWork,
            deleteWork: profileHttpService.deleteWork,

            changePassword: profileHttpService.changePassword,
            verifyCheck: profileHttpService.verifyCheck,
            sendCode: profileHttpService.sendCode,
            sendCodeToPhn: profileHttpService.sendCodeToPhn,
            verifyCode: profileHttpService.verifyCode,
            verifyPhnCode: profileHttpService.verifyPhnCode,

            changePrivacy: profileHttpService.changePrivacy,
            saveCallPvcEdit: profileHttpService.saveCallPvcEdit,
            saveChatPvcEdit: profileHttpService.saveChatPvcEdit,
            saveFeedPvcEdit: profileHttpService.saveFeedPvcEdit,
            moodChange: profileHttpService.moodChange,

            addSocialAccount: profileHttpService.addSocialAccount

        };

    }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .controller('ProfileAboutController', ProfileAboutController);



    ProfileAboutController.$inject = ['Storage', 'rgDropdownService', '$timeout', '$scope','utilsFactory', 'friendsFactory', 'profileFactory','languageConstant',

        '$routeParams','$$connector', 'countryListService', '$templateCache','Notification' , '$authSocial', 'Ringalert'];

    function ProfileAboutController(Storage, rgDropdownService, $timeout, $scope,utilsFactory, friendsFactory, profileFactory, languageConstant, //jshint ignore:line
                                    $routeParams,$$connector, countryListService, $templateCache,Notification, $authSocial, Ringalert) {

        $scope.activeNav = 'basic';
        // for adding social account twitter,facebook to ringid account
        $scope.addSocialAccount = addSocialAccount;

        function addSocialAccount(platform) {
            $authSocial.authenticate(platform).then(function(authData) {
                RingLogger.print(authData, RingLogger.tags.PROFILE);
                profileFactory.addSocialAccount(authData).then(function(response) {
                    RingLogger.print(response, RingLogger.tags.PROFILE);
                });
            });
        }

        var tmpSkill, tmpEducation, tmpWork;
        var uid = $routeParams.uId;
        var verifyEmail;
        var mblDc;
        //$scope.showDiv = false;
        $scope.consType = languageConstant.get();


        $scope.ddHtml = 'pages/dropdowns/country-list-dropdown.html';
        $scope.status = false;
        $scope.isEditProfile = false; // profile-basic
        $scope.isEditPrivacy = false;
        $scope.isEditAbout = false;
        $scope.isEditEducation = -1;
        $scope.isEditSkill = -1;
        $scope.isEditWork = -1;
        $scope.isaddNewEducation = false;
        $scope.isAddNewSkill = false;

        $scope.emailVerified = false;
        $scope.phoneVerified = false;


        $scope.isAddNewWork = false;

        $scope.educationObj = {};
        $scope.countryList = {};

        $scope.showSuccess = false;
        $scope.oldError = false;

        $scope.educationInfo = []; // profile education
        $scope.eduObjInfo = {}; // profile education

        $scope.skillObjInfo = {};
        $scope.skillObj = {};
        $scope.skillInfo = [];

        $scope.workObjInfo = {};
        $scope.workObj = {};
        $scope.workInfo = [];

        $scope.fPrivacyInfo = {}; // profile-privacy


        $scope.enableEditMode = enableEditMode;
        $scope.enablePrivacyEditMode = enablePrivacyEditMode;
        $scope.enableAboutEditMode = enableAboutEditMode;
        $scope.enableEducationEditMode = enableEducationEditMode;
        $scope.updateAbout = updateAbout;
        $scope.updateMyBasicInfo = updateMyBasicInfo; // profile-basic
        $scope.cancelUpdateMyBasicInfo = cancelUpdateMyBasicInfo; // profile-basic
        $scope.cancelUpdateEducation = cancelUpdateEducation;
        $scope.cancelUpdatePrivacySetting = cancelUpdatePrivacySetting;
        $scope.addNewEducation = addNewEducation;
        $scope.deleteEducation = deleteEducation;
        $scope.submitNewEducation = submitNewEducation; // profile-education
        $scope.cancelAddEducation = cancelAddEducation; // profile-education
        $scope.cancelUpdateAbout = cancelUpdateAbout;
        $scope.updateEducation = updateEducation;
        //$scope.updateProfilePrivacy = updateProfilePrivacy;

        $scope.addNewSkill = addNewSkill;
        $scope.submitNewSkill = submitNewSkill;
        $scope.cancelNewSkill = cancelNewSkill;
        $scope.enableSkillEditMode = enableSkillEditMode;
        $scope.updateSkill = updateSkill;
        $scope.deleteSkill = deleteSkill;
        $scope.cancelUpdateSkill = cancelUpdateSkill;


        $scope.addNewWork = addNewWork;
        $scope.cancelNewWork = cancelNewWork;
        $scope.submitNewWork = submitNewWork;
        $scope.enableWorkEditMode = enableWorkEditMode;
        $scope.updateWork = updateWork;
        $scope.cancelUpdateWork = cancelUpdateWork;
        $scope.deleteWork = deleteWork;
        $scope.checked = false;

        $scope.showPassEdit = false;
        $scope.enablePassEdit = enablePassEdit;
        $scope.updatePassword = updatePassword;
        $scope.cancelUpdatePassword = cancelUpdatePassword;
        $scope.showMessage = true;

        //recovery settings
        $scope.isAddEmail = false;
        $scope.isAddPhone = false;
        $scope.addEmail = addEmail;
        $scope.addPhone = addPhone;
        $scope.isAddCode = false;
        $scope.showAddEmailButton = true;
        $scope.showAddPhoneButton = true;
        $scope.cancelAddEmail = cancelAddEmail;
        $scope.cancelAddPhone = cancelAddPhone;
        $scope.sendCode = sendCode;
        $scope.sendCodeToPhn = sendCodeToPhn;
        $scope.verifyCode = verifyCode;
        $scope.verifyPhoneCode = verifyPhoneCode;

        //friend privacy settings
        // profile-education
        $scope.isFrndsPrivacyEdit = false;
        $scope.frndsPrivacyEditMode = function(){ // profile-privacy not sure if needed or not
            $scope.isFrndsPrivacyEdit = true;
        };

        $scope.cancelPvcEdit = function() { // profile-privacy
            $scope.isFrndsPrivacyEdit = false;
        };

        if($scope.profileObj.isCurrentUser() || $scope.profileObj.isFriend()){ // profile-privacy not needed anyway
            $scope.showFrndsPvcEditOpt = true;
        }else{
            $scope.showFrndsPvcEditOpt = false;
        }


        $scope.savePvcEdit = function(fPrivacyInfo) { // profile-privacy
            var callobj;
            $scope.isFrndsPrivacyEdit=false;
            //call privacy settings
            if($scope.profileObj.isCurrentUser()){
                callobj = {
                    actn:216,
                    sv:fPrivacyInfo.callPrivacy,
                    sn:6,
                    isCurrent:true
                };
            }else{
                callobj = {
                    actn:82,
                    sv:fPrivacyInfo.callPrivacy,
                    sn:6,
                    utId:$scope.profileObj.getUtId(),
                    isCurrent:false
                };
            }
            $scope.fPrivacyInfo.callPrivacy = fPrivacyInfo.callPrivacy;
            $timeout(function(){
                profileFactory.saveCallPvcEdit(callobj).then(function(data){
                    //RingLogger.print('call response', RingLogger.tags.PROFILE);
                    //RingLogger.print(data, RingLogger.tags.PROFILE);
                    if(data.sucs===true){
                        $scope.fPrivacyInfo.callPrivacy = fPrivacyInfo.callPrivacy;
                    }else{
                        $scope.fPrivacyInfo.callPrivacy = 0;
                        Notification.error({message: data.mg});
                    }

                    //$scope.callPvcEdit = false;
                });
            },100);

            //chat privacy settings
            var chatobj;
            if($scope.profileObj.isCurrentUser()){
                chatobj = {
                    actn:216,
                    sv:fPrivacyInfo.chatPrivacy,
                    sn:7,
                    isCurrent:true
                };
            }else{
                chatobj = {
                    actn:82,
                    sv:fPrivacyInfo.chatPrivacy,
                    sn:7,
                    utId:$scope.profileObj.getUtId(),
                    isCurrent:false
                };
            }
            $scope.fPrivacyInfo.chatPrivacy = fPrivacyInfo.chatPrivacy;
            $timeout(function(){
                profileFactory.saveChatPvcEdit(chatobj).then(function(data){
                    //RingLogger.print('chat response', RingLogger.tags.PROFILE);
                    //RingLogger.print(data, RingLogger.tags.PROFILE);
                    if(data.sucs===true){
                        $scope.fPrivacyInfo.chatPrivacy = fPrivacyInfo.chatPrivacy;
                    }else{
                        $scope.fPrivacyInfo.chatPrivacy = 0;
                    }

                    //$scope.chatPvcEdit = false;
                });
            },200);

            //feed privacy settings
            var feedObj;
            if($scope.profileObj.isCurrentUser()){
                feedObj = {
                    actn:216,
                    sv:fPrivacyInfo.feedPrivacy,
                    sn:8,
                    isCurrent:true
                };
            }else{
                feedObj = {
                    actn:82,
                    sv:fPrivacyInfo.feedPrivacy,
                    sn:8,
                    utId:$scope.profileObj.getUtId(),
                    isCurrent:false
                };
            }
            $scope.fPrivacyInfo.feedPrivacy = fPrivacyInfo.feedPrivacy;
            $timeout(function(){
                profileFactory.saveFeedPvcEdit(feedObj).then(function(data){
                    //RingLogger.print('feed response', RingLogger.tags.PROFILE);
                    //RingLogger.print(data, RingLogger.tags.PROFILE);
                    if(data.sucs===true){
                        $scope.fPrivacyInfo.feedPrivacy = fPrivacyInfo.feedPrivacy;
                    }else{
                        $scope.fPrivacyInfo.feedPrivacy = 0;
                    }

                    //$scope.feedPvcEdit = false;
                });
            },300);

        };

        //cancel code verification
        $scope.cancelVerification = function(){
            $scope.isAddCode = false;
            $scope.isAddPhnCode  = false;
            $scope.showAddEmailButton  = true;
            $scope.showAddPhoneButton  = true;
        };



        $scope.callPvcEditMode = callPvcEditMode;
        $scope.callPvcEdit = false; // profile-privacy
        $scope.saveCallPvcEdit = saveCallPvcEdit;
        $scope.cancelCallPvcEdit = cancelCallPvcEdit;

        $scope.chatPvcEditMode = chatPvcEditMode;
        $scope.chatPvcEdit = false; // profile-privacy
        $scope.saveChatPvcEdit = saveChatPvcEdit;
        $scope.cancelChatPvcEdit = cancelChatPvcEdit;

        $scope.feedPvcEditMode = feedPvcEditMode;
        $scope.feedPvcEdit = false; // profile-privacy
        $scope.saveFeedPvcEdit = saveFeedPvcEdit;
        $scope.cancelFeedPvcEdit = cancelFeedPvcEdit;

        $scope.emailValue = 'Verify Email';
        $scope.emailTitle = 'Click here to verify your Email';
        $scope.phoneValue = 'Verify Phone';
        $scope.phoneTitle = 'Click here to verify your Phone';

        //$scope.basicAndPrivacy = basicAndPrivacy;

        //$scope.message = message;
        $scope.profileObj = profileFactory.getProfile(uid);
        //RingLogger.information($scope.profileObj.getBasicInfo().bDay, RingLogger.tags.PROFILE);
        //if($scope.profileObj)

        //default settings // profile-privacy block
        $scope.fPrivacyInfo.callPrivacy = 0;
        $scope.fPrivacyInfo.chatPrivacy = 0;
        $scope.fPrivacyInfo.feedPrivacy = 0;

        $scope.ddControl = {
            listData: []
        };

        $scope.phone = {
            countryCode     : '+93'
        };
        $scope.countryFlag   = 'a93';

        $scope.setPrefix = setPrefix;

        countryListService.getList().success(function (data) {
            $scope.ddControl.countryList = data;
        });

        function setPrefix(actionObj) { //jshint ignore:line
            RingLogger.print(actionObj, RingLogger.tags.PROFILE);
            actionObj.event.preventDefault();
            $scope.phone.countryCode = actionObj.item.code;
            $scope.countryFlag = actionObj.item.flagcode;
            rgDropdownService.close();
        }


        $scope.basicInfo = $scope.profileObj.getBasicInfo(); // profile-basic

        if($scope.profileObj.isCurrentUser()){ // profile-privacy
            profileFactory.verifyCheck().then(function(data){
                if(data.sucs===true){
                    $scope.emailVerified = data.iev;
                    $scope.phoneVerified = data.imnv;

                    $scope.fPrivacyInfo.callPrivacy = data.cla;
                    $scope.fPrivacyInfo.chatPrivacy = data.chta;
                    $scope.fPrivacyInfo.feedPrivacy = data.fda;

                    if($scope.emailVerified){$scope.emailValue = 'Verified Email';$scope.emailTitle = 'Your Email is verified.';}
                    if($scope.phoneVerified){$scope.phoneValue = 'Verified Phone';$scope.phoneTitle = 'Your Phone is verified.';}

                }

            });
        }else{
            $scope.access = $scope.profileObj.getAccess;
            $scope.fPrivacyInfo.callPrivacy = $scope.profileObj.getAccess().cla;
            $scope.fPrivacyInfo.chatPrivacy = $scope.profileObj.getAccess().chta;
            $scope.fPrivacyInfo.feedPrivacy = $scope.profileObj.getAccess().fda;
            if( !$scope.fPrivacyInfo.callPrivacy && !$scope.fPrivacyInfo.chatPrivacy && !$scope.fPrivacyInfo.feedPrivacy ) {
                $scope.profileObj.setBlock(1);
            }
        }





        //$scope.privacyInfo = profileFactory.profile.getPrivacyInfo();
        // USE USERMAP API CALL TO SET PRIVACY
            //$timeout(function() {
                //$scope.myPrivacySettings = profileFactory.myPrivacySettings().then(function(data){
                    ////RingLogger.print(data, RingLogger.tags.PROFILE);
                    //$scope.fPrivacyInfo.callPrivacy = data.cla;
                    //$scope.fPrivacyInfo.chatPrivacy = data.chta;
                    //$scope.fPrivacyInfo.feedPrivacy = data.fda;
                //});
            //}, 200);



        //datepicker // full block profile-basic
        $scope.isDatePickerOpen = false;
        $scope.model = {};

        $scope.open = function($event, elementOpened) {
            RingLogger.print(elementOpened, RingLogger.tags.PROFILE);
            $event.preventDefault();
            $event.stopPropagation();
            switch(elementOpened){
                case 'wcalendar':
                    $scope.model.wcalendarTo = false;
                    break;
                case 'wcalendarTo':
                    $scope.model.wcalendar = false;
                    break;
                case 'ecalendar':
                    $scope.model.ecalendarTo = false;
                    break;
                case 'ecalendarTo':
                    $scope.model.ecalendar = false;
                    break;
                case 'mcalendar':
                    $scope.model.mcalendar = false;
                    break;
            }
            $scope.model[elementOpened] = !$scope.model[elementOpened];

        };
        $scope.dateOptions = {
            showWeeks:'false',
            startingDay: 1
        };






        profileFactory.getUserProfileData({uId:uid},$scope.profileObj.isCurrentUser());


        function profiledata(data){
            var workObj,
                educationObj,
                skillObj,
                ftime,
                ttime,
                fDate,
                tDate;
            //RingLogger.print(data, RingLogger.tags.PROFILE);
            var utid = data.utId, i;
            if(data.actn===234){
                if (data.sucs === true && data.utId===utid) {
                    for(i=0; i<data.workList.length; i++) {
                        //RingLogger.print(data.workList[i], RingLogger.tags.PROFILE);
                        workObj = data.workList[i];
                        ftime = workObj.ft;
                        ttime = workObj.tt;
                        workObj.fromTime = new Date(ftime);
                        workObj.toTime = new Date(ttime);

                        if(workObj.tt===0){
                            workObj.status = true;
                            workObj.date_info = 'Present';
                        }else{
                            tDate = utilsFactory.profileVerbalDate(ttime);
                            workObj.toTimeE = tDate;
                        }
                        fDate = utilsFactory.profileVerbalDate(ftime);
                        workObj.fromTimeE = fDate;

                        $scope.workInfo.push(workObj);
                    }
                }else{
                    for(i=0; i<data.workList.length; i++) {
                        workObj = data.workList[i];
                        ftime = workObj.ft;
                        ttime = workObj.tt;
                        workObj.fromTime = new Date(ftime);
                        workObj.toTime = new Date(ttime);

                        if(workObj.tt===0){
                            workObj.status = true;
                            workObj.date_info = 'Present';
                        }else{

                            tDate = utilsFactory.profileVerbalDate(ttime);
                            workObj.toTimeE = tDate;
                        }

                        fDate = utilsFactory.profileVerbalDate(ftime);
                        workObj.fromTimeE = fDate;

                        $scope.workInfo.push(workObj);
                    }
                    RingLogger.print('failed', RingLogger.tags.PROFILE);
                }
            }
            if(data.actn===235){
                if (data.sucs === true && data.utId===utid) {
                    for(i=0; i<data.educationList.length; i++) {
                        //RingLogger.print(data.educationList[i], RingLogger.tags.PROFILE);
                        educationObj = data.educationList[i];
                        ftime = educationObj.ft;
                        ttime = educationObj.tt;

                        educationObj.fromTime = new Date(ftime);
                        educationObj.toTime = new Date(ttime);

                        fDate = utilsFactory.profileVerbalDate(ftime);
                        educationObj.fromTimeE = fDate;

                        tDate = utilsFactory.profileVerbalDate(ttime);
                        educationObj.toTimeE = tDate;
                        $scope.educationInfo.push(educationObj);
                    }
                }else{
                    for(i=0; i<data.educationList.length; i++) {
                        //RingLogger.print(data.educationList[i], RingLogger.tags.PROFILE);
                        educationObj = data.educationList[i];
                        ftime = educationObj.ft;
                        ttime = educationObj.tt;

                        educationObj.fromTime = new Date(educationObj.ft);
                        educationObj.toTime = new Date(educationObj.tt);

                        fDate = utilsFactory.profileVerbalDate(ftime);
                        educationObj.fromTimeE = fDate;

                        tDate = utilsFactory.profileVerbalDate(ttime);
                        educationObj.toTimeE = tDate;
                        $scope.educationInfo.push(educationObj);
                    }
                    RingLogger.print('failed', RingLogger.tags.PROFILE);
                }
            }
            if(data.actn===236){
                if (data.sucs === true && data.utId===utid) {
                    for(i=0; i<data.skillList.length; i++) {
                        skillObj = data.skillList[i];
                        skillObj.fromTime = new Date(skillObj.ft);
                        skillObj.toTime = new Date(skillObj.tt);
                        $scope.skillInfo.push(skillObj);
                    }
                }else{
                    for(i=0; i<data.skillList.length; i++) {
                        skillObj = data.skillList[i];
                        skillObj.fromTime = new Date(skillObj.ft);
                        skillObj.toTime = new Date(skillObj.tt);
                        $scope.skillInfo.push(skillObj);
                    }

                    RingLogger.print('failed', RingLogger.tags.PROFILE);
                }
            }
        }
        $$connector.subscribe(profiledata,{
            action: [234,235,236]
        });

        //dropdown action directive start
        $scope.ddActionHtml = 'pages/dropdowns/action-dropdown.html';//$templateCache.get('action-dropdown.html');
        //$scope.ddCommentHtml = $templateCache.get('comment-edit-dropdown.html');

        $scope.actionSkillDropdown = function(actionObj) {

            actionObj.event.preventDefault();
            switch(actionObj.action) {
                case 'edit':
                    enableSkillEditMode(actionObj.event, actionObj.data.index);
                    break;
                case 'delete':
                    deleteSkill(actionObj.data.obj);
                    break;
                default:
            }
        };

        $scope.actionEduDropdown = function(actionObj) {

            actionObj.event.preventDefault();
            switch(actionObj.action) {
                case 'edit':
                    enableEducationEditMode(actionObj.event, actionObj.data.index);
                    break;
                case 'delete':
                    deleteEducation(actionObj.data.obj);
                    break;
                default:
            }
        };

        $scope.actionWorkDropdown = function(actionObj) {

            actionObj.event.preventDefault();

            switch(actionObj.action) {
                case 'edit':
                    enableWorkEditMode(actionObj.event, actionObj.data.index);
                    break;
                case 'delete':
                    deleteWork(actionObj.data.obj);
                    break;
                default:
            }
        };

        function callPvcEditMode() { //jshint ignore:line
            $scope.callPvcEdit = true;
        }
        function cancelCallPvcEdit() {
            $scope.callPvcEdit = false;
        }

        function saveCallPvcEdit() {
            var obj;
            if($scope.profileObj.isCurrentUser()){
                obj = {
                    actn:216,
                    sv:$scope.fPrivacyInfo.call,
                    sn:6,
                    isCurrent:true
                };
            }else{
                obj = {
                    actn:82,
                    sv:$scope.fPrivacyInfo.call,
                    sn:6,
                    utId:$scope.profileObj.getUtId(),
                    isCurrent:false
                };
            }
            //RingLogger.print(obj, RingLogger.tags.PROFILE);
            profileFactory.saveCallPvcEdit(obj).then(function(data){
                //RingLogger.print(data, RingLogger.tags.PROFILE);
                $scope.fPrivacyInfo.callPrivacy = $scope.fPrivacyInfo.call;
                $scope.callPvcEdit = false;
            });
        }

        function chatPvcEditMode() {
            $scope.chatPvcEdit = true;
        }
        function cancelChatPvcEdit() {
            $scope.chatPvcEdit = false;
        }

        function saveChatPvcEdit() {
            var obj;
            if($scope.profileObj.isCurrentUser()){
                obj = {
                    actn:216,
                    sv:$scope.fPrivacyInfo.chat,
                    sn:7,
                    isCurrent:true
                };
            }else{
                obj = {
                    actn:82,
                    sv:$scope.fPrivacyInfo.chat,
                    sn:7,
                    utId:$scope.profileObj.getUtId(),
                    isCurrent:false
                };
            }
            //RingLogger.print(obj, RingLogger.tags.PROFILE);
            profileFactory.saveChatPvcEdit(obj).then(function(data){
                //RingLogger.print(data, RingLogger.tags.PROFILE);
                $scope.fPrivacyInfo.chatPrivacy = $scope.fPrivacyInfo.chat;
                $scope.chatPvcEdit = false;
            });
        }

        function feedPvcEditMode() {
            $scope.feedPvcEdit = true;
        }
        function cancelFeedPvcEdit() {
            $scope.feedPvcEdit = false;
        }

        function saveFeedPvcEdit(obj) {
            RingLogger.print(obj, RingLogger.tags.PROFILE);
            if($scope.profileObj.isCurrentUser()){
                obj = {
                    actn:216,
                    sv:$scope.fPrivacyInfo.feed,
                    sn:8,
                    isCurrent:true
                };
            }else{
                obj = {
                    actn:82,
                    sv:$scope.fPrivacyInfo.feed,
                    sn:8,
                    utId:$scope.profileObj.getUtId(),
                    isCurrent:false
                };
            }
            profileFactory.saveFeedPvcEdit(obj).then(function(data){
                //RingLogger.print(data, RingLogger.tags.PROFILE);
                $scope.fPrivacyInfo.feedPrivacy = $scope.fPrivacyInfo.feed;
                $scope.feedPvcEdit = false;
            });
        }

        function addEmail(){
            $scope.isAddEmail = true;
            $scope.showAddEmailButton = false;
        }

        function addPhone(){
            $scope.isAddPhone = true;
            $scope.showAddPhoneButton = false;
        }

        function cancelAddEmail(){
            $scope.isAddEmail = false;
            $scope.showAddEmailButton = true;
        }

        function cancelAddPhone(){
            $scope.isAddPhone = false;
            $scope.showAddPhoneButton = true;
        }

        function sendCode(email) {
            profileFactory.sendCode(email).then(function(data){
                RingLogger.print(email, RingLogger.tags.PROFILE);
                verifyEmail = data.el;
                $scope.isAddEmail = false;
                $scope.isAddCode = true;
                Notification.success({message: data.mg});
            });
        }

        function sendCodeToPhn(phone) {
            RingLogger.print(phone, RingLogger.tags.PROFILE);
            $scope.phone.number = phone.phone;
            RingLogger.print($scope.phone, RingLogger.tags.PROFILE);

            profileFactory.sendCodeToPhn($scope.phone).then(function(data){
                RingLogger.print(data, RingLogger.tags.PROFILE);
                if(data.sucs===true){
                    $scope.phoneNumber = data.mbl;
                    mblDc = data.mblDc;
                    $scope.isAddPhone = false;
                    $scope.isAddPhnCode = true;
                    Notification.success({message: data.mg});
                }else{
                    $scope.isAddPhone = false;
                    $scope.isAddPhnCode = false;
                    $scope.showAddPhoneButton = true;
                    $scope.phoneVerified = false;
                    Notification.error({message: data.mg});
                }

            });
        }

        function verifyCode(obj) {
            RingLogger.print(obj, RingLogger.tags.PROFILE);
            obj.email = verifyEmail;
            profileFactory.verifyCode(obj).then(function(data){
                RingLogger.print(data, RingLogger.tags.PROFILE);
                if(data.sucs===true){
                    $scope.isAddEmail = false;
                    $scope.isAddCode = false;
                    $scope.showAddEmailButton = true;
                    $scope.emailVerified = true;
                    $scope.emailValue = 'Verified Email';
                    $scope.emailTitle = 'Your Email is verified.';
                    RingLogger.print(data.mg, RingLogger.tags.PROFILE);
                }else{
                    $scope.isAddEmail = false;
                    $scope.isAddCode = false;
                    $scope.showAddEmailButton = true;
                    $scope.emailVerified = false;
                }

            });
        }

        function verifyPhoneCode(obj) {
            var phnObj = {};
            phnObj.phone = $scope.phoneNumber;
            phnObj.uId = uid;
            phnObj.mblDc = mblDc;
            phnObj.code = obj.code;
            RingLogger.print(phnObj, RingLogger.tags.PROFILE);
            profileFactory.verifyPhnCode(phnObj).then(function(data){
                RingLogger.print(data, RingLogger.tags.PROFILE);
                if(data.sucs===true){
                    $scope.isAddPhone = false;
                    $scope.isAddPhnCode = false;
                    $scope.showAddPhoneButton = true;
                    $scope.phoneVerified = true;
                    $scope.phoneValue = 'Verified Phone';
                    $scope.phoneTitle = 'Your Phone is verified.';
                }else{
                    $scope.isAddPhone = false;
                    $scope.isAddPhnCode = false;
                    $scope.showAddPhoneButton = true;
                    $scope.phoneVerified = false;
                }

                RingLogger.print(data.mg, RingLogger.tags.PROFILE);
            });
        }

        function enableEditMode(event) { // profile-basic
            event.preventDefault();
            $scope.tmpBasic = angular.copy($scope.profileObj.getBasicInfo());
            if($scope.tmpBasic.mDay==1){
                $scope.tmpBasic.marriageDay = null;
            }
            if($scope.tmpBasic.birthDay==1){
                $scope.tmpBasic.birthday = null;
            }
            if ($scope.isEditProfile === false) {
                $scope.isEditProfile = true;
            }
        }

        function enablePrivacyEditMode(event) {
            event.preventDefault();
            $scope.tmpPrivacy = angular.copy($scope.privacyInfo);
            if ($scope.isEditPrivacy === false) {
                $scope.isEditPrivacy = true;
            }
        }

        function enableAboutEditMode(event) {
            event.preventDefault();
            if ($scope.isEditAbout === false) {
                $scope.isEditAbout = true;
            }
        }

        function addNewEducation(){ // profile-education
            $scope.isaddNewEducation = true;
            $scope.isEditEducation = -1;
        }

        function submitNewEducation() { // profile-education
            var fromTime   = $scope.eduObjInfo.ft;
            var toTime     = $scope.eduObjInfo.tt;

            var fDate = utilsFactory.profileVerbalDate(fromTime);
            $scope.eduObjInfo.ft = new Date(fDate).getTime();//will alert something like 1330192800000

            var tDate = utilsFactory.profileVerbalDate(toTime);

            $scope.eduObjInfo.tt = new Date(tDate).getTime();//will alert something like 1330192800000

            $scope.eduObjInfo.ut = new Date().getTime();
            //$scope.eduObjInfo.desc = 'description';
            $scope.eduObjInfo.af = 1;
            $scope.eduObjInfo.grtd = true;
            $scope.eduObjInfo.iss = true;

            profileFactory.submitNewEducation($scope.eduObjInfo).then(function(data) {
                //RingLogger.print(data, RingLogger.tags.PROFILE);

                $scope.eduObjInfo.id = data.id;
                $scope.eduObjInfo.fromTime = fromTime;
                $scope.eduObjInfo.toTime = toTime;



                var fDate = utilsFactory.profileVerbalDate(fromTime);
                $scope.eduObjInfo.fromTimeE = fDate;



                var tDate = utilsFactory.profileVerbalDate(toTime);
                $scope.eduObjInfo.toTimeE = tDate;

                $scope.educationInfo.push(angular.copy($scope.eduObjInfo));

                $scope.eduObjInfo.id = 0;
                $scope.eduObjInfo.scl='';
                $scope.eduObjInfo.dgr='';
                $scope.eduObjInfo.cntn='';
                $scope.eduObjInfo.ft='';
                $scope.eduObjInfo.tt='';

                $scope.isaddNewEducation = false;
            });

        }



        function updateAbout(event) {

        }

        /* skill methods */

        function addNewSkill(event) {
            $scope.isAddNewSkill = true;
            $scope.isEditSkill = -1;
        }

        function submitNewSkill() {
            profileFactory.submitNewSkill($scope.skillObjInfo).then(function(data) {
                RingLogger.print(data, RingLogger.tags.PROFILE);
                //var response = angular.fromJson(data);
                $scope.skillObjInfo.id = data.id;
                $scope.skillInfo.push(angular.copy($scope.skillObjInfo));

                $scope.skillObjInfo.id = 0;
                $scope.skillObjInfo.skl='';
                $scope.skillObjInfo.desc='';
                $scope.isAddNewSkill = false;
            });
            //$scope.isAddNewSkill = false;
        }

        function enableSkillEditMode(event, index) {
            event.preventDefault();
            $scope.isAddNewSkill = false;
            tmpSkill = angular.copy($scope.skillInfo[index]);
            $scope.isEditSkill = index;

        }

        function cancelNewSkill() {
            $scope.skillObjInfo.skl='';
            $scope.skillObjInfo.desc='';
            $scope.isAddNewSkill = false;

        }

        function updateSkill(obj) {
            profileFactory.updateSkill(obj).then(function(){
                RingLogger.print(obj, RingLogger.tags.PROFILE);
                $scope.isEditSkill = -1;
            });
        }

        function deleteSkill(obj) {
            $scope.isEditSkill = -1;
            profileFactory.deleteSkill(obj).then(function(){
                var index = $scope.skillInfo.indexOf(obj);
                $scope.skillInfo.splice(index,1);
            });
        }

        function cancelUpdateSkill(index) {
            $scope.isEditSkill = '';
            $scope.skillInfo[index] = tmpSkill;
        }

        /* work methods*/

        function addNewWork () {
            $scope.isAddNewWork = true;
            $scope.isEditWork = -1;
        }

        function cancelNewWork () {
            $scope.workObjInfo.cnm = '';
            $scope.workObjInfo.pstn = '';
            $scope.workObjInfo.ct = '';
            $scope.workObjInfo.desc = '';
            $scope.workObjInfo.ft = '';
            $scope.workObjInfo.tt = '';
            $scope.isAddNewWork = false;
        }

        function submitNewWork() {

            var fromTime = $scope.workObjInfo.ft;
            var toTime = $scope.workObjInfo.tt;

            var fDate = utilsFactory.profileVerbalDate(fromTime);
            $scope.workObjInfo.ft = new Date(fDate).getTime();//will alert something like 1330192800000

            //to date
            if($scope.checked === true){
                $scope.workObjInfo.tt = '0000000000000';
                $scope.workObjInfo.status = true;
                $scope.workObjInfo.date_info = 'Present';
                toTime = 0;

            }else{
                $scope.workObjInfo.status = false;

                var tDate = utilsFactory.profileVerbalDate(toTime);

                $scope.workObjInfo.tt = new Date(tDate).getTime();//will alert something like 1330192800000
            }

            profileFactory.submitNewWork($scope.workObjInfo).then(function(data) {
                //RingLogger.print(data, RingLogger.tags.PROFILE);
                if(data.sucs == true){
                    $scope.workObjInfo.id = data.id;

                    $scope.workObjInfo.fromTime = fromTime;
                    $scope.workObjInfo.toTime = toTime;

                    var fDate = utilsFactory.profileVerbalDate(fromTime);
                    $scope.workObjInfo.fromTimeE = fDate;

                    if($scope.checked !== true) {
                        var tDate = utilsFactory.profileVerbalDate(toTime);
                        $scope.workObjInfo.toTimeE = tDate;
                    }

                    $scope.workInfo.push(angular.copy($scope.workObjInfo));

                    $scope.workObjInfo.cnm = '';
                    $scope.workObjInfo.pstn = '';
                    $scope.workObjInfo.ct = '';
                    $scope.workObjInfo.desc = '';
                    $scope.workObjInfo.ft = '';
                    $scope.workObjInfo.tt = '';

                    $scope.isAddNewWork = false;
                    $scope.isEditWork = -1;
                }else{
                    $scope.isAddNewWork = false;
                    $scope.isEditWork = -1;
                    alert('Failed ! Please Try again.');
                }


            });
        }

        function enableWorkEditMode(event,index) {
            event.preventDefault();
            $scope.isAddNewWork = false;
            $scope.isEditWork = index;
            if($scope.workInfo[index].tt==1){
                $scope.workInfo[index].toTimeE = null;
            }
            if($scope.workInfo[index].ft==1){
                $scope.workInfo[index].fromTimeE = null;
            }
            tmpWork = angular.copy($scope.workInfo[index]);
        }

        function cancelUpdateWork(index) {
            $scope.isEditWork = '';
            $scope.workInfo[index] = tmpWork;
        }

        function updateWork(obj) {

            obj.ft = new Date(obj.fromTimeE).getTime();//will alert something like 1330192800000

            if(obj.status === true){
                obj.tt = '0000000000000';
                obj.date_info = 'Present';
            }else{
                obj.tt = new Date(obj.toTimeE).getTime();//will alert something like 1330192800000
            }

            profileFactory.updateWork(obj).then(function(data){
                RingLogger.print(data, RingLogger.tags.PROFILE);
                if(data.sucs == true){
                    if(obj.ft){
                        obj.fromTime = new Date(obj.ft);
                    }else{
                        obj.ft = 1;
                    }
                    if(obj.tt){
                        obj.toTime = new Date(obj.tt);
                    }else{
                        obj.tt = 1;
                    }
                    $scope.isEditWork = -1;
                }else{
                    Ringalert.show('Failed ! Please Try Again','info');
                }

            });
        }

        function deleteWork(obj) {
            $scope.isEditWork = -1;
            profileFactory.deleteWork(obj).then(function(){
                var index = $scope.workInfo.indexOf(obj);
                $scope.workInfo.splice(index,1);
            });
        }

        /* education methods*/

        function cancelAddEducation(){
            $scope.eduObjInfo.scl='';
            $scope.eduObjInfo.dgr='';
            $scope.eduObjInfo.cntn='';
            $scope.eduObjInfo.ft='';
            $scope.eduObjInfo.tt='';
            $scope.isaddNewEducation = false;
        }

        function enableEducationEditMode(event,index) {

            event.preventDefault();

            if($scope.educationInfo[index].tt==1){
                $scope.educationInfo[index].toTimeE = null;
            }
            if($scope.educationInfo[index].ft==1){
                $scope.educationInfo[index].fromTimeE = null;
            }
            tmpEducation = angular.copy($scope.educationInfo[index]);
            $scope.isaddNewEducation = false;
            $scope.isEditEducation = index;

        }

        function updateEducation(obj) {

            obj.ft = new Date(obj.fromTimeE).getTime();//will alert something like 1330192800000

            obj.tt = new Date(obj.toTimeE).getTime();//will alert something like 1330192800000

            profileFactory.updateEducation(obj).then(function(data){
                RingLogger.print(data, RingLogger.tags.PROFILE);

                if(data.sucs==true){
                    if(obj.ft){
                        obj.fromTime = new Date(obj.ft);
                    }else{
                        obj.ft = 1;
                    }
                    if(obj.tt){
                        obj.toTime = new Date(obj.tt);
                    }else{
                        obj.tt = 1;
                    }

                    $scope.isEditEducation = -1;
                }else{
                    Ringalert.show('Failed ! Please Try Again','info');
                }

            });
        }

        function cancelUpdateEducation(index) {
            $scope.isEditEducation = '';
            $scope.educationInfo[index] = tmpEducation;
        }

        function deleteEducation(edu) {
            $scope.isEditEducation = -1;
            profileFactory.deleteEducation(edu.id).then(function(data){
                RingLogger.print(data, RingLogger.tags.PROFILE);
                var index = $scope.educationInfo.indexOf(edu);
                $scope.educationInfo.splice(index,1);
            });
        }

        function updateMyBasicInfo() { // profile-basic
            var mdateobj = $scope.tmpBasic.marriageDay;
            if(mdateobj==null){
                mdateobj = 1;
            }
            var dateobj;
            $scope.basicInfo = $scope.tmpBasic;

            var datetype = typeof($scope.basicInfo.birthday);
            var mdatetype = typeof(mdateobj);
            RingLogger.print(datetype, RingLogger.tags.PROFILE);
            if(datetype==='string'){
                var data = $scope.basicInfo.birthday.split('-');
                var bdDate = parseInt(data[0])+','+parseInt(data[1])+','+parseInt(data[2]);
                dateobj = new Date(bdDate);
            }else{
                dateobj = $scope.basicInfo.birthday;

                var frTime = utilsFactory.profileVerbalDate($scope.basicInfo.birthDay);
                $scope.basicInfo.birthday = frTime;
            }
            if(mdatetype === 'string'){
                var mdata = mdateobj.split('-');
                var mDate = parseInt(mdata[0])+','+parseInt(mdata[1])+','+parseInt(mdata[2]);
                mdateobj = new Date(mDate);
            }


            profileFactory.updateUserProfile($scope.uId,$scope.basicInfo,dateobj,mdateobj).then(function(data){
                RingLogger.print(data, RingLogger.tags.PROFILE);
                if(data.sucs===true){
                    $scope.basicInfo.birthDay = dateobj ? dateobj.getTime() : '1';
                    if( typeof(dateobj) ==='object' ){
                        $scope.currentUser.setBirthday($scope.basicInfo.birthDay);
                    }else{
                        $scope.currentUser.setBirthday('1');
                    }
                    if( mdatetype ==='object' ){
                        $scope.currentUser.setMarriageday(mdateobj.getTime());
                    }else{
                        $scope.currentUser.setMarriageday('1');
                    }


                    $scope.profileObj.getBasicInfo().birthDay = $scope.basicInfo.birthDay;

                    $scope.currentUser.setName($scope.basicInfo.fn);
                    $scope.currentUser.setHomeCity($scope.basicInfo.hc);
                    $scope.currentUser.setCurrentCity($scope.basicInfo.cc);
                    $scope.currentUser.setAboutMe($scope.basicInfo.am);
                    Storage.updateLoginData('fn', $scope.basicInfo.fn);
                    $scope.currentUser.setGender($scope.basicInfo.gr);

                    $scope.isEditProfile = false;
                    $scope.isOwner = true;
                }else{
                    RingLogger.print('something went wrong', RingLogger.tags.PROFILE);
                }
            });
        }

        //function updateProfilePrivacy() {
            //profileFactory.updateUserPrivacy($scope.currentUser,$scope.privacyInfo).then(function(data){
                //RingLogger.print(data, RingLogger.tags.PROFILE);
            //});
            //if($scope.privacyInfo.suggestion === 'true'){
                //var sugObj = {};
                //sugObj.operation = 9;
                //sugObj.sn =3 ;
                //sugObj.sv =1 ;
                //profileFactory.frndSuggestion(sugObj);

            //}else if($scope.privacyInfo.suggestion === 'false'){
                //var sugObj = {};
                //sugObj.operation = 9;
                //sugObj.sn =3 ;
                //sugObj.sv =0 ;
                //profileFactory.frndSuggestion(sugObj);
            //}
            //$scope.isEditPrivacy = false;
        //}

        function cancelUpdateMyBasicInfo() { // profile-basic
            $scope.basicInfo = $scope.tmpBasic;
            $scope.isEditProfile = false;
            $scope.isOwner = true;
        }

        function cancelUpdateAbout() {
            $scope.isEditAbout = false;
        }

        function cancelUpdatePrivacySetting() {
            $scope.privacyInfo = $scope.tmpPrivacy;
            $scope.isEditPrivacy = false;
        }

        function enablePassEdit(event) {
            event.preventDefault();
            if ($scope.showPassEdit === false) {
                $scope.showPassEdit = true;
                $scope.showMessage = false;
            }
        }

        function updatePassword(obj) {
            if(obj.newpassword != obj.repassword){
                $scope.IsMatch=true;
            }else if(obj.newpassword == obj.repassword){
                $scope.IsMatch=false;
                $scope.oldError = false;
                profileFactory.changePassword(obj.oldpassword, obj.newpassword).then(function(data) {
                    RingLogger.print(data, RingLogger.tags.PROFILE);
                    if(data.sucs===true) {
                        obj = {
                            oldpassword : '',
                            newpassword : '',
                            repassword : ''
                        };
                        $scope.showPassEdit = false;
                        $scope.showMessage = true;

                        Notification.success({message: 'Password Changed SuccessFully'});
                    }else{
                        Notification.success({message: data.mg});
                    }


                },function(data){
                    $scope.oldError = true;
                });
            }

        }

        function cancelUpdatePassword(obj) {
            obj.oldpassword = '';
            obj.newpassword = '';
            obj.repassword = '';
            $scope.IsMatch = false;
            $scope.showPassEdit = false;
            $scope.showMessage = true;
        }

    }
})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.chat', [
            'ringid.config',
            'ringid.common.stacked_map',
            'ngWebSocket',
            'ringid.utils',
            'ringid.common.rgemoticon_directive',
            'ringid.connector',
            'ringid.common.rgupload_directive',
            'ringid.tagchat',

            'angularAudioRecorder'
        ])
        .config(['recorderServiceProvider', function(recorderServiceProvider){
            //configure here
        }]);
})();

/*###################################################################################################################################*/

/*
 * ngDialog - easy modals and popup windows
 * http://github.com/likeastore/ngDialog
 * (c) 2013-2015 MIT License, https://likeastore.com
 */

//(function (root, factory) {
//    if (typeof module !== 'undefined' && module.exports) {
//        // CommonJS
//        module.exports = factory(require('angular'));
//    } else if (typeof define === 'function' && define.amd) {
//        // AMD
//        define(['angular'], factory);
//    } else {
//        // Global Variables
//        factory(root.angular);
//    }
//}(this, function (angular, undefined) {
//    'use strict';
//
//    var m = angular.module('ngDialog', []);
//
//    var $el = angular.element;
//    var isDef = angular.isDefined;
//    var style = (document.body || document.documentElement).style;
//    var animationEndSupport = isDef(style.animation) || isDef(style.WebkitAnimation) || isDef(style.MozAnimation) || isDef(style.MsAnimation) || isDef(style.OAnimation);
//    var animationEndEvent = 'animationend webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend';
//    var focusableElementSelector = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]';
//    var forceBodyReload = false;
//    var scope;
//
//    m.provider('ngDialog', function () {
//        var defaults = this.defaults = {
//            className: 'ngdialog-theme-default',
//            plain: false,
//            showClose: true,
//            closeByDocument: true,
//            closeByEscape: true,
//            closeByNavigation: false,
//            appendTo: false,
//            preCloseCallback: false,
//            overlay: true,
//            cache: true,
//            trapFocus: true,
//            preserveFocus: true,
//            ariaAuto: true,
//            ariaRole: null,
//            ariaLabelledById: null,
//            ariaLabelledBySelector: null,
//            ariaDescribedById: null,
//            ariaDescribedBySelector: null
//        };
//
//        this.setForceBodyReload = function (_useIt) {
//            forceBodyReload = _useIt || false;
//        };
//
//        this.setDefaults = function (newDefaults) {
//            angular.extend(defaults, newDefaults);
//        };
//
//        var globalID = 0, dialogsCount = 0, closeByDocumentHandler, defers = {};
//
//        this.$get = ['$document', '$templateCache', '$compile', '$q', '$rootScope', '$timeout', '$window', '$controller',
//            function ($document, $templateCache, $compile, $q, $rootScope, $timeout, $window, $controller) {
//                var $body = $document.find('body');
//                if (forceBodyReload) {
//                    $rootScope.$on('$locationChangeSuccess', function () {
//                        $body = $document.find('body');
//                    });
//                }
//
//                var privateMethods = {
//                    onDocumentKeydown: function (event) {
//                        if (event.keyCode === 27) {
//                            publicMethods.close('$escape');
//                        }
//                    },
//
//                    activate: function($dialog) {
//                        var options = $dialog.data('$ngDialogOptions');
//
//                        if (options.trapFocus) {
//                            $dialog.on('keydown', privateMethods.onTrapFocusKeydown);
//
//                            // Catch rogue changes (eg. after unfocusing everything by clicking a non-focusable element)
//                            $body.on('keydown', privateMethods.onTrapFocusKeydown);
//                        }
//                    },
//
//                    deactivate: function($dialog) {
//                        $dialog.off('keydown', privateMethods.onTrapFocusKeydown);
//                        $body.off('keydown', privateMethods.onTrapFocusKeydown);
//                    },
//
//                    deactivateAll: function($all) {
//                        angular.forEach(function(el) {
//                            var $dialog = angular.element(el);
//                            privateMethods.deactivate($dialog);
//                        });
//                    },
//
//                    setBodyPadding: function (width) {
//                        var originalBodyPadding = parseInt(($body.css('padding-right') || 0), 10);
//                        $body.css('padding-right', (originalBodyPadding + width) + 'px');
//                        $body.data('ng-dialog-original-padding', originalBodyPadding);
//                    },
//
//                    resetBodyPadding: function () {
//                        var originalBodyPadding = $body.data('ng-dialog-original-padding');
//                        if (originalBodyPadding) {
//                            $body.css('padding-right', originalBodyPadding + 'px');
//                        } else {
//                            $body.css('padding-right', '');
//                        }
//                    },
//
//                    performCloseDialog: function ($dialog, value) {
//                        var id = $dialog.attr('id');
//
//                        if (typeof $window.Hammer !== 'undefined') {
//                            var hammerTime = scope.hammerTime;
//                            hammerTime.off('tap', closeByDocumentHandler);
//                            hammerTime.destroy && hammerTime.destroy();
//                            delete scope.hammerTime;
//                        } else {
//                            $dialog.unbind('click');
//                        }
//
//                        if (dialogsCount === 1) {
//                            $body.unbind('keydown');
//                        }
//
//                        if (!$dialog.hasClass("ngdialog-closing")){
//                            dialogsCount -= 1;
//                        }
//
//                        var previousFocus = $dialog.data('$ngDialogPreviousFocus');
//                        if (previousFocus) previousFocus.focus();
//
//                        $rootScope.$broadcast('ngDialog.closing', $dialog);
//                        dialogsCount = dialogsCount < 0 ? 0: dialogsCount;
//                        if (animationEndSupport) {
//                            scope.$destroy();
//                            $dialog.unbind(animationEndEvent).bind(animationEndEvent, function () {
//                                $dialog.remove();
//                                if (dialogsCount === 0) {
//                                    $body.removeClass('ngdialog-open');
//                                    privateMethods.resetBodyPadding();
//                                }
//                                $rootScope.$broadcast('ngDialog.closed', $dialog);
//                            }).addClass('ngdialog-closing');
//                        } else {
//                            scope.$destroy();
//                            $dialog.remove();
//                            if (dialogsCount === 0) {
//                                $body.removeClass('ngdialog-open');
//                                privateMethods.resetBodyPadding();
//                            }
//                            $rootScope.$broadcast('ngDialog.closed', $dialog);
//                        }
//                        if (defers[id]) {
//                            defers[id].resolve({
//                                id: id,
//                                value: value,
//                                $dialog: $dialog,
//                                remainingDialogs: dialogsCount
//                            });
//                            delete defers[id];
//                        }
//                    },
//
//                    closeDialog: function ($dialog, value) {
//                        var preCloseCallback = $dialog.data('$ngDialogPreCloseCallback');
//
//                        if (preCloseCallback && angular.isFunction(preCloseCallback)) {
//
//                            var preCloseCallbackResult = preCloseCallback.call($dialog, value);
//
//                            if (angular.isObject(preCloseCallbackResult)) {
//                                if (preCloseCallbackResult.closePromise) {
//                                    preCloseCallbackResult.closePromise.then(function () {
//                                        privateMethods.performCloseDialog($dialog, value);
//                                    });
//                                } else {
//                                    preCloseCallbackResult.then(function () {
//                                        privateMethods.performCloseDialog($dialog, value);
//                                    }, function () {
//                                        return;
//                                    });
//                                }
//                            } else if (preCloseCallbackResult !== false) {
//                                privateMethods.performCloseDialog($dialog, value);
//                            }
//                        } else {
//                            privateMethods.performCloseDialog($dialog, value);
//                        }
//                    },
//
//                    onTrapFocusKeydown: function(ev) {
//                        var el = angular.element(ev.currentTarget);
//                        var $dialog;
//
//                        if (el.hasClass('ngdialog')) {
//                            $dialog = el;
//                        } else {
//                            $dialog = privateMethods.getActiveDialog();
//
//                            if ($dialog === null)
//                                return;
//                        }
//
//                        var isTab = (ev.keyCode === 9);
//                        var backward = (ev.shiftKey === true);
//
//                        if (isTab) {
//                            privateMethods.handleTab($dialog, ev, backward);
//                        }
//                    },
//
//                    handleTab: function($dialog, ev, backward) {
//                        var focusableElements = privateMethods.getFocusableElements($dialog);
//
//                        if (focusableElements.length === 0) {
//                            if (document.activeElement) {
//                                document.activeElement.blur();
//                            }
//                            return;
//                        }
//
//                        var currentFocus = document.activeElement;
//                        var focusIndex = Array.prototype.indexOf.call(focusableElements, currentFocus);
//
//                        var isFocusIndexUnknown = (focusIndex === -1);
//                        var isFirstElementFocused = (focusIndex === 0);
//                        var isLastElementFocused = (focusIndex === focusableElements.length - 1);
//
//                        var cancelEvent = false;
//
//                        if (backward) {
//                            if (isFocusIndexUnknown || isFirstElementFocused) {
//                                focusableElements[focusableElements.length - 1].focus();
//                                cancelEvent = true;
//                            }
//                        } else {
//                            if (isFocusIndexUnknown || isLastElementFocused) {
//                                focusableElements[0].focus();
//                                cancelEvent = true;
//                            }
//                        }
//
//                        if (cancelEvent) {
//                            ev.preventDefault();
//                            ev.stopPropagation();
//                        }
//                    },
//
//                    autoFocus: function($dialog) {
//                        var dialogEl = $dialog[0];
//
//                        // Browser's (Chrome 40, Forefix 37, IE 11) don't appear to honor autofocus on the dialog, but we should
//                        var autoFocusEl = dialogEl.querySelector('*[autofocus]');
//                        if (autoFocusEl !== null) {
//                            autoFocusEl.focus();
//
//                            if (document.activeElement === autoFocusEl)
//                                return;
//
//                            // Autofocus element might was display: none, so let's continue
//                        }
//
//                        var focusableElements = privateMethods.getFocusableElements($dialog);
//
//                        if (focusableElements.length > 0) {
//                            focusableElements[0].focus();
//                            return;
//                        }
//
//                        // We need to focus something for the screen readers to notice the dialog
//                        var contentElements = privateMethods.filterVisibleElements(dialogEl.querySelectorAll('h1,h2,h3,h4,h5,h6,p,span'));
//
//                        if (contentElements.length > 0) {
//                            var contentElement = contentElements[0];
//                            $el(contentElement).attr('tabindex', '0');
//                            contentElement.focus();
//                        }
//                    },
//
//                    getFocusableElements : function($dialog) {
//                        var dialogEl = $dialog[0];
//
//                        var rawElements = dialogEl.querySelectorAll(focusableElementSelector);
//
//                        return privateMethods.filterVisibleElements(rawElements);
//                    },
//
//                    filterVisibleElements: function(els) {
//                        var visibleFocusableElements = [];
//
//                        for (var i=0; i<els.length; i++) {
//                            var el = els[i];
//
//                            if (el.offsetWidth > 0 || el.offsetHeight > 0)
//                                visibleFocusableElements.push(el);
//                        }
//
//                        return visibleFocusableElements;
//                    },
//
//                    getActiveDialog: function() {
//                        var dialogs = document.querySelectorAll('.ngdialog');
//
//                        if (dialogs.length === 0)
//                            return null;
//
//                        // TODO: This might be incorrect if there are a mix of open dialogs with different 'appendTo' values
//                        return $el(dialogs[dialogs.length - 1]);
//                    },
//
//                    applyAriaAttributes: function($dialog, options) {
//
//                        if (options.ariaAuto) {
//                            if (!options.ariaRole) {
//                                var detectedRole = (privateMethods.getFocusableElements($dialog).length > 0)
//                                    ? 'dialog'
//                                    : 'alertdialog';
//
//                                options.ariaRole = detectedRole;
//                            }
//
//                            if (!options.ariaLabelledBySelector) {
//                                options.ariaLabelledBySelector = 'h1,h2,h3,h4,h5,h6';
//                            }
//
//                            if (!options.ariaDescribedBySelector) {
//                                options.ariaDescribedBySelector = 'article,section,p';
//                            }
//                        }
//
//                        if (options.ariaRole) {
//                            $dialog.attr('role', options.ariaRole);
//                        }
//
//                        privateMethods.applyAriaAttribute(
//                            $dialog, 'aria-labelledby', options.ariaLabelledById, options.ariaLabelledBySelector);
//
//                        privateMethods.applyAriaAttribute(
//                            $dialog, 'aria-describedby', options.ariaDescribedById, options.ariaDescribedBySelector);
//                    },
//
//                    applyAriaAttribute: function($dialog, attr, id, selector) {
//                        if (id) {
//                            $dialog.attr(attr, id);
//                        }
//
//                        if (selector) {
//                            var dialogId = $dialog.attr('id');
//
//                            var firstMatch = $dialog[0].querySelector(selector);
//
//                            if (!firstMatch) {
//                                return;
//                            }
//
//                            var generatedId = dialogId + '-' + attr;
//
//                            $el(firstMatch).attr('id', generatedId);
//
//                            $dialog.attr(attr, generatedId);
//
//                            return generatedId;
//                        }
//                    }
//                };
//
//                var publicMethods = {
//
//                    /*
//                     * @param {Object} options:
//                     * - template {String} - id of ng-template, url for partial, plain string (if enabled)
//                     * - plain {Boolean} - enable plain string templates, default false
//                     * - scope {Object}
//                     * - controller {String}
//                     * - className {String} - dialog theme class
//                     * - showClose {Boolean} - show close button, default true
//                     * - closeByEscape {Boolean} - default true
//                     * - closeByDocument {Boolean} - default true
//                     * - preCloseCallback {String|Function} - user supplied function name/function called before closing dialog (if set)
//                     *
//                     * @return {Object} dialog
//                     */
//                    open: function (opts) {
//                        var self = this;
//                        var options = angular.copy(defaults);
//
//                        opts = opts || {};
//                        angular.extend(options, opts);
//
//                        globalID += 1;
//
//                        self.latestID = 'ngdialog' + globalID;
//
//                        var defer;
//                        defers[self.latestID] = defer = $q.defer();
//
//                        scope = angular.isObject(options.scope) ? options.scope.$new() : $rootScope.$new();
//                        var $dialog, $dialogParent;
//
//                        $q.when(loadTemplate(options.template || options.templateUrl)).then(function (template) {
//
//                            $templateCache.put(options.template || options.templateUrl, template);
//
//                            if (options.showClose) {
//                                template += '<div class="ngdialog-close"></div>';
//                            }
//
//                            self.$result = $dialog = $el('<div id="ngdialog' + globalID + '" class="ngdialog"></div>');
//                            $dialog.html((options.overlay ?
//                            '<div class="ngdialog-overlay"></div><div class="ngdialog-content" role="document">' + template + '</div>' :
//                            '<div class="ngdialog-content" role="document">' + template + '</div>'));
//
//                            $dialog.data('$ngDialogOptions', options);
//
//                            if (options.data && angular.isString(options.data)) {
//                                var firstLetter = options.data.replace(/^\s*/, '')[0];
//                                scope.ngDialogData = (firstLetter === '{' || firstLetter === '[') ? angular.fromJson(options.data) : options.data;
//                            } else if (options.data && angular.isObject(options.data)) {
//                                scope.ngDialogData = options.data;
//                            }
//
//                            if (options.controller && (angular.isString(options.controller) || angular.isArray(options.controller) || angular.isFunction(options.controller))) {
//                                var controllerInstance = $controller(options.controller, {
//                                    $scope: scope,
//                                    $element: $dialog
//                                });
//                                $dialog.data('$ngDialogControllerController', controllerInstance);
//                            }
//
//                            if (options.className) {
//                                $dialog.addClass(options.className);
//                            }
//
//                            if (options.appendTo && angular.isString(options.appendTo)) {
//                                $dialogParent = angular.element(document.querySelector(options.appendTo));
//                            } else {
//                                $dialogParent = $body;
//                            }
//
//                            privateMethods.applyAriaAttributes($dialog, options);
//
//                            if (options.preCloseCallback) {
//                                var preCloseCallback;
//
//                                if (angular.isFunction(options.preCloseCallback)) {
//                                    preCloseCallback = options.preCloseCallback;
//                                } else if (angular.isString(options.preCloseCallback)) {
//                                    if (scope) {
//                                        if (angular.isFunction(scope[options.preCloseCallback])) {
//                                            preCloseCallback = scope[options.preCloseCallback];
//                                        } else if (scope.$parent && angular.isFunction(scope.$parent[options.preCloseCallback])) {
//                                            preCloseCallback = scope.$parent[options.preCloseCallback];
//                                        } else if ($rootScope && angular.isFunction($rootScope[options.preCloseCallback])) {
//                                            preCloseCallback = $rootScope[options.preCloseCallback];
//                                        }
//                                    }
//                                }
//
//                                if (preCloseCallback) {
//                                    $dialog.data('$ngDialogPreCloseCallback', preCloseCallback);
//                                }
//                            }
//
//                            scope.closeThisDialog = function (value) {
//                                privateMethods.closeDialog($dialog, value);
//                            };
//
//                            $timeout(function () {
//                                var $activeDialogs = document.querySelectorAll('.ngdialog');
//                                privateMethods.deactivateAll($activeDialogs);
//
//                                $compile($dialog)(scope);
//                                var widthDiffs = $window.innerWidth - $body.prop('clientWidth');
//                                $body.addClass('ngdialog-open');
//                                var scrollBarWidth = widthDiffs - ($window.innerWidth - $body.prop('clientWidth'));
//                                if (scrollBarWidth > 0) {
//                                    privateMethods.setBodyPadding(scrollBarWidth);
//                                }
//                                $dialogParent.append($dialog);
//
//                                privateMethods.activate($dialog);
//
//                                if (options.trapFocus) {
//                                    privateMethods.autoFocus($dialog);
//                                }
//
//                                if (options.name) {
//                                    $rootScope.$broadcast('ngDialog.opened', {dialog: $dialog, name: options.name});
//                                } else {
//                                    $rootScope.$broadcast('ngDialog.opened', $dialog);
//                                }
//                            });
//
//                            if (options.closeByEscape) {
//                                $body.bind('keydown', privateMethods.onDocumentKeydown);
//                            }
//
//                            if (options.closeByNavigation) {
//                                $rootScope.$on('$locationChangeSuccess', function () {
//                                    privateMethods.closeDialog($dialog);
//                                });
//                            }
//
//                            if (options.preserveFocus) {
//                                $dialog.data('$ngDialogPreviousFocus', document.activeElement);
//                            }
//
//                            closeByDocumentHandler = function (event) {
//                                var isOverlay = options.closeByDocument ? $el(event.target).hasClass('ngdialog-overlay') : false;
//                                var isCloseBtn = $el(event.target).hasClass('ngdialog-close');
//
//                                if (isOverlay || isCloseBtn) {
//                                    publicMethods.close($dialog.attr('id'), isCloseBtn ? '$closeButton' : '$document');
//                                }
//                            };
//
//                            if (typeof $window.Hammer !== 'undefined') {
//                                var hammerTime = scope.hammerTime = $window.Hammer($dialog[0]);
//                                hammerTime.on('tap', closeByDocumentHandler);
//                            } else {
//                                $dialog.bind('click', closeByDocumentHandler);
//                            }
//
//                            dialogsCount += 1;
//
//                            return publicMethods;
//                        });
//
//                        return {
//                            id: 'ngdialog' + globalID,
//                            closePromise: defer.promise,
//                            close: function (value) {
//                                privateMethods.closeDialog($dialog, value);
//                            }
//                        };
//
//                        function loadTemplateUrl (tmpl, config) {
//                            return $http.get(tmpl, (config || {})).then(function(res) {
//                                return res.data || '';
//                            });
//                        }
//
//                        function loadTemplate (tmpl) {
//                            if (!tmpl) {
//                                return 'Empty template';
//                            }
//
//                            if (angular.isString(tmpl) && options.plain) {
//                                return tmpl;
//                            }
//
//                            if (typeof options.cache === 'boolean' && !options.cache) {
//                                return loadTemplateUrl(tmpl, {cache: false});
//                            }
//
//                            return $templateCache.get(tmpl) || loadTemplateUrl(tmpl, {cache: true});
//                        }
//                    },
//
//                    /*
//                     * @param {Object} options:
//                     * - template {String} - id of ng-template, url for partial, plain string (if enabled)
//                     * - plain {Boolean} - enable plain string templates, default false
//                     * - name {String}
//                     * - scope {Object}
//                     * - controller {String}
//                     * - className {String} - dialog theme class
//                     * - showClose {Boolean} - show close button, default true
//                     * - closeByEscape {Boolean} - default false
//                     * - closeByDocument {Boolean} - default false
//                     * - preCloseCallback {String|Function} - user supplied function name/function called before closing dialog (if set); not called on confirm
//                     *
//                     * @return {Object} dialog
//                     */
//                    openConfirm: function (opts) {
//                        var defer = $q.defer();
//
//                        var options = {
//                            closeByEscape: false,
//                            closeByDocument: false
//                        };
//                        angular.extend(options, opts);
//
//                        options.scope = angular.isObject(options.scope) ? options.scope.$new() : $rootScope.$new();
//                        options.scope.confirm = function (value) {
//                            defer.resolve(value);
//                            var $dialog = $el(document.getElementById(openResult.id));
//                            privateMethods.performCloseDialog($dialog, value);
//                        };
//
//                        var openResult = publicMethods.open(options);
//                        openResult.closePromise.then(function (data) {
//                            if (data) {
//                                return defer.reject(data.value);
//                            }
//                            return defer.reject();
//                        });
//
//                        return defer.promise;
//                    },
//
//                    /*
//                     * @param {String} id
//                     * @return {Object} dialog
//                     */
//                    close: function (id, value) {
//                        var $dialog = $el(document.getElementById(id));
//
//                        if ($dialog.length) {
//                            privateMethods.closeDialog($dialog, value);
//                        } else {
//                            publicMethods.closeAll(value);
//                        }
//
//                        return publicMethods;
//                    },
//
//                    closeAll: function (value) {
//                        var $all = document.querySelectorAll('.ngdialog');
//
//                        // Reverse order to ensure focus restorationi works as expected
//                        for (var i=$all.length; i>-1; i--) {
//                            var dialog = $all[i];
//                            privateMethods.closeDialog($el(dialog), value);
//                        }
//                    },
//
//                    getDefaults: function () {
//                        return defaults;
//                    }
//                };
//
//                return publicMethods;
//            }];
//    });
//
//    m.directive('ngDialog', ['ngDialog', function (ngDialog) {
//        return {
//            restrict: 'A',
//            scope : {
//                ngDialogScope : '='
//            },
//            link: function (scope, elem, attrs) {
//                elem.on('click', function (e) {
//                    e.preventDefault();
//
//                    var ngDialogScope = angular.isDefined(scope.ngDialogScope) ? scope.ngDialogScope : 'noScope';
//                    angular.isDefined(attrs.ngDialogClosePrevious) && ngDialog.close(attrs.ngDialogClosePrevious);
//
//                    var defaults = ngDialog.getDefaults();
//
//                    ngDialog.open({
//                        template: attrs.ngDialog,
//                        className: attrs.ngDialogClass || defaults.className,
//                        controller: attrs.ngDialogController,
//                        scope: ngDialogScope,
//                        data: attrs.ngDialogData,
//                        showClose: attrs.ngDialogShowClose === 'false' ? false : (attrs.ngDialogShowClose === 'true' ? true : defaults.showClose),
//                        closeByDocument: attrs.ngDialogCloseByDocument === 'false' ? false : (attrs.ngDialogCloseByDocument === 'true' ? true : defaults.closeByDocument),
//                        closeByEscape: attrs.ngDialogCloseByEscape === 'false' ? false : (attrs.ngDialogCloseByEscape === 'true' ? true : defaults.closeByEscape),
//                        preCloseCallback: attrs.ngDialogPreCloseCallback || defaults.preCloseCallback
//                    });
//                });
//            }
//        };
//    }]);
//
//    return m;
//}));

/*
 * Md. Ibrahim Rashid
 * © Ipvision
 */

(function() {
	'use strict';

		var chatApp = angular.module('ringid.chat');

        var CHAT_GENERAL_CONSTANTS = {

            MESSAGE_STATUS                  : { UNREAD : -1, DELETED : 0, SENT : 1, DELIVERED  : 2,  SEEN : 3, VIEWED : 4, PLAYED : 4 },
            MESSAGE_TYPES                   : {
                DELETE_MESSAGE              : 0,
                BLANK_MESSAGE               : 1,
                TEXT                        : 2,
                EMOTICON_MESSAGE            : 3,
                LOCATION_SHARE              : 4,
                LINK_SHARE                  : 5,
                STICKER                     : 6,
                IMAGE                       : 7,
                AUDIO                       : 8,
                VIDEO                       : 9,
                CAMERA_IMAGE                : 10,
                TYPING                      : 101
            },

            USER_PRESENCE : {
                OFFLINE : 1,
                ONLINE : 2,
                AWAY : 3
            },

            HISTORY_MAX_MESSAGE             :  20,


            /* Internal */
            TAB_SYNC_MAX_TIME               : 180 * 1000,
            TAB_SYNC_ACTIONS                : { AUTH_REQUEST            : 0,
                                                CHAT_REQUEST            : 1,
                                                GENERAL_INFO_UPDATE     : 3,
                                                CHAT_BOX_INFO_UPDATE    : 4,
                                                SECRET_CHAT_TIMER       : 5,
                                                CHAT_HISTORY_REFRESH    : 6,
                                                CHAT_MSESSAGE_UPDATE    : 7
                                              },

            SHARED_WORKER_PATH              : 'js/worker/chat/shared.js'

        };

        var CHAT_GLOBAL_VALUES = {
            serverTimeDiff : 0,
            offlineUpdateTime : 0
        };

        var CHAT_GENERAL_INFOS = {
            version : '1.5'
        };

        var CHAT_STATES = {
            MESSAGE_SENDING: {

                ONLINE_IP_PORT_REQUEST              : 0,
                FIRST_ONLINE                        : 1,
                PRESENCE_REFRESH                    : 2,
                SECOND_ONLINE                       : 3,
                ONLINE_IP_PORT_REFRESH              : 4,
                THIRD_ONLINE                        : 5,
                ONLINE_SUCCESS                      : 6,
                ONLINE_FAILED                       : 7,


                FIRST_OFFLINE                       : 101,
                OFFLINE_IP_PORT_REFRESH             : 102,
                SECOND_OFFLINE                      : 102,
                OFFLINE_FAILED                      : 104,
                OFFLINE_SUCCESS                     : 105,

                SUCCESS                             : 201,
                FAILED                              : 202

            }
        };

        var CHAT_FLOWS = {
            SEND_MESSAGE : [
                CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REQUEST,
                CHAT_STATES.MESSAGE_SENDING.FIRST_ONLINE,
                CHAT_STATES.MESSAGE_SENDING.PRESENCE_REFRESH,
                CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REFRESH,
                CHAT_STATES.MESSAGE_SENDING.ONLINE_FAILED,

                CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE,
                CHAT_STATES.MESSAGE_SENDING.OFFLINE_IP_PORT_REFRESH
            ]
        };

        var CHAT_STATE_INFO ={};

        CHAT_STATE_INFO[CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REQUEST] = {
            NEXT : [CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE]
        };

        CHAT_STATE_INFO[CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE] = {
            NEXT : [CHAT_STATES.MESSAGE_SENDING.ONLINE_SUCCESS, CHAT_STATES.MESSAGE_SENDING.PRESENCE_REFRESH]
        };

        CHAT_STATE_INFO[CHAT_STATES.MESSAGE_SENDING.PRESENCE_REFRESH] = {
            NEXT : [CHAT_STATES.MESSAGE_SENDING.ONLINE_SUCCESS, CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REFRESH]
        };

        CHAT_STATE_INFO[CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REFRESH] = {
            NEXT : [CHAT_STATES.MESSAGE_SENDING.ONLINE_SUCCESS, CHAT_STATES.MESSAGE_SENDING.ONLINE_FAILED]
        };

        CHAT_STATE_INFO[CHAT_STATES.MESSAGE_SENDING.ONLINE_FAILED] = {
            NEXT : [CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE]
        };

        CHAT_STATE_INFO[CHAT_STATES.MESSAGE_SENDING.OFFLINE_SUCCESS] = {
            NEXT : [CHAT_STATES.MESSAGE_SENDING.SUCCESS]
        };


        CHAT_STATE_INFO[CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE] = {
            NEXT : [CHAT_STATES.MESSAGE_SENDING.OFFLINE_SUCCESS, CHAT_STATES.MESSAGE_SENDING.OFFLINE_IP_PORT_REFRESH]
        };

        CHAT_STATE_INFO[CHAT_STATES.MESSAGE_SENDING.OFFLINE_IP_PORT_REFRESH] = {
            NEXT : [CHAT_STATES.MESSAGE_SENDING.OFFLINE_SUCCESS, CHAT_STATES.MESSAGE_SENDING.OFFLINE_FAILED]
        };

        CHAT_STATE_INFO[CHAT_STATES.MESSAGE_SENDING.OFFLINE_FAILED] = {
            NEXT : [CHAT_STATES.MESSAGE_SENDING.FAILED]
        };

        CHAT_STATE_INFO[CHAT_STATES.MESSAGE_SENDING.OFFLINE_SUCCESS] = {
            NEXT : [CHAT_STATES.MESSAGE_SENDING.SUCCESS]
        };

        var chatStates = Object.keys(CHAT_STATES.MESSAGE_SENDING);

        for(var index = 0, length = chatStates.length; index < length; index++){
            var aChatStateIndex = CHAT_STATES['MESSAGE_SENDING'][ chatStates[index] ];
            try{
                CHAT_STATE_INFO [ aChatStateIndex ]['NAME'] = chatStates[index];
            }catch(e) {

                CHAT_STATE_INFO [ aChatStateIndex ] = {};
                CHAT_STATE_INFO [ aChatStateIndex ]['NAME'] = chatStates[index];
            }
        }

        var CHAT_PACKET_TYPE = {//not in use right now but will be, but before that we need to change the values as they've changed

            CHAT_REGISTER : 1,
            CHAT_FRIEND_UNREGISTERED : 2,
            CHAT_REGISTER_CONFIRMATION : 3,
            CHAT_GROUP_UNREGISTER : 4,
            //Friend to Friend Chat Constants
            CHAT_FRIEND : 5,
            CHAT_DELIVERED : 6,
            CHAT_SEEN : 7,
            CHAT_SENT : 8,
            CHAT_TYPING : 9,
            CHAT_IDEL : 10,

            /** Chat Grouup **/
            CHAT_GROUP_REGISTER : 12,
            CHAT_GROUP_REG_CONFIRMATION : 13,
            CHAT_GROUP : 14,
            CHAT_GROUP_DELIVERED : 15,
            CHAT_GROUP_SEEN : 16,
            CHAT_GROUP_SENT : 17,
            CHAT_GROUP_TYPING : 18,
            CHAT_GROUP_IDEL : 19,

            //Offline Message
            CHAT_FRIEND_OFFLINE : 20,
            CHAT_GROUP_OFFLINE : 21,
            CHAT_GET_OFFLINE : 22,
            CHAT_OFFLINE_CONFIRMATION : 23,

            //Chat Delete Constants
            FRIEND_CHAT_DELETE : 24,
            FRIEND_CHAT_DELETE_CONFIRMATION : 25,
            FRIEND_INFORMATION : 28,
            FRIEND_INFORMATION_CONFIRMATION : 29,

            GROUP_CHAT_DELETE : 26,
            GROUP_CHAT_DELETE_CONFIRMATION : 27,

            //File Stream
            FILE_TOTAL_SEQUENCE : 30,
            FILE_TOTAL_SEQUENCE_CONFIRMATION : 31,
            FILE_STREAM_SEND : 32,
            FILE_STREAM_SEND_CONFIRMATION : 33
        };

        var CHAT_PACKET_ATTRIBUTE = {
            PACKET_TYPE: 1,
            USER_ID: 2,
            FRIEND_ID : 3,
            PACKET_ID_LENGTH : 4,
            PACKET_ID : 5,
            PLATFORM : 6,
            CHAT_BINDING_PORT : 7,
            TAG_ID : 8,
            ONLINE_STATUS : 9,
            USER_MOOD : 10,
            MESSAGE_TYPE : 11,
            TIMEOUT : 12,
            LATITUDE : 13,
            LONGITUDE : 14,
            MESSAGE_LENGTH : 15,
            MESSAGE : 16,
            MESSAGE_DATE : 17,
            NO_OF_MESSAGE : 18,
            FULL_NAME_LENGTH : 19,
            FULL_NAME : 20,
            NO_OF_PACKET : 21,
            SEQUENCE_NO : 22,
            NO_OF_MEMBERS : 23,
            UPDATE_TIME : 24,
            SERVER_DATE : 25,
            IS_SECRET_VISIBLE: 26,
            MESSAGE_STATUS: 27,
            BLOCK_UNBLOCK_UPDATE_DATE: 28

        };

        var CHAT_PACKET_FORMAT = {
            'REGISTER_PKT' : {
                'PACKET_NAME': 'REGISTER_PKT',
                'PACKET_TYPE': 1,
                'FORMAT': [1,2,3,4,5,6]
            },
            'FRIEND_UNREGISTER_PKT' : {
                'PACKET_NAME': 'FRIEND_UNREGISTER_PKT',
                'PACKET_TYPE': 2,
                'FORMAT': [1,2,3,4,5,9,10]//packetId and packetIdLength added(16feb2016)
            },
            'REGISTER_CONFIRM_PKT' : {
                'PACKET_NAME': 'REGISTER_CONFIRM_PKT',
                'PACKET_TYPE': 3,
                'FORMAT': [1,3,4,5,7,25]
            },
            'CHAT_MSG' : {
                'PACKET_NAME': 'CHAT_MSG',
                'PACKET_TYPE': 6, // previous: 5
                'FORMAT': [1, 2, 3, 4, 5, 11, 12, 15, 16, 17, 26]//13,14 lat lon is omitted; 26 issecretvisible added
            },
            'CHAT_MSG_OFFLINE' : {
                'PACKET_NAME': 'CHAT_MSG_OFFLINE',
                'PACKET_TYPE': 6, // previous: 5
                'FORMAT': [1, 2, 3, 4, 5, 11, 12, 15, 16, 17, 26, 6]//13,14 lat lon is omitted; 26 issecretvisible added
            },
            'DELIVER_PKT' : {
                'PACKET_NAME': 'DELIVER_PKT',
                'PACKET_TYPE': 15, // previous: 6
                'FORMAT': [1, 2, 3, 4, 5]
            },
            'DELIVER_PKT_OFFLINE' : {
                'PACKET_NAME': 'DELIVER_PKT_OFFLINE',
                'PACKET_TYPE': 15, // previous: 6
                'FORMAT': [1, 2, 3, 4, 5, 6]
            },
            'SEEN_PKT' : {
                'PACKET_NAME': 'SEEN_PKT',
                'PACKET_TYPE': 17, // previous: 7
                'FORMAT': [1, 2, 3, 4, 5, 18, 4, 5, 17, 27] // previous: [1.2.3.4.5]
            },
            'SEEN_PKT_CONFIRM' : {
                'PACKET_NAME': 'SEEN_PKT_CONFIRM',
                'PACKET_TYPE': 18, // previous: NaN
                'FORMAT': [1, 2, 3, 4, 5]
            },
            'SENT_PKT' : {
                'PACKET_NAME': 'SENT_PKT',
                'PACKET_TYPE': 16, // previous: 8
                'FORMAT': [1, 2, 3, 4, 5]
            },
            'SEEN_PKT_OFFLINE' : {
                'PACKET_NAME': 'SEEN_PKT_OFFLINE',
                'PACKET_TYPE': 17, // previous: 7
                'FORMAT': [1, 2, 3, 4, 5, 18, 4, 5, 17, 27, 6] // previous: [1.2.3.4.5.6]
            },
            'TYPING_PKT' : {
                'PACKET_NAME': 'TYPING_PKT',
                'PACKET_TYPE': 5, // previous: 9
                'FORMAT': [1, 2, 3, 6]
            },
            'IDLE_PKT' : {
                'PACKET_NAME': 'IDLE_PKT',
                'PACKET_TYPE': 4, // previous: 10
                'FORMAT': [1, 2, 3, 6]
            },
            'DELETE_PKT' : {
                'PACKET_NAME': 'DELETE_PKT',
                'PACKET_TYPE': 19, // previous: 24
                'FORMAT': [1, 2, 3, 4, 5, 18, 4, 5]
            },
            'DELETE_PKT_OFFLINE' : {
                'PACKET_NAME': 'DELETE_PKT_OFFLINE',
                'PACKET_TYPE': 19, // previous: 24
                'FORMAT': [1, 2, 3, 4, 5, 18, 4, 5, 6]
            },
            'DELETE_CONFIRM_PKT' : {
                'PACKET_NAME': 'DELETE_CONFIRM_PKT',
                'PACKET_TYPE': 20, // previous: 25
                'FORMAT': [1, 2, 3, 4, 5]
            },
            'DELETE_CONFIRM_PKT_OFFLINE' : {
                'PACKET_NAME': 'DELETE_CONFIRM_PKT_OFFLINE',
                'PACKET_TYPE': 20, // previous: 25
                'FORMAT': [1, 2, 3, 4, 5, 6]
            },

            'OFFLINE_REGISTER_PKT' : {
                'PACKET_NAME': 'OFFLINE_REGISTER_PKT',
                'PACKET_TYPE': 93, // previous: 222
                'FORMAT': [1, 2, 4, 5, 24, 28, 6]
            },

            // THIS PACKET USER WILL RECEIVE FROM SERVER AFTER SENDING OFFLINE REGISTER PACKET,
            // THEN HE SHOULD STOP SENDING OFFLINE REGISTER PACKET
            'OFFLINE_CONFIRM_PKT' : {
                'PACKET_NAME': 'OFFLINE_CONFIRM_PKT',
                'PACKET_TYPE': 94, // previous: 23
                'FORMAT': [1, 4, 5, 17]
            },
            'FRIEND_OFFLINE_PKT' : {//friend unread message
                'PACKET_NAME': 'FRIEND_OFFLINE_PKT',
                'PACKET_TYPE': 95, // previous: 20
                'FORMAT': [1, 4, 5, 18, 1, 2, 4, 5, 11, 12, 15, 16, 17, 26]//noofpacket, sequenceno omitted 21,22; lat lon omitted 13,14; issecretvisible added 26
            },

            // THESE PACKETS(58,59) USER WILL SEND AFTER GETTING OFFLINE MSG PACKETS SO THAT
            // SEVER DOESN'T SEND OFFLINE MESSAGE AGAIN
            'FRIEND_OFFLINE_CONFIRM_PKT' : {//FRIEND_UNREAD_MESSAGE_CONFIRMATION
                'PACKET_NAME': 'FRIEND_OFFLINE_CONFIRM_PKT',
                'PACKET_TYPE': 96,// previous: 58
                'FORMAT': [1, 2, 4, 5, 18, 4, 5, 6] //Here noOfPackets is assumed as noOfMessages
            }
        };

        var AUTH_SERVER_ACTIONS = {
            START_F2F_CHAT          : 175,
            RECEIVED_F2F_CHAT       : 375,
            START_TAG_CHAT          : 134,
            RECEIVED_TAG_CHAT       : 334,
            ADD_TAG_CHAT_MEMBERS    : 135,
            GET_OFFLINE_IP_PORT     : 83
        };

        chatApp.constant('CHAT_PACKET_TYPE',        CHAT_PACKET_TYPE );
        chatApp.constant('CHAT_PACKET_ATTRIBUTE',   CHAT_PACKET_ATTRIBUTE);
        chatApp.constant('CHAT_PACKET_FORMAT',      CHAT_PACKET_FORMAT);
        chatApp.constant('CHAT_GENERAL_CONSTANTS',  CHAT_GENERAL_CONSTANTS );

        chatApp.constant('CHAT_FLOWS',              CHAT_FLOWS );
        chatApp.constant('CHAT_STATE_INFO',         CHAT_STATE_INFO );
        chatApp.constant('CHAT_STATES',             CHAT_STATES );
        chatApp.value('CHAT_GLOBAL_VALUES',         CHAT_GLOBAL_VALUES);
        chatApp.value('CHAT_GENERAL_INFOS',         CHAT_GENERAL_INFOS);
        chatApp.constant('AUTH_SERVER_ACTIONS',     AUTH_SERVER_ACTIONS );
})();

(function() {
	'use strict';
	angular
		.module('ringid.chat')
        .controller('ChatController', ChatController);

        ChatController.$inect = ['$scope', '$rootScope', 'ChatFactory','ChatHelper',
            'tagOfflineChatManager', 'chatUtilsFactory',
            'settings','SystemEvents', 'PacketDataParse', 'friendsFactory', 'ChatPacketSenderService',
            'chatTabSync', 'utilsFactory', 'CHAT_GENERAL_CONSTANTS',
             'chatHistoryFactory', '$ringhttp', '$$connector', 'Auth', 'tagChatManager', 'PullerSubscriber', '$location'];
        function ChatController($scope, $rootScope, ChatFactory, ChatHelper,
                                tagOfflineChatManager, chatUtilsFactory,
                                settings,SystemEvents, PacketDataParse, friendsFactory, ChatPacketSenderService,
                                chatTabSync, utilsFactory, CHAT_GENERAL_CONSTANTS, 
                                chatHistoryFactory, $ringhttp, $$connector, Auth, tagChatManager, PullerSubscriber, $location) {

                $scope.chatAppInitiated = false;

                $scope.boxes = ChatFactory.getBoxes();

                $scope.domBoxLength = function () {
                    var count = 0 ;
                    for(var i=0; i< $scope.boxes.length; i++){
                        if($scope.boxes[i].value.nonDomBox == true){
                            count++;
                        }
                    }
                    if(count>10){
                        return 10;
                    }else{
                        return count;
                    }
                };

                $scope.availableNo = ChatFactory.getNumberOfAvailableChatBox();

                $scope.getProfileLink = settings.baseUrl + '#/profile/';

                //$scope.previousDate = {timestamp:1,date:''};
                $scope.goToProfile = function(event, profileLink){
                    //$location.path('/profile/2110010128');
                    $location.path(profileLink);
                    event.stopPropagation();
                };

                $rootScope.$on("chatOpened",function(e, data){
                    //RingLogger.log("event Received: This doesn't need to be logged.");
                    if(!!data.sendToTab){
                        chatTabSync.sendData(CHAT_GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.CHAT_BOX_INFO_UPDATE, {boxId : data.user});
                    }

                });
                //$rootScope.$on('ringInactive', function () {
                //    for(var i=0; i<$scope.boxes.length; i++){
                //        $scope.boxes[i].value.isFocused = false;
                //    }
                //});

                //addFriend and acceptFriend functions are now combined to contactListAction
                //$scope.addFriend = function (param) {
                //    friendsFactory.addFriend(param, true).then(function() {
                //         $scope.$rgDigest();
                //    }, function() {
                //         $scope.$rgDigest();
                //    });
                //};
                //
                //$scope.acceptFriend = function (param) {
                //    friendsFactory.acceptFriendRequest(param, true).then(function() {
                //         $scope.$rgDigest();
                //    }, function() {
                //         $scope.$rgDigest();
                //    });
                //};

                $scope.contactListAction = function(actionObj) {
                    if (!actionObj.friend.isLoading()) {
                        friendsFactory.friendAction(actionObj,true).then(function() {
                            $scope.$rgDigest();
                        }, function() {
                            $scope.$rgDigest();
                        });
                        $scope.$rgDigest();
                    }
                };

                $scope.$on(SystemEvents.COMMON.WINDOW_RESIZED, function(event, viewport){
                    RingLogger.print("viewport : X: "+viewport.x+" Y:"+viewport.y,RingLogger.tags.CHAT);
                    $scope.availableNo = ChatFactory.getNumberOfAvailableChatBox(viewport.x);
                    utilsFactory.safeDigest($scope);
                });


                utilsFactory.onCustomEvent(SystemEvents.CHAT.TAB_SYNC_NEW_DATA, function(data){
                    RingLogger.information('TAB SYNC DATA', data, RingLogger.tags.TAB_DATA_RECEIVED);

                    if( data.type == CHAT_GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.CHAT_BOX_INFO_UPDATE ){
                        ChatFactory.refreshBox(data.boxId);

                    }else if ( data.type == CHAT_GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.CHAT_MSESSAGE_UPDATE){

                        chatHistoryFactory.loadChatBoxes();
                        ChatFactory.openAndAddMessage(data.boxId, data.msg);
                        //ChatHelper.loadHistoryMessageForF2FChat(data.boxId);
                    }

                });

                var startChatHearBeatInterval = function(){
                    window.addEventListener("online", function(e) {
                        if( window.navigator.onLine){
                            RingLogger.debug('Browser Gets Online From Offline', RingLogger.tags.CHAT);
                            tagOfflineChatManager.getUnreadMessagesMultipleTimes();
                        }
                    });

                    var counter = 0;
                    var state = "online";
                    $$connector.addInterval(function(){

                        $ringhttp.get(settings.chatHeartBeatUrl).success(function(response){

                            if(!!response){
                                if( state == "offline"){
                                    state = "online";
                                    utilsFactory.triggerCustomEvent('online');
                                }
                            }
                        }).error(function(response){
                            if(counter > 3){
                                counter = 0;
                                state = "offline";
                            }else{
                                counter++;
                            }

                        });
                    });
                };

                var sendOfflineGetRequest = function(){

                    if( !chatUtilsFactory.hasOfflineIpPort()){

                        ChatPacketSenderService.doUpdateOfflineIpPort().then(function(response){
                            tagOfflineChatManager.getUnreadMessagesMultipleTimes();
                        });

                    }else{
                        tagOfflineChatManager.getUnreadMessagesMultipleTimes();
                    }
                };

                var openPreviouslyOpenedBoxes = function(){
                    setTimeout(function(){
                            var storageBoxes = chatHistoryFactory.getAllOpenBoxes();// previously this was an array but now it is an object
                            if(!!storageBoxes){
                                Object.keys(storageBoxes).forEach(function(anOpenBoxId, key){
                                    var box,
                                        anOpenBoxInfo = storageBoxes[anOpenBoxId];

                                    if(!anOpenBoxInfo.isTagChat){
                                        
                                        ChatFactory.openChatBox(anOpenBoxInfo.boxId);
                                        box = ChatFactory.getBoxByUId(anOpenBoxInfo.boxId);
                                        var historyBox = chatHistoryFactory.getBox(anOpenBoxInfo.boxId);
                                        angular.extend(box, historyBox);

                                        PullerSubscriber.requestForIp(anOpenBoxInfo.boxId);
                                    
                                        if(!!box){
                                            box.loadHistoryMessages();
                                        }

                                    }else{

                                        tagChatManager.openPreviouslyOpenedBoxes(anOpenBoxInfo.boxId);
                                    }
                                });

                            } // end of if(storageBoxes)
                        }, 2000);
                }

                function initChatApp(){
                    
                    chatHistoryFactory.init();
                    chatTabSync.init();
                    
                    sendOfflineGetRequest();
                    startChatHearBeatInterval();

                    openPreviouslyOpenedBoxes();
                    
                }

                var registerChatAppInitEvent = function(){
                     $rootScope.$on('FIRST_FEED_RECEIVED', function(){
                        if( !$scope.chatAppInitiated){
                            $scope.chatAppInitiated = true;
                            initChatApp();    
                        }
                        
                    });

                    setTimeout(function(){
                        if( !$scope.chatAppInitiated){
                            $scope.chatAppInitiated = true;
                            initChatApp();
                        }
                    }, 6000);

                };

                if( Auth.isLoggedIn() ){

                   registerChatAppInitEvent();

                }else{
                    $scope.$on(SystemEvents.AUTH.LOGIN, function (event, data) {

                        registerChatAppInitEvent();                
                    });    
                }

                

                
        }
        ChatController.$inject = ['$scope', '$rootScope', 'ChatFactory', 'ChatHelper', 'tagOfflineChatManager', 'chatUtilsFactory', 'settings', 'SystemEvents', 'PacketDataParse', 'friendsFactory', 'ChatPacketSenderService', 'chatTabSync', 'utilsFactory', 'CHAT_GENERAL_CONSTANTS', 'chatHistoryFactory', '$ringhttp', '$$connector', 'Auth', 'tagChatManager', 'PullerSubscriber', '$location'];


})();

/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.chat')
        .controller('ChatHistoryController', ChatHistoryController);

    ChatHistoryController.$inject = ['$scope', '$rootScope', 'ChatFactory', 'Storage',
        'Auth', 'profileFactory', 'tagChatFactory', 'userFactory', 'utilsFactory',
        'chatHistoryFactory',
        'CHAT_GLOBAL_VALUES', 'TAG_CHAT_GENERAL_CONSTANTS',
        '$$stackedMap', 'SystemEvents', 'rgScrollbarService'];
    function ChatHistoryController($scope, $rootScope, ChatFactory, Storage,
                                   Auth, profileFactory, tagChatFactory, userFactory, utilsFactory,
                                   chatHistoryFactory,
                                   CHAT_GLOBAL_VALUES, TAG_CHAT_GENERAL_CONSTANTS,
                                   $$stackedMap, SystemEvents, rgScrollbarService) {

        $scope.selectedLeftBox = {key: 0, messages : []};

        $scope.boxes = $$stackedMap.createNew(true);

        $scope.recentMessages = $$stackedMap.createNew(true);

        $scope.ready = $rootScope.chatHistoryReady || false;

        $scope.selectLeftBox = function(box){
            $scope.selectedLeftBox = box;
        };

        var getMessageTime  = function(messageDate) {
            var localTime = messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff;
            var localFormatedTime = utilsFactory.verbalDate(localTime);
            return localFormatedTime;
        };

        $scope.getMessageTime = getMessageTime;


        var updateMessageObject = function(messageObject){
            profileFactory.getUserDetailsByUId(messageObject.userId || messageObject.user).then(function(userObj){
                if(!!userObj){
                    messageObject.user =  userObj;

                    $scope.$rgDigest();
                }

            });
        };

        var updateUserObject = function(msgObject, userId){
            if( !!userId){
                msgObject.user = profileFactory.getUserObjectByUId(userId, function(){
                    $scope.$rgDigest();
                });
            }
        };



        var initABox = function(aBox){
            if(!aBox.messages.length){
                return;
            }

            var aBoxObject = {
                key :  aBox.key,
                boxImg : '',
                boxTitle : '',
                boxUser  : '',
                boxLastMessage : '',
                messages : [],
                isTagChat : false,
                sortBy : function(){
                    return this.getLastMessage().messageDate;
                },
                getBoxTitle : function(){
                    return this.boxTitle;
                },
                getLastMessage : function(){
                    if( this.messages.length > 0){
                        return this.messages[this.messages.length-1];
                    }
                },

                getLastMessageText : function(){
                    var lastMessage = this.getLastMessage();
                    if( lastMessage.messageType == 2){
                        return lastMessage.text;
                    }else{
                        return "[MEDIA]";
                    }

                }
            };

            aBoxObject.messages = aBox.messages;

            for(var index = 0, length = aBox.messages.length; index < length; index++){
                aBox.messages[index].userId = aBox.messages[index].user;
                delete aBox.messages[index].user;

                updateUserObject(aBoxObject.messages[index], aBox.messages[index].userId);
            }

            aBoxObject.boxTitle = aBox.key;

            if( !aBox.isTagChat){

                var boxUser = userFactory.getUser(aBox.key);
                if(!!boxUser){

                    aBoxObject.boxTitle = boxUser.getName();
                    aBoxObject.boxImg = boxUser.avatar('thumb');

                }else{

                    profileFactory.getUserDetailsByUId(aBox.key).then(function(userObj){
                        if(!!userObj){
                            aBoxObject.boxTitle = userObj.getName();
                            aBoxObject.boxImg = userObj.avatar();
                        }

                    });
                }


            }else{

                aBoxObject.isTagChat = true;

                var aTag = tagChatFactory.getOrCreateTag(aBox.key);
                aBoxObject.tag = aTag;
                aBoxObject.boxTitle = aTag.getTagName();
                aBoxObject.boxImg = aTag.getPictureUrl();
            }


            RingLogger.debug(aBoxObject.key, 'DEBUG');
            $scope.boxes.save(aBoxObject.key, aBoxObject);

        };


        var getMessageText = function(message){
            if (!!message.statusType){
                return "Activity message.";
            }
            else if( message.messageType == TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.PLAIN_MESSAGE){
                return message.text;

            } else {
                return "Received media message.";
            }
        };

        var getUnreadStatus = function(message){

            if( message.status == 'Unread' ){
                return true;
            }else if ( message.status == "Received" && !message.seenSent){
                return true;
            }else{
                return false;
            }

        };

        var getBoxUnreadCount = function(aBox){

            return chatHistoryFactory.getUnreadMessageCountByBoxId(aBox.key);
        };

        var getMessageAdaptorObject = function(aHistoryMessageObject){

            var aMessageObject              = angular.copy(aHistoryMessageObject);
            aMessageObject['date']          = getMessageTime(aMessageObject.messageDate);
            aMessageObject['isUnread']      = function(){ return getUnreadStatus(aMessageObject) };
            aMessageObject['messageText']   = function(){ return getMessageText(aMessageObject) };

            if( !!aMessageObject.user.getKey ){
                updateUserObject(aMessageObject, aMessageObject.user);
            }

            aMessageObject['isSelf'] = function() { return aHistoryMessageObject.userId == Auth.currentUser().getKey() };


            return aMessageObject;
        };

        var getBoxLastMessage = function(aBoxObject){
            var lastMessage = false;
            if( aBoxObject.messages.length > 0){
                
                aBoxObject.messages.sort(function(a, b){
                    if( a.messageDate > b.messageDate ){
                        return 1
                    }else if( a.messageDate < b.messageDate){
                        return -1
                    }
                    return 0;
                });

                lastMessage = aBoxObject.messages[aBoxObject.messages.length-1];
            }
            return lastMessage;
        };

        var updateBoxLastMessageByBoxId = function(boxId){

            var currentUserBoxes = chatHistoryFactory.getChatBoxes();
            var aHistoryBoxObject =  currentUserBoxes[boxId];

            var aBox = $scope.boxes.get(boxId);
            if( !!aBox){
                aBox.messages = aHistoryBoxObject.messages;

                var lastMessage = getBoxLastMessage(aBox);

                if( lastMessage ){
                    aBox['lastMessage'] = getMessageAdaptorObject(lastMessage);
                }
            }

        };

        var getBoxObject = function(aHistoryBoxObject){

            var aBoxObject = angular.copy(aHistoryBoxObject);

            var lastMessage = getBoxLastMessage(aBoxObject);

            if( lastMessage ){
                aBoxObject['lastMessage'] = getMessageAdaptorObject(lastMessage);
            }

            aBoxObject['unreadCount'] = function(){ return getBoxUnreadCount(aHistoryBoxObject); }

            aBoxObject['sortBy'] = function(){ return this.lastMessage.messageDate; };

            if( aBoxObject.isTagChat ){
                var tagId = aHistoryBoxObject.key;

                var tagObject = tagChatFactory.getTag(tagId);

                aBoxObject['getTitle'] = function() {
                    var tagObject = tagChatFactory.getTag(tagId);
                    return !tagObject ? "" : tagObject.getTagName();
                };

                aBoxObject['getCover']= function(){
                    var tagObject = tagChatFactory.getTag(tagId);
                    return !tagObject ? "" : tagObject.getPictureFullUrl()
                };

                aBoxObject['shouldVisible'] = function(){
                    var tagObject = tagChatFactory.getTag(tagId);
                    return !tagObject ? false : tagObject.isTagSafeToShow();
                };


            }else{

                updateUserObject(aBoxObject, aBoxObject.key);

                aBoxObject['getTitle'] = function(){
                    return aBoxObject.user.getName();
                };

                aBoxObject['getCover']= function(){
                    return aBoxObject.user.avatar('thumb') ;
                };

                aBoxObject['shouldVisible'] = function(){ return true; };

            }


            return aBoxObject;
        };


        $scope.initBoxMessages = function(aBox){
            if( !!aBox.messages ){
                angular.forEach(aBox.messages, function(aBoxMessage, index){
                    var aBoxMessage = getMessageAdaptorObject(aBoxMessage);
                    //RingLogger.debug('BOX MESSAGE', aBoxMessage, RingLogger.tags.CHAT_HISTORY_DEBUG);
                    $scope.recentMessages.add(aBoxMessage.key, aBoxMessage );
                });
            }
        };


        $scope.initRecentMessages = function(){

            var currentUserId = Auth.currentUser().getKey();

            var currentUserBoxes = chatHistoryFactory.getChatBoxes();
            if(!!currentUserBoxes){
                angular.forEach( currentUserBoxes, function(aBox, key){

                    var aBoxObject = getBoxObject(aBox);

                    if( aBoxObject.lastMessage ){
                        //RingLogger.debug('BOX MESSAGE', aBoxObject, RingLogger.tags.CHAT_HISTORY_DEBUG);
                        $scope.boxes.add(aBox.key, aBoxObject);
                    }

                });
            }

        };

        $scope.clearRecentMessages = function(){
            $scope.recentMessages.clear();
        };

        $scope.openChatBox = function(boxId, isTagChat){

            utilsFactory.triggerCustomEvent(SystemEvents.CHAT.UNREAD_MESSAGE_INFO_UPDATED);

            if( !!isTagChat ){
                ChatFactory.openTagChatBox(boxId);
            }else{
                ChatFactory.openChatBox(boxId);
            }

        };

        $scope.initRecentMessages();

        if(!$rootScope.chatHistoryReady){
            setTimeout(function(){
                $scope.ready = true;
                $rootScope.chatHistoryReady = true;
                $scope.$rgDigest();
                rgScrollbarService.recalculate($scope);
            }, 3000);
        }

        var myTagListReceivedEventListener = utilsFactory.onCustomEvent('MY_TAG_LIST_RECEIVED', function(){
            $scope.$rgDigest();
        });

        var taglistupdatedEventListener = utilsFactory.onCustomEvent('taglistupdated', function(){
            $scope.$rgDigest();
        });

        var messageReceivedEventListener = utilsFactory.onCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED, function(data){
            updateBoxLastMessageByBoxId(data.boxId);
            $scope.$rgDigest();
        });


        var newMessageSubmittedEventListener = utilsFactory.onCustomEvent( SystemEvents.CHAT.MESSAGE_SUBMITTED , function(data){
            updateBoxLastMessageByBoxId(data.boxId);
            $scope.$rgDigest();
        });

        $scope.$on("$destroy", function(){

            utilsFactory.removeCustomEvent('MY_TAG_LIST_RECEIVED', myTagListReceivedEventListener);
            utilsFactory.removeCustomEvent('taglistupdated', taglistupdatedEventListener);

            utilsFactory.removeCustomEvent(SystemEvents.CHAT.MESSAGE_SUBMITTED, newMessageSubmittedEventListener);

            utilsFactory.removeCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED, messageReceivedEventListener);

        });



    }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.chat')
		.controller('ChatMediaUploadController', ChatMediaUploadController);

    ChatMediaUploadController.$inject = ['$scope', 'fileUploadService', 'utilsFactory', '$boxInstance'];
        function ChatMediaUploadController($scope, fileUploadService, utilsFactory, $boxInstance){

            $scope.navSection = 0;

            $scope.sendMedia = function(){

                if( !!$scope.capturedMedia ){

                    var uploadFile = fileUploadService.queueFile('chatimage', utilsFactory.dataURLToBlob($scope.capturedMedia));


                    // uploadFile.initUpload().then(function(json) {
                    //     RingLogger.print(json, RingLogger.tags.UPLOAD);

                    //     $boxInstance.close();
                    // }, function(err) {
                    //     RingLogger.warning(err, RingLogger.tags.UPLOAD);
                    // });

                    //var uploadActionObj = fileUploadService.getUploadActionObjectByBase64Image($scope.capturedMedia);

                    utilsFactory.triggerCustomEvent('BOX_CAM_UPLOAD', { uploadFile : uploadFile })

                    $boxInstance.close();

                }
            };


        }



})();

(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {

    }
    chatApp
        .factory('chatUtilsFactory', chatUtilsFactory);


    function STATE_OUT_OF_BOUND_EXCEPTION(){}

    chatUtilsFactory.$inject = ['utilsFactory', 'settings', 'CHAT_STATES',
        'CHAT_FLOWS', "CHAT_STATE_INFO",
        'CHAT_GLOBAL_VALUES', 'Auth'];

    function chatUtilsFactory(utilsFactory, settings, CHAT_STATES,
                              CHAT_FLOWS, CHAT_STATE_INFO,
                              CHAT_GLOBAL_VALUES, Auth){

        var textParseForLinkAndEmo = function(text){

            //var out, flag= 0,
            //stickerPattern = /^http:\/\/image\.ringid\.com\/?.*$/, // /(http|ftp|https):\/\/[\w-]+(\.[\w-]+)+([\w.,@?^=%&amp;:\/~+#-]*[\w@?^=%&amp;\/~+#-])?/gi,
            //
            //googleMapJslocationPattern = /^https:\/\/maps\.google\.com\/?.*$/, //gogoleMapJslocationPattern
            //googleMapStaticPattern = /^https:\/\/maps\.googleapis\.com\/?.*$/; //gogoleMapJsStaticPattern
            //
            ////replacing the sticker starts
            //out =  text.replace(stickerPattern, function(match) {
            //    flag = 1;
            //    var caption = match.split('__');
            //    if(caption.length > 1){
            //        match = caption[0];
            //        caption = caption[1];
            //        return '<img title="' + match + '" width="100%" src="' + match + '" /><br/><p>'+caption+'</p>';
            //    }
            //    return '<img title="' + match + '" width="100%" src="' + match + '" />';
            //});
            //
            ////replacing the sticker ends
            //
            ////replacing location map starts
            //if(flag !==1){
            //    //out =  text.replace(googleMapJslocationPattern, function(match) {
            //    //    flag = 3;
            //    //    return '<iframe width="100%" height="100" frameborder="0" scrolling="no" marginheight="0" marginwidth="0" src="'+match+'"></iframe>';
            //    //});
            //
            //    out =  text.replace(googleMapStaticPattern, function(match) {
            //        flag = 3;
            //        return '<img src="{0}" alt="" />'.format(match);
            //    });
            //}
            ////replacing location map ends
            //
            //if( flag == 0 ){
            //    out = text;
            //}

            text = utilsFactory.parseForLE(text, 0);

            return text;
        };

        var _getOfflineIpPort = function(){
            var loginData = Auth.loginData, ip, port;

            var oIpPort = {
                ip : '',
                port : ''
            };

            if( !!loginData ){
                oIpPort.ip = loginData.oIP;
                oIpPort.port = loginData.oPrt;
            }

            return oIpPort;
        };

        var _hasOfflineIpPort = function(){
            var ipPort = _getOfflineIpPort();
            return !(!ipPort || !ipPort.ip  || !ipPort.port);
        };

        var getChatServerCurrentTime = function () {
            return parseInt(new Date().getTime() + CHAT_GLOBAL_VALUES.serverTimeDiff);
        };

        function getChatStateName(stateId){
            try{

                return CHAT_STATE_INFO[stateId].NAME;

            }catch(e){

            }

        }

        return {
            parseForLE : function(text){ // prases for link and emoticon
                return textParseForLinkAndEmo(text);
            },

            getChatServerCurrentTime : getChatServerCurrentTime,
            getOfflineIpPort : _getOfflineIpPort,
            hasOfflineIpPort : _hasOfflineIpPort,
            getChatStateName : getChatStateName
        }

    }
})();


/*** State Machine ***/

//function ChatStateMachine(){
//
//    this.currentStateIndex = 0;
//    this.states = [];
//    this.flow = [];
//    //this.stateCallbacks = {};
//    //this.stateCallbackResults = {};
//}
//
//ChatStateMachine.prototype = {
//
//    defaultCallback : function(stateInfo){
//        RingLogger.information('STATE DEFAULT CALLBACK', stateInfo.NAME, RingLogger.tags.CHAT_STATE_MACHINE);
//    },
//
//    setFLow : function(flow){
//        this.flow  = flow;
//    },
//
//    getFLow : function(){
//        return this.flow;
//    },
//
//    //on : function(stateName, callback){
//    //    this.stateCallbacks[stateName] = callback;
//    //},
//
//    getCurrentState : function(){
//        return this.flow[this.currentStateIndex];
//    },
//
//    setCurrentState : function(state){
//        this.currentStateIndex = this.flow.indexOf(state);
//    },
//
//    next : function(){
//        if( this.currentStateIndex < this.flow.length ){
//            this.currentStateIndex++;
//        }else{
//            throw new STATE_OUT_OF_BOUND_EXCEPTION()
//        }
//    },
//
//    previous : function(){
//        if( this.currentStateIndex > 0 ){
//            this.currentStateIndex--;
//        }else{
//            throw new STATE_OUT_OF_BOUND_EXCEPTION()
//        }
//    }
//
//
//};

/**
 * Created by mahbubul on 3/5/15.
 */
(function () {
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {

    }

    chatApp
        //box
        .factory('ChatFactory', ['settings','CHAT_PACKET_FORMAT', 'ChatPacketSenderService',
            'Storage', '$window', '$$stackedMap',
            'ChatMap', 'Auth', 'utilsFactory', '$rootScope',
            'PacketDataParse','$timeout','globalSocketFactory',
            'chatHistoryFactory', 'profileHttpService','userFactory','friendsFactory',
            'tagChatPacketProcessor', 'tagChatApiService', 'tagChatFactory', '$interval', '$$connector', 'OPERATION_TYPES','CHAT_GLOBAL_VALUES',
            'AUTH_SERVER_ACTIONS', 'CHAT_GENERAL_CONSTANTS', 'TAG_CHAT_PACKET_TYPE', 'FRIEND_CHAT_PACKET_TYPE', 'OFFLINE_PACKET_TYPE',
            'chatPacketResender', 'ChatApiService', 'PLATFORM', 'profileFactory',

            function (settings, CHAT_PACKET_FORMAT, ChatPacketSenderService,
                      Storage,  $window, $$stackedMap,
                      ChatMap, Auth, utilsFactory, $rootScope,
                      PacketDataParse,$timeout,globalSocketFactory,
                      chatHistoryFactory,profileHttpService,userFactory, friendsFactory,
                      tagChatPacketProcessor, tagChatApiService, tagChatFactory, $interval, $$connector, OPERATION_TYPES,CHAT_GLOBAL_VALUES,
                      AUTH_SERVER_ACTIONS, CHAT_GENERAL_CONSTANTS, TAG_CHAT_PACKET_TYPE, FRIEND_CHAT_PACKET_TYPE, OFFLINE_PACKET_TYPE,
                      chatPacketResender, ChatApiService, PLATFORM, profileFactory

            ) {

                var ChatPacketSender = chatPacketResender.ChatPacketSender;
                var getUUIDPacketId = tagChatFactory.getUUIDPacketId;

                var boxes = $$stackedMap.createNew();


                var getNumberOfAvailableChatBox = function (viewportXValue) { //return 4;

                    // left panel   : 200 px
                    // right panel  : 200 px
                    // hidden list  : 165 px
                    // box width    : 300 px
                    // padding      :  10 px
                    //var avaiable_width = utilsFactory.viewport.x - 400 - 100;
                    if(!!viewportXValue){
                        var avaiable_width = viewportXValue - 400 - 165;
                    }else{
                        var avaiable_width = utilsFactory.viewport.x - 400 - 165;
                    }
                    var box_counter = $window.parseInt(avaiable_width / 310);
                    return box_counter;
                };

                //var numberOfAvailableChatBox = getNumberOfAvailableChatBox();

                var processInMessage = function (message) {// right now it may not in action

                    var friendId = message.friendName.split(",")[0];

                    var box = getBox(friendId);
                    // boxes.add(friendId,box);
                    if (angular.isArray(message.messageList)) {
                        for (var i = 0; i < message.messageList.length; i++) {
                            box.pushMessage(message.messageList[i]);
                        }
                    }
                };

                var getBoxObjectClass = function(userId){
                    var chatBoxClass = {
                        key                 : userId,
                        isMinimized         : false,
                        isHidden            : false,
                        isFocused           : false,
                        blinkOn             : false,
                        timeout             : 5,
                        secretChat          : false,
                        nonDomBox           : false,
                        closedBox           : false,
                        offlineStatus       : false,
                        blocked             : false,
                        isSecretVisible     : true,
                        singlePage          : false,
                        lastSeenBar         : true,
                        unreadCount         : 0,
                        chatBoxClass        : 'chat-body-opened'
                    };

                    return chatBoxClass;

                };


                var getNewBoxObject = function(userId, isTagChat, boxInfo){
                    userId = userId.toString();

                    if(!boxInfo){
                        boxInfo = {};
                    }

                    var box = boxes.get(userId);
                    if (box !== false) {
                        return box;
                    } else {
                        box = ChatMap.create(userId, isTagChat);
                    }

                    if(!isTagChat){

                        profileFactory.getUserObjectByUId(userId);
                        profileHttpService.fetchPresence([userId]);
                    }

                    var boxChatBoxObject = getBoxObjectClass(userId);
                    boxChatBoxObject.isFocused = true;
                    boxChatBoxObject.nonDomBox = true;
                    boxChatBoxObject.isTagChat = isTagChat;
                    boxChatBoxObject.lastLogin = (!!box.getUser() && box.getUser().lastOnline) ? box.getUser().lastOnline() : '';


                    boxChatBoxObject = angular.extend(box, boxChatBoxObject, boxInfo);

                    return boxChatBoxObject;
                };

                var getBox = function (userId, isTagChat) {

                    var box = getNewBoxObject(userId, isTagChat);

                    boxes.save(userId, box);

                    chatHistoryFactory.addBox(box);    //for adding box to localStorage for saving chatHistory

                    return box;
                };

                var openChatBox = function (userId, sendToTab) {
                    userId = userId.toString();

                    var box = boxes.get(userId);
                    if (box === false) {

                        box = getBox(userId, false);
                        $rootScope.$broadcast("chatOpened", {user: userId, sendToTab : sendToTab});
                        //$rootScope.$broadcast("ScrollToBottom", userId);

                    } else {

                        if( !box.nonDomBox ){
                            $rootScope.$broadcast("chatOpened", {user: userId, sendToTab : sendToTab});
                        }

                        box.isFocused = true;
                        box.nonDomBox = true;
                        box.blinkOn   = false;
                        chatHistoryFactory.updateBox(box);
                    }
                };
                var openTagChatBox = function (groupId, sendToTab) {
                    groupId = groupId.toString();

                    var box = boxes.get(groupId);
                    if (box === false) {
                        box = getBox(groupId, true);

                        $rootScope.$broadcast("chatOpened", {user: groupId, sendToTab : sendToTab});
                        //$rootScope.$broadcast("ScrollToBottom", groupId);
                    } else {

                        if( !box.nonDomBox ){
                            $rootScope.$broadcast("chatOpened", {user: groupId, sendToTab : sendToTab});
                        }

                        box.isFocused = true;
                        box.nonDomBox = true;
                        box.blinkOn   = false;
                        chatHistoryFactory.updateBox(box);
                    }
                    return box;
                };
                var createNonDomBox = function (userId, isTagChat) {
                    userId = userId.toString();

                    var box = ChatMap.create(userId, isTagChat);

                    var boxChatBoxObject = getBoxObjectClass(userId);
                    boxChatBoxObject.closedBox = true;
                    boxChatBoxObject.isTagChat = isTagChat;

                    boxChatBoxObject = angular.extend(box, boxChatBoxObject);
                    boxes.save(userId, boxChatBoxObject);

                    chatHistoryFactory.addBox(boxChatBoxObject);//for adding box to localStorage for saving chatHistory

                    return box;
                };


                /*
                 * Description: to make the hidden chatbox visible
                 * param: userId (which is the key for the stackmap)
                 * Date: 04-04-15
                 * Developed By: rabbi
                 * */                //
                var makeVisibleChatBox = function (userId) {
                    userId = userId.toString();

                    var boxObject = boxes.get(userId);// get the box object from boxes using key(userId), which returns the only value not the key
                    if (boxObject !== false) {
                        boxes.remove(userId); //remove from the boxes with the key (userId)
                        boxes.save(userId, boxObject);// reAdd the same box object into boxes using key(userId), so it would add at the end of the stack
                    }
                };
                var closeChatBox = function (userId) {
                    /* to make the box closed we'll need to change the box close property
                     instead of removing it from the stackMap
                     box.closedBox = false;// will always be true and only be false when user closes box
                     need to send unregister packet only for online users
                     offline box will have no ip/port so in that case we won't send unregister packet */

                    userId = userId.toString();
                    var box = boxes.get(userId);
                    box.closedBox = true;
                    chatHistoryFactory.updateBox(box);

                    if(!!box.getIp()){
                        ChatPacketSenderService.sendChatUnRegisterPacket(box);
                    }
                    box.stopInterval();
                    boxes.remove(userId);
                };

                var closeTagChatBox = function (tagId) {
                    tagId = tagId.toString();
                    var box = boxes.get(tagId);
                    box.closedBox = true;
                    chatHistoryFactory.updateBox(box);

                    box.stopInterval();
                    boxes.remove(tagId);
                };

                var minimizeBox = function (userId) {
                    userId = userId.toString();
                    var box = boxes.get(userId);
                    //if(!!box.blinkOn && !box.isMinimized){//true false: if blinking is on then it won't minimize
                    //
                    //} else if(!!box.blinkOn && !!box.isMinimized){//true true:
                    //
                    //} else if(!box.blinkOn && !box.isMinimized){// false true:
                    //    box.chatBoxClass = 'chat-body';
                    //    box.isMinimized = !box.isMinimized;
                    //} else if(!box.blinkOn && !!box.isMinimized){ // false false:
                    //    box.chatBoxClass = 'chat-body-opened';
                    //    box.isMinimized = !box.isMinimized;
                    //}
                    box.isMinimized = !box.isMinimized;
                    // might need to handle the case where if box is minimized then it will be isFocus false(but will not need 'cause it is handle in chatFocus onclick)
                    if (box.isMinimized){
                        box.isFocused = false;
                        box.chatBoxClass = 'chat-body';
                    }else{
                        box.isFocused = true;
                        box.chatBoxClass = 'chat-body-opened';
                    }
                    //RingLogger.log(box.isMinimized);
                    chatHistoryFactory.updateBox(box);
                };

                var refreshBox = function(boxId){

                    chatHistoryFactory.loadChatBoxes();

                    var historyBox = chatHistoryFactory.getBox(boxId);

                    var chatbox = boxes.get(boxId);

                    if( !chatbox){

                        if( !historyBox.closedBox ){
                            var boxChatBoxObject = getNewBoxObject(boxId, historyBox.isTagChat, historyBox);
                            boxes.save(boxId, boxChatBoxObject);

                            boxChatBoxObject.loadHistoryMessages();

                        }


                    }else{

                        if( !historyBox.closedBox ){

                            angular.extend(chatbox, historyBox);
                            chatbox.loadHistoryMessages();

                        }else {
                            boxes.remove(boxId);
                        }
                    }

                };

                var openAndAddMessage = function(boxId, message){
                    if(!message){
                        return;
                    }

                    var currentUser = Auth.currentUser();

                    var box = boxes.get(boxId);

                    if(!box){

                        if(!!message.tag_chat){
                            var tag = tagChatFactory.getTag(boxId);
                            if( tag.isTagSafeToShow()){
                                openTagChatBox(boxId);
                            }
                        }else{
                            openChatBox(boxId);
                        }

                        box = getBox(boxId, message.tag_chat);
                        box.loadHistoryMessages();

                    }else{
                        box.nonDomBox = true;
                        box.pushMessage(message, currentUser);
                    }

                    utilsFactory.triggerCustomEvent('NEW_MESSAGE_PUSHED', {boxId : boxId, scroll : 'bottom'});

                };


                return {
                    openChatBox: function (userId, sendToTab) {
                        openChatBox(userId, sendToTab);
                    },
                    openTagChatBox: openTagChatBox,
                    closeTagChatBox: closeTagChatBox,
                    creatNonDomBox: createNonDomBox,
                    makeVisibleChatBox: makeVisibleChatBox,
                    processInMessage: processInMessage,
                    closeChatBox: closeChatBox,

                    getBoxes: function () {
                        return boxes.all();
                    },
                    ggg: function () {
                        return boxes.nonClosedLength();
                    },
                    getBoxByUId : function(uId){
                        return boxes.get(uId);
                    },
                    refreshBox : refreshBox,

                    minimizeBox: minimizeBox,

                    getNumberOfAvailableChatBox: function (viewportXValue) {
                        //return numberOfAvailableChatBox;
                        return getNumberOfAvailableChatBox(viewportXValue);
                    },

                    getNonClosedLength: function () {
                        return boxes.nonClosedLength();
                    },

                    increaseUnreadMessageCount : function(boxId, messageId){
                        chatHistoryFactory.addUnreadMessageInfo(boxId, messageId);
                        chatHistoryFactory.updateUnreadMessageInfos();
                    },

                    decreaseUnreadMessageCount : function(boxId, messageId){
                        chatHistoryFactory.removeUnreadMessageInfo(boxId, messageId);
                        chatHistoryFactory.updateUnreadMessageInfos()
                    },

                    getUnreadMessageCount : function(){
                        return chatHistoryFactory.getUnreadMessageCount();
                    },

                    getUUIDPacketId : getUUIDPacketId,

                    openAndAddMessage : openAndAddMessage

                };
            }
        ]);



})();


/* author @ibrahim */
(function() {
    'use strict';
    angular
        .module('ringid.chat')
        .service('ChatApiService', ChatApiService);

    ChatApiService.$inject = [ '$$connector', 'OPERATION_TYPES', 'Auth',
        'FRIEND_CHAT_PACKET_TYPE', 'OFFLINE_PACKET_TYPE',
        'globalSocketFactory',
        'PacketDataParse',
        'CHAT_GENERAL_CONSTANTS',
        'tagChatFactory',
        'AUTH_SERVER_ACTIONS', 'PLATFORM', 'utilsFactory',
        'chatUtilsFactory'];

    function ChatApiService ( $$connector, OPERATION_TYPES, Auth,
                              FRIEND_CHAT_PACKET_TYPE, OFFLINE_PACKET_TYPE,
                              globalSocketFactory,
                              PacketDataParse,
                              CHAT_GENERAL_CONSTANTS,
                              tagChatFactory,
                              AUTH_SERVER_ACTIONS, PLATFORM, utilsFactory,
                              chatUtilsFactory) {

        var getUUIDPacketId = tagChatFactory.getUUIDPacketId;

        var self = this;

        self.getFriendOnlineStatus = function(friendId){
            //199 request object single presence : 136 request object multiple presence
            // here we are using 199
            var presenceRequestObject ={
                actn: OPERATION_TYPES.SYSTEM.PROFILE.TYPE_ACTION_USER_MOOD_PRESENCE,
                fndId:friendId
            };
            return $$connector.request(presenceRequestObject, OPERATION_TYPES.SYSTEM.REQUEST_TYPE.REQUEST);
        };

        self.requestForIp = function(friendId){

            /* Duplicate Work, Puller Subscriber Has this method, but due to circular dependency its redefined
            *  todo refactor, ChatFactory to hold only data boxes, it don't do any actions
            *  todo refactor, Use ChatApiService to Send Api Requests
            *  todo refactor, Use ChatHelper to preprocess data, and common processing
            *  todo refactor, Use ChatUtils to Do Generic Stuffs
            *
            * */

            var requestObject = {
                actn            : 175,
                fndId           : friendId,
                uId             : Auth.loginData.uId
            };

            _logRequestedPacketInfo('AUTH ' + requestObject.actn, requestObject);

            $$connector.send(requestObject,OPERATION_TYPES.SYSTEM.REQUEST_TYPE.CHAT);

        };


        self.getRegisterForFriendChatRequestObject = function(ip, port, userId, friendId){
            var registerObject = {
                ip: ip,
                port: port,
                packetType: FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_REGISTER,
                packetId: tagChatFactory.getUUIDPacketId(),
                userId: userId,
                friendId: friendId,
                platform: PLATFORM.WEB

            };

            return registerObject
        };

        var getMessageObjectClass = function(ip, port, packetType, userId, messageType,
                                             messageDate, message, timeout, packetId){
            var msgObjectClass = {
                ip                  : ip,
                port                : port,
                packetType          : packetType,
                userId              : userId,
                tag_chat            : false,
                messageType         : messageType,
                message             : message,
                messageDate         : messageDate,
                key                 : packetId,
                packetId            : packetId,
                timeout             : timeout,
                platform            : PLATFORM.WEB
            };

            return msgObjectClass;
        };


        self.getBlankMessageObject = function(friendId){

            var ipPort = chatUtilsFactory.getOfflineIpPort(),
                currentUserId = Auth.currentUser().getKey(),
                messageDate = chatUtilsFactory.getChatServerCurrentTime(),
                packetId = getUUIDPacketId(messageDate),
                messageType = CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.BLANK_MESSAGE,
                packetType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG;



            var blankMessageObject = {
                ip                  : ipPort.ip,
                port                : ipPort.port,
                packetType          : packetType,
                userId              : currentUserId,
                friendId            : friendId,
                tag_chat            : false,
                messageType         : messageType,
                message             : '',
                messageDate         : messageDate,
                key                 : packetId,
                packetId            : packetId,
                timeout             : 0,
                platform            : PLATFORM.WEB
            };

            return blankMessageObject;

        };

        self.getFriendInformationPacketObject = function(friendId, friendFullName,
                                                         friendPlatfrom, friendOnlineStatus,
                                                         friendAppType, friendDeviceToken,
                                                         friendMood
        ){

            var ipPort = chatUtilsFactory.getOfflineIpPort(),
                currentUserId = Auth.currentUser().getKey(),
                messageDate = chatUtilsFactory.getChatServerCurrentTime(),
                packetId = getUUIDPacketId(messageDate),
                packetType = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_INFORMATION;



            var friendInformationObject = {
                ip                  : ipPort.ip,
                port                : ipPort.port,
                packetType          : packetType,
                userId              : currentUserId,
                friendId            : friendId,
                packetId            : packetId,
                fullName            : friendFullName,
                platform            : friendPlatfrom,
                onlineStatus        : friendOnlineStatus,
                friendAppType       : friendAppType,
                friendDeviceToken   : friendDeviceToken,
                userMood            : friendMood,

            };

            return friendInformationObject;

        };

        self.getIdlePacketObject = function(box){

            var ip = box.getIp(),
                port = box.getPort(),
                currentUserId = Auth.currentUser().getKey(),
                friendId = box.getKey(),                                     // this is the friendId 'cause
                messageDate = chatUtilsFactory.getChatServerCurrentTime(),
                packetId = getUUIDPacketId(messageDate),
                packetType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_IDLE;      //idle pcaket : previous:10

            var idlePacketObject = {
                ip                  : ip,
                port                : port,
                packetType          : packetType,
                userId              : currentUserId,
                friendId            : friendId,
                packetId            : packetId,
                platform            : PLATFORM.WEB
            };

            return idlePacketObject;

        };

        self.getTypingPacketObject = function(box){

            var ip = box.getIp(),
                port = box.getPort(),
                currentUserId = Auth.currentUser().getKey(),
                friendId = box.getKey(),                                     // this is the friendId 'cause
                messageDate = chatUtilsFactory.getChatServerCurrentTime(),
                packetId = getUUIDPacketId(messageDate),
                packetType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_TYPING;      //typing packet : previous:9

            var typingPacketObject = {
                ip                  : ip,
                port                : port,
                packetType          : packetType,
                userId              : currentUserId,
                friendId            : friendId,
                packetId            : packetId,
                platform            : PLATFORM.WEB

            };

            return typingPacketObject;

        };


        self.getF2FUnRegisterObject = function(box){

            var ip = box.getIp(),
                port = box.getPort(),
                currentUserId = Auth.currentUser().getKey(),
                friendId = box.getKey(),                                     // this is the friendId 'cause
                messageDate = chatUtilsFactory.getChatServerCurrentTime(),
                packetId = getUUIDPacketId(messageDate),
                packetType = FRIEND_CHAT_PACKET_TYPE.FRIEND_UNREGISTER_PKT;      //typing packet : previous:9

            var unregisterObject = {
                ip                  : ip,
                port                : port,
                packetType          : packetType,
                packetId            : packetId,
                userId              : currentUserId,
                friendId            : friendId,
                onlineStatus        : 0,
                userMood            : 0

            };

            return unregisterObject;
        };

        self.getF2FMessageDeleteObject = function(box, packetId){

            var ip = box.getIp(),
                port = box.getPort(),
                currentUserId = Auth.currentUser().getKey(),
                messageDate = chatUtilsFactory.getChatServerCurrentTime(),
                friendId = box.getKey(),                                     // this is the friendId 'cause
                packetType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_TYPING;      //typing packet : previous:9

            if(box.offlineStatus == true){
                var offlineIpPort = chatUtilsFactory.getOfflineIpPort();
                ip = offlineIpPort.ip;
                port = offlineIpPort.port;
            }

            var deleteObject = {
                ip                  : ip,
                port                : port,
                packetId            : packetId,
                packetType          : FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MULTIPLE_MSG_DELETE,
                userId              : currentUserId,
                friendId            : friendId,
                noOfMessages        : 1,
                packetIds           : [packetId],
                messageDate         : messageDate,
                platform            : PLATFORM.WEB
            };

            return deleteObject;
        };

        self.getOfflineIpPort = function(){
            var currentUserId = Auth.currentUser().getKey();

            var requestObject = {
                actn: AUTH_SERVER_ACTIONS.GET_OFFLINE_IP_PORT,
                rid : currentUserId
            };

            return $$connector.request(requestObject, OPERATION_TYPES.SYSTEM.REQUEST_TYPE.REQUEST);

        };


        function _getPacket(requestObject, packetType, format){

            var packet = PacketDataParse.constructPacket(requestObject, packetType, format);

            return packet;
        }

        function _logRequestedPacketInfo(packetName, packetObject){
            RingLogger.infoblack(packetName,  packetObject, RingLogger.tags.CHAT_REQUEST );
        }

        self.sendViaGlobalChatSocket =  function(requestObject, formatInfo){

            var requestObjectPacket = _getPacket(requestObject, formatInfo.PACKET_TYPE, formatInfo.FORMAT);

            if(!!requestObjectPacket){
                globalSocketFactory.send(requestObjectPacket);
            }

            if( formatInfo.PACKET_TYPE != 4 && formatInfo.PACKET_TYPE != 5){
                _logRequestedPacketInfo(formatInfo.PACKET_NAME, requestObject);
            }


            return requestObjectPacket;
        }





    }
})();

(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}

    chatApp
        .factory('ChatMap', ['$$stackedMap','$interval',
            'CHAT_PACKET_FORMAT', 'globalSocketFactory', 'userFactory', 'utilsFactory',
            '$websocket','$rootScope','$sce',
            'Auth', 'tagChatFactory', 'profileFactory',
            'chatHistoryFactory','PacketDataParse','settings',
            'tagChatApiService', 'TAG_CHAT_GENERAL_CONSTANTS', 'tagChatHelper', 'tagChatStorage','CHAT_GLOBAL_VALUES',
            'CHAT_GENERAL_CONSTANTS', 'chatUtilsFactory', 'rgScrollbarService', 'chatTabSync', 'ChatPacketSenderService',

        function ($$stackedMap, $interval,
            CHAT_PACKET_FORMAT, globalSocketFactory, userFactory, utilsFactory,
            $websocket, $rootScope,$sce,
            Auth, tagChatFactory, profileFactory,
                  chatHistoryFactory, PacketDataParse,settings,
            tagChatApiService, TAG_CHAT_GENERAL_CONSTANTS, tagChatHelper, tagChatStorage,CHAT_GLOBAL_VALUES,
            CHAT_GENERAL_CONSTANTS, chatUtilsFactory, rgScrollbarService, chatTabSync, ChatPacketSenderService

        ) {


                var getBasicMessageObject = function(message){

                    var key = message.key || message.packetId;
                    var mdate = message.messageDate || new Date().getTime();

                    var basicMsgObj = {
                        key: key.toString(),
                        packetId: key.toString(),
                        text: message.message || message.mg || message.text,
                        hrtime: utilsFactory.chatVerbalDate(mdate),
                        status: message.status || 0,
                        fullName : message.fullName,
                        tagName : message.tagName || '',
                        messageDate: mdate,
                        isDeleted: false,
                        messageDateString: message.messageDateString || '',
                        timeout: message.timeout,
                        messageType: message.messageType,
                        tag_chat: message.tag_chat || false,
                        seenSent : message.seenSent || false,
                        isSecretVisible: message.isSecretVisible,
                        secretTimedOut : message.secretTimedOut ? message.secretTimedOut : false,
                        lastUpdateTime : new Date().getTime(),
                        platform: 5
                    };
                    if(!!message.tag_chat){
                        basicMsgObj.packetType = message.packetType || 63;
                        basicMsgObj.brokenPacketType = message.brokenPacketType;
                    }else{
                        basicMsgObj.packetType = message.packetType || 6;
                        basicMsgObj.brokenPacketType = message.brokenPacketType;
                    }
                    return basicMsgObj;

                };

                return {

                    create: function (userId,isTagChat) {
                        var chat, returnob, intervalVar,
                            tagItem, tagId, user,
                            boxId = userId;

                        if(isTagChat){
                            tagId = userId;
                            tagItem = tagChatFactory.getTag(tagId);//pass groupId which is coming here as userId
                        }
                        else{
                            user = userFactory.create({uId: userId});
                        }

                        var isTyping = false,
                        isFriendTyping = false,
                        ip,port,connection,
                        rIp,rPort,rConnection,
                        lastCommunicationTime=0,
                        tempMessageArray = [],
                        tempSeenMessageArray = [],
                        messages = $$stackedMap.createNew(true, 'asc');

                        var pushMessage = function (message, user, sendToTab) {

                            //RingLogger.print(chatHistoryFactory.getMessages(userId), RingLogger.tags.CHAT);
                            // messageDate was previously mgDate:::
                            // and need to * with 1000 it was sent as second and now it need to be in milisecond

                            //message.messageDate *= 1000;// right now it sending messageDate as millisecond as we've handled 53bit number in 8Byte
                            //RingLogger.print(chatHistoryFactory.getMessages(userId), RingLogger.tags.CHAT);
                            var tempmesg;
                            if (!!message.type && message.type === 101) { // user is typing
                                isTyping = true;
                                return;
                            }
                            if (message.type == 0 && message.status === 0) { // when message is deleted// set only property to zero
                                tempmesg = messages.get(messages.packetId);
                                tempmesg.isDeleted = true;
                                return;

                            }


                            /*  wasn't sure why we needed this part of the code, but and thought it doesn't required
                                so commented out while doing message editing feature:21 oct,2015
                             */
                            //if (message.key !== undefined) {
                            //    tempmesg = messages.get(message.key);
                            //    if (tempmesg !== false && message.packetId !== undefined) {
                            //        messages.remove(message.key);
                            //        tempmesg.key = message.packetId;
                            //        tempmesg.status = message.status;
                            //        tempmesg.messageDate = message.messageDate;
                            //        tempmesg.hrtime = utilsFactory.chatVerbalDate(message.messageDate);
                            //        //messages.add(message.packetId, tempmesg); //we might need to use save instead of add, as we don't want duplicate object with same key/packetId
                            //        messages.save(message.packetId, tempmesg);
                            //        return;
                            //    }
                            //
                            //}
                            //this mdate needs to be in miliseonds
                            //var mdate = message.messageDate - returnob.serverTimeDiff || new Date().getTime();
                            var parsedMessageText = "";

                            var basicMsgObj = getBasicMessageObject(message);

                            if( !angular.isObject(user)  ){

                                user = profileFactory.getUserObjectByUId(message.userId, function(){
                                    utilsFactory.triggerCustomEvent('SINGLE_MESSAGE_UPDATED', { message : basicMsgObj });
                                });
                            }

                            var msgObj = {

                                locationInfo : {},
                                ogData : {},
                                seenUserIds : {},
                                deliveredUserIds : {},
                                user: user,

                                sortBy: function () {
                                    return message.messageDate;
                                },
                                getTextPartition: function () {
                                    return parsedMessageText;
                                },
                                setTextPartition: function () {
                                    parsedMessageText = chatUtilsFactory.parseForLE(msgObj.text);
                                    parsedMessageText = $sce.trustAsHtml(parsedMessageText);
                                },
                                getMessageTime: function () {
                                    var localTime = message.messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff;
                                    var localFormatedTime = utilsFactory.chatVerbalDate(localTime);
                                    return localFormatedTime;
                                },
                                seenUsersCount : function(){
                                    return Object.keys(msgObj.seenUserIds).length;
                                },
                                deliveredUsersCount : function(){
                                    return Object.keys(msgObj.deliveredUserIds).length;
                                },
                                addSeenUserId : function(userId){
                                    msgObj.seenUserIds[userId] = true;
                                },
                                addDeliveredUserId : function(userId){
                                    msgObj.deliveredUserIds[userId] = true;
                                    //RingLogger.log(msgObj);
                                    RingLogger.print(msgObj,RingLogger.tags.CHAT);
                                    RingLogger.print(msgObj, RingLogger.tags.CHAT);
                                },
                                updateLocationInfo : function(){
                                    var locationInfo, latitude, longitude;
                                    try{
                                        locationInfo = angular.fromJson(msgObj.text);
                                        latitude = locationInfo.la; //PacketDataParse.Bytes2Float32
                                        longitude = locationInfo.lo; //PacketDataParse.Bytes2Float32
                                        msgObj.locationInfo = { lat : latitude, long : longitude, description : locationInfo.loc };
                                        msgObj.plainText = locationInfo.loc;
                                    }catch(e){
                                    }
                                },
                                updateLinkShareInfo : function(){
                                    msgObj.ogData = {};
                                    try {
                                        var messageLinkJson = angular.fromJson(msgObj.text);
                                        msgObj.ogData = {
                                            lnkDmn: messageLinkJson.u,
                                            description: messageLinkJson.d,
                                            title: messageLinkJson.t,
                                            url: messageLinkJson.u,
                                            image: messageLinkJson.i,
                                            message : messageLinkJson.m
                                        };
                                        msgObj.plainText = messageLinkJson.m;
                                    }catch (e){
                                    }
                                },
                                updateMediaInfo : function(){
                                    var mediaInfo;
                                    try{
                                        mediaInfo = angular.fromJson(msgObj.text);
                                        msgObj.mediaInfo = { url : mediaInfo.u, caption : mediaInfo.c, width: mediaInfo.w, height: mediaInfo.h };
                                        msgObj.plainText = mediaInfo.c;
                                    }catch(e){
                                    }
                                }
                            };//end of msgObj

                            angular.extend(msgObj, basicMsgObj);

                            message.userId = msgObj.userId = msgObj.user.getKey();

                            if( !!message.usersToChange ){
                                msgObj.usersToChange = message.usersToChange;
                            }

                            if( !!message.statusType){
                                msgObj.statusType = message.statusType;
                            }

                            if( message.status !== 'status_update'){

                                if(!(message.secretTimedOut == true) && message.status === "Deleted") {
                                    //only for non secret delete messages
                                    //we're making them forcefully type text otherwise it won't show 'this message has been deleted'
                                    msgObj.messageType = 2;
                                    parsedMessageText = chatUtilsFactory.parseForLE(msgObj.text);
                                }
                                else{
                                    switch (message.messageType){
                                        case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.TEXT:
                                            parsedMessageText = chatUtilsFactory.parseForLE(msgObj.text);
                                            break;

                                        case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.LOCATION_SHARE:
                                            msgObj.updateLocationInfo();
                                            var latitude = msgObj.locationInfo.lat,
                                                longitude = msgObj.locationInfo.long,
                                                mapUrl;

                                            if(latitude !=0 && longitude !=0){

                                                msgObj.mapStaticUrl =  utilsFactory.getGoogleMapStaticUrl(latitude, longitude) ;
                                                msgObj.mapJsUrl = utilsFactory.getGoogleMapJSUrl(latitude, longitude) ;

                                            }else{

                                                parsedMessageText = chatUtilsFactory.parseForLE(msgObj.text);

                                            }
                                            break;

                                        case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.LINK_SHARE:
                                            msgObj.updateLinkShareInfo();
                                            break;

                                        case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.STICKER:
                                            //parsedMessageText = utilsFactory.parseForLE(settings.imBase + msgObj.text);
                                            msgObj.stickerUrl = settings.stickerBase + msgObj.text;
                                            break;

                                        case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.IMAGE:
                                        case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.CAMERA_IMAGE:
                                            msgObj.updateMediaInfo();

                                            try{
                                                
                                                msgObj.mediaUrl = settings.imBase + msgObj.mediaInfo.url;    

                                            }catch(e){
                                                msgObj.mediaUrl = ""
                                            }

                                            parsedMessageText = "";

                                            break;

                                        case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.AUDIO:
                                            msgObj.updateMediaInfo();
                                            msgObj.isVideo = false;

                                            try{
                                                msgObj.mediaUrl = settings.mediaBase + msgObj.mediaInfo.url;    
                                            }catch(e){
                                                msgObj.mediaUrl = "";
                                            }
                                            

                                            break;

                                        case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.VIDEO:
                                            msgObj.updateMediaInfo();
                                            msgObj.isVideo = true;

                                            try{
                                                
                                                msgObj.mediaUrl = settings.mediaBase + msgObj.mediaInfo.url;    

                                            }catch(e){
                                                msgObj.mediaUrl = ""
                                            }
                                            
                                            break;

                                        default:
                                            parsedMessageText = chatUtilsFactory.parseForLE(msgObj.text);
                                            break;
                                    }
                                }
                            }else{
                                if( !!message.usersToChange){
                                    parsedMessageText = tagChatHelper.getTagChatStatusMessage(message);
                                    if(!parsedMessageText){
                                        return;
                                    }
                                }
                            }

                            parsedMessageText = $sce.trustAsHtml(parsedMessageText);
                            messages.save(msgObj.key, msgObj);

                            if( !message.fromLocalHistory ){
                                updateBoxMessageMinMaxPacketId(msgObj);
                            }

                            var boxId = userId.toString();//here userId contains the boxId
                            chatHistoryFactory.addMessage(msgObj, boxId);//here we have to pass the boxId, and user contains box.getKey() from the different calling portion

                            /*for editing message starts*/
                            //if (msgObj.key !== undefined) {
                            //    tempmesg = messages.get(msgObj.key);
                            //    if (tempmesg !== false && message.packetId !== undefined) {
                            //        msgObj.status = 'Edited';
                            //        messages.save(msgObj.key, msgObj);
                            //        var boxId = userId.toString();//here userId contains the boxId
                            //        chatHistoryFactory.updateMessage(msgObj, boxId);
                            //        return;
                            //    }
                            //
                            //}
                            /*for editing message ends*/

                            if(!!sendToTab){
                                chatTabSync.sendData(CHAT_GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.CHAT_MSESSAGE_UPDATE, {boxId : boxId, msg : basicMsgObj, isTagChat : message.tag_chat});
                            }

                        };

                        var pushDummyMessage = function(message, user){
                            var key = message.key || message.packetId;

                            var mdate = message.messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff || new Date().getTime();
                            var parsedMessageText = [];

                            var msgObj = {
                                key: key,
                                text: message.message || message.mg || message.text,
                                hrtime: utilsFactory.chatVerbalDate(mdate),
                                status: message.status || 0,
                                //status: message.status || 'Received',
                                messageType : message.messageType,
                                uploading : message.uploading,
                                uploadProgress : message.uploadProgress,
                                messageDate: mdate,
                                isDeleted: false,
                                messageDateString: message.messageDateString || '',
                                mediaUrl : message.mediaUrl,
                                timeout: message.timeout,
                                isSecretVisible: message.isSecretVisible,
                                //progressValue: message.progressValue,
                                //tempImage: message.tempImage,
                                //user: angular.isObject(user) ? user : userFactory.getUser(message.uId),
                                user: angular.isObject(user) ? user : userFactory.getUser(message.userId),
                                lastUpdateTime : new Date().getTime(),

                                sortBy: function () {
                                    return message.messageDate;
                                },
                                getTextPartition: function () {
                                    return parsedMessageText;
                                },
                                setTextPartition: function () {
                                    parsedMessageText = chatUtilsFactory.parseForLE(msgObj.text);
                                    parsedMessageText = $sce.trustAsHtml(parsedMessageText);
                                }
                            };


                            parsedMessageText = chatUtilsFactory.parseForLE(msgObj.text);
                            parsedMessageText = $sce.trustAsHtml(parsedMessageText);

                            messages.save(msgObj.key, msgObj);
                        };
                        var processMessage = function (message, friendId) {
                            //TODO need to process the message both messages that the user sending for show status pending/send/typing and the incoming from server for updating
                            //
                        };

                        var setConnection = function(currUserId){
                            if(!!connection && connection.socket === true)
                                connection.close(true);
                            connection = $websocket('ws://' + ip + ':'+port+'/'+currUserId+'/'+utilsFactory.getToken);
                            connection.socket.binaryType = 'arraybuffer';
                            connection.onMessage(function(messageEvent){
                                //RingLogger.print(messageEvent.data, RingLogger.tags.CHAT);
                                $rootScope.$broadcast("chatDataReceived",{'box':returnob,'messageEvent':messageEvent});
                                //$rootScope.$broadcast("chatDataReceived",messageEvent);
                            });
                            connection.onClose(function (messageEvent) {
                                RingLogger.print('socket closed', RingLogger.tags.CHAT);
                                RingLogger.print("socket closed from chat box factory:note: this is not in use",RingLogger.tags.CHAT);
                                //RingLogger.log('socket closed');
                            });
                        };


                        var updateBoxMessageMinMaxPacketId = function(aMessageObject){

                            var box = returnob;
                            var packetId = aMessageObject.key || aMessageObject.packetId;

                            if( aMessageObject.status == 'status_update'){
                                try{
                                    packetId = packetId.split('_')[0];
                                }catch(e){
                                    RingLogger.alert("History PacketID Split Error", RingLogger.tags.CHAT);
                                }

                            }

                            if( box.messageMaxDate < aMessageObject.messageDate ){
                                box.messageMaxDate = aMessageObject.messageDate;
                                box.messageMaxPacketId = packetId;
                            }

                            if( !box.messageMinDate || box.messageMinDate >= aMessageObject.messageDate ){
                                box.messageMinDate = aMessageObject.messageDate;
                                box.messageMinPacketId = packetId;
                            }

                        };


                        returnob = {
                            ip: ip,
                            port: port,
                            rPort: rPort,
                            lastCommunicationTime: lastCommunicationTime,
                            waitingTime: 160, //in second(waiting time is 3 minute)
                            tempMessageArray: tempMessageArray,
                            tempSeenMessageArray : tempSeenMessageArray,
                            boxTitle:"",
                            unreadCount : 0,

                            messageMaxPacketId : '',
                            messageMinPacketId : '',
                            messageMaxDate : 0,
                            messageMinDate : 0,

                            hasHistoryMessage : false,
                            messages: messages.all(),
                            getTitleString : function(){

                                var box = returnob;
                                //var title = box.getTitle().slice(0, 15);
                                var title = box.getTitle();

                                if( !isTagChat && !title ){
                                    title = box.getKey();
                                }

                                if( box.unreadCount > 0 ){
                                    title = title + ' ('+ box.unreadCount +')';
                                }

                                return title;

                            },
                            updateUnreadCount : function(){
                                var box = returnob;
                                box.unreadCount = chatHistoryFactory.getUnreadMessageCountByBoxId(boxId)
                            },
                            getProfileLink : function () {
                                var box = returnob;
                                if(box.isTagChat){
                                    false;
                                }else{
                                    //return box.getUser().link();
                                    return '/profile/'+box.getUser().getKey();
                                }
                            },
                            checkWaitingTimePassed: function(){
                                var currentTime = Math.floor(Date.now()/1000);
                                if(currentTime - this.lastCommunicationTime > this.waitingTime){
                                    return true;
                                }else {
                                    return false;
                                }
                            },
                            hasIpPort : function(){
                                return !!returnob.ip && !!returnob.port
                            },
                            updateLastCommunicationTime : function(){
                               returnob.lastCommunicationTime =  Math.floor(Date.now() / 1000);
                            },

                            pushMessage: function (message, user, sendToTab) {

                                pushMessage(message, user, sendToTab);
                            },
                            pushDummyMessage: function (message, user) {

                                pushDummyMessage(message, user);
                            },
                            sendTabUpdate : function(message){

                                var basicMsgObj = getBasicMessageObject(message);

                                chatTabSync.sendData(CHAT_GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.CHAT_MSESSAGE_UPDATE, {boxId : boxId, msg : basicMsgObj, isTagChat : message.tag_chat});
                            },
                            processMessage: function (message, friendId) {
                                processMessage(message, friendId);
                            },
                            getKey: function () {
                                return userId.toString();//this contains either userId or tagId
                            },
                            getTagItem : function(){
                              return tagItem;
                            },
                            getUser: function () {
                                if(tagItem)
                                    return tagItem;
                                return user;
                            },
                            getTitle: function () {
                                if(tagItem){
                                    this.boxTitle =  tagItem.getTagName();
                                }else if(user){
                                    this.boxTitle = user.getName();
                                }

                                return this.boxTitle;
                            },
                            setTitle: function(tagTitleForNonInitingUser){
                                this.boxTitle = tagTitleForNonInitingUser;
                            },
                            isConsicutive: function (messageKey) {
                                var currentMessage = messages.get(messageKey);
                                var previousMessage = messages.previous(messageKey);

                                if (previousMessage && previousMessage.status != 'status_update' && previousMessage.user.getKey() === currentMessage.user.getKey()) {
                                    return true;
                                }
                                return false;
                            },
                            isSamePacketId: function (messageKey) {
                                return !!messages.get(messageKey.toString());
                            },
                            getMessages: function () {
                                return messages.all();
                            },
                            getMessage : function(key){
                                return messages.get(key.toString());
                            },
                            getBottomMessage : function(){
                                return messages.bottom();
                            },
                            getTopMessage : function(){
                                return messages.top();
                            },
                            removeMessage: function (key) {
                                messages.remove(key.toString());
                            },
                            updateMessageStatus : function( messageKey, status){
                                var messageObject = messages.get(messageKey);

                                if(!!messageObject){
                                    messageObject.status = status;
                                    return messageObject;
                                }
                                return false;
                            },
                            isTyping: function () {
                                return isTyping;
                            },
                            setTypingBool: function (bool) {
                                isTyping = bool;
                            },
                            isFriendTyping: function () {
                                return isFriendTyping;
                            },
                            setFriendTypingBool: function (bool) {
                                isFriendTyping = bool;
                            },
                            setIp: function (ip) {
                                this.ip = ip;
                            },
                            getIp: function () {
                                return this.ip;
                            },
                            setPort: function (port) {
                                this.port = port;
                            },
                            getPort: function () {
                                return this.port;
                            },
                            setRPort: function (rPort) {
                                this.rPort = rPort;
                            },
                            getRPort: function () {
                                return this.rPort;
                            },
                            setIpPort : function(ipAdd,Rport,currUserId){
                                ip = ipAdd;port=Rport;
                                setConnection(currUserId);
                            },
                            setRegisterConnection: function (userSocket) {
                                rConnection = userSocket;
                            },
                            connect: function(){
                                return connection = $websocket('ws://' + ip + ':'+port);
                            },
                            getConnection : function(){
                                return connection;
                            },
                            getRConnection: function () {
                                return rConnection;
                            },
                            isBoxBindingPortValid : function(){
                                var box = returnob;
                                var diff = (Math.floor(Date.now()/1000)- box.lastCommunicationTime);
                                return diff > 10 && diff < box.waitingTime;

                            },
                            getRemainingRegisteredTime : function(){
                                var box = returnob;
                                return box.waitingTime - ( Math.floor(Date.now()/1000) - box.lastCommunicationTime);
                            },
                            initInterval: function () {
                                if(!!intervalVar){
                                    this.stopInterval();
                                }
                                intervalVar = $interval(function () {
                                    var box = returnob;
                                    var currentTime = Math.floor(Date.now()/1000);
                                    var diff = currentTime - box.lastCommunicationTime;

                                    RingLogger.print("background idle packet init called:"+ currentTime+":"+diff+":"+returnob.getKey()+":"+intervalVar.$$intervalId, RingLogger.tags.CHAT);

                                    if(diff > 10 && diff < box.waitingTime){

                                        //if(box.isTagChat){//for tag chat
                                        //    var tagObject = tagChatFactory.getTag(box.getKey());
                                        //    if(!!tagObject){
                                        //        tagChatApiService.sendTagIdlePacket(Auth.currentUser().getKey(), tagObject);
                                        //    }
                                        //
                                        //
                                        //}else{ //for individual chat
                                        //    var idleObj = {
                                        //        ip: box.getIp(),
                                        //        port: box.getPort(),
                                        //        packetType: 4,// previous: 10
                                        //        userId: Auth.loginData.uId,
                                        //        friendId:box.getKey()// this is the friendId 'cause
                                        //    };
                                        //
                                        //    var idlePacket = PacketDataParse.constructPacket(idleObj,4,CHAT_PACKET_FORMAT.IDLE_PKT.FORMAT);
                                        //    globalSocketFactory.send(idlePacket);
                                        //}
                                        ChatPacketSenderService.sendIdlePacket(box);
                                        RingLogger.print("idle packet sent as interval"+ currentTime+":"+diff+":"+returnob.getKey()+":"+intervalVar.$$intervalId,RingLogger.tags.CHAT);

                                    }else if(diff > box.waitingTime){
                                        box.stopInterval();
                                    }
                                },15000);
                            },
                            stopInterval: function () {
                                if (angular.isDefined(intervalVar)) {
                                    RingLogger.print("interval stopped:"+intervalVar.$$intervalId, RingLogger.tags.CHAT);
                                    $interval.cancel(intervalVar);
                                }
                            },
                            startTimer: function () {//need to recheck what the problem is, right now we're going with previous way where timer was started from different places
                                var box = returnob;
                                var messages = box.getMessages();
                                if(angular.isArray(messages) && messages.length>0) {
                                    for(var m = 0; m< messages.length; m++) {
                                        if (messages[m].value.timeout > 0 && box.isMinimized == false && box.isHidden == false && !messages[m].value.timerStartFlag) {
                                            switch (messages[m].value.messageType){
                                                case 2:
                                                case 3:
                                                case 4:
                                                case 5:
                                                case 6:
                                                    var timeoutCount = messages[m].value.timeout;
                                                    var mes = messages[m].value;
                                                    mes.key = mes.packetId;
                                                    messages[m].value.timerStartFlag = true;
                                                    var testTimeoutDeleteFunc = function (me, timeoutCount) {
                                                        //RingLogger.log("tT: "+timeoutCount+":meKey:"+me.key);
                                                        RingLogger.print("tT: " + timeoutCount + ":meKey:" + me.key, RingLogger.tags.CHAT);
                                                        $rootScope.$broadcast('timeoutDelete', me.key, timeoutCount);
                                                    };//this fucking semicolon(;) caused me "TypeError: (intermediate value)(...) is not a function" ggrgrrrrrrr...
                                                    (function (mes, timeoutCount) {
                                                        $interval(function () {
                                                            testTimeoutDeleteFunc(mes, timeoutCount--);
                                                        }, 1000, timeoutCount + 1);
                                                    })(mes, timeoutCount);
                                                    break;
                                            }//end of messageType switch

                                        }// end of conditions for starting timer
                                    } // end of for loop for all messages
                                }// end of isArray(messaged)
                            },
                            send : function(msgObj){
                                if(connection) {
                                    RingLogger.print('connectionState: '+connection.readyState, RingLogger.tags.CHAT);
                                    if (connection.readyState !== 1) {
                                        //connection.reconnect();
                                        //connection.socket.send(msgObj);
                                        //setConnection(Auth.currentUser().getKey());
                                        //connection.socket.onopen(function () {
                                        //    connection.socket.send(msgObj);
                                        //});
                                    } else {
                                        //connection.reconnect();
                                        connection.socket.send(msgObj);
                                    }
                                } else{
                                    RingLogger.print('connection not ready yet', RingLogger.tags.CHAT);
                                    //TODO we have to use a global array which will store temporarily messages that were not sent due to delay of websocket initialization
                                }
                            },
                            rSend: function (msgObj) {
                                RingLogger.print('Register connectionState: '+rConnection.readyState, RingLogger.tags.CHAT);
                                rConnection.socket.send(msgObj);
                            },
                            updateBoxMessageMinMaxPacketId : updateBoxMessageMinMaxPacketId,

                            loadHistoryMessages : function(){
                                var box = returnob;

                                var minDate, maxDate;

                                var historyMessages = chatHistoryFactory.getMessages(boxId);
                                if(historyMessages){
                                    for(var h=0; h<historyMessages.length; h++){
                                        var aHistoryMessage = historyMessages[h];

                                        updateBoxMessageMinMaxPacketId(aHistoryMessage);

                                        aHistoryMessage.fromLocalHistory = true;
                                        pushMessage(aHistoryMessage, profileFactory.getUserObjectByUId(aHistoryMessage.user));
                                    }
                                }

                                box.updateUnreadCount();

                                utilsFactory.triggerCustomEvent('CHAT_HISTORY_LOADED', { boxId : boxId});
                            }




                        };

                        return returnob;

                    }
                };
            }
        ]);
})();

/**
 * Created by mahbubul on 8/23/15.
 */
(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
        //console.log('rrradlsfja;ls');
    } catch (e) {
        //console.log('bbbbbbbbbb');
        chatApp = angular
            .module('ringid.chat', [
                'ringid.config',
                'ringid.common.stacked_map',
                'ngWebSocket',
                'ringid.utils',
                'ringid.common.chat_factory',
                'ngStorage',
                'ringid.common.rgemoticon_directive',
                'ringid.puller',
                'ringid.connector',
                'ringid.common.rgupload_directive',
                'ringid.tagchat'
            ]);
    }
    chatApp
        .factory('globalSocketFactory', ['settings', '$websocket', 'utilsFactory','PacketDataParse','$rootScope','$timeout', 'tagChatPacketProcessor',
            function (settings, $websocket, utilsFactory, PacketDataParse,$rootScope, $timeout, tagChatPacketProcessor) {
                var globalSocket;

                var logRequestData = function(data){
                    //if(!!window.RingLogger){
                    if(false){
                        try{
                            var packetType = data.getInt8(6, 1);
                            var packetName = tagChatPacketProcessor.getPacketName(packetType);
                            RingLogger.debug("{1}({0}) Length: {2} ".format(packetType, packetName, data.byteLength), RingLogger.tags.CHAT_REQUEST );
                        }catch(e){
                            data.print_r(true);
                            RingLogger.alert(e, RingLogger.tags.CHAT_REQUEST );
                        }
                    }
                };

                return {
                    initiate: function () {
                        if(angular.isObject(globalSocket)){
                            if(!globalSocket.isOpen() && globalSocket.readyState !== 0){
                                RingLogger.print("Global ChatSocket: socket reconnected", RingLogger.tags.CHAT);
                                globalSocket.reconnect();
                            }
                            return; // if socket is already initiated then return
                        }
                        try{
                            globalSocket = $websocket(settings.socketProtocol + settings.siteUrl + '/ChatSocket');

                            //globalSocket.socket.binaryType = 'arraybuffer';
                            globalSocket.onError(function (error) {
                                //RingLogger.log("Global ChatSocket: Connection Error");
                                RingLogger.print("Global ChatSocket: Conneciton Error",RingLogger.tags.CHAT);
                                RingLogger.alert(error,RingLogger.tags.CHAT);
                                //RingLogger.log(error);
                            });
                            globalSocket.onClose(function (event) {
                                //RingLogger.log("Global ChatSocket: socket Closed");
                                RingLogger.print("Glbal ChatSocket: socket Closed",RingLogger.tags.CHAT);
                            });
                            globalSocket.onOpen(function () {
                                //RingLogger.log("Global ChatSocket: socket initiated and opened");
                                RingLogger.print("Global ChatSocket: socket initiated and opened",RingLogger.tags.CHAT);
                            });
                            globalSocket.onMessage(function (messageEvent) {

                                /*
                                * using arraybuffer.slice which works on all browser but IE-10 sucks, so I'm adding
                                * a polyfill for the arrayBuffer.slice method at wat.fall.js.
                                * source: http://stackoverflow.com/questions/21440050/arraybuffer-prototype-slice-shim-for-ie
                                */

                                RingLogger.print('byteLength ', messageEvent.data.byteLength, RingLogger.tags.TAG_CHAT);

                                //var arrayBuffer = messageEvent.data.slice(8);
                                 RingLogger.print("chat packet length : "+messageEvent.data.byteLength,"SOCKETTEST");
                                var arrayBuffer = ArrayBuffer.prototype.slice.call( messageEvent.data, 8 );
                                var packetType = PacketDataParse.getPacketType(arrayBuffer);
                                //RingLogger.log("Global ChatSocket: socket Message received;PacketType:"+packetType);
                                RingLogger.print("Global ChatSocket: socket Message received; PacketType:" + packetType,RingLogger.tags.CHAT);
                                $rootScope.$broadcast("chatDataReceived",{'byteData':arrayBuffer});

                            });
                        } catch (e){
                            //RingLogger.log("Global ChatSocket: Error while initializing chatSocket");
                            //RingLogger.log(e);
                            RingLogger.alert("Global ChatSocket: Error while initializing chatSocket",RingLogger.tags.CHAT);
                            RingLogger.alert(e,RingLogger.tags.CHAT);
                        }
                    },
                    send: function ( data ) {
                        var sendFunction = function (data) {
                            if(globalSocket && globalSocket.isOpen()){
                                //RingLogger.log("Global ChatSocket: data sent");
                                logRequestData(data);
                                //if(data.byteLength <= 4){
                                //    debugger;
                                //}
                                globalSocket.send(data);
                            }else{
                                try {
                                    //sendFunction(data);
                                    //RingLogger.log("Global ChatSocket not connected yet");
                                    RingLogger.print("Global ChatSocket not connected yet",RingLogger.tags.CHAT);
                                    globalSocket.send(data);
                                } catch(e){
                                    //RingLogger.error('Global ChatSocket :chat sendFunction()');
                                    RingLogger.alert("Global ChatSocket :chat sendFunction()",RingLogger.tags.CHAT);
                                }

                            }

                        };

                        if(globalSocket && globalSocket.isOpen()){
                            sendFunction(data);
                        }else{
                            this.initiate();
                            $timeout( sendFunction.bind(null,data), 2000, true);
                        }

                    },
                    gs : function(){ return globalSocket; },
                    reConnect: function () {
                        if(!globalSocket.isOpen()){
                            globalSocket.reConnect();
                        }
                    }
                }
            }
        ]);
})();

(function() {
    'use strict';
    angular
        .module('ringid.chat')
        .factory('ChatHelper', ChatHelper);

    ChatHelper.$inject = ['SystemEvents', 'ChatFactory', 'ChatPacketSenderService', 'OPERATION_TYPES',
                          'PacketDataParse', 'CHAT_PACKET_FORMAT', 'globalSocketFactory',
                          'Auth', '$interval', 'CHAT_GENERAL_CONSTANTS', 'tagChatManager', 'PullerSubscriber',
        'ChatApiService', 'utilsFactory', 'chatHistoryFactory', 'profileFactory'];

    function ChatHelper ( SystemEvents, ChatFactory, ChatPacketSenderService, OPERATION_TYPES,
                          PacketDataParse, CHAT_PACKET_FORMAT, globalSocketFactory,
                          Auth, $interval, CHAT_GENERAL_CONSTANTS, tagChatManager, PullerSubscriber,
                          ChatApiService, utilsFactory, chatHistoryFactory, profileFactory

    ) {
        return {
            executeAfterRegisterEvent   : _executeAfterRegisterEvent,
            hasChatFriendSession        : _hasChatFriendSession,
            getOnlineStatus             : _getOnlineStatus,
            getOfflineUpdateTime        : _getOfflineUpdateTime,
            setOfflineUpdateTime        : _setOfflineUpdateTime,
            updateFriendPresence        : _updateFriendPresence,
            registerForFriendChat       : _registerForFriendChat,
            sendChatSeenConfirmation    : _sendChatSeenConfirmation,
            updateBoxSessionIfRequired  : _updateBoxSessionIfRequired,
            sendAfterRegisterIdlePacket : _sendAfterRegisterIdlePacket,
            startTimerText              : _startTimerText,
            startTimerOthers            : _startTimerOthers,
            decreaseUnreadCount         : _decreaseUnreadCount,
            increaseUnreadCount         : _increaseUnreadCount,
            deleteMessageFromOwn        : _deleteMessageFromOwn,
            loadHistoryMessageForF2FChat: _loadHistoryMessageForF2FChat

        };


        ///////////////////

        function _getOfflineUpdateTime(){

        }

        function _setOfflineUpdateTime(){

        }

        function _decreaseUnreadCount(box,number){
            if(!number){
                _resetUnreadCount(box);
                
            }else{
                if((box.unreadCount - number)> 0){
                    box.unreadCount -= number;
                }
                else if ((box.unreadCount - number) < 0){
                    box.unreadCount = 0;
                } else{
                    box.unreadCount = 0;
                }    
            }
            
            chatHistoryFactory.updateBox(box);
            chatHistoryFactory.removeUnreadMessageInfoByBoxId(box.getKey());
            utilsFactory.triggerCustomEvent("SINGLE_BOX_UPDATED", {box: box});
        }

        function _resetUnreadCount(box){
            box.unreadCount = 0;
        }

        function _increaseUnreadCount(box,number){
            if(!!box && box.isFocused === false){
                box.unreadCount += number;
            }
        }
        function _deleteMessageFromOwn(box,message){
            if(!!box){
                if(!!message.key){
                    //if(message.user.getKey().toString() === Auth.loginData.uId.toString())
                    box.removeMessage(message.key);
                    chatHistoryFactory.removeMessage(message.key, box.getKey());
                    var messages = box.getMessages();
                    for(var k=0,length=messages.length; k<length; k++){
                        messages[k].value.showDate = messages[k].value.takeDecisionForShowingDate();
                        messages[k].value.showAvator = messages[k].value.takeDecisionForShowingMessageUserAvator();
                    }
                    utilsFactory.triggerCustomEvent("SINGLE_BOX_UPDATED", {box: box});
                }
            }
        }
        function _startTimerText(scope, messages) {
            /*start timer for incoming secret message automatically if box is opened and not minimized: starts*/
            //scope.box.value.startTimer();
            if(messages.length <1){
                RingLogger.print("No message to start Timer",RingLogger.tags.CHAT);
                return;
            }
            for(var m= 0, l= messages.length; m < l; m++) {
                if (messages[m].value.timeout > 0 && !messages[m].value.timerStartFlag) {
                    switch (messages[m].value.messageType) {
                        case 2:
                        case 3:
                        case 4://this is for location
                        case 5://this is for url
                        case 6:
                            //messages[m].value.text = "Removed...";
                            var timeoutCount = messages[m].value.timeout;
                            var mes = messages[m].value;
                            messages[m].value.timerStartFlag = true;
                            //messages[m].value.timeout = 0;
                            var timoutDeleteFunc = function (me, scope, timeoutCount) {
                                RingLogger.print("tT: " + timeoutCount + ":meKey:" + me.key, RingLogger.tags.CHAT);
                                scope.$broadcast('timeoutDelete', me.key, timeoutCount);
                            };
                            var testTimeoutDeleteFunc = function (me, timeoutCount) {
                                //RingLogger.log("tT: "+timeoutCount+":meKey:"+me.key);
                                RingLogger.print("tT: " + timeoutCount + ":meKey:" + me.key, RingLogger.tags.CHAT);
                                scope.$broadcast('timeoutDelete', me.key, timeoutCount);
                            };//this fucking semicolon(;) caused me "TypeError: (intermediate value)(...) is not a function" ggrgrrrrrrr...
                            //$timeout( timoutDeleteFunc.bind(null,messages[m].value,scope), tT * 1000, true);
                            //$interval( function(){ testTimeoutDeleteFunc(mes, timeoutCount--)}, 1000, timeoutCount+1);
                            (function (mes, timeoutCount) {
                                $interval(function () {
                                    testTimeoutDeleteFunc(mes, timeoutCount--);
                                }, 1000, timeoutCount + 1);
                            })(mes, timeoutCount);
                            break;
                    }// end of switch for mesaggetype
                }//end of if timeout>0
            }
            /*start timer for incoming secret message automatically if box is opened and not minimized: ends*/
        }

        function _startTimerOthers(scope, message) {
            // this function will only be called if user clicks on secret image/audio/video
            // so this will always get single messageObject
            /*start timer for incoming secret message automatically if box is opened and not minimized: starts*/
            //scope.box.value.startTimer();
            if (!message[0].value) {
                RingLogger.print("No message to start Timer", RingLogger.tags.CHAT);
                return;
            }
            if (message[0].value.timeout > 0 && !message[0].value.timerStartFlag) {
                switch (message[0].value.messageType) {
                    case 7://IMAGE_FILE_FROM_GALLERY
                    case 8://AUDIO_FILE
                    case 9://VIDEO_FILE
                    case 10://IMAGE_FILE_FROM_CAMERA
                        //messages[m].value.text = "Removed...";
                        //todo need to reset timeout according to audio/video length
                        var timeoutCount = message[0].value.timeout;
                        var mes = message[0].value;
                        message[0].value.timerStartFlag = true;
                        //messages[m].value.timeout = 0;
                        var timoutDeleteFunc = function (me, scope, timeoutCount) {
                            RingLogger.print("tT: " + timeoutCount + ":meKey:" + me.key, RingLogger.tags.CHAT);
                            scope.$broadcast('timeoutDelete', me.key, timeoutCount);
                        };
                        var testTimeoutDeleteFunc = function (me, timeoutCount) {
                            //RingLogger.log("tT: "+timeoutCount+":meKey:"+me.key);
                            RingLogger.print("tT: " + timeoutCount + ":meKey:" + me.key, RingLogger.tags.CHAT);
                            scope.$broadcast('timeoutDelete', me.key, timeoutCount);
                        };//this fucking semicolon(;) caused me "TypeError: (intermediate value)(...) is not a function" ggrgrrrrrrr...
                        //$timeout( timoutDeleteFunc.bind(null,messages[m].value,scope), tT * 1000, true);
                        //$interval( function(){ testTimeoutDeleteFunc(mes, timeoutCount--)}, 1000, timeoutCount+1);
                        (function (mes, timeoutCount) {
                            $interval(function () {
                                testTimeoutDeleteFunc(mes, timeoutCount--);
                            }, 1000, timeoutCount + 1);
                        })(mes, timeoutCount);
                        break;
                }// end of switch for mesaggetype
            }//end of if timeout>0
            /*start timer for incoming secret message automatically if box is opened and not minimized: ends*/
        }

        function _updateBoxSessionIfRequired(boxId, box){
            if(!box){
                box = ChatFactory.getBoxByUId(boxId);
            }
            if( box.checkWaitingTimePassed()){

                if(box.isTagChat) {
                    tagChatManager.requestForIp(boxId);
                }
                else
                {
                    PullerSubscriber.requestForIp(boxId);
                }
            }
        }

        function _updateFriendPresence(friendId, box){
            _getOnlineStatus(friendId).then(function(jsonPresence){
                if(!box){
                    box = ChatFactory.getBoxByUId(friendId);
                }
                if(jsonPresence.sucs && jsonPresence.psnc ==CHAT_GENERAL_CONSTANTS.USER_PRESENCE.ONLINE ){
                    box.offlineStatus = false;
                }else{
                    box.offlineStatus = true;
                }
            });
        }

        function _sendChatSeenConfirmation(ip, port, userId, friendId, packetId){
            var seenConfirmationObject = {
                ip: ip,
                port: port,
                packetType: 18,
                packetId: packetId,
                userId: userId,
                friendId: friendId,
                platform: 5

            };
            var seenConfirmationPacket = PacketDataParse.constructPacket(seenConfirmationObject, 18, CHAT_PACKET_FORMAT.SEEN_PKT_CONFIRM.FORMAT);
            if(!!seenConfirmationPacket){
                globalSocketFactory.send(seenConfirmationPacket);
            }
        }
        function _registerForFriendChat(ip, port, userId, friendId){
            var registerObject = ChatApiService.getRegisterForFriendChatRequestObject(ip, port, userId, friendId);
            var registerPacket = PacketDataParse.constructPacket(registerObject, 1, CHAT_PACKET_FORMAT.REGISTER_PKT.FORMAT);
            if(!!registerPacket){
                globalSocketFactory.send(registerPacket);
            }
        }


        function _getOnlineStatus(friendId){
            return ChatApiService.getFriendOnlineStatus(friendId);
        }

        function _hasChatFriendSession(friendId, box){
            if( !box){
                box = ChatFactory.getBoxByUId(friendId);
            }
            return !box.checkWaitingTimePassed();
        }

        function _executeAfterRegisterEvent(friendId, func, args, immidiate){
            if(immidiate){
                func.call(null, args);

            }else{
                var eventHandler = function(event) {
                    if(event.data.friendId.toString() === friendId.toString()){
                        func.call(null, args);
                        document.removeEventListener(SystemEvents.CHAT.CHAT_REGISTER, eventHandler);
                    }
                };
                document.addEventListener(SystemEvents.CHAT.CHAT_REGISTER, eventHandler);
            }
        }

        function _sendAfterRegisterIdlePacket(boxId, box){
            if(!box){
                box = ChatFactory.getBoxByUId(boxId);
            }

            var counter = 0, lastIncrement = 1, hitValue = 1;
            var idleIntervalKey = setInterval(function(){
                if(lastIncrement > 15){
                    clearInterval(idleIntervalKey);
                    box.initInterval();
                }

                if( !counter || counter == hitValue){
                    //RingLogger.debug('Hit');

                    ChatPacketSenderService.sendIdlePacket(box);

                    lastIncrement++;
                    hitValue = hitValue + lastIncrement
                }

                counter++;

                //RingLogger.debug('BOX ID {0}, IDLE_SENT_HIT {1}, COUNTER {2} LAST INC {3}'.format( boxId, hitValue, counter, lastIncrement ),  RingLogger.tags.CHAT);
            }, 1000);
        }

        function _loadHistoryMessageForF2FChat(boxId, box){

            if( !box){
                box = ChatFactory.getBoxByUId(boxId);
            }

            if(!box){
                return;
            }

            box.loadHistoryMessages();
        }







    }
})();

(function() {
    'use strict';
    angular
        .module('ringid.chat')
        .factory('ChatSeenSend', ChatSeenSend);

    ChatSeenSend.$inject = ['PullerSubscriber','ChatFactory', 'chatHistoryFactory','utilsFactory','Auth',
                            'tagChatApiService','tagChatFactory', 'tagChatManager', 'CHAT_GLOBAL_VALUES',
                            'ChatHelper', 'CHAT_GENERAL_CONSTANTS', 'tagChatHelper','chatPacketResender',
                            'FRIEND_CHAT_PACKET_TYPE', '$q', 'TAG_CHAT_PACKET_TYPE', 'chatUtilsFactory'];
    function ChatSeenSend ( PullerSubscriber, ChatFactory, chatHistoryFactory, utilsFactory,Auth,
                            tagChatApiService, tagChatFactory, tagChatManager, CHAT_GLOBAL_VALUES,
                            ChatHelper, CHAT_GENERAL_CONSTANTS, tagChatHelper, chatPacketResender,
                            FRIEND_CHAT_PACKET_TYPE, $q, TAG_CHAT_PACKET_TYPE, chatUtilsFactory
    ) {
        var executeAfterTagRegisterEvent = tagChatHelper.executeAfterTagRegisterEvent;
        var registerTag = tagChatManager.registerTag;
        var USER_PRESENCE = CHAT_GENERAL_CONSTANTS.USER_PRESENCE;
        var ChatPacketResender = chatPacketResender.ChatPacketResender;
        var ChatPacketSender = chatPacketResender.ChatPacketSender;


        ///////////////////

        var _sendSeenPacket = function (box, messages){
            if(messages.length <1){
                RingLogger.print("No message to send seen packet",RingLogger.tags.CHAT);
                return;
            }
            //todo store messages reference
            var currentUserId = Auth.loginData.uId;
            //var seenPacketIds = getSeenPacketIds(messages);
            var seenPartialMsgObjects = getSeenPartialMsgObjects(messages);

            var isTagChat = box.isTagChat;
            if( isTagChat ){
                var tagId = box.getKey();

                var isRegisterNeeded = registerTag(tagId, 1);
                executeAfterTagRegisterEvent(tagId, function(){
                    sendTagChatSeenPackets(currentUserId, tagId, seenPartialMsgObjects);
                }, null, !isRegisterNeeded);

            }else{//f2f
                var friendId = box.getKey();
                var packetId = utilsFactory.getUniqueID('cseen');
                var isOffline = box.offlineStatus;
                var hasSentSeenPackets = false;

                var hasChatFriendSession = ChatHelper.hasChatFriendSession(friendId, box);

                if(!hasChatFriendSession){//3min passed
                    PullerSubscriber.requestForIp(friendId, true).then(function(response){
                        if(!hasSentSeenPackets){
                            if(response.sucs === true && response.psnc == USER_PRESENCE.ONLINE){
                                ChatHelper.registerForFriendChat(box.ip, box.rPort, currentUserId, friendId);

                                ChatHelper.executeAfterRegisterEvent(friendId, function(){
                                    hasSentSeenPackets  = true;
                                    sendF2fSeenPacketOnline(box.ip, box.port, friendId, seenPartialMsgObjects, packetId);
                                }, null, hasChatFriendSession);
                            }else{
                                sendF2fSeenPacketOffline(friendId, seenPartialMsgObjects, packetId);
                            }
                        }
                    });
                }else{
                    if( !isOffline ){
                        sendF2fSeenPacketOnline(box.ip, box.port, friendId, seenPartialMsgObjects, packetId);
                    }else{
                        sendF2fSeenPacketOffline(friendId, seenPartialMsgObjects, packetId);
                    }
                }
                //ChatHelper.startTimerText(scope, messages);
            }
        };

        var _updateMessageSeenSentProperty = function (boxId, seenPartialMsgObjects) {
            var box = ChatFactory.getBoxByUId(boxId);
            var messagesToUpdate = [];
            for(var index = 0; index < seenPartialMsgObjects.length; index++){
                if( !!box){
                    var aMessage = box.getMessage(seenPartialMsgObjects[index].key);
                    if(!!aMessage){
                        aMessage.seenSent = true;
                        messagesToUpdate.push(aMessage);
                    }

                }
            }

            chatHistoryFactory.updateMessages(messagesToUpdate, boxId);

        };
        var _doSendATagChatSeenPacketMultipleTimes = function(userId, friendId, packetId, tagObject){
            var aChatResender;

            aChatResender = new ChatPacketResender();
            aChatResender.setPacketType(TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN);
            aChatResender.setPacketId(packetId);
            aChatResender.on('send', function () {
                tagChatApiService.sendTagMsgSeenPacket(userId, tagObject, friendId, packetId );
            });
            aChatResender.start();
            //tagChatApiService.sendTagMsgSeenPacket(userId, tagObject, packetId );
        };

        var sendTagChatSeenPackets = function(userId, tagId, seenPartialMsgObjects){
            var tagObject = tagChatFactory.getTag(tagId);
            var currentUserId = Auth.loginData.uId;
            if(!!tagObject){
                for(var index =0; index < seenPartialMsgObjects.length; index++){
                    var packetId = seenPartialMsgObjects[index].key;
                    var friendId = seenPartialMsgObjects[index].senderId;
                    try{
                        _doSendATagChatSeenPacketMultipleTimes(currentUserId, friendId, packetId, tagObject );
                    }catch(e){
                        RingLogger.alert('Tag Seen Sending  Exception ', e, RingLogger.tags.TAG_CHAT);
                    }
                }
                _updateMessageSeenSentProperty(tagId,seenPartialMsgObjects);
            }else{
                RingLogger.print('TagSeen packet not send, tagObject not found.');
            }
        };

        var sendChatSeenPackets = function(ip, port, friendId, seenPartialMsgObjects, packetId){
            var defer = $q.defer();
            var seenObject = {
                ip: ip,
                port: port,
                packetId: packetId,
                packetType: 17,
                userId: Auth.loginData.uId,
                friendId: friendId,
                messages: [],
                platform : 5
            };
            var messageDate = parseInt(new Date().getTime() + CHAT_GLOBAL_VALUES.serverTimeDiff);
            for(var index = 0; index < seenPartialMsgObjects.length; index++){
                seenObject.messages[index] = {
                    packetId : seenPartialMsgObjects[index].key,
                    messageDate: messageDate,
                    status: getStatusByMessageType(seenPartialMsgObjects[index].messageType)
                }
            }
            var aChatSender, aChatSenderInstance;

            aChatSender = new ChatPacketSender();
            aChatSender.setPacketObject(seenObject);
            aChatSender.setBrokenPacketType(FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN);

            aChatSenderInstance = aChatSender.getInstance();

            aChatSenderInstance.on('success', function(response){
                RingLogger.print('F2F Seen packet Success', RingLogger.tags.CHAT);
                //var box = ChatFactory.getBoxByUId(friendId);
                //var messagesToUpdate = [];
                //for(var index = 0; index < seenPartialMsgObjects.length; index++){
                //    var aMessage = box.getMessage(seenObject.messages[index].packetId);
                //    if(!!aMessage){
                //        aMessage.seenSent = true;
                //        messagesToUpdate.push(aMessage);
                //    }
                //}
                //chatHistoryFactory.updateMessages(messagesToUpdate, box.getKey());
                _updateMessageSeenSentProperty(friendId,seenPartialMsgObjects);
                defer.resolve('success');
            });
            aChatSenderInstance.on('failure', function(response){
                RingLogger.print('F2F Seen packet Failure', RingLogger.tags.CHAT);
                defer.reject('failed');
            });
            aChatSenderInstance.start();
            return defer.promise;
        };

        var getSeenPacketIds = function(messages){
            var packetIds = [];
            for(var index = 0; index < messages.length; index++){
                packetIds.push(messages[index].key);
            }
            return packetIds;
        };
        var getSeenPartialMsgObjects = function (messages){
            var seenPartialMsgObjects = [];
            for(var index = 0; index < messages.length; index++){
                seenPartialMsgObjects.push({key: messages[index].key, messageType: messages[index].value.messageType, senderId : messages[index].value.user.getKey() });
            }
            return seenPartialMsgObjects;
        };

        //var filterMessagesByViewPort = function(messages){
        //    var filteredMessages = [];
        //    for(var index = 0, length = messages.length; index < length; index++){
        //        if(messages[index].value.user.getKey() !== Auth.loginData.uId
        //            && messages[index].value.status !== "Deleted"
        //            && messages[index].value.status !== "Played"
        //            && messages[index].value.status !== "Viewed"
        //            && messages[index].value.seenSent != true
        //        ) {
        //            filteredMessages.push(messages[index]);
        //        }
        //    }
        //    return filteredMessages;
        //};

        var sendF2fSeenPacketOnline = function (ip, port, friendId, seenPartialMsgObjects, packetId) {
            sendChatSeenPackets(ip, port, friendId, seenPartialMsgObjects, packetId)
                .then(function () {

                },function(){
                    sendF2fSeenPacketOffline(friendId, seenPartialMsgObjects, packetId);
                });
        };

        var sendF2fSeenPacketOffline = function (friendId, seenPartialMsgObjects, packetId) {
            var offlineIpPort = chatUtilsFactory.getOfflineIpPort();
            var ip = offlineIpPort.ip;
            var port = offlineIpPort.port;

            sendChatSeenPackets(ip, port, friendId, seenPartialMsgObjects, packetId);
        };
        var getStatusByMessageType = function(messageType){
            var messageStatus = 0;
            switch (messageType){
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    messageStatus = CHAT_GENERAL_CONSTANTS.MESSAGE_STATUS.SEEN;
                    break;
                case 7:
                case 8:
                case 9:
                case 10:
                    messageStatus = CHAT_GENERAL_CONSTANTS.MESSAGE_STATUS.VIEWED;
                    break;
            }
            return messageStatus;
        };
        return {
            sendSeenPacket : _sendSeenPacket
        };
    }
})();
(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}

    chatApp
        .factory('chatHistoryFactory', ['Storage', 'Auth', 'userFactory', 'CHAT_GENERAL_CONSTANTS' , 'CHAT_GENERAL_INFOS', 'chatTabSync', 'SystemEvents', 'utilsFactory',
            function (Storage, Auth, userFactory, CHAT_GENERAL_CONSTANTS, CHAT_GENERAL_INFOS, chatTabSync, SystemEvents, utilsFactory) {

                var chatOpenedBoxes= {},
                    chatBoxes = {},
                    unreadMessageInfos = {},
                    unreadMessageCount = 0;

                var loadChatBoxes = function(){
                    chatOpenedBoxes = Storage.getData('chatOpenedBoxes') || {};
                    chatBoxes = Storage.getData('chatBoxes') || {};

                };
                
                var initUnreadMessageCount = function(){
                    Object.keys(unreadMessageInfos).forEach(function(val, key){
                        unreadMessageCount += Object.keys(val).length;
                    });
                };


                var loadUnreadMessageInfos = function(){

                    var _unreadMessageInfos = Storage.getData('unreadMessageIds');
                    
                    unreadMessageCount = 0;

                    if( !_unreadMessageInfos ){
                        
                        unreadMessageInfos =  {};

                    }else{

                        Object.keys(_unreadMessageInfos).forEach(function(aBoxId, key){
                            
                            unreadMessageInfos[aBoxId] = {};

                            _unreadMessageInfos[aBoxId].forEach(function(packetId, key){
                                unreadMessageInfos[aBoxId][packetId] = true;
                                unreadMessageCount++;
                            })
                        });
                    }

                };

                var _updateUnreadMessageInfos = function(async){
                    if(async !== false){
                        async = true
                    }

                    var _unreadMessageInfos = {}
                    Object.keys(unreadMessageInfos).forEach(function(aBoxId, key){
                        _unreadMessageInfos[aBoxId] = Object.keys(unreadMessageInfos[aBoxId]);
                    })
                
                    Storage.setData('unreadMessageIds', _unreadMessageInfos, async);

                    utilsFactory.triggerCustomEvent(SystemEvents.CHAT.UNREAD_MESSAGE_INFO_UPDATED);

                };
                
                var migrateLocalDb = function(){
                    chatOpenedBoxes= {};
                    chatBoxes = {};
                    _updateChatBoxes(false);
                    _updateChatOpenBoxes(false);
                    _updateUnreadMessageInfos(false);
                    saveChatGeneralInfo(CHAT_GENERAL_INFOS, false);
                };

                var loadChatGeneralInfo = function(){

                    var cgInf = Storage.getData('cgInf');

                    if( !cgInf || !cgInf.version || cgInf.version != CHAT_GENERAL_INFOS.version){
                        migrateLocalDb();
                    }

                    if(!cgInf){
                        saveChatGeneralInfo();
                    }else{
                        angular.extend(CHAT_GENERAL_INFOS, cgInf);
                    }

                };

                var saveChatGeneralInfo = function(info, async){
                    if(async !== false){
                        async = true
                    }

                    if(!!info){
                        angular.extend(CHAT_GENERAL_INFOS, info);
                    }

                    Storage.setData('cgInf', CHAT_GENERAL_INFOS, async);
                };

                var getHistoryMessageObject = function(message){

                    if( !message.user){
                        message.user = userFactory.create(message.user);
                    }

                    var messageObject = {
                        key              : message.key,
                        packetId         : message.packetId || message.key,
                        packetType       : message.packetType || 6,
                        brokenPacketType : message.brokenPacketType || 8,
                        platform         : message.platform || 5,
                        text             : message.text || message.message || message.mg,
                        hrtime           : message.hrtime,
                        status           : message.status || 0,
                        //status         : message.status || 'Received',
                        seenSent         : message.seenSent || false,
                        messageDate      : message.messageDate,
                        isDeleted        : message.isDeleted,
                        latitude         : message.latitude,
                        longitude        : message.longitude,
                        messageDateString: message.messageDateString || '',
                        timeout          : message.timeout,
                        messageType      : message.messageType,
                        tag_chat         : message.tag_chat,
                        isSecretVisible  : message.isSecretVisible,
                        secretTimedOut   : message.secretTimedOut ? message.secretTimedOut : false,
                        //user           : angular.isObject(user) ? user : userFactory.getUser(message.uId),
                        user             : message.user.getKey()
                    };

                    if( !!message.usersToChange ){
                        messageObject.usersToChange = message.usersToChange;
                    }

                    if( !!message.statusType){
                        messageObject.statusType = message.statusType;
                    }

                    return messageObject;

                };

                var _updateChatBoxes = function(async){
                    if(async !== false){
                        async = true
                    }

                    Storage.setData('chatBoxes', chatBoxes, async);
                };

                var _updateChatOpenBoxes = function(async){
                    if(async !== false){
                        async = true
                    }

                    Storage.setData('chatOpenedBoxes', chatOpenedBoxes, async);
                };


                var _addOpenBoxes = function (boxId, isTagChat) {

                    if (!chatOpenedBoxes) {
                        chatOpenedBoxes = {};
                    }
                    if(!chatOpenedBoxes[boxId]){
                        chatOpenedBoxes[boxId] = {
                            boxId : boxId,
                            isTagChat : isTagChat
                        };
                    }

                    _updateChatOpenBoxes();
                };

                var _getMessageByPacketId = function(boxId, packetId){
                    if(!!chatBoxes[boxId]){
                        var messages = chatBoxes[boxId]['messages'];
                        if(!!messages){
                            for(var index = 0, length = messages.length; index < length; index++){
                                if( messages[index].key == packetId){
                                    return messages[index];
                                }
                            }
                        }
                    }
                    return false;
                };

                var _addUnreadMessageInfo  = function(boxId, messageId){
                    
                    if(!unreadMessageInfos[boxId]){
                        unreadMessageInfos[boxId] = {};
                    }

                    if( !unreadMessageInfos[boxId][messageId]){
                        unreadMessageInfos[boxId][messageId] = true;
                        unreadMessageCount++;    
                    }
                    
                };

              

                var _removeUnreadMessageInfo = function(boxId, messageId){
                    if( !unreadMessageInfos[boxId] || !unreadMessageInfos[boxId][messageId]){
                        return;
                    }else{                        
                        delete unreadMessageInfos[boxId][messageId];    
                        unreadMessageCount--;
                    }

                    _updateUnreadMessageInfos();
                };

                var _removeUnreadMessageInfoByBoxId = function(boxId){
                    var aBox = chatBoxes[boxId];
                    if( !unreadMessageInfos[boxId] ){
                        return;
                    }

                    var boxUnreadCount = Object.keys(unreadMessageInfos[boxId]).length;
                    delete unreadMessageInfos[boxId]
                    unreadMessageCount -= boxUnreadCount;

                    if( unreadMessageCount < 0){
                        unreadMessageCount = 0;
                    }

                    _updateUnreadMessageInfos();
                    
                };

                var _getUnreadMessageInfos = function(){
                    return unreadMessageInfos;
                };

                var _getUnreadMessageCount = function(){
                    return unreadMessageCount;
                };

                var _getUnreadMessageCountByBoxId = function(boxId){
                    if( !unreadMessageInfos[boxId] ){
                        return 0;
                    }

                    return Object.keys(unreadMessageInfos[boxId]).length
                };


                var _init = function(){

                    loadChatGeneralInfo();    
                    loadChatBoxes();
                    loadUnreadMessageInfos();
                    
                }

                var ReturnOb =  {

                    init : _init,

                    loadChatBoxes : loadChatBoxes,
                    loadChatGeneralInfo : loadChatGeneralInfo,
                    saveChatGeneralInfo : saveChatGeneralInfo,
                    updateChatOpenBoxes : _updateChatOpenBoxes,
                    updateChatBoxes : _updateChatBoxes,

                    addUnreadMessageInfo : _addUnreadMessageInfo,
                    removeUnreadMessageInfo : _removeUnreadMessageInfo,
                    updateUnreadMessageInfos :_updateUnreadMessageInfos,
                    getUnreadMessageInfos : _getUnreadMessageInfos,
                    getUnreadMessageCount : _getUnreadMessageCount,
                    getUnreadMessageCountByBoxId : _getUnreadMessageCountByBoxId,
                    removeUnreadMessageInfoByBoxId : _removeUnreadMessageInfoByBoxId,

                    getMessageByPacketId : _getMessageByPacketId,

                    getChatOpenBoxes : function(){
                        return chatOpenedBoxes;
                    },

                    getChatBoxes : function(){
                        return chatBoxes;
                    },

                    addOpenBox: _addOpenBoxes,

                    removeOpenBox: function (boxId) {

                        if(!!chatOpenedBoxes[boxId]){
                            delete chatOpenedBoxes[boxId];
                        }

                        _updateChatOpenBoxes();

                    },

                    countOpenBoxes: function () {

                        if (chatOpenedBoxes) {
                            return Object.keys(chatOpenedBoxes).length;
                        } else {
                            return 0;
                        }
                    },
                    getAllOpenBoxes: function () {

                        if(chatOpenedBoxes && Object.keys(chatOpenedBoxes).length > 0){
                            return chatOpenedBoxes;
                        }else{
                            return false;
                        }
                    },
                    addBox: function (box) {

                        _addOpenBoxes(box.key, box.isTagChat);

                        var box = {
                            key            : box.key,
                            ip             : box.ip,
                            rPort          : box.rPort,
                            closedBox      : box.closedBox,
                            isMinimized    : box.isMinimized,
                            isHidden       : box.isHidden,
                            isFocused      : box.isFocused,
                            blinkOn        : box.blinkOn,
                            timeout        : box.timeout,
                            secretChat     : box.secretChat,
                            nonDomBox      : box.nonDomBox,
                            offlineStatus  : box.offlineStatus,
                            isTagChat      : box.isTagChat,
                            chatBoxClass   : box.chatBoxClass,
                            unreadCount    : box.unreadCount,
                            isSecretVisible: box.isSecretVisible,
                            blocked        : box.blocked,
                            //serverTimeDiff: box.serverTimeDiff,
                            messages       : []
                        };

                        if (!chatBoxes) {
                            chatBoxes = {};
                        }

                        if(!chatBoxes[box.key]){
                            chatBoxes[box.key] = box;
                        }

                        _updateChatBoxes();

                    },
                    updateBox: function (box) {

                        var box       = {
                            key            : box.key,
                            ip             : box.ip,
                            rPort          : box.rPort,
                            closedBox      : box.closedBox,
                            isMinimized    : box.isMinimized,
                            isHidden       : box.isHidden,
                            isFocused      : box.isFocused,
                            blinkOn        : box.blinkOn,
                            timeout        : box.timeout,
                            secretChat     : box.secretChat,
                            nonDomBox      : box.nonDomBox,
                            offlineStatus  : box.offlineStatus,
                            isTagChat      : box.isTagChat,
                            isSecretVisible: box.isSecretVisible,
                            blocked        : box.blocked,
                            chatBoxClass   : box.chatBoxClass,
                            unreadCount    : box.unreadCount
                            //serverTimeDiff: box.serverTimeDiff
                        };

                        if (!chatBoxes) {
                            chatBoxes = {};
                        }

                        if(!chatBoxes[box.key]){
                            chatBoxes[box.key] = box;
                        }else{
                            angular.extend(chatBoxes[box.key], box);
                        }

                        _updateChatBoxes();

                    },
                    getBox: function (key) {

                      if(!chatBoxes[key]){
                          return false;
                      }

                      return chatBoxes[key];

                    },
                    addMessage: function (message, boxId) {

                        if(!!chatBoxes[boxId]){

                            if( !message.user || !message.user.getKey){
                                message.user = userFactory.create(message.user);
                            }

                            var messageObject = {
                                key              : message.key || message.packetId,

                                packetId         : message.packetId || message.key,
                                packetType       : message.packetType || 6,
                                brokenPacketType : message.brokenPacketType || 8,
                                platform         : message.platform || 5,

                                text             : message.text || message.message || message.mg,
                                hrtime           : message.hrtime || '',
                                status           : message.status || 0,
                                fullName         : message.fullName || '',
                                tagName          : message.tagName || '',
                                messageDate      : message.messageDate,
                                seenSent         : message.seenSent || false,
                                isDeleted        : message.isDeleted || false,

                                messageDateString: message.messageDateString || '',
                                timeout          : message.timeout || 0,
                                messageType      : message.messageType,
                                tag_chat         : message.tag_chat,
                                isSecretVisible  : message.isSecretVisible,
                                secretTimedOut   : message.secretTimedOut ? message.secretTimedOut : false,
                                user             : message.user.getKey(),
                                userId           : message.user.getKey()
                            };

                            if( !message.user){
                                RingLogger.error('Invalid User', message);
                            }


                            if( !!message.statusType){
                                messageObject.statusType = message.statusType;
                            }

                            if( !!message.usersToChange ){
                                messageObject.usersToChange = message.usersToChange;
                            }

                            if(!chatBoxes[boxId].messages){
                                chatBoxes[boxId].messages = [];
                            }

                            //find if that message(check with messageKey/packetId) exists, if exists then dont push otherwise does
                            var messageKeyFlag = 0;
                            try{
                                for(var j=0; j<chatBoxes[boxId].messages.length; j++){
                                    if(chatBoxes[boxId].messages[j].key === messageObject.key){
                                        messageKeyFlag = 1;
                                        break;
                                    }
                                }
                            }catch(e){
                                RingLogger.error('Error Check', e);
                            }


                            if(messageKeyFlag ===0){
                                if(ReturnOb.countMessage(boxId) >= CHAT_GENERAL_CONSTANTS.HISTORY_MAX_MESSAGE){
                                    var removedMessage = chatBoxes[boxId].messages.shift();
                                    // _removeUnreadMessageInfo(removedMessage.key);
                                }

                                chatBoxes[boxId].messages.push(messageObject);
                            }
                        }

                        _updateChatBoxes();
                    },
                    removeMessage: function (messageKey, boxId) {

                        var removed = false;
                        if(chatBoxes) {
                            if (!!chatBoxes[boxId]) {
                                for (var j = 0; j < chatBoxes[boxId].messages.length; j++) {
                                    if (chatBoxes[boxId].messages[j].key === messageKey) {
                                        chatBoxes[boxId].messages.splice(j, 1);
                                        removed = true;
                                        // _removeUnreadMessageInfo(messageKey);
                                    }
                                }
                            }
                        }

                        if(removed){
                            _updateChatBoxes();
                        }
                    },

                    updateMessage: function (message, boxId) {

                        var currentUserId = Auth.loginData.uId;

                        if(!!chatBoxes[boxId]){

                            if( !angular.isObject(message.user)){
                                message.user = userFactory.create(message.user);
                            }

                            var messageObject = {
                                key              : message.key,

                                packetId         : message.packetId || message.key,
                                packetType       : message.packetType || 6,
                                brokenPacketType : message.brokenPacketType || 8,
                                platform         : message.platform || 5,

                                text             : message.text || message.message || message.mg,
                                hrtime           : message.hrtime,
                                status           : message.status || 0,
                                //status: message.status || 'Received',
                                seenSent         : message.seenSent || false,
                                messageDate      : message.messageDate,
                                isDeleted        : message.isDeleted,
                                latitude         : message.latitude,
                                longitude        : message.longitude,
                                messageDateString: message.messageDateString || '',
                                timeout          : message.timeout,
                                messageType      : message.messageType,
                                isSecretVisible  : message.isSecretVisible,
                                tag_chat         : message.tag_chat,
                                secretTimedOut   : message.secretTimedOut ? message.secretTimedOut : false,
                                //user: angular.isObject(user) ? user : userFactory.getUser(message.uId),
                                user             : message.user.getKey()
                            };

                            if( !!message.usersToChange ){
                                messageObject.usersToChange = message.usersToChange;
                            }

                            if( !!message.statusType){
                                messageObject.statusType = message.statusType;
                            }

                            for(var j=0; j<chatBoxes[boxId].messages.length; j++){
                                if(chatBoxes[boxId].messages[j].key == messageObject.key){
                                    chatBoxes[boxId].messages[j] = messageObject;
                                    break;
                                }
                            }
                        }

                        _updateChatBoxes();
                    },

                    updateMessages: function (messages, boxId) {

                        if(! messages.length ){
                            return;
                        }

                        var messagesCache = {};
                        for(var index = 0, len = messages.length; index < len; index++){
                            messagesCache[messages[index].key] = messages[index];
                        }

                        if(chatBoxes){
                            var currentUserBox = chatBoxes[boxId];

                            for(var j=0; j<currentUserBox.messages.length; j++){
                                var historyMessage = currentUserBox.messages[j];
                                var cachedMessage = messagesCache[historyMessage.key];
                                if( !!cachedMessage){
                                    currentUserBox.messages[j] = getHistoryMessageObject(cachedMessage);
                                }
                            }

                        }

                        _updateChatBoxes();
                    },

                    isInLocalStorageChatMsgMap : function(boxId, packetId){
                       try{
                           return !!chatBoxes[boxId][packetId];
                       }catch(e){
                            return false;
                        }
                    },
                    countMessage: function (boxId) {
                        var currentUserId = Auth.loginData.uId;

                        if(chatBoxes[boxId]){
                            var box = chatBoxes[boxId];
                            return !!box.messages ? box.messages.length : 0;
                        }

                        return false;

                    },
                    getMessages: function (boxId) {

                        if(chatBoxes[boxId]){
                            var box = chatBoxes[boxId];
                            return box.messages;
                        }

                        return [];
                    },

                    getMessage : function(boxId, packetId){
                        if( !!chatBoxes[boxId] && !!chatBoxes[boxId].messages){
                            for(var j=0; j<chatBoxes[boxId].messages.length; j++){
                                if(chatBoxes[boxId].messages[j].key == packetId){
                                    return chatBoxes[boxId].messages[j];
                                }
                            }
                        }
                        return false;
                    }
                };

                return ReturnOb;

            }
        ]);
})();

(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {
    }

    chatApp.factory('PullerSubscriber', PullerSubscriber);

    PullerSubscriber.$inject  = [
                'OPERATION_TYPES',
                'ChatFactory',
                'userFactory','Auth','$$connector','friendsFactory','chatHistoryFactory',
                '$q', 'CHAT_GENERAL_CONSTANTS',
                'ChatPacketSenderService', 'ChatApiService', 'tagChatApiService', 'chatPacketResender' ];

            function PullerSubscriber(OPERATION_TYPES,
                        ChatFactory,
                      userFactory,Auth ,$$connector,friendsFactory,chatHistoryFactory,
                       $q, CHAT_GENERAL_CONSTANTS,
                      ChatPacketSenderService, ChatApiService, tagChatApiService, chatPacketResender) {

                var ChatPacketResender = chatPacketResender.ChatPacketResender;

                var USER_PRESENECE = CHAT_GENERAL_CONSTANTS.USER_PRESENCE;


                var sendFriendInformation = function(friendObj){
                    var friendInfoObject = ChatApiService.getFriendInformationPacketObject(
                        friendObj.getUId(), friendObj.getName(), friendObj.getPlatform(),
                        friendObj.getOnlineStatus(), friendObj.getAppType(), friendObj.getDeviceToken(), friendObj.getUserMood());

                    tagChatApiService.sendViaGlobalChatSocket(friendInfoObject, friendInfoObject.packetType);
                };

                var sendBlankOfflineMesssage = function(friendId){
                    ChatPacketSenderService.sendBlankMessage(friendId);
                };


                var doAfterF2FChatRequestResponse = function(response, friendId){


                };

                var _getBox = function(friendId){
                    var box = ChatFactory.getBoxByUId(friendId);

                    if(!box){
                        box = ChatFactory.creatNonDomBox(friendId, false);
                        box.loadHistoryMessages();
                    }

                    return box;
                };

                var sendF2FRegisterRequest = function(ip , port, userId, friendId){

                    var registerObject = ChatApiService.getRegisterForFriendChatRequestObject(ip, port, userId, friendId);

                    var chatPacketResender = new ChatPacketResender();
                    chatPacketResender.setPacketType(registerObject.packetType);
                    chatPacketResender.setPacketObject(registerObject);

                    chatPacketResender.on('failure', function(response){
                        var box = _getBox(userId);
                        ChatPacketSenderService.sendTemporaryMessages(box, true);
                    });

                    chatPacketResender.start();
                };



                var subscribePuller = function () {

                    //Following code is for individual chat

                    $$connector.subscribe(function (message) {

                        RingLogger.print('175.375 RESPONSE ', message, RingLogger.tags.CHAT);

                        var dataObj = message;
                        var friendId = dataObj.fndId;
                        var box = _getBox(friendId);
                        box.platform = dataObj.dvc;

                        var friendObject = userFactory.create({
                            uId: dataObj.fndId,
                            utId: dataObj.utId,
                            fn: dataObj.nm
                        });

                        friendsFactory.getContactDetailsByUtIds([dataObj.utId]);// this is for getting the userobject with detail info and push it in contactlist

                        var friendPreviousOnlineStatus = friendObject.getOnlineStatus();

                        friendObject.setOnlineStatus(dataObj.psnc);

                        if(!!dataObj.mood){
                            friendObject.setUserMood(dataObj.mood);
                        }
                        if(!!dataObj.dt ){
                            friendObject.setDeviceToken(dataObj.dt);
                        }
                        if(!!dataObj.apt){
                            friendObject.setAppType(dataObj.apt);
                        }
                        if(!!dataObj.dvc){
                            friendObject.setPlatform(dataObj.dvc);
                        }


                        if( friendPreviousOnlineStatus != friendObject.getOnlineStatus() ){
                            sendFriendInformation(friendObject);
                        }

                        if(dataObj.sucs === true && dataObj.psnc == USER_PRESENECE.ONLINE){ // if this sucs is false then user is not logged in with whom user is trying to chat

                            var ip = dataObj.chIp;
                            var port = parseInt(dataObj.chRp) ;
                            var userId = Auth.loginData.uId;

                            box.setIp(ip);
                            box.setRPort(port);
                            box.offlineStatus = false;

                            sendF2FRegisterRequest(ip , port, userId, friendId);
                            chatHistoryFactory.updateBox(box);

                        }
                        else{ // when dataObj.sucs !== true

                            // if the user isn't logged in with whom user is trying to chat
                            if(dataObj.rc == 1){
                                // this is the case where user is blocked(either by him or by friend), permission is denied
                                box.blocked = true;
                            }else{
                                box.offlineStatus = true;

                                if( dataObj.psnc == USER_PRESENECE.OFFLINE ){
                                    sendBlankOfflineMesssage(friendId);
                                }

                                ChatPacketSenderService.sendTemporaryMessages(box, true);
                            }
                            chatHistoryFactory.updateBox(box);
                        }
                    }, {
                        action:[175,375] // for friend chat 175 and update 375
                    });
                }();

                var RequestForIp = function(friendId, returnPromise){
                    var requestObject = {
                        actn: 175,
                        fndId : friendId,
                        uId : Auth.loginData.uId
                    };

                    if(!returnPromise){
                        $$connector.send(requestObject,OPERATION_TYPES.SYSTEM.REQUEST_TYPE.CHAT);

                    }else{
                        var defer = $q.defer();
                        $$connector.request(requestObject,OPERATION_TYPES.SYSTEM.REQUEST_TYPE.CHAT)
                            .then(function(response){

                                var box = _getBox(response.fndId);

                                if(response.sucs === true && response.psnc == USER_PRESENECE.ONLINE){

                                    box.offlineStatus = false;
                                    box.ip = response.chIp;
                                    box.platform = response.dvc;
                                    box.rPort = parseInt(response.chRp);

                                }else{

                                    box.platform = response.dvc;
                                    box.offlineStatus = true;

                                }
                                defer.resolve(response);
                            },
                            function (response) {
                                defer.reject(response);
                            });

                        return defer.promise;
                    }
                };


                return {
                    subscribePuller: function () {
                        subscribePuller();
                    },
                    requestForIp : function(friendId, returnPromise){
                        return RequestForIp(friendId, returnPromise);
                    }

                };
            }

})();

/**
 * Created by mahbubul on 4/21/15.
 */
(function () {
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
        //console.log('rrradlsfja;ls');
    } catch (e) {
        //console.log('bbbbbbbbbb');
        chatApp = angular
            .module('ringid.chat', [
                'ringid.config',
                'ringid.common.stacked_map',
                'ngWebSocket',
                'ringid.utils',
                'ringid.common.chat_factory',
                'ngStorage',
                'ringid.common.rgemoticon_directive',
                'ringid.puller',
                'ringid.connector',
                'ringid.common.rgupload_directive',
                'ringid.tagchat'
            ]);
    }

    chatApp
        .factory('PacketDataParse',[ 'CHAT_PACKET_ATTRIBUTE',
            function (CHAT_PACKET_ATTRIBUTE) {
                return {
                    /* Message Formation in Byte
                     ******************************************************
                     *** Packet Type 1 Byte
                     *** Platform 1 Byte
                     *** User Identity Length 1 Byte
                     *** Friend Identity Length 1 Byte
                     *** Full Name Length 1 Byte [Note: if the full Name length is greater then 127 then u should limit the name to 127 bytes for sending full Name in chat register Message]
                     *** Message Type 1 byte[Message Type 0=>Need to delete this message with Packet ID,1=>No Need to Insert ur DB,2=>Plain Message,3=>Message With emoticons,4=>Large Emoticons,5=>Text Emoticon,6=>Downloaded stiker message,7=>Image File view(From Gallery),8=>Audio File Play,9=>Video File Play,10=>Image File view(Ring Camera)]
                     *** Message Timeout 2 Bytes [ you should add Timeout Interger Value using 2 Bytes]
                     *** Latitude 4 bytes
                     *** Longitude 4 bytes
                     *** Message Length 2 Bytes
                     *** TAG ID 8 bytes
                     *** Chat Binding Port 4 bytes
                     *** TAG Members Length 2 bytes
                     *** TAG Name Length 1 bytes[if Tag Name Length is greater then 127 then u need to set up tag name with in 127]
                     *** Device Token Length 2 Bytes
                     *** Message Date 8 Bytes
                     *** Sequence Number 1 Byte
                     *** Number Packets 1 Byte
                     *** Number of Message 1 Byte
                     ******************************************************/
                    /*
                     ******************************************************
                     ***    1. Registration Message:
                     ***    Packet Type + Platform + PacketId Length + Packet Id + User Identity Length + User Identity + Friend Identity Length + Friend Identity + Full Name Length+Full Name
                     ***    Packet Type+User Identity+Friend Identity+PacketID Length+Packet ID+Platform
                     ***
                     ***    2. Register Confirmation Message:
                     ***    Packet Type + Chat Binding Port + PacketId Length + Packet Id + Friend Identity Length + Friend Identity
                     ***
                     ***    4. Chat Message/Edit Friend Message:
                     ***    Packet Type + Message Type + Timeout + Latitude + Longitude + Packet Id Length + Packet Id+ User Identity Length+User Identity+
                     ***    Friend Identity Length + Friend Identity+ Message Length + Message+Message Date + (8 byte)
                     ***
                     ***    5. Deliver Or Seen Message:
                     ***    Packet Type+User Identity Length+User Identity+Friend Identity Length + Friend Identity+PacketID Length+Packet ID+Message Date
                     ***
                     ***    6. Typing or Idle Message:
                     ***    Packet Type+User Identity Length+User Identity+Friend Identity Length + Friend Identity
                     ***
                     ***    8. Delete Message:
                     ***    Packet Type+User Identity Length+User Identity+Friend Identity Length + Friend Identity+PacketID Length+Packet ID
                     ***
                     ***    9. Delete Message Confirmation:
                     ***    Packet Type+User Identity Length+User Identity+Friend Identity Length + Friend Identity+PacketID Length+Packet ID
                     ***
                     ***    10. Chat Unregister Message:
                     ***    Packet Type+User Identity Length+User Identity+Friend Identity Length+Friend Identity+Online Status
                     ***
                     ***    16. Offline Message Request:
                     ***    Packet Type+PacketID Length+Packet ID+User Identity Length+User Identity
                     ***
                     ***    17. Offline Message Confirmation:
                     ***    Packet Type+PacketID Length+Packet ID+Message Date
                     ***
                     ***    18. Friend Chat Offline Message:
                     ***    Packet Type + Number of Message + PacketID Length + Packet ID + ***[[Packet Type + Message Type + Timeout + Latitude + Longitude +
                     ***    User Identity Length + User Identity + Number of Packets + Sequence Number + Message Length + Message+Message Date + Packet ID Length +
                     ***    Packet ID]]
                     ***    [Note: ***[Packet DATA] means this packet will repeated Number of Message]
                     ***    if client received Friend Chat Offline Message(18) then it need to be send Offline Message Confirmation(17) message using received Packet ID.
                     ***
                     ***    Before Send any message to offline Server You need to send a Blank Message to ur friend with Message Type =0;
                     ***
                     ***    ----------------------------------
                     ***    1. Tag chat Registration Message:
                     ***    Packet Type + Platform + PacketID Length + Packet ID + User Identity Length + User Identity + Full Name Length + Full Name + TAG ID
                     ***
                     ***    2. Tag chat confirmation Message:
                     ***    Packet Type+Chat Binding Port+PacketID Length+Packet ID+Tag ID
                     ***
                     ***    3. Tag chat message:
                     ***    Packet Type + Message Type + Timeout + Latitude + Longitude + Packet ID Length + Packet ID+ User Identity Length+User Identity +
                     ***    Full Name Length + Full Name+TAG ID + Message Length + Message+Message Date
                     ******************************************************/
                    getPacketType : function (packetData) {
                        //var array = new Uint8Array(packetData);
                        var dView = new DataView(packetData);
                        var packetType = dView.getIntByByte(0,1);
                        return packetType;
                    },
                    getPacketId : function (packetData) {

                    },
                    copyBufferArray: function (bufferArrayData, offsetByteLength) {
                        var array = new Uint8Array(bufferArrayData);
                        var array2 = new Uint8Array(array.length - offsetByteLength);
                        for(var i = 0; i< (array.length - offsetByteLength); i++){
                            array2[i] = array[i + offsetByteLength];
                        }
                        return array2;
                    },
                    ipToLong: function (ipAddress) {
                        var  ipAddressInArray  = ipAddress.split(".");

                        var longValue = 0;
                        for (var i = 0; i < ipAddressInArray.length; i++) {

                            var power = i ;
                            var ip = parseInt(ipAddressInArray[i]);
                            longValue += ip * Math.pow(256, power);

                        }

                        return longValue;
                    },
                    longToIp: function (longValue) {
                        var ipAddress ="";

                        for (var i = 3; i >= 0; i--) {
                            ipAddress += (longValue & 0xff);
                            if (i > 0) {
                                ipAddress+='.';
                            }

                            longValue = longValue >> 8;
                        }
                        return ipAddress;
                    },
                    ipToByte: function (ipAddress,startPoint) {
                        var ipAddressArray = ipAddress.split("."),
                            ipAddressByte = new Uint8Array(4);
                        for(var k = startPoint; k < startPoint +4; k++){
                            ipAddressByte[k] = ipAddressArray[k-startPoint];
                        }
                        return ipAddressByte;
                    },
                    byteToIp : function (ipByte) {
                        var ipAddress = "";
                        for(var k = 0; k < 4; k++){
                            ipAddress = ipByte[k];
                            if(k<3)
                                ipAddress +=".";
                        }
                        return ipAddress;
                    },
                    integerToByte: function (integerValue, byteLength, startPoint) {
                        var bytes = new Uint8Array(byteLength);
                        for(var k = (byteLength-1); k >=0 ; k--) {
                            bytes[k] = integerValue & (255);
                            integerValue = integerValue / 256;
                        }
                        return bytes;
                    },
                    byteToInteger: function (byteArray, byteLength, startPoint) {
                        var res = 0, bit = (byteLength - 1)*8;
                        for(var k = startPoint; k < (byteLength+startPoint-1); k ++){
                            res += (byteArray [ k ] << bit);
                            bit -= 8;
                        }
                        res += byteArray [ startPoint+byteLength-1 ];
                        return res;
                    },
                    //byteToInteger: function (byteArray, byteLength, startpoint) {
                    //    var value = 0;
                    //    for(var k=(byteLength + startpoint-1);k>=startpoint;k--) {
                    //        value *= 256;
                    //        value += byteArray[k];
                    //    }
                    //    return value;
                    //},

                    Bytes2Float32 : function(bytes) {
                        var sign = (bytes & 0x80000000) ? -1 : 1;
                        var exponent = ((bytes >> 23) & 0xFF) - 127;
                        var significand = (bytes & ~(-1 << 23));

                        if (exponent == 128)
                            return sign * ((significand) ? Number.NaN : Number.POSITIVE_INFINITY);

                        if (exponent == -127) {
                            if (significand == 0) return sign * 0.0;
                            exponent = -126;
                            significand /= (1 << 22);
                        } else significand = (significand | (1 << 23)) / (1 << 23);

                        return sign * significand * Math.pow(2, exponent);
                    },

                    Float32ToInt : function(floatData){
                        var view = new DataView(new ArrayBuffer(4));
                        view.setFloat32(0, floatData);
                        return view.getInt32(0);
                    },

                    //Packet Type+User Identity+Friend Identity+PacketID Length+Packet ID+Platform
                    constructRegisterPacket: function (registerJson) {
                        //var array = new Uint8Array( 9 + /*registerJson.userId.length*/8 + registerJson.packetId.length + /*registerJson.friendId.length*/8 /*+ registerJson.fullName.length*/);
                        var array = new Uint8Array( 25 + registerJson.packetId.length );
                        var i = 0;
                        //session Id : don't need sessionId now
                        //array[ i++ ] = registerJson.sessionId.length;
                        //for(var j = 0; j < registerJson.sessionId.length; j ++){
                        //    array[ i++ ] = registerJson.sessionId.charCodeAt(j);
                        //}
                        // ip
                        //var ipArray = this.integerToByte(this.ipToLong(registerJson.ip),8,0);
                        var ipArray = this.ipToByte(registerJson.ip,0);
                        for(var j = 0; j< ipArray.length; j++){
                            array[i++] = ipArray[j];
                        }
                        // port
                        var portArray = this.integerToByte(registerJson.port,2,i);
                        for(var j = 0; j< portArray.length; j++){
                            array[i++] = portArray[j];
                        }
                        //packet type
                        array[ i++ ] = 1;


                        //userId
                        //array[i++] = registerJson.userId.length;
                        //for(var j = 0; j < registerJson.userId.length; j ++){
                        //    array[ i++ ] = registerJson.userId.charCodeAt(j);
                        //}
                        var userId = this.integerToByte(registerJson.userId,8,i);
                        for(var j = 0; j< userId.length; j++){
                            array[i++] = userId[j];
                        }
                        //friendId
                        //array[i++] = registerJson.friendId.length;
                        //for(var j = 0; j < registerJson.friendId.length; j ++){
                        //    array[ i++ ] = registerJson.friendId.charCodeAt(j);
                        //}
                        var friendId = this.integerToByte(registerJson.friendId,8,i);
                        for(var j = 0; j< friendId.length; j++){
                            array[i++] = friendId[j];
                        }
                        //fullName
                        //array[i++] = registerJson.fullName.length;
                        //for(var j = 0; j < registerJson.fullName.length; j ++){
                        //    array[ i++ ] = registerJson.fullName.charCodeAt(j);
                        //}
                        //packetId
                        array[i++] = registerJson.packetId.length;
                        for(var j = 0; j < registerJson.packetId.length; j ++){
                            array[ i++ ] = registerJson.packetId.charCodeAt(j);
                        }
                        //platform???
                        array[ i++ ] = 5;// platform value is 5 for web

                        //var debugArray = new Uint8Array(array.length -6);
                        //for(var q = 0; q< array.length-6; q++){
                        //    debugArray[q] = array[q+6];
                        //}
                        //RingLogger.log(this.parseRegisterPacket(debugArray));
                        return array;
                        //return registerPacket;
                    },
                    constructTagRegisterPacket: function (tagRegisterObject) {
                        var array = new Uint8Array( 14 + tagRegisterObject.sessionId.length + tagRegisterObject.userId.length + tagRegisterObject.packetId.length);
                        var i = 0;
                        //session Id : don't need sessionId now
                        //array[ i++ ] = tagRegisterObject.sessionId.length;
                        //for(var j = 0; j < tagRegisterObject.sessionId.length; j ++){
                        //    array[ i++ ] = tagRegisterObject.sessionId.charCodeAt(j);
                        //}
                        // ip
                        var ipArray = this.integerToByte(this.ipToLong(registerJson.ip),8,0);
                        for(var j = 0; j< ipArray.length; j++){
                            array[i++] = ipArray[j];
                        }
                        // port
                        var portArray = this.integerToByte(registerJson.port,2,i);
                        for(var j = 0; j< portArray.length; j++){
                            array[i++] = portArray[j];
                        }
                        //packet type
                        array[ i++ ] = 12;//12 for tag chat register
                        //platform???
                        array[ i++ ] = 5;// platform value is 5 for web
                        //packetId
                        array[i++] = tagRegisterObject.packetId.length;
                        for(var j = 0; j < tagRegisterObject.packetId.length; j ++){
                            array[ i++ ] = tagRegisterObject.packetId.charCodeAt(j);
                        }
                        //userId
                        array[i++] = tagRegisterObject.userId.length;
                        for(var j = 0; j < tagRegisterObject.userId.length; j ++){
                            array[ i++ ] = tagRegisterObject.userId.charCodeAt(j);
                        }
                        //fullName
                        array[i++] = tagRegisterObject.fullName.length;
                        for(var j = 0; j < tagRegisterObject.fullName.length; j ++){
                            array[ i++ ] = tagRegisterObject.fullName.charCodeAt(j);
                        }
                        //tagId 8 byte
                        //var tempI = i;
                        var tempArrayTagId = this.integerToByte(tagRegisterObject.tagId,8,i);
                        //for(var j = tempI; j< (tempI+tempArrayTagId.length); j++){
                        //    array[i++] = tempArrayTagId[j];
                        //}
                        for(var j = 0; j< tempArrayTagId.length; j++){
                            array[i++] = tempArrayTagId[j];
                        }
                        //RingLogger.log(array);
                        return array;
                        //return registerPacket;
                    },
                    //Packet Type+User Identity+Friend Identity Length+Online Status
                    //Packet Type+User Identity+Friend Identity Length+Online Status
                    constructUnregisterPacket: function (unregisterObject) {
                        // Packet Type+User Identity Length+User Identity+Friend Identity Length+Friend Identity+Online Status
                        //var array = new Uint8Array( 7 + unregisterObject.userId.length + unregisterObject.friendId.length );
                        var array = new Uint8Array( 24 );
                        var i = 0;
                        //session Id : don't need sessionId now
                        //array[ i++ ] = unregisterObject.sessionId.length;
                        //for(var j = 0; j < unregisterObject.sessionId.length; j ++){
                        //    array[ i++ ] = unregisterObject.sessionId.charCodeAt(j);
                        //}
                        // ip
                        //var ipArray = this.integerToByte(this.ipToLong(registerJson.ip),8,0);
                        var ipArray = this.ipToByte(unregisterObject.ip,0);
                        for(var j = 0; j< ipArray.length; j++){
                            array[i++] = ipArray[j];
                        }
                        // port
                        var portArray = this.integerToByte(unregisterObject.port,2,i);
                        for(var j = 0; j< portArray.length; j++){
                            array[i++] = portArray[j];
                        }
                        //packet type
                        array[ i++ ] = 2; // 2 for unregister, 1 for register
                        //userId
                        //array[i++] = unregisterObject.userId.length;
                        //for(var j = 0; j < unregisterObject.userId.length; j ++){
                        //    array[ i++ ] = unregisterObject.userId.charCodeAt(j);
                        //}
                        var userId = this.integerToByte(unregisterObject.userId,8,i);
                        for(var j = 0; j< userId.length; j++){
                            array[i++] = userId[j];
                        }
                        //friendId
                        //array[i++] = unregisterObject.friendId.length;
                        //for(var j = 0; j < unregisterObject.friendId.length; j ++){
                        //    array[ i++ ] = unregisterObject.friendId.charCodeAt(j);
                        //}
                        var friendId = this.integerToByte(unregisterObject.friendId,8,i);
                        for(var j = 0; j< friendId.length; j++){
                            array[i++] = friendId[j];
                        }
                        //online Status
                        array[i++] = 1 // 1 for online, 2 for away, 3 for offline

                        return array;
                    },
                    //Packet Type+Friend Identity+PacketID Length+Packet ID+Chat Binding Port+Server Date
                    parseRegisterPacket: function (registerPacket) {
                        var array = new Uint8Array(registerPacket);
                        var registerJson = {};
                        var i= 0 ;
                        //var bit = 24;
                        //var res = 0;
                        //var port = 0;
                        //packet type
                        registerJson.packetType = array[i++];
                        //friendId
                        registerJson.friendId = this.byteToInteger(array,8,i);
                        i = i + 8;
                        //packetId
                        registerJson.packetId = this.getIndPckData(array, i+1, array[i]); // data, startpoint, length
                        i = i + 1 + array[i];
                        //port
                        //for(var i = 1; i < 4; i ++){
                        //    //RingLogger.log(array[i]);
                        //    res += (array [ i ] << bit);
                        //    //RingLogger.log(res + " bit : " + bit);
                        //    bit -= 8;
                        //}
                        //RingLogger.log(array[4]);
                        //res += array [ 4 ];
                        //var port = res;
                        var port = this.byteToInteger(array, 4, i);//data,length, startpoint
                        //var port2 = this.byteToInteger(array, 4, 1);//data,length, startpoint
                        registerJson.port = port;
                        //registerJson.port2 = port2;




                        return registerJson;
                    },
                    parseTagRegisterPacket: function (tagRegisterPacket) {
                        var array = new Uint8Array(tagRegisterPacket);
                        var tagRegisterObject = {};
                        var bit = 24;
                        var bit2 = 56;
                        var res = 0;
                        var tagId = 0;
                        //packet type
                        tagRegisterObject.packetType = array[0];
                        //port
                        //for(var i = 1; i < 4; i ++){
                        //    res += (array [ i ] << bit);
                        //    //RingLogger.log(res + " bit : " + bit);
                        //    bit -= 8;
                        //}
                        //res += array [ 4 ];
                        //var port = res;
                        var port = this.byteToInteger(array, 4, 1);
                        tagRegisterObject.port = port;
                        //packetId
                        tagRegisterObject.packetId = this.getIndPckData(tagRegisterPacket, 6, array[5]); // data, startpoint, length
                        //tagId
                        for(var i = 1; i < 8; i ++){
                            tagId += (array [ i ] << bit2);
                            //RingLogger.log(tagId + " bit : " + bit2);
                            bit2 -= 8;
                        }
                        tagId += array [ 8 ];
                        tagRegisterObject.tagId = tagId;
                        return tagRegisterObject;
                    },
                    processUnregisterPacket: function (unregisterPacket) {
                        var array = new Uint8Array(unregisterPacket);
                        var unregisterObject = {};
                        var headPointer = 0;

                        //packet type
                        unregisterObject.packetType = array[headPointer++];
                        //userId
                        unregisterObject.userId = this.byteToInteger(array,8,headPointer);
                        headPointer = headPointer + 8;

                        //friendId
                        unregisterObject.friendId = this.byteToInteger(array,8,headPointer);
                        headPointer = headPointer + 8;

                        //headPointer = i;
                        ////userId
                        //unregisterObject.userId = this.getIndPckData(array, 2, array[1]);
                        ////friendId
                        //unregisterObject.friendId = this.getIndPckData(array, 1+array[1]+2, array[1+array[1]+1]); // data, startpoint, length

                        unregisterObject.onlineStatus = 1;

                        return unregisterObject;
                    },
                    ////Packet Type+User Identity+Friend Identity++ Packet ID Length + Packet ID + Message Type + Timeout + Latitude + Longitude + Message Length + Message+Message Date
                    //constructChatMsgPacket: function (msgObj) {
                    //    //var array = new Uint8Array( 38 /*+ msgObj.sessionId.length*/ + msgObj.userId.length + msgObj.packetId.length + msgObj.friendId.length + msgObj.message.length);
                    //    var array = new Uint8Array( 53 + msgObj.packetId.length + msgObj.message.length);
                    //    var i = 0;
                    //    //sessionId : don't need sessionId now
                    //    //array[ i++ ] = msgObj.sessionId.length;
                    //    //for(var j = 0; j < msgObj.sessionId.length; j ++){
                    //    //    array[ i++ ] = msgObj.sessionId.charCodeAt(j);
                    //    //}
                    //    // ip
                    //    //var ipArray = this.integerToByte(this.ipToLong(registerJson.ip),8,0);
                    //    var ipArray = this.ipToByte(msgObj.ip,0);
                    //    for(var j = 0; j< ipArray.length; j++){
                    //        array[i++] = ipArray[j];
                    //    }
                    //    // port
                    //    var portArray = this.integerToByte(msgObj.port,2,i);
                    //    for(var j = 0; j< portArray.length; j++){
                    //        array[i++] = portArray[j];
                    //    }
                    //    //packet type
                    //    array[ i++ ] = 5;//5 is for sending chat message
                    //    //userId
                    //    var userId = this.integerToByte(msgObj.userId,8,i);
                    //    for(var j = 0; j< userId.length; j++){
                    //        array[i++] = userId[j];
                    //    }
                    //    //friendId
                    //    //array[ i++ ] = msgObj.friendId.length;
                    //    //for(var j = 0; j < msgObj.friendId.length; j ++){
                    //    //    array[ i++ ] = msgObj.friendId.charCodeAt(j);
                    //    //}
                    //    var friendId = this.integerToByte(msgObj.friendId,8,i);
                    //    for(var j = 0; j< friendId.length; j++){
                    //        array[i++] = friendId[j];
                    //    }
                    //    //packetId
                    //    array[ i++ ] = msgObj.packetId.length;
                    //    for(var j = 0; j < msgObj.packetId.length; j ++){
                    //        array[ i++ ] = msgObj.packetId.charCodeAt(j);
                    //    }
                    //    //message type
                    //    array[ i++] = msgObj.messageType;// 2 for text message, 0 for blank message
                    //    //timeout
                    //    var timeout = this.integerToByte(msgObj.timeout,2,i);
                    //    for( var j = 0; j<2; j++){
                    //        array[i++] = timeout[j];
                    //    }
                    //    //array[ i++] = 0;
                    //    //array[ i++] = 0;
                    //    //lattitude
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //    //longitude
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //
                    //
                    //    //messageText
                    //    array[ i++ ] = 0;
                    //    array[ i++ ] = msgObj.message.length;
                    //    for(var j = 0; j < msgObj.message.length; j ++){
                    //        array[ i++ ] = msgObj.message.charCodeAt(j);
                    //    }
                    //    //messageDate
                    //    for(var j = 0; j < 8; j ++){
                    //        array[ i++ ] = 1;
                    //    }
                    //    // extra 8 byte for timeout(doesn't know what this timeout is)
                    //    for(var j = 0; j < 8; j ++){
                    //        array[ i++ ] = 1;
                    //    }
                    //    return array;
                    //},
                    ///*
                    //Packet Type + Message Type + Timeout + Latitude + Longitude + Packet ID Length + Packet ID+ User Identity Length+User Identity +
                    //Full Name Length + Full Name+TAG ID + Message Length + Message+Message Date
                    //*/
                    //constructTagChatMsgPacket: function (msgObj) {
                    //    var array = new Uint8Array( 33 + msgObj.sessionId.length + msgObj.userId.length + msgObj.packetId.length + msgObj.fullname.length + msgObj.message.length);
                    //    var i = 0;
                    //    //sessionId : don't need sessionId now
                    //    //array[ i++ ] = msgObj.sessionId.length;
                    //    //for(var j = 0; j < msgObj.sessionId.length; j ++){
                    //    //    array[ i++ ] = msgObj.sessionId.charCodeAt(j);
                    //    //}
                    //    // ip
                    //    var ipArray = this.integerToByte(this.ipToLong(registerJson.ip),8,0);
                    //    for(var j = 0; j< ipArray.length; j++){
                    //        array[i++] = ipArray[j];
                    //    }
                    //    // port
                    //    var portArray = this.integerToByte(registerJson.port,2,i);
                    //    for(var j = 0; j< portArray.length; j++){
                    //        array[i++] = portArray[j];
                    //    }
                    //    //packet type
                    //    array[ i++ ] = 5;//5 is for sending chat message
                    //    //message type
                    //    array[ i++] = 2;// for text message
                    //    //timeout
                    //    var timeout = this.integerToByte(msgObj.timeout,2,i);
                    //    for( var j = 0; j<2; j++){
                    //        array[i++] = timeout[j];
                    //    }
                    //    //array[ i++] = 1;
                    //    //array[ i++] = 1;
                    //    //lattitude
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //    //longitude
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //    array [ i ++ ] = 1;
                    //    //packetId
                    //    array[ i++ ] = msgObj.packetId.length;
                    //    for(var j = 0; j < msgObj.packetId.length; j ++){
                    //        array[ i++ ] = msgObj.packetId.charCodeAt(j);
                    //    }
                    //    //userId
                    //    array[ i++ ] = msgObj.userId.length;
                    //    for(var j = 0; j < msgObj.userId.length; j ++){
                    //        array[ i++ ] = msgObj.userId.charCodeAt(j);
                    //    }
                    //    //fullname
                    //    array[ i++ ] = msgObj.fullname.length;
                    //    for(var j = 0; j < msgObj.fullname.length; j ++){
                    //        array[ i++ ] = msgObj.fullname.charCodeAt(j);
                    //    }
                    //    //tagId
                    //    var tempArrayTagId = this.integerToByte(msgObj.tagId,8,i);
                    //    for(var j = i; j< (i+tempArrayTagId.length); j++){
                    //        array[i++] = tempArrayTagId[j];
                    //    }
                    //    //messageText
                    //    array[ i++ ] = 0;
                    //    array[ i++ ] = msgObj.message.length;
                    //    for(var j = 0; j < msgObj.message.length; j ++){
                    //        array[ i++ ] = msgObj.message.charCodeAt(j);
                    //    }
                    //    //messageDate
                    //    for(var j = 0; j < 8; j ++){
                    //        array[ i++ ] = 1;
                    //    }
                    //    // extra 8 byte for timeout(doesn't know what this timeout is)
                    //    for(var j = 0; j < 8; j ++){
                    //        array[ i++ ] = 1;
                    //    }
                    //    return array;
                    //},
                    ////Packet Type+User Identity+Friend Identity++ Packet ID Length + Packet ID + Message Type + Timeout + Latitude + Longitude + Message Length + Message+Message Date
                    //processChatMsgPacket: function (msgBufferData) {
                    //    var array = new Uint8Array(msgBufferData);
                    //    //RingLogger.log(array);
                    //    var headPointer = 0;
                    //    var message = {};
                    //    //message.packetType = array [ 0 ];
                    //    //message.messageType = array [ 1 ];
                    //    //message.timeout = (array[2] << 8) + array[3] ;
                    //    message.latitude = '';
                    //    message.longitude = '';
                    //    message.packetId = '';
                    //    //message.userId = '';
                    //    //message.friendId = '';
                    //    message.message = '';
                    //    message.messageDate = '';
                    //    message.timeoutLast = '';
                    //
                    //    //packetType
                    //    message.packetType = array[headPointer++];
                    //
                    //    //userId
                    //    message.userId = this.byteToInteger(array,8,headPointer);
                    //    headPointer = headPointer + 8;
                    //
                    //    //friendId
                    //    message.friendId = this.byteToInteger(array,8,headPointer);
                    //    headPointer = headPointer + 8;
                    //
                    //    //packetId
                    //    message.packetIdLength = array[headPointer++];
                    //    for(var i = headPointer; i < headPointer+message.packetIdLength; i ++){
                    //        message.packetId += String.fromCharCode(array [ i ]);
                    //    }
                    //    headPointer = i;
                    //
                    //    //messageType
                    //    message.messageType = array[headPointer++];
                    //
                    //    //timeout
                    //    message.timeout = this.byteToInteger(array,2,headPointer);
                    //    headPointer += 2;
                    //
                    //    //latitude
                    //    for(var i = headPointer; i < headPointer + 4; i ++){
                    //        message.latitude += (array [ i ])+"";
                    //    }
                    //    headPointer = i;
                    //
                    //    //longitude
                    //    for(var i = headPointer; i < headPointer + 4; i ++){
                    //        message.longitude += (array [ i ])+"";
                    //    }
                    //    headPointer = i;
                    //
                    //    //message
                    //    message.messageLength = (array[headPointer++] << 8) + array[headPointer++];
                    //    //headPointer ++;
                    //    for(var i = headPointer; i < headPointer + message.messageLength; i ++){
                    //        message.message += String.fromCharCode(array [ i ]);
                    //    }
                    //    headPointer = i;
                    //
                    //    //messageDate
                    //    message.messageDateLength = 8;
                    //    headPointer ++;
                    //    for(var i = headPointer; i < headPointer + message.messageDateLength; i ++){
                    //        message.messageDate += array [ i ]+"";
                    //    }
                    //    headPointer = i;
                    //
                    //
                    //    //timeout added lastly and which is 8 byte
                    //    //message.timeoutLastLength = 8;
                    //    //headPointer ++;
                    //    //for(var i = headPointer; i < headPointer + message.timeoutLastLength; i ++){
                    //    //    message.timeoutLast += array [ i ]+"";
                    //    //    headPointer = i + 1;
                    //    //}
                    //    //message.user = message.userId;
                    //    //var messageLength = array [ 24 ];
                    //    ////RingLogger.log("Message Length: " + messageLength);
                    //    //var slice = msgBufferData.slice(25,25 + messageLength);
                    //    //var array2 = new Uint8Array(slice);
                    //    //
                    //    //var message = "";
                    //    //for(var i = 0; i < array2.length; i ++){
                    //    //    message += String.fromCharCode(array2 [ i ]);
                    //    //}
                    //    return message;
                    //},
                    ////Packet Type+User Identity+ Friend Identity+PacketID Length+Packet ID
                    //constructDeliverPacket: function (packetObject) {
                    //    //var array = new Uint8Array( 18 /*+ packetObject.sessionId.length*/ + packetObject.userId.length + packetObject.packetId.length + packetObject.friendId.length);
                    //    var array = new Uint8Array( 24 + packetObject.packetId.length);
                    //    var i = 0;
                    //    //sessionId : don't need sessionId now
                    //    //array[ i++ ] = packetObject.sessionId.length;
                    //    //for(var j = 0; j < packetObject.sessionId.length; j ++){
                    //    //    array[ i++ ] = packetObject.sessionId.charCodeAt(j);
                    //    //}
                    //    // ip
                    //    //var ipArray = this.integerToByte(this.ipToLong(registerJson.ip),8,0);
                    //    var ipArray = this.ipToByte(packetObject.ip,0);
                    //    for(var j = 0; j< ipArray.length; j++){
                    //        array[i++] = ipArray[j];
                    //    }
                    //    // port
                    //    var portArray = this.integerToByte(packetObject.port,2,i);
                    //    for(var j = 0; j< portArray.length; j++){
                    //        array[i++] = portArray[j];
                    //    }
                    //    //packet type
                    //    array[ i++ ] = packetObject.packetType;// 6 is for delivered packet and 7 for seen packet
                    //    //userId
                    //    //array[ i++ ] = packetObject.userId.length;
                    //    //for(var j = 0; j < packetObject.userId.length; j ++){
                    //    //    array[ i++ ] = packetObject.userId.charCodeAt(j);
                    //    //}
                    //    var userId = this.integerToByte(packetObject.userId,8,i);
                    //    for(var j = 0; j< userId.length; j++){
                    //        array[i++] = userId[j];
                    //    }
                    //    //friendId
                    //    //array[ i++ ] = packetObject.friendId.length;
                    //    //for(var j = 0; j < packetObject.friendId.length; j ++){
                    //    //    array[ i++ ] = packetObject.friendId.charCodeAt(j);
                    //    //}
                    //    var friendId = this.integerToByte(packetObject.friendId,8,i);
                    //    for(var j = 0; j< friendId.length; j++){
                    //        array[i++] = friendId[j];
                    //    }
                    //    //packetId
                    //    array[ i++ ] = packetObject.packetId.length;
                    //    for(var j = 0; j < packetObject.packetId.length; j ++){
                    //        array[ i++ ] = packetObject.packetId.charCodeAt(j);
                    //    }
                    //    //messageDate
                    //    //for(var j = 0; j < 8; j ++){
                    //    //    array[ i++ ] = 1;
                    //    //}
                    //    return array;
                    //},
                    //processDeliverPacket : function (packetData) {
                    //    var array = new Uint8Array(packetData);
                    //    var deliverObject = {};
                    //    var headPointer = 0;
                    //    //deliverObject.userId= '';
                    //    //deliverObject.friendId= '';
                    //    deliverObject.packetId= '';
                    //    //deliverObject.messageDate= '';
                    //
                    //    //packet type
                    //    deliverObject.packetType = array[headPointer++];
                    //
                    //    //userId
                    //    deliverObject.userId = this.byteToInteger(array,8,headPointer);
                    //    headPointer = headPointer + 8;
                    //
                    //    //friendId
                    //    deliverObject.friendId = this.byteToInteger(array,8,headPointer);
                    //    headPointer = headPointer + 8;
                    //
                    //    //packetId
                    //    deliverObject.packetIdLength = array[headPointer++];
                    //    for(var i = headPointer; i < headPointer+deliverObject.packetIdLength; i ++){
                    //        deliverObject.packetId += String.fromCharCode(array [ i ]);
                    //    }
                    //    headPointer = i;
                    //    ////userId
                    //    //deliverObject.userIdLength = array[1];
                    //    //for(var i = 2; i < 2 +deliverObject.userIdLength; i ++){
                    //    //    deliverObject.userId += String.fromCharCode(array [ i ]);
                    //    //}
                    //    //headPoint = i;
                    //    ////friendId
                    //    //deliverObject.friendIdLength = array[headPoint];
                    //    //headPoint++;
                    //    //for(var i = headPoint; i < headPoint +deliverObject.friendIdLength; i ++){
                    //    //    deliverObject.friendId += String.fromCharCode(array [ i ]);
                    //    //}
                    //    //headPoint = i;
                    //    ////packetId
                    //    //deliverObject.packetIdLength = array[headPoint];
                    //    //headPoint++;
                    //    //for(var i = headPoint; i < headPoint +deliverObject.packetIdLength; i ++){
                    //    //    deliverObject.packetId += String.fromCharCode(array [ i ]);
                    //    //}
                    //    //headPoint = i;
                    //    //messageDate
                    //    //for(var i = headPoint; i < 8 ; i ++){
                    //    //    deliverObject.messageDate += String.fromCharCode(array [ i ]);
                    //    //}
                    //
                    //    return deliverObject;
                    //},
                    ////Packet Type+User Identity+ Friend Identity
                    //constructTypingPacket: function (packetObject) {
                    //    //var array = new Uint8Array( 9 /*+ packetObject.sessionId.length*/ + packetObject.userId.length + packetObject.friendId.length);
                    //    var array = new Uint8Array( 23 );
                    //    var i = 0;
                    //    //sessionId : don't need sessionId now
                    //    //array[ i++ ] = packetObject.sessionId.length;
                    //    //for(var j = 0; j < packetObject.sessionId.length; j ++){
                    //    //    array[ i++ ] = packetObject.sessionId.charCodeAt(j);
                    //    //}
                    //    // ip
                    //    //var ipArray = this.integerToByte(this.ipToLong(registerJson.ip),8,0);
                    //    var ipArray = this.ipToByte(packetObject.ip,0);
                    //    for(var j = 0; j< ipArray.length; j++){
                    //        array[i++] = ipArray[j];
                    //    }
                    //    // port
                    //    var portArray = this.integerToByte(packetObject.port,2,i);
                    //    for(var j = 0; j< portArray.length; j++){
                    //        array[i++] = portArray[j];
                    //    }
                    //    //packet type
                    //    array[ i++ ] = packetObject.packetType;//9 is for sending typing packet and 10 for idle packet
                    //
                    //    //userId
                    //    //array[ i++ ] = packetObject.userId.length;
                    //    //for(var j = 0; j < packetObject.userId.length; j ++){
                    //    //    array[ i++ ] = packetObject.userId.charCodeAt(j);
                    //    //}
                    //    var userId = this.integerToByte(packetObject.userId,8,i);
                    //    for(var j = 0; j< userId.length; j++){
                    //        array[i++] = userId[j];
                    //    }
                    //    //friendId
                    //    //array[ i++ ] = packetObject.friendId.length;
                    //    //for(var j = 0; j < packetObject.friendId.length; j ++){
                    //    //    array[ i++ ] = packetObject.friendId.charCodeAt(j);
                    //    //}
                    //    var friendId = this.integerToByte(packetObject.friendId,8,i);
                    //    for(var j = 0; j< friendId.length; j++){
                    //        array[i++] = friendId[j];
                    //    }
                    //
                    //    return array;
                    //},
                    //processIdlePacket: function (packetData) {
                    //    var array = new Uint8Array(packetData);
                    //    var IdleObject = {};
                    //    var headPointer = 0;
                    //    //IdleObject.userId = '';
                    //    //IdleObject.friendId = '';
                    //
                    //    //packet type
                    //    IdleObject.packetType = array[headPointer++];
                    //    //userId
                    //    IdleObject.userId = this.byteToInteger(array,8,headPointer);
                    //    headPointer = headPointer + 8;
                    //
                    //    //friendId
                    //    IdleObject.friendId = this.byteToInteger(array,8,headPointer);
                    //    headPointer = headPointer + 8;
                    //
                    //    ////userId
                    //    //IdleObject.userIdLength = array[1];
                    //    //for(var i = 2; i < 2 +IdleObject.userIdLength; i ++){
                    //    //    IdleObject.userId += String.fromCharCode(array [ i ]);
                    //    //}
                    //    //headPoint = i;
                    //    ////friendId
                    //    //IdleObject.friendIdLength = array[headPoint];
                    //    //headPoint++;
                    //    //for(var i = headPoint; i < headPoint +IdleObject.friendIdLength; i ++){
                    //    //    IdleObject.friendId += String.fromCharCode(array [ i ]);
                    //    //}
                    //
                    //    return IdleObject;
                    //},
                    ////Packet Type+User Identity+ Friend Identity+PacketID Length+Packet ID
                    //constructDeletePacket: function (deleteObject) {
                    //    //Packet Type+User Identity Length+User Identity+Friend Identity Length + Friend Identity+PacketID Length+Packet ID
                    //    //var array = new Uint8Array( 10 /*+ deleteObject.sessionId.length*/ + deleteObject.userId.length + deleteObject.packetId.length + deleteObject.friendId.length);
                    //    var array = new Uint8Array( 24 + deleteObject.packetId.length);
                    //    var i = 0;
                    //    ////sessionId : don't need sessionId now
                    //    //array[ i++ ] = deleteObject.sessionId.length;
                    //    //for(var j = 0; j < deleteObject.sessionId.length; j ++){
                    //    //    array[ i++ ] = deleteObject.sessionId.charCodeAt(j);
                    //    //}
                    //    // ip
                    //    //var ipArray = this.integerToByte(this.ipToLong(registerJson.ip),8,0);
                    //    var ipArray = this.ipToByte(deleteObject.ip,0);
                    //    for(var j = 0; j< ipArray.length; j++){
                    //        array[i++] = ipArray[j];
                    //    }
                    //    // port
                    //    var portArray = this.integerToByte(deleteObject.port,2,i);
                    //    for(var j = 0; j< portArray.length; j++){
                    //        array[i++] = portArray[j];
                    //    }
                    //    //packet type
                    //    array[ i++ ] = deleteObject.packetType;// 24 is for delete friend chat packet and 25 for delete confirm friend chat packet
                    //    //userId
                    //    //array[ i++ ] = deleteObject.userId.length;
                    //    //for(var j = 0; j < deleteObject.userId.length; j ++){
                    //    //    array[ i++ ] = deleteObject.userId.charCodeAt(j);
                    //    //}
                    //    var userId = this.integerToByte(deleteObject.userId,8,i);
                    //    for(var j = 0; j< userId.length; j++){
                    //        array[i++] = userId[j];
                    //    }
                    //    //friendId
                    //    //array[ i++ ] = deleteObject.friendId.length;
                    //    //for(var j = 0; j < deleteObject.friendId.length; j ++){
                    //    //    array[ i++ ] = deleteObject.friendId.charCodeAt(j);
                    //    //}
                    //    var friendId = this.integerToByte(deleteObject.friendId,8,i);
                    //    for(var j = 0; j< friendId.length; j++){
                    //        array[i++] = friendId[j];
                    //    }
                    //    //packetId
                    //    array[ i++ ] = deleteObject.packetId.length;
                    //    for(var j = 0; j < deleteObject.packetId.length; j ++){
                    //        array[ i++ ] = deleteObject.packetId.charCodeAt(j);
                    //    }
                    //    return array;
                    //},
                    //processDeletePacket: function (deletePacket) {
                    //    var array = new Uint8Array(deletePacket);
                    //    var deleteObject = {};
                    //    var headPointer = 0;
                    //    //deleteObject.userId= '';
                    //    //deleteObject.friendId= '';
                    //    deleteObject.packetId= '';
                    //    //deleteObject.messageDate= '';
                    //
                    //    //packet type
                    //    deleteObject.packetType = array[headPointer++];
                    //    //userId
                    //    deleteObject.userId = this.byteToInteger(array,8,headPointer);
                    //    headPointer = headPointer + 8;
                    //
                    //    //friendId
                    //    deleteObject.friendId = this.byteToInteger(array,8,headPointer);
                    //    headPointer = headPointer + 8;
                    //
                    //    //packetId
                    //    deleteObject.packetIdLength = array[headPointer++];
                    //    for(var i = headPointer; i < headPointer+deleteObject.packetIdLength; i ++){
                    //        deleteObject.packetId += String.fromCharCode(array [ i ]);
                    //    }
                    //    headPointer = i;
                    //    ////userId
                    //    //deleteObject.userIdLength = array[1];
                    //    //for(var i = 2; i < 2 +deleteObject.userIdLength; i ++){
                    //    //    deleteObject.userId += String.fromCharCode(array [ i ]);
                    //    //}
                    //    //headPoint = i;
                    //    ////friendId
                    //    //deleteObject.friendIdLength = array[headPoint];
                    //    //headPoint++;
                    //    //for(var i = headPoint; i < headPoint +deleteObject.friendIdLength; i ++){
                    //    //    deleteObject.friendId += String.fromCharCode(array [ i ]);
                    //    //}
                    //    //headPoint = i;
                    //    ////packetId
                    //    //deleteObject.packetIdLength = array[headPoint];
                    //    //headPoint++;
                    //    //for(var i = headPoint; i < headPoint +deleteObject.packetIdLength; i ++){
                    //    //    deleteObject.packetId += String.fromCharCode(array [ i ]);
                    //    //}
                    //
                    //    return deleteObject;
                    //},
                    ////Packet Type+User Identity+PacketID Length+Packet ID
                    //constructOfflineRequest: function (offlineRequestObject) {
                    //    // Packet Type+PacketID Length+Packet ID+User Identity Length+User Identity(this was the previous format)
                    //    //var array = new Uint8Array( 4 + offlineRequestObject.sessionId.length + offlineRequestObject.userId.length + offlineRequestObject.packetId.length);
                    //    var array = new Uint8Array( 16 + offlineRequestObject.packetId.length);
                    //    var i = 0;
                    //
                    //    // ip
                    //    //var ipArray = this.integerToByte(this.ipToLong(registerJson.ip),8,0);
                    //    var ipArray = this.ipToByte(offlineRequestObject.ip,0);
                    //    for(var j = 0; j< ipArray.length; j++){
                    //        array[i++] = ipArray[j];
                    //    }
                    //    // port
                    //    var portArray = this.integerToByte(offlineRequestObject.port,2,i);
                    //    for(var j = 0; j< portArray.length; j++){
                    //        array[i++] = portArray[j];
                    //    }
                    //    //packet type
                    //    array[ i++ ] = offlineRequestObject.packetType; // packetType is 20 for offline request
                    //
                    //    //userId
                    //    //array[i++] = offlineRequestObject.userId.length;
                    //    //for(var j = 0; j < offlineRequestObject.userId.length; j ++){
                    //    //    array[ i++ ] = offlineRequestObject.userId.charCodeAt(j);
                    //    //}
                    //    var userId = this.integerToByte(offlineRequestObject.userId,8,i);
                    //    for(var j = 0; j< userId.length; j++){
                    //        array[i++] = userId[j];
                    //    }
                    //    //packetId
                    //    array[i++] = offlineRequestObject.packetId.length;
                    //    for(var j = 0; j < offlineRequestObject.packetId.length; j ++){
                    //        array[ i++ ] = offlineRequestObject.packetId.charCodeAt(j);
                    //    }
                    //    return array;
                    //},
                    ////Packet Type+PacketID Length+Packet ID+Message Date
                    //processOfflineConfirmPacket: function (offlineConfirmPacket) {
                    //    //Packet Type+PacketID Length+Packet ID+Message Date
                    //    var array = new Uint8Array(offlineConfirmPacket);
                    //    var offlineConfirmObject = {};
                    //    var i = 0;
                    //    //packet type
                    //    offlineConfirmObject.packetType = array[i++];
                    //
                    //    //packetId
                    //    offlineConfirmObject.packetIdLength = array[i++];
                    //    for(var j = i; j < i + offlineConfirmObject.packetIdLength; j ++){
                    //        offlineConfirmObject.packetId += String.fromCharCode(array [ j ]);
                    //    }
                    //    i = j;
                    //    //offlineConfirmObject.packetId = this.getIndPckData(array, 2, array[1]); // data, startpoint, length
                    //    //messageDate[assuming 8 byte long value as timestamp]
                    //    //offlineConfirmObject.messageDate = this.getIndPckData(array, 2+array[1]+1, 8); // data, startpoint, length
                    //    offlineConfirmObject.messageDate = this.byteToInteger(array, 8, i);// data, length, startpoint
                    //
                    //    return offlineConfirmObject;
                    //},
                    //createDummyOfflinePacket: function(){
                    //    var array = new Uint8Array( 4 +(39*3));
                    //    var i = 0;
                    //    array[i++] = 20; //packet type
                    //    array[i++] = 1; //packetId length
                    //    array[i++] = 'p'; //packetId
                    //    array[i++] = 3; //no of message
                    //    for(var k=0; k<3; k++){
                    //        var uI = 210010131;
                    //        uI += k;
                    //        array[i++] = 5; // message packet type
                    //        //userId
                    //        var userId = this.integerToByte(uI,8,i);
                    //        for(var j = 0; j< userId.length; j++){
                    //            array[i++] = userId[j];
                    //        }
                    //        array[i++] = 2; //packetId length for each message
                    //        array[i++] = 'm' + k; //packetId
                    //        array[i++] = 1; //no of packets
                    //        array[i++] = 1; //sequence no
                    //        array[i++] = 2; //message type
                    //        array[i++] = 0; //timeout
                    //        array[i++] = 0; //timeout
                    //        array[i++] = 0; //latitude
                    //        array[i++] = 0; //latitude
                    //        array[i++] = 0; //latitude
                    //        array[i++] = 0; //latitude
                    //        array[i++] = 0; //longitude
                    //        array[i++] = 0; //longitude
                    //        array[i++] = 0; //longitude
                    //        array[i++] = 0; //longitude
                    //        array[i++] = 0; //message length
                    //        array[i++] = 5; //message length
                    //        array[i++] = 't'; //message
                    //        array[i++] = 't'; //message
                    //        array[i++] = 't'; //message
                    //        array[i++] = 't'; //message
                    //        array[i++] = 't'; //message
                    //        array[i++] = 0; //message date
                    //        array[i++] = 0; //message date
                    //        array[i++] = 0; //message date
                    //        array[i++] = 0; //message date
                    //        array[i++] = 0; //message date
                    //        array[i++] = 0; //message date
                    //        array[i++] = 0; //message date
                    //        array[i++] = 0; //message date
                    //    }
                    //    return array;
                    //},
                    //processOfflineMessagePacket: function (offlineMessagePacket) {
                    ///*     Packet Type + Number of Message + PacketID Length + Packet ID + ***[[Packet Type + Message Type + Timeout + Latitude + Longitude +
                    //***    User Identity Length + User Identity + Number of Packets + Sequence Number + Message Length + Message+Message Date + Packet ID Length +
                    //***    Packet ID]]
                    //***    [Note: ***[Packet DATA] means this packet will repeated Number of Message]
                    //***    if client received Friend Chat Offline Message(18) then it need to be send Offline Message Confirmation(17) message using received Packet ID.
                    //***
                    //***    Before Send any message to offline Server You need to send a Blank Message to ur friend with Message Type =0;
                    //*/
                    ///*------------------------------------------------------------------------------------------------------------------------------------------------*/
                    ///*     {this is the updated packet format}
                    //***    Packet Type + PacketID Length + Packet ID + Number of Message + ***[[Packet Type + User Identity + Packet ID Length + Packet ID +
                    //***    Number of Packets + Sequence Number+Message Type + Timeout + Latitude + Longitude + Message Length + Message+Message Date]]
                    //***
                    //***    [Note: ***[Packet DATA] means this packet will repeated Number of Message]
                    //***    if client received Friend Chat Offline Message(18) then it need to be send Offline Message Confirmation(17) message using received Packet ID.
                    //***
                    //***
                    //***    Before Send any message to offline Server You need to send a Blank Message to ur friend with Message Type =0;
                    //*/
                    //    var array = new Unit8Array(offlineMessagePacket);
                    //    var offlineMessageObject = {};
                    //    offlineMessageObject.packetData = [];
                    //    var headPoint = 0;
                    //
                    //    //packetType
                    //    offlineMessageObject.packetType = array[headPoint++];
                    //    //packetID
                    //    offlineMessageObject.packetIdLength = array[headPoint++];
                    //    for(var i = headPoint; i < headPoint +offlineMessageObject.packetIdLength; i ++){
                    //        offlineMessageObject.packetId += String.fromCharCode(array [ i ]);
                    //    }
                    //    headPoint = i;
                    //    // no of messages
                    //    offlineMessageObject.noOfMessages = array[headPoint++];
                    //    for(var j = 0; j < offlineMessageObject.noOfMessages; j++){
                    //        offlineMessageObject.packetData[j] = {};
                    //        //offlineMessageObject.packetData[j].userId = "";
                    //        offlineMessageObject.packetData[j].message = "";
                    //
                    //        offlineMessageObject.packetData[j].packetType = array[headPoint++];
                    //
                    //        //userId
                    //        offlineMessageObject.packetData[j].userId = this.byteToInteger(array,8,headPoint);
                    //        headPoint = headPoint + 8;
                    //        //packetId
                    //        offlineMessageObject.packetData[j].packetIdLength = array[headPoint++];
                    //        for(var k = headPoint; k < headPoint + offlineMessageObject.packetData[j].packetIdLength; k ++){
                    //            offlineMessageObject.packetData[j].packetId += String.fromCharCode(array [ k ]);
                    //        }
                    //        headPoint = k;
                    //        //offlineMessageObject.packetData[j].userIdLength = array[headPoint];
                    //        //for(var k = headPoint; k < headPoint +offlineMessageObject.packetData[j].userIdLength; k ++){
                    //        //    offlineMessageObject.packetData[j].userId += String.fromCharCode(array [ k ]);
                    //        //}
                    //        //headPoint = k;
                    //        offlineMessageObject.packetData[j].noOfPackets = array[headPoint++];
                    //        offlineMessageObject.packetData[j].sequenceNo = array[headPoint++];
                    //        offlineMessageObject.packetData[j].messageType = array[headPoint++];
                    //        offlineMessageObject.packetData[j].timeout = this.byteToInteger(array, 2, headPoint);//data,length, startpoint
                    //        headPoint += 2;
                    //        offlineMessageObject.packetData[j].latitude = this.byteToInteger(array, 4, headPoint);//data,length, startpoint
                    //        headPoint += 4;
                    //        offlineMessageObject.packetData[j].longitude = this.byteToInteger(array, 4, headPoint);//data,length, startpoint
                    //        headPoint += 4;
                    //        offlineMessageObject.packetData[j].messageLength = this.byteToInteger(array, 2, headPoint);//data,length, startpoint
                    //        headPoint +=2;
                    //        //message text
                    //        for(var k = headPoint; k < offlineMessageObject.packetData[j].messageLength; k ++){
                    //            offlineMessageObject.packetData[j].message += String.fromCharCode(array [ k ]);
                    //        }
                    //        headPoint = k;
                    //        //messageDate
                    //        offlineMessageObject.packetData[j].messageDate = this.byteToInteger(array, 8, headPoint);// data, length, startpoint
                    //        //for(var k = headPoint; k < headPoint + 8; k ++){
                    //        //    offlineMessageObject.packetData[j].messageDate += array [ k ]+"";
                    //        //}
                    //        headPoint += 8;
                    //
                    //    }// end of data packet messages for loop
                    //    return offlineMessageObject;
                    //},
                    ////Packet Type+User Identity+PacketID Length+Packet ID+Number of Packets+[***MSG Packet ID Length+MSG Packet ID]
                    //constructOfflineConfirmPacket2: function (offlineConfirmPacket2) {
                    //    var array = new Uint8Array( 16 + offlineConfirmPacket2.packetId.length);
                    //    var i = 0;
                    //
                    //    // ip
                    //    //var ipArray = this.integerToByte(this.ipToLong(registerJson.ip),8,0);
                    //    var ipArray = this.ipToByte(offlineConfirmPacket2.ip,0);
                    //    for(var j = 0; j< ipArray.length; j++){
                    //        array[i++] = ipArray[j];
                    //    }
                    //    // port
                    //    var portArray = this.integerToByte(offlineConfirmPacket2.port,2,i);
                    //    for(var j = 0; j< portArray.length; j++){
                    //        array[i++] = portArray[j];
                    //    }
                    //    //packet type
                    //    array[ i++ ] = offlineConfirmPacket2.packetType; // packetType is 58 for offline message getting confirmation
                    //
                    //    //userId
                    //    var userId = this.integerToByte(offlineConfirmPacket2.userId,8,i);
                    //    for(var j = 0; j< userId.length; j++){
                    //        array[i++] = userId[j];
                    //    }
                    //    //packetId
                    //    array[i++] = offlineConfirmPacket2.packetId.length;
                    //    for(var j = 0; j < offlineConfirmPacket2.packetId.length; j ++){
                    //        array[ i++ ] = offlineConfirmPacket2.packetId.charCodeAt(j);
                    //    }
                    //    //noOfPackets
                    //    array[i++] = offlineConfirmPacket2.noOfPackets; // this is the noOfMessage
                    //
                    //    //list of packetIDs
                    //    for(j=0; j<offlineConfirmPacket2.noOfPackets; j++){
                    //        array[i++] = offlineConfirmPacket2.packetIds[j].length;
                    //        for(var k = 0; k < offlineConfirmPacket2.packetIds[j].length; k ++){
                    //            array[ i++ ] = offlineConfirmPacket2.packetIds[j].charCodeAt(k);
                    //        }
                    //    }
                    //    return array;
                    //},
                    constructPacket: function (object, packetType, format) {

                        if( !object.ip ){
                            //RingLogger.log('ip not provided in packet', packetType);
                            RingLogger.print("ip not provided in packet",RingLogger.tags.CHAT);
                            return false;
                        }

                        if(object.message || object.message === ""){
                            var encodedMessage = object.message;
                            //RingLogger.log(encodedMessage.length+":::"+encodedMessage);
                            encodedMessage = encodedMessage.utf8Encode();
                            //RingLogger.log(encodedMessage.length+":::"+encodedMessage);
                            var encodedMessageLength = encodedMessage.length;
                        }

                        var noOfByte = 0 + 6;//for ip+port(4+2)
                        for(var x = 0; x < format.length; x++){
                            switch (format[x]){
                                case 1:                 //packetType(1)
                                    noOfByte += 1;
                                    break;
                                case 2:                 //userId(8)
                                    noOfByte += 8;
                                    break;
                                case 3:                 //friendId(8)
                                    noOfByte += 8;
                                    break;
                                case 4:                 //packetId length(1)
                                    noOfByte += 1;
                                    break;
                                case 5:                 //packetId(dynamic)
                                    noOfByte += object.packetId.length;
                                    break;
                                case 6:                 //platform(1)
                                    noOfByte += 1;
                                    break;
                                case 7:                 //chat binding port(4)
                                    noOfByte += 4;
                                    break;
                                case 8:                 //tagId(8)
                                    noOfByte += 8;
                                    break;
                                case 9:                 //online status(1)
                                    noOfByte += 1;
                                    break;
                                case 10:                 //userMood(1)probably 1 Byte
                                    noOfByte += 1;
                                    break;
                                case 11:                 //messageType(1)
                                    noOfByte += 1;
                                    break;
                                case 12:                 //timeout(2)
                                    noOfByte += 2;
                                    break;
                                case 13:                 //latitude(4)
                                    noOfByte += 4;
                                    break;
                                case 14:                 //longitude(4)
                                    noOfByte += 4;
                                    break;
                                case 15:                 //messageLength(2)
                                    noOfByte += 2;
                                    break;
                                case 16:                 //message(dynamic)
                                    //noOfByte += object.message.length;
                                    noOfByte += encodedMessageLength;
                                    break;
                                case 17:                 //messageDate(8)
                                    noOfByte += 8;
                                    break;
                                case 18:                 //noOfMessages(1)
                                    noOfByte += 1;
                                    var repeatFormat = format.slice(x);
                                    for(var z=0; z<object.noOfMessages; z++){
                                        for(var p=0; p<repeatFormat.length; p++) {
                                            switch (repeatFormat[p]) {

                                                case 4:                 //packetId length(1)
                                                    noOfByte += 1;
                                                    break;
                                                case 5:                 //packetId(dynamic)
                                                    //noOfByte += object.packetData[z].packetId.length;
                                                    noOfByte += object.packetIds[z].length;
                                                    break;
                                            }//end of switch(repeatFormat[z])
                                        }//end of for p
                                    }//end of for z
                                    break;
                                case 19:                 //fullNameLength(1)
                                    noOfByte += 1;
                                    break;
                                case 20:                 //fullName(dynamic)
                                    noOfByte += object.fullName.length;
                                    break;
                                case 21:                 //noOfPacket(1)
                                    noOfByte += 1;
                                    break;
                                case 22:                 //sequenceNo(1)
                                    noOfByte += 1;
                                    break;
                                case 23:                 //noOfMembers(2)
                                    noOfByte += 2;
                                    noOfByte += object.noOfMembers * 8;

                                    break;
                                case 24:                 //updateTime(8)
                                    noOfByte += 8;
                                    break;
                                case 26:                 //isSecretVisible(1)
                                    noOfByte++;
                                    break;
                                case 27:                 //messageStatus(1)
                                    noOfByte++;
                                    break;
                                case 28:                 //blockUnblockUpdateDate(8)
                                    noOfByte += 8;
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH :   // tagNameLength(1)
                                    noOfByte += 1;
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_NAME :                 //tagName(dynamic)
                                    noOfByte += object.tagName.length;
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH : //tagPictureUrlLength(1)
                                    noOfByte += 1;
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL : //tagPictureUrl(dynamic)
                                    noOfByte += object.tagPictureUrl.length;
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS :  //tagNoOfMembers(1)

                                    noOfByte += 1;
                                    var repeatFormat = format.slice(x + 1);
                                    for(z=0; z<object.tagMembers.length; z++){
                                        for(var p=0; p<repeatFormat.length; p++) {
                                            switch (repeatFormat[p]) {

                                                case CHAT_PACKET_ATTRIBUTE.USER_ID:                   //userId(8)
                                                    noOfByte += 8;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH :          //fullNameLength(1)
                                                    noOfByte += 1;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.FULL_NAME :                 //fullName(dynamic)
                                                    noOfByte += object.tagMembers[z].fullName.length;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE:
                                                    noOfByte += 1;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_ADDED_BY:
                                                    noOfByte += 8;
                                                    break;
                                           }
                                       }

                                    }
                                    break;

                            }//end switch(format[x])
                            //this is for if we get noOfMessage then we're ignoring the rest of the format values
                            // because we've already repeated them in noOfMessage case in switch case code block
                            // by slicing them into repeatFormat, so we don't need to address them twice.
                            if(format[x] == 18 || format[x] == 23 || format[y] == 37)
                                break;
                        }//end of for x
                        if(format[format.length-1] == 6 && (object.packetType == 58 || object.packetType == 59 || object.packetType == 19)){
                            noOfByte += 1;
                        }
                        /*------------------------------------------------------------------*/
                        //var packet = new Uint8Array(noOfByte);
                        var dViewPacket = new DataView(new ArrayBuffer(noOfByte));
                        var i=0;
                        // ip
                        //var ipArray = this.ipToByte(object.ip,0);
                        var ipArray = object.ip.split(".");
                        for(var j = 0; j< ipArray.length; j++){
                            //packet[i++] = ipArray[j];
                            dViewPacket.setUint8(i++,ipArray[j]);
                        }
                        // port
                        //var portArray = this.integerToByte(object.port,2,i);
                        //for(var j = 0; j< portArray.length; j++){
                        //    packet[i++] = portArray[j];
                        //}
                        dViewPacket.setUint16(i,object.port);
                        i += 2;
                        for(var y=0; y<format.length; y++){
                            switch (format[y]){
                                case 1:                 //packetType(1)
                                    //packet[ i++ ] = object.packetType;
                                    dViewPacket.setUint8(i++,object.packetType);
                                    break;
                                case 2:                 //userId(8)
                                    //var userId = this.integerToByte(object.userId,8,i);
                                    //for(var j = 0; j< userId.length; j++){
                                    //    packet[i++] = userId[j];
                                    //}
                                    dViewPacket.setUint64(i,object.userId);
                                    i += 8;
                                    break;
                                case 3:                 //friendId(8)
                                    //var friendId = this.integerToByte(object.friendId,8,i);
                                    //for(var j = 0; j< friendId.length; j++){
                                    //    packet[i++] = friendId[j];
                                    //}
                                    dViewPacket.setUint64(i,object.friendId);
                                    i += 8;
                                    break;
                                case 4:                 //packetId length(1)
                                    //packet[i++] = object.packetId.length;
                                    dViewPacket.setUint8(i++,object.packetId.length);
                                    break;
                                case 5:                 //packetId(dynamic)
                                    for(var j = 0; j < object.packetId.length; j ++){
                                        //packet[ i++ ] = object.packetId.charCodeAt(j);
                                        dViewPacket.setUint8(i++,object.packetId.charCodeAt(j));
                                    }
                                    break;
                                case 6:                 //platform(1)
                                    //packet[i++] = object.platform;
                                    dViewPacket.setUint8(i++,object.platform);
                                    break;
                                case 7:                 //chat binding port(4)
                                    dViewPacket.setUint32(i,object.port);
                                    i += 4;
                                    //var port = this.integerToByte(object.port,4,i);
                                    //for(var j = 0; j< port.length; j++){
                                    //    packet[i++] = port[j];
                                    //}
                                    break;
                                case 8:                 //tagId(8)
                                    //var tagId = this.integerToByte(object.tagId,8,i);
                                    //for(var j = 0; j< tagId.length; j++){
                                    //    packet[i++] = tagId[j];
                                    //}
                                    dViewPacket.setUint64(i,object.tagId);
                                    i += 8;
                                    break;
                                case 9:                 //online status(1)
                                    //packet[i++] = object.onlineStatus;
                                    dViewPacket.setUint8(i++,object.onlineStatus);
                                    break;
                                case 10:                 //userMood(1)probably 1 Byte
                                    //packet[i++] = object.userMood;
                                    dViewPacket.setUint8(i++,object.userMood);
                                    break;
                                case 11:                 //messageType(1)
                                    //packet[i++] = object.messageType;
                                    dViewPacket.setUint8(i++,object.messageType);
                                    break;
                                case 12:                 //timeout(2)
                                    //var timeout = this.integerToByte(object.timeout,2,i);
                                    //for( var j = 0; j<2; j++){
                                    //    packet[i++] = timeout[j];
                                    //}
                                    dViewPacket.setUint16(i,object.timeout);
                                    i += 2;
                                    break;
                                case 13:                 //latitude(4)
                                    //var latitude = this.integerToByte(object.latitude,4,i);
                                    //for( var j = 0; j<4; j++){
                                    //    packet[i++] = latitude[j];
                                    //}
                                    dViewPacket.setUint32(i,object.latitude);
                                    i += 4;
                                    break;
                                case 14:                 //longitude(4)
                                    //var longitude = this.integerToByte(object.longitude,4,i);
                                    //for( var j = 0; j<4; j++){
                                    //    packet[i++] = longitude[j];
                                    //}
                                    dViewPacket.setUint32(i,object.longitude);
                                    i += 4;
                                    break;
                                case 15:                 //messageLength(2)
                                    //var messageLength = this.integerToByte(object.message.length,2,i);
                                    //for( var j = 0; j<2; j++){
                                    //    packet[i++] = messageLength[j];
                                    //}
                                    dViewPacket.setUint16(i,encodedMessageLength);
                                    i += 2;
                                    break;
                                case 16:                 //message(dynamic)
                                    for(var j = 0; j < encodedMessageLength; j ++){
                                        //packet[ i++ ] = object.message.charCodeAt(j);
                                        dViewPacket.setUint8(i++,encodedMessage.charCodeAt(j));
                                    }
                                    break;
                                case 17:                 //messageDate(8)
                                    //var messageDate = this.integerToByte(object.messageDate,8,i);
                                    //for(var j = 0; j< messageDate.length; j++){
                                    //    packet[i++] = messageDate[j];
                                    //}
                                    dViewPacket.setUint64(i,object.messageDate);
                                    i += 8;
                                    break;
                                case 18:                 //noOfMessages(1)
                                    //packet[i++] = object.noOfMessages;
                                    dViewPacket.setUint8(i++,object.noOfMessages);
                                    var repeatFormat = format.slice(y);
                                    for(var z=0; z<object.noOfMessages; z++){
                                        for(var p=0; p<repeatFormat.length; p++) {
                                            switch (repeatFormat[p]) {

                                                case 4:                 //packetId length(1)
                                                    //packet[i++] = object.packetData[z].packetId.length;
                                                    //dViewPacket.setUint8(i++,object.packetData[z].packetId.length);
                                                    dViewPacket.setUint8(i++,object.packetIds[z].length);
                                                    break;
                                                case 5:                 //packetId(dynamic)
                                                    //for(var j = 0; j < object.packetData[z].packetId.length; j ++){
                                                    for(var j = 0; j < object.packetIds[z].length; j ++){
                                                        //packet[ i++ ] = object.packetData[z].packetId.charCodeAt(j);
                                                        //dViewPacket.setUint8(i++,object.packetData[z].packetId.charCodeAt(j));
                                                        dViewPacket.setUint8(i++,object.packetIds[z].charCodeAt(j));
                                                    }
                                                    break;
                                            }//end of switch(repeatFormat[z])
                                        }//end of for p
                                    }//end of for z
                                    break;
                                case 19:                 //fullNameLength(1)
                                    //packet[i++] = object.fullName.length;
                                    dViewPacket.setUint8(i++,object.fullName.length);
                                    break;
                                case 20:                 //fullName(dynamic)
                                    for(var j = 0; j < object.fullName.length; j ++){
                                        //packet[ i++ ] = object.fullName.charCodeAt(j);
                                        dViewPacket.setUint8(i++,object.fullName.charCodeAt(j));
                                    }
                                    break;
                                case 21:                 //noOfPacket(1)
                                    //packet[i++] = object.noOfPackets;
                                    dViewPacket.setUint8(i++,object.noOfPackets);
                                    break;
                                case 22:                 //sequenceNo(1)
                                    //packet[i++] = object.sequenceNo;
                                    dViewPacket.setUint8(i++,object.sequenceNo);
                                    break;
                                case 23:                 //noOfMembers(2)
                                    //var noOfMembers = this.integerToByte(object.noOfMembers,2,i);
                                    //for( var j = 0; j<2; j++){
                                    //    packet[i++] = noOfMembers[j];
                                    //}
                                    dViewPacket.setUint16(i,object.noOfMembers);
                                    i += 2;
                                    for(var z=0; z<object.noOfMembers; z++){
                                        //var userId = this.integerToByte(object.userIds[z],8,i);
                                        //for(var p = 0; p< userId.length; p++){
                                        //    packet[i++] = userId[p];
                                        //}
                                        dViewPacket.setUint64(i,object.userIds[z]);
                                        i+= 8;
                                    }
                                    break;
                                case 24:                 //updateTime(8)
                                    dViewPacket.setUint64(i,object.updateTime);
                                    i += 8;
                                    break;
                                case 26:                 //isSecretVisible(1)
                                    dViewPacket.setUint8(i++,object.isSecretVisible);
                                    break;
                                case 27:                 //messageStatus(1)
                                    dViewPacket.setUint8(i++,object.messageStatus);
                                    break;
                                case 28:                 //blockUnblockUpdateDate(8)
                                    dViewPacket.setUint64(i,object.blockUnblockUpdateDate);
                                    i += 8;
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH :   // tagNameLength(1)
                                    dViewPacket.setUint8(i++,object.tagName.length);
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_NAME :                 //tagName(dynamic)
                                    for(var j = 0; j < object.tagName.length; j ++){
                                        dViewPacket.setUint8(i++,object.tagName.charCodeAt(j));
                                    }
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH : //tagPictureUrlLength(1)
                                    dViewPacket.setUint8(i++,object.tagPictureUrl.length);
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL : //tagPictureUrl(dynamic)
                                    for(var j = 0; j < object.tagPictureUrl.length; j ++){
                                        dViewPacket.setUint8(i++,object.tagPictureUrl.charCodeAt(j));
                                    }
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS :  //tagNoOfMembers(2)

                                    dViewPacket.setUint8(i, object.tagMembers.length);
                                    i += 1;

                                    var repeatFormat = format.slice(x + 1);
                                    for(z=0; z<object.tagMembers.length; z++){
                                        for(var p=0; p<repeatFormat.length; p++) {
                                            switch (repeatFormat[p]) {

                                                case CHAT_PACKET_ATTRIBUTE.USER_ID:                   //userId(8)
                                                    dViewPacket.setUint64(i,object.tagMembers[z].userId);
                                                    i += 8;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH :          //fullNameLength(1)
                                                    dViewPacket.setUint8(i, object.tagMembers[z].fullName.length);
                                                    i += 1;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.FULL_NAME :                 //fullName(dynamic)
                                                    for(var j = 0; j < object.tagMembers[z].fullName.length; j ++){
                                                        dViewPacket.setUint8(i, object.tagMembers[z].fullName.charCodeAt(j));
                                                        i += 1;
                                                    }
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE:
                                                    dViewPacket.setUint8(i, object.tagMembers[z].status);
                                                    i += 1;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_ADDED_BY:
                                                    dViewPacket.setUint64(i, object.tagMembers[z].addedBy);
                                                    i += 8;
                                                    break;
                                           }
                                       }

                                    }
                                    break;

                            }//end of switch(format[y])
                            //this is for if we get noOfMessage then we're ignoring the rest of the format values
                            // because we've already repeated them in noOfMessage case in switch case code block
                            // by slicing them into repeatFormat, so we don't need to address them twice.
                            if(format[y] == 18 || format[y] == 23 || format[y] == 37)
                                break;
                        }//end of for y
                        if(format[format.length-1] == 6 && (object.packetType == 58 || object.packetType == 59 || object.packetType == 19)){
                            dViewPacket.setUint8(i++,object.platform);
                        }
                        return dViewPacket;
                    },
                    parsePacket: function (packet, packetType, format) {
                        //var object = {};
                        var dViewObject = {};
                        //var array = new Uint8Array(packet);
                        var dView = new DataView(packet);
                        var i = 0;
                        for(var y=0; y<format.length; y++){
                            switch (format[y]){
                                case 1:                 //packetType(1)
                                    //object.packetType = array[ i++ ];
                                    dViewObject.packetType = dView.getIntByByte(i++,1);
                                    break;
                                case 2:                 //userId(8)
                                    //object.userId = this.byteToInteger(array,8,i);
                                    dViewObject.userId = dView.getIntByByte(i,8);
                                    i += 8;
                                    break;
                                case 3:                 //friendId(8)
                                    //object.friendId = this.byteToInteger(array,8,i);
                                    dViewObject.friendId = dView.getIntByByte(i,8);
                                    i += 8;
                                    break;
                                case 4:                 //packetId length(1)
                                    //object.packetIdLength = array[i++];
                                    dViewObject.packetIdLength = dView.getIntByByte(i++,1);
                                    break;
                                case 5:                 //packetId(dynamic)
                                    //object.packetId = '';
                                    dViewObject.packetId = '';
                                    dViewObject.packetId = dView.getString(i,dViewObject.packetIdLength);
                                    //for(var j = i; j < i+object.packetIdLength; j ++){
                                    //    object.packetId += String.fromCharCode(array [ j ]);
                                    //}
                                    i += dViewObject.packetIdLength;
                                    break;
                                case 6:                 //platform(1)
                                    //object.platform = array[i++];
                                    dViewObject.platform = dView.getIntByByte(i++,1);
                                    break;
                                case 7:                 //chat binding port(4)
                                    //object.port = this.byteToInteger(array,4,i);
                                    dViewObject.port = dView.getIntByByte(i,4);
                                    i +=  4;
                                    break;
                                case 8:                 //tagId(8)
                                    //object.tagId = this.byteToInteger(array,8,i);
                                    dViewObject.tagId = dView.getIntByByte(i,8);
                                    i += 8;
                                    break;
                                case 9:                 //online status(1)
                                    //object.onlineStatus = array[i++];
                                    dViewObject.onlineStatus = dView.getIntByByte(i++,1);
                                    break;
                                case 10:                 //userMood(1)probably 1 Byte
                                    //object.userMood = array[i++];
                                    dViewObject.userMood = dView.getIntByByte(i++,1);
                                    break;
                                case 11:                 //messageType(1)
                                    //object.messageType = array[i++];
                                    dViewObject.messageType = dView.getIntByByte(i++,1);
                                    break;
                                case 12:                 //timeout(2)
                                    //object.timeout = this.byteToInteger(array,2,i);
                                    dViewObject.timeout = dView.getIntByByte(i,2);
                                    i +=  2;
                                    break;
                                case 13:                 //latitude(4)
                                    //object.latitude = this.byteToInteger(array,4,i);
                                    dViewObject.latitude = dView.getIntByByte(i,4,true);
                                    i +=  4;
                                    break;
                                case 14:                 //longitude(4)
                                    //object.longitude = this.byteToInteger(array,4,i);
                                    dViewObject.longitude = dView.getIntByByte(i,4,true);
                                    i +=  4;
                                    break;
                                case 15:                 //messageLength(2)
                                    //object.messageLength = this.byteToInteger(array,2,i);
                                    dViewObject.messageLength = dView.getIntByByte(i,2);
                                    i +=  2;
                                    break;
                                case 16:                 //message(dynamic)
                                    //object.message = '';
                                    dViewObject.message = '';
                                    dViewObject.message = dView.getString(i,dViewObject.messageLength);
                                    //for(var j = i; j < i+object.messageLength; j ++){
                                    //    object.message += String.fromCharCode(array [ j ]);
                                    //}
                                    i += dViewObject.messageLength;
                                    break;
                                case 17:                 //messageDate(8)
                                    //object.messageDate = this.byteToInteger(array,8,i);
                                    dViewObject.messageDate = dView.getIntByByte(i,8);
                                    //this *1000 won't require at packet parsing stage as we're doing it in pushMessage function
                                    //object.messageDate *= 1000; // this was sent in second from sender end, now need to * with 1000 to make it milisecond
                                    i += 8;
                                    break;
                                case 18:                 //noOfMessages(1)
                                    //object.noOfMessages = array[i++];
                                    dViewObject.noOfMessages = dView.getIntByByte(i++,1);
                                    var repeatFormat = format.slice(y);
                                    dViewObject.packetData = [];
                                    //for(var z=0; z<object.noOfMessages; z++){
                                    for(var z=0; z<dViewObject.noOfMessages; z++){
                                        //object.packetData[z] = {};
                                        dViewObject.packetData[z] = {};
                                        for(var p=0; p<repeatFormat.length; p++) {
                                            switch (repeatFormat[p]) {
                                                case 1:                 //packetType(1)
                                                    //object.packetData[z].packetType = array[i++];
                                                    dViewObject.packetData[z].packetType = dView.getIntByByte(i++,1);
                                                    break;
                                                case 2:                 //userId(8)
                                                    //object.packetData[z].userId = this.byteToInteger(array, 8, i);
                                                    dViewObject.packetData[z].userId = dView.getIntByByte(i,8);
                                                    i += 8;
                                                    break;
                                                case 3:                 //friendId(8)
                                                    //object.packetData[z].friendId = this.byteToInteger(array, 8, i);
                                                    dViewObject.packetData[z].friendId = dView.getIntByByte(i,8);
                                                    i += 8;
                                                    break;
                                                case 4:                 //packetId length(1)
                                                    //object.packetData[z].packetIdLength = array[i++];
                                                    dViewObject.packetData[z].packetIdLength = dView.getIntByByte(i++,1);
                                                    break;
                                                case 5:                 //packetId(dynamic)
                                                    //object.packetData[z].packetId = '';
                                                    dViewObject.packetData[z].packetId = '';
                                                    dViewObject.packetData[z].packetId = dView.getString(i,dViewObject.packetData[z].packetIdLength);
                                                    //for (var j = i; j < i + object.packetData[z].packetIdLength; j++) {
                                                    //    object.packetData[z].packetId += String.fromCharCode(array [j]);
                                                    //}
                                                    i += dViewObject.packetData[z].packetIdLength;
                                                    break;
                                                case 8:                 //tagId(8)
                                                    //object.packetData[z].tagId = this.byteToInteger(array,8,i);
                                                    dViewObject.packetData[z].tagId = dView.getIntByByte(i,8);
                                                    i += 8;
                                                    break;
                                                case 11:                 //messageType(1)
                                                    //object.packetData[z].messageType = array[i++];
                                                    dViewObject.packetData[z].messageType = dView.getIntByByte(i++,1);
                                                    break;
                                                case 12:                 //timeout(2)
                                                    //object.packetData[z].timeout = this.byteToInteger(array,2,i);
                                                    dViewObject.packetData[z].timeout = dView.getIntByByte(i,2);
                                                    i +=  2;
                                                    break;
                                                case 13:                 //latitude(4)
                                                    //object.packetData[z].latitude = this.byteToInteger(array,4,i);
                                                    dViewObject.packetData[z].latitude = dView.getIntByByte(i,4);
                                                    i +=  4;
                                                    break;
                                                case 14:                 //longitude(4)
                                                    //object.packetData[z].longitude = this.byteToInteger(array,4,i);
                                                    dViewObject.packetData[z].longitude = dView.getIntByByte(i,4);
                                                    i +=  4;
                                                    break;
                                                case 15:                 //messageLength(2)
                                                    //object.packetData[z].messageLength = this.byteToInteger(array,2,i);
                                                    dViewObject.packetData[z].messageLength = dView.getIntByByte(i,2);
                                                    i +=  2;
                                                    break;
                                                case 16:                 //message(dynamic)
                                                    //object.packetData[z].message = '';
                                                    dViewObject.packetData[z].message = '';
                                                    dViewObject.packetData[z].message = dView.getString(i,dViewObject.packetData[z].messageLength);
                                                    //for(var j = i; j < i+object.packetData[z].messageLength; j ++){
                                                    //    object.packetData[z].message += String.fromCharCode(array [ j ]);
                                                    //}
                                                    i += dViewObject.packetData[z].messageLength;
                                                    break;
                                                case 17:                 //messageDate(8)
                                                    //object.packetData[z].messageDate = this.byteToInteger(array,8,i);
                                                    dViewObject.packetData[z].messageDate = dView.getIntByByte(i,8);
                                                    i += 8;
                                                    break;
                                                case 19:                 //fullNameLength(1)
                                                    //object.packetData[z].fullNameLength = array[i++];
                                                    dViewObject.packetData[z].fullNameLength = dView.getIntByByte(i++,1);
                                                    break;
                                                case 20:                 //fullName(dynamic)
                                                    //object.packetData[z].fullName = '';
                                                    dViewObject.packetData[z].fullName = '';
                                                    dViewObject.packetData[z].fullName = dView.getString(i,dViewObject.packetData[z].fullNameLength);
                                                    //for(var j = i; j < i+object.packetData[z].fullNameLength; j ++){
                                                    //    object.packetData[z].fullName += String.fromCharCode(array [ j ]);
                                                    //}
                                                    i += dViewObject.packetData[z].fullNameLength;
                                                    break;
                                                case 21:                 //noOfPacket(1)
                                                    //object.packetData[z].noOfPackets = array[i++];
                                                    dViewObject.packetData[z].noOfPackets = dView.getIntByByte(i++,1);
                                                    break;
                                                case 22:                 //sequenceNo(1)
                                                    //object.packetData[z].sequenceNo = array[i++];
                                                    dViewObject.packetData[z].sequenceNo = dView.getIntByByte(i++,1);
                                                    break;
                                                case 24:                 //updateTime(8)
                                                    dViewObject.packetData[z].updateTime = dView.getIntByByte(i,8);
                                                    i += 8;
                                                    break;
                                                case 25:                 //updateTime(8)
                                                    dViewObject.packetData[z].serverDate = dView.getIntByByte(i,8);
                                                    i += 8;
                                                    break;

                                                case 26:                 //isSecretVisible(1)
                                                    dViewObject.packetData[z].isSecretVisible = dView.getIntByByte(i++,1);
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH :   // tagNameLength(1)
                                                    dViewObject.packetData[z].tagNameLength = dView.getIntByByte(i++,1);
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.TAG_NAME :                 //tagName(dynamic)
                                                    dViewObject.packetData[z].tagName = '';
                                                    dViewObject.packetData[z].tagName = dView.getString(i, dViewObject.packetData[z].tagNameLength);
                                                    i += dViewObject.packetData[z].tagNameLength;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH : //tagPictureUrlLength(1)
                                                    dViewObject.packetData[z].tagPictureUrlLength = dView.getIntByByte(i++,1);
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL : //tagPictureUrl(dynamic)
                                                    if(dViewObject.packetData[z].tagPictureUrlLength > 0){
                                                        dViewObject.packetData[z].tagPictureUrl = dView.getString(i, dViewObject.packetData[z].tagPictureUrlLength);
                                                        i += dViewObject.packetData[z].tagPictureUrlLength;
                                                    }else{
                                                        dViewObject.packetData[z].tagPictureUrl = '';
                                                    }

                                                    break;

                                            }//end of switch(repeatFormat[z])
                                        }//end of for p
                                    }//end of for z
                                    break;
                                case 19:                 //fullNameLength(1)
                                    //object.fullNameLength = array[i++];
                                    dViewObject.fullNameLength = dView.getIntByByte(i++,1);
                                    break;
                                case 20:                 //fullName(dynamic)
                                    //object.fullName = '';
                                    dViewObject.fullName = '';

                                    if( dViewObject.fullNameLength != 0){
                                        dViewObject.fullName = dView.getString(i,dViewObject.fullNameLength);
                                        //for(var j = i; j < i+object.fullNameLength; j ++){
                                        //    object.fullName += String.fromCharCode(array [ j ]);
                                        //}
                                        i += dViewObject.fullNameLength;
                                    }
                                    break;
                                case 21:                 //noOfPacket(1)
                                    //object.noOfPackets = array[i++];
                                    dViewObject.noOfPackets = dView.getIntByByte(i++,1);
                                    break;
                                case 22:                 //sequenceNo(1)
                                    //object.sequenceNo = array[i++];
                                    dViewObject.sequenceNo = dView.getIntByByte(i++,1);
                                    break;
                                case 23:                 //noOfMembers(2)
                                    //object.noOfMembers = this.byteToInteger(array,2,i);
                                    dViewObject.noOfMembers = dView.getIntByByte(i,2);
                                    i += 2;
                                    //object.userIds = [];
                                    dViewObject.userIds = [];
                                    //for(z=0; z<object.noOfMembers; z++){
                                    for(z=0; z<dViewObject.noOfMembers; z++){
                                        //object.userIds[z] = this.byteToInteger(array, 8, i);
                                        dViewObject.userIds[z] = dView.getIntByByte(i,8);
                                        i += 8;
                                    }
                                    break;
                                case 24:                 //updateTime(1)
                                    dViewObject.updateTime = dView.getIntByByte(i,8);
                                    i += 8;
                                    break;
                                case 25:                 //serverDate(8)
                                    dViewObject.serverDate = dView.getIntByByte(i,8);
                                    i += 8;
                                    break;
                                case 26:                 //isSecretVisible(1)
                                    dViewObject.isSecretVisible = dView.getIntByByte(i++,1);

                                    break;
                                case 27:                 //messageStatus(1)
                                    dViewObject.messageStatus = dView.getIntByByte(i++,1);
                                    break;
                                case 28:                 //blockUnblockUpdateDate(8)
                                    dViewObject.blockUnblockUpdateDate = dView.getIntByByte(i,8);
                                    i += 8;
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS :  //tagNoOfMembers(1)

                                    var noOfTagMembers = dView.getIntByByte(i,1);
                                    i += 1;

                                    var repeatFormat = format.slice(y + 1);
                                    dViewObject.tagMembers = [];

                                    for(z=0; z< noOfTagMembers; z++){
                                        dViewObject.tagMembers[z] = {};

                                        for(var p=0; p<repeatFormat.length; p++) {
                                            switch (repeatFormat[p]) {

                                                case CHAT_PACKET_ATTRIBUTE.USER_ID:                   //userId(8)
                                                    //object.tagMembers[z].userId = this.byteToInteger(array, 8, i);
                                                    dViewObject.tagMembers[z].userId = dView.getIntByByte(i, 8);
                                                    i += 8;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH :          //fullNameLength(1)
                                                    dViewObject.tagMembers[z].fullNameLength = dView.getIntByByte(i, 1);
                                                    i += 1;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.FULL_NAME :                 //fullName(dynamic)
                                                    dViewObject.tagMembers[z].fullName = '';
                                                    dViewObject.tagMembers[z].fullName = dView.getString(i, dViewObject.tagMembers[z].fullNameLength);

                                                    i += dViewObject.tagMembers[z].fullNameLength;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE:
                                                    dViewObject.tagMembers[z].status = dView.getIntByByte(i,1);
                                                    i += 1;
                                                    break;

                                                case CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_ADDED_BY:
                                                    dViewObject.tagMembers[z].addedBy = dView.getIntByByte(i,8);
                                                    i += 8;
                                                    break;
                                           }
                                        }

                                    }
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH :   // tagNameLength(1)
                                    dViewObject.tagNameLength = dView.getIntByByte(i++,1);
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_NAME :                 //tagName(dynamic)
                                    dViewObject.tagName = '';
                                    dViewObject.tagName = dView.getString(i, dViewObject.tagNameLength);
                                    i += dViewObject.tagNameLength;
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH : //tagPictureUrlLength(1)
                                    dViewObject.tagPictureUrlLength = dView.getIntByByte(i++,1);
                                    break;

                                case CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL : //tagPictureUrl(dynamic)
                                    if(dViewObject.tagPictureUrlLength > 0){
                                        dViewObject.tagPictureUrl = dView.getString(i, dViewObject.tagPictureUrlLength);
                                        i += dViewObject.tagPictureUrlLength;
                                    }else{
                                        dViewObject.tagPictureUrl = '';
                                    }

                                    break;

                            }//end of switch(format[y])
                            //this is for if we get noOfMessage then we're ignoring the rest of the format values
                            // because we've already repeated them in noOfMessage case in switch case code block
                            // by slicing them into repeatFormat, so we don't need to address them twice.
                            if(format[y] == 18 || format[y] == 23 || format[y] == 37)
                                break;
                        }//end of for y
                        //return object;
                        return dViewObject;
                    },
                    buildPacketID: function () {
                        return "ring" + Math.floor(Math.random() * (new Date()).getTime());
                        //return "ring" +$window.Math.floor($window.Math.random() * (new $window.Date()).getTime())
                    },
                    getIndPckData: function (data, startPoint, length) {
                        var value='';
                        for(var j = startPoint; j < (length + startPoint); j ++){
                            value += String.fromCharCode(data[j]);
                        }
                        return value;
                    }

                }
            }
        ]);
})();

(function() {
    'use strict';
    angular
        .module('ringid.chat')
        .service('ChatPacketSenderService', ChatPacketSenderService);

    ChatPacketSenderService.$inject = ['CHAT_PACKET_FORMAT',
        'Auth', 'utilsFactory',
         'tagChatApiService', 'tagChatFactory',
        'CHAT_GENERAL_CONSTANTS', 'TAG_CHAT_PACKET_TYPE', 'FRIEND_CHAT_PACKET_TYPE', 'OFFLINE_PACKET_TYPE',
        'chatPacketResender', 'ChatApiService', 'PLATFORM', "chatUtilsFactory", "CHAT_STATES", "$q",
        "chatHistoryFactory", "chatTabSync"

    ];
    function ChatPacketSenderService (CHAT_PACKET_FORMAT,
                               Auth, utilsFactory,
                               tagChatApiService, tagChatFactory,
                               CHAT_GENERAL_CONSTANTS, TAG_CHAT_PACKET_TYPE, FRIEND_CHAT_PACKET_TYPE, OFFLINE_PACKET_TYPE,
                               chatPacketResender, ChatApiService, PLATFORM, chatUtilsFactory, CHAT_STATES, $q, chatHistoryFactory, chatTabSync

    ) {

        var self = this;
        var ChatPacketSender = chatPacketResender.ChatPacketSender;
        var getUUIDPacketId = tagChatFactory.getUUIDPacketId;


        var processMsgForLinkShare = function(msgObj, ogData){
            if(!!ogData && !!ogData.url){
                var plainText = msgObj.message;

                var jsonMessage = {
                    u : ogData.url,
                    d: ogData.description,
                    t: ogData.title,
                    i: ogData.image,
                    m : plainText
                };

                msgObj.message = angular.toJson(jsonMessage);

            }
            return msgObj;
        };

        var processMsgForLocationShare = function(msgObj, locationData){
            if( !!locationData && !!locationData.lat){

                msgObj.la = locationData.lat; // PacketDataParse.Float32ToInt();
                msgObj.lo = locationData.lng; //PacketDataParse.Float32ToInt();
                msgObj.loc = locationData.description;

                var jsonMessage = {
                    lo : msgObj.lo,
                    la : msgObj.la,
                    loc : msgObj.loc
                };

                msgObj.message = angular.toJson(jsonMessage);

            }
            return msgObj;
        };

        var processMsgForMedia = function(msgObj, mediaData){
            if( !!mediaData && !!mediaData.url){

                var jsonMessage = {
                    u : mediaData.url,
                    c : mediaData.caption,
                    w : mediaData.width,
                    h : mediaData.height
                };

                msgObj.message = angular.toJson(jsonMessage);

                msgObj.mediaUrl = mediaData.url;

                msgObj.plainText = mediaData.caption;

            }
            return msgObj;
        };

        var pushToTemporaryArray = function(box, message, messageData){
            message.fromTemporary = true;
            message.messageData = messageData;
            box.tempMessageArray.push(message);
        };

        var getMessageObject = function(box, message, messageType, messageData){
            var msgObj, keyOrPacketId,
                isEditedMessage = false,
                packetType, brokenPacketType,
                currentUser = Auth.currentUser(),
                currentUserId = Auth.currentUser().getKey(),
                messageDate = chatUtilsFactory.getChatServerCurrentTime(),
                isTagChat = box.isTagChat,
                ip = box.getIp(),
                port = box.getPort();


            if(box.editMessageKey){
                keyOrPacketId = box.editMessageKey;
                box.editMessageKey = undefined;
                messageDate = box.editMessageDate;
                box.editMessageDate = undefined;

                isEditedMessage = true;

                if( !!isTagChat ){

                    packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_EDIT;
                    brokenPacketType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG_EDIT;
                }else{

                    packetType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG_EDIT;
                    brokenPacketType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG_EDIT;
                }


            }else{
                keyOrPacketId = getUUIDPacketId(messageDate);

                if( !!isTagChat ){

                    packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG;
                    brokenPacketType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG;
                }else{

                    packetType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG;
                    brokenPacketType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG;
                }

            }

            msgObj = {
                isEdit              : isEditedMessage,
                tag_chat            : false,
                ip                  : ip,
                port                : port,
                packetType          : packetType,
                brokenPacketType    : brokenPacketType,
                fullName            : currentUser.getName(),
                userId              : currentUserId,                                     // used to construct packetData for sending
                messageType         : messageType,                                      // 2 for plain text message
                messageDate         : messageDate,                                      //in second instead of millisecond, need to * with 1000 in the receiver end
                message             : message,                                          // used to construct packetData for sending
                key                 : keyOrPacketId,                                    // added "ring" later
                packetId            : keyOrPacketId,                                    // used to construct packetData for sending
                isSecretVisible     : box.isSecretVisible ? 1 : 0,
                timeout             : 0,
                platform            : PLATFORM.WEB
            };

            if( isTagChat ){//for tagChat
                var tagId = box.getKey();

                var tagObject = tagChatFactory.getOrCreateTag( tagId );

                if( !ip && !!tagObject.getChatIp()){
                    ip = tagObject.getChatIp();
                    box.setIp(ip);
                }
                if( !box.getPort() && !!tagObject.getChatBindingPort()){
                    port = tagObject.getChatBindingPort();
                    box.setPort(port);
                    box.lastCommunicationTime  = tagObject.getLastCommunicationTime();
                }

                msgObj.tag_chat = true;
                msgObj.tagId = tagId;


            }else{ //for individual chat
                msgObj.friendId         = box.getUser().getKey();
                if(box.secretChat){
                    msgObj.timeout = box.timeout;
                }else{
                    msgObj.timeout = 0;
                }
            }

            return msgObj;

        };

        var messagePreSendProcess = function(msgObj, messageData){

            if( utilsFactory.hasEmoticon(msgObj.message) ){
                msgObj.messageType = 3;
            }

            switch (msgObj.messageType){
                case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.LOCATION_SHARE:
                    processMsgForLocationShare(msgObj, messageData.locationData);
                    break;
                case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.LINK_SHARE:
                    processMsgForLinkShare(msgObj, messageData.ogData);
                    break;
                case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.IMAGE:
                case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.CAMERA_IMAGE:
                case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.VIDEO:
                    processMsgForMedia(msgObj, messageData.mediaData);
                    break;
            }

        };

        var utf8EncodeMessageObject = function(msgObj){
            msgObj.message = msgObj.message || msgObj.text;
            msgObj.message = msgObj.message.utf8Encode();
        };

        var _doAfterTagSendFailure = function(box, msgObj, messageData){

            pushToTemporaryArray(box, msgObj, messageData);

            utilsFactory.triggerCustomEvent('RE_REGISTER_TAG',{ tagId : box.getKey() });


            RingLogger.alert('Unable to send tag msg ', msgObj, RingLogger.tags.TAG_CHAT);
        };


        var getFriendOnlineStatusMultipleTime = function(friendId){

            var func = ChatApiService.getFriendOnlineStatus;
            var args = [friendId];

            return utilsFactory.requestMultipleTime(func, args);
        };

        var getF2FIpPortMultipleTime = function(friendId){
            ChatApiService.requestForIp(friendId);
        };

        var _doAfterChatMsgSendFailure = function (box, msgObj, messageData) {

            var boxMessageObject = box.getMessage(msgObj.packetId);
            var currentState = msgObj.SENDING_STATE;

            if(boxMessageObject.status == 0 || boxMessageObject.status == 'Pending'){
                getFriendOnlineStatusMultipleTime(msgObj.userId).then(function(response){

                    RingLogger.debug('SEND MESSAGE USER PRESENCE ', response, RingLogger.tags.CHAT_SEND_MESSAGE);

                    if(!!response.sucs && response.psnc == CHAT_GENERAL_CONSTANTS.USER_PRESENCE.ONLINE){//online

                        msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.SECOND_ONLINE;
                        doSendMessage(box, msgObj, messageData);


                    }else{ //sucs false

                        msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE;
                        doSendMessage(box, msgObj, messageData, true);

                        RingLogger.debug("CHAT MSG SENDING FAILED, PRESENCE STATUS SUCS FALSE", RingLogger.tags.CHAT);
                    }

                    logSendMessageStateChange(msgObj, currentState);


                }, function(response){


                    msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REFRESH;

                    pushToTemporaryArray(box, msgObj, messageData);
                    ChatApiService.requestForIp(msgObj.friendId);

                    logSendMessageStateChange(msgObj, currentState);

                });
            }

        };

        var doUpdateOfflineIpPort = function(){
            var defer = $q.defer();

            ChatApiService.getOfflineIpPort().then(function(response){

                if(!!response.sucs){
                    Auth.loginData.oIP = response.oIP;
                    Auth.loginData.oPrt = response.oPrt;

                    Auth.updateLocalStorageLoginData(Auth.loginData);
                    RingLogger.debug('OFFLINE_IP_PORT_UPDATED', response, RingLogger.tags.CHAT_SEND_MESSAGE);

                    defer.resolve(response);

                }else{

                    RingLogger.debug('OFFLINE_IP_PORT_UPDATE_FAILED', response, RingLogger.tags.CHAT_SEND_MESSAGE);
                    defer.reject(response);
                }



            }, function(response){

                RingLogger.debug('OFFLINE_IP_PORT_UPDATE_FAILED', response, RingLogger.tags.CHAT_SEND_MESSAGE);
                defer.reject(response);
            });

            return defer.promise;

        };

        var logSendMessageStateChange = function(msgObj, previousState){
            if( msgObj.SENDING_STATE == previousState){
                return;
            }

            if( !angular.isDefined(previousState)){

                RingLogger.debug(chatUtilsFactory.getChatStateName( msgObj.SENDING_STATE ) ,msgObj.message , RingLogger.tags.CHAT_SEND_MESSAGE);

            }else{

                RingLogger.debug(chatUtilsFactory.getChatStateName( previousState), ' -> ' , chatUtilsFactory.getChatStateName( msgObj.SENDING_STATE ) ,msgObj.message , RingLogger.tags.CHAT_SEND_MESSAGE);
            }

        };

        var updateMessageObjectIpPort = function( box, msgObj, sendOffline ){
            if( !!sendOffline){

                var offlineIpPort = chatUtilsFactory.getOfflineIpPort();
                msgObj.ip = offlineIpPort.ip;
                msgObj.port = offlineIpPort.port;

            }else{

                msgObj.ip = box.getIp();
                msgObj.port = box.getPort();
            }

            return msgObj;
        };

        var updateBoxMessageStatus = function(box, msgObj, status){

            var boxMessageObject = box.getMessage(msgObj.packetId);
            if(!!boxMessageObject){
                boxMessageObject.status = status;

                chatHistoryFactory.updateMessage(boxMessageObject, box.getKey());
                utilsFactory.triggerCustomEvent('SINGLE_BOX_UPDATED', {box : box});
            }
        };

        var doSendMessage = function(box, msgObj, messageData, sendOffline){

            var afterFailureCallback,
                aChatSender, aChatSenderInstance;

            updateMessageObjectIpPort(box, msgObj, sendOffline);
            utf8EncodeMessageObject(msgObj);

            msgObj.fromTemporary = false;

            if(!!msgObj.tag_chat){
                afterFailureCallback = _doAfterTagSendFailure;
            }else{
                afterFailureCallback = _doAfterChatMsgSendFailure;
            }

            logSendMessageStateChange(msgObj);

            try{

                aChatSender = new ChatPacketSender();
                aChatSender.setPacketObject( msgObj );
                aChatSender.setBrokenPacketType( msgObj.brokenPacketType );
                aChatSenderInstance = aChatSender.getInstance();

                aChatSenderInstance.on('failure', function(){

                    var currentState = msgObj.SENDING_STATE;

                    switch ( msgObj.SENDING_STATE ){

                        case CHAT_STATES.MESSAGE_SENDING.FIRST_ONLINE:

                            if( box.isTagChat ){
                                msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REFRESH;

                            }else{
                                msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.PRESENCE_REFRESH;
                            }

                            afterFailureCallback.call(this, box, msgObj, messageData);

                            break;

                        case CHAT_STATES.MESSAGE_SENDING.SECOND_ONLINE:

                            if( box.isTagChat ) {
                                msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.ONLINE_FAILED;

                                updateBoxMessageStatus(box, msgObj, 'Failed');

                            }else{
                                msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REFRESH;

                                pushToTemporaryArray(box, msgObj, messageData);
                                ChatApiService.requestForIp(msgObj.friendId);
                            }
                            break;

                        case CHAT_STATES.MESSAGE_SENDING.THIRD_ONLINE:

                            msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE;

                            doSendMessage(box, msgObj, msgObj.messageData, true);
                            break;

                        case CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE:

                            msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.OFFLINE_IP_PORT_REFRESH;

                            doUpdateOfflineIpPort().then(function(){

                                msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.SECOND_OFFLINE;

                                doSendMessage(box, msgObj, msgObj.messageData, true);

                            }, function(){

                                msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.OFFLINE_FAILED;

                                updateBoxMessageStatus(box, msgObj, 'Failed');

                            });

                            break;

                        case CHAT_STATES.MESSAGE_SENDING.SECOND_OFFLINE:

                            msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.OFFLINE_FAILED;

                            updateBoxMessageStatus(box, msgObj, 'Failed');

                            break;

                    }

                    logSendMessageStateChange(msgObj, currentState);


                });

                aChatSenderInstance.on('success', function(){

                    var currentState = msgObj.SENDING_STATE;

                    switch ( msgObj.SENDING_STATE ){

                        case CHAT_STATES.MESSAGE_SENDING.FIRST_ONLINE:
                        case CHAT_STATES.MESSAGE_SENDING.SECOND_ONLINE:
                        case CHAT_STATES.MESSAGE_SENDING.THIRD_ONLINE:

                            msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.ONLINE_SUCCESS;
                            break;

                        case CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE:
                        case CHAT_STATES.MESSAGE_SENDING.SECOND_OFFLINE:
                            msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.OFFLINE_SUCCESS;
                            break;
                    }

                    logSendMessageStateChange(msgObj, currentState);


                    //updateBoxMessageStatus(box, msgObj, 'Delivered');


                });

                aChatSenderInstance.start();

            }catch(e){
                RingLogger.alert('Tag Create  Exception ', e, RingLogger.tags.TAG_CHAT);

            }

        };
        var doRetryMessage = function(box, msgObj, messageData){
            if(!!msgObj.tag_chat){
                msgObj.tagId = box.getKey();
            }else {
                msgObj.friendId = box.getKey();
            }

            if( box.checkWaitingTimePassed() || !box.hasIpPort() ){

                msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REQUEST;
                pushToTemporaryArray(box, msgObj, messageData);

                ChatApiService.requestForIp(msgObj.friendId);

            } else {

                msgObj.SENDING_STATE = msgObj.SENDING_STATE || CHAT_STATES.MESSAGE_SENDING.FIRST_ONLINE;
                updateMessageObjectIpPort(box, msgObj);
                doSendMessage(box, msgObj, messageData);

            }
        };

        var sendTemporaryMessages = function(box, sendOffline){
            /* Need to reset ip and port, because while this message was pushed in temp array then ip,port was for that time,
             and 3 minutes has passed so we've requested another request and server is sending binding port again, which might
             not be the same as was before. so we're resetting the ip and port for those messages individually */

            while(angular.isArray(box.tempMessageArray) && box.tempMessageArray.length >0){
                var individualMsgObject = box.tempMessageArray.shift();

                var currentState = individualMsgObject.SENDING_STATE;

                switch ( individualMsgObject.SENDING_STATE ){

                    case CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REFRESH:

                        if( box.isTagChat ){
                            individualMsgObject.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.SECOND_ONLINE;

                        }else{

                            if( sendOffline ){
                                individualMsgObject.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE;
                            }else{
                                individualMsgObject.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.THIRD_ONLINE;
                            }

                        }

                        doSendMessage(box, individualMsgObject, individualMsgObject.messageData, sendOffline);

                        break;

                    case CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REQUEST:

                        if( box.isTagChat || !sendOffline) {

                            individualMsgObject.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.FIRST_ONLINE;

                        }else{

                            individualMsgObject.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE;
                        }


                        doSendMessage(box, individualMsgObject, individualMsgObject.messageData, sendOffline);

                        break;
                }

                logSendMessageStateChange(individualMsgObject, currentState);

            }
        };

        var processAndSendMessage = function (box, message, messageType, messageData) {

            var msgObj = getMessageObject(box, message, messageType, messageData),
                currentUser = Auth.currentUser();

            messagePreSendProcess(msgObj, messageData);

            updateMessageObjectIpPort(box, msgObj);

            //RingLogger.debug('SENDING MSG `{0}` IN STATE {1}'.format(
            //        msgObj.message,
            //        chatUtilsFactory.getChatStateName( msgObj.SENDING_STATE)
            //    ),  RingLogger.tags.CHAT_SEND_MESSAGE
            //);

            if( !msgObj.fromTemporary){
                box.pushMessage(msgObj, currentUser, true);
                //box.pushMessage(angular.extend({status: 0}, msgObj), currentUser);

            }

            if( box.checkWaitingTimePassed() || !box.hasIpPort() ){

                msgObj.SENDING_STATE = CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REQUEST;
                pushToTemporaryArray(box, msgObj, messageData);

                ChatApiService.requestForIp(msgObj.friendId);

            } else {

                msgObj.SENDING_STATE = msgObj.SENDING_STATE || CHAT_STATES.MESSAGE_SENDING.FIRST_ONLINE;

                doSendMessage(box, msgObj, messageData);

            }

        };

        var sendTypingPacket = function (box) {
            if(box.isTagChat){
                //for tagChat
                if( !!box.getIp() ){
                    var tagObject = tagChatFactory.getTag(box.getKey());
                    tagChatApiService.sendTagMsgTypingPacket(Auth.currentUser().getKey(), tagObject);
                }
            }else{
                //for individual chat
                if( !!box.getIp() && !!box.getPort()){
                    var typingPacketObject = ChatApiService.getTypingPacketObject(box);
                    ChatApiService.sendViaGlobalChatSocket(typingPacketObject, CHAT_PACKET_FORMAT.TYPING_PKT);
                }

            }
        };
        var sendIdlePacket = function (box) {
            if(box.isTagChat){
                //for tag chat
                var tagObject = tagChatFactory.getTag(box.getKey());
                if(!!tagObject){
                    tagChatApiService.sendTagIdlePacket(Auth.currentUser().getKey(), tagObject);
                }
            }else{
                //for individual chat
                var idlePacketObject = ChatApiService.getIdlePacketObject(box);
                ChatApiService.sendViaGlobalChatSocket(idlePacketObject, CHAT_PACKET_FORMAT.IDLE_PKT);
            }
        };
        var sendBlankMessage = function (friendId) {

            var blankMessageObject = ChatApiService.getBlankMessageObject(friendId);
            ChatApiService.sendViaGlobalChatSocket(blankMessageObject, CHAT_PACKET_FORMAT.CHAT_MSG_OFFLINE);

        };

        var processAndSendOfflineMessage = function (box, message, messageType, previousPacketId, messageData) {

            var msgObj = getMessageObject(box, message, messageType, messageData),
                currentUser = Auth.currentUser();

            if( !!previousPacketId){
                msgObj.packetId = previousPacketId;
                msgObj.key = previousPacketId;
            }

            messagePreSendProcess(msgObj, messageData);

            msgObj.SENDING_STATE = msgObj.SENDING_STATE || CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE;

            if( !msgObj.fromTemporary && !previousPacketId){
                box.pushMessage(msgObj, currentUser, true);
                utilsFactory.triggerCustomEvent('NEW_MESSAGE_PUSHED', {boxId : box.getKey(), scroll : 'bottom'});

            }

            RingLogger.debug('SEND OFFLINE MSG OBJECT : ', msgObj,RingLogger.tags.CHAT);

            doSendMessage(box, msgObj, messageData, true);
        };


        var sendChatUnRegisterPacket = function(box){
            var unRegisterPacket = ChatApiService.getF2FUnRegisterObject(box);
            ChatApiService.sendViaGlobalChatSocket(unRegisterPacket, CHAT_PACKET_FORMAT.FRIEND_UNREGISTER_PKT);
        };






        self.processAndSendMessage = processAndSendMessage;
        self.sendMessage = doSendMessage;
        self.retryMessage = doRetryMessage;
        self.sendTypingPacket = sendTypingPacket;
        self.sendIdlePacket = sendIdlePacket;
        self.sendBlankMessage = sendBlankMessage;
        self.sendChatUnRegisterPacket = sendChatUnRegisterPacket;
        self.sendTemporaryMessages = sendTemporaryMessages;
        self.processAndSendOfflineMessage = processAndSendOfflineMessage;

        /* This Shouldn't be in here, need to resovled circular dependency to move */
        self.doUpdateOfflineIpPort = doUpdateOfflineIpPort;

        self.getF2FIpPortMultipleTime = getF2FIpPortMultipleTime;

    }
})();

(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}

    chatApp
        .factory('chatTabSync', chatTabSync);


    function CrossTab(){
        var self;

        var callbacks = {},
            lastNewValue,
            lastOldValue,
            tabId;

        function NotSupported() {
            var errorMsg = 'CrossTab not supported';
            var reasons = [];
            if (!localStorage) {
                reasons.push('localStorage not available');
            }
            if (!window.addEventListener) {
                reasons.push('addEventListener not available');
            }

            if (reasons.length > 0) {
                errorMsg += ': ' + reasons.join(', ');
            }

            throw new Error(errorMsg);
        }

        function now(){
            return new Date().getTime();
        }


        function onStorageEvent(event) {
            // Only handle crosstab events
            if (!event || (event.key != '__CROSSTAB') ) {
                return;
            }

            var eventValue;
            try {
                eventValue = event.newValue ? JSON.parse(event.newValue) : {};
            } catch (e) {
                eventValue = {};
            }
            if (!eventValue || !eventValue.id || eventValue.id === CrossTab.id) {
                // This is to force IE to behave properly
                return;
            }
            if (event.newValue === lastNewValue && event.oldValue === lastOldValue) {
                // Fix bug in IE11 where StorageEvents in iframes are sent twice.
                return;
            }
            lastNewValue = event.newValue;
            lastOldValue = event.oldValue;

            if(!!callbacks['message']){
                callbacks['message'].call(this, eventValue.data);
            }else{
                RingLogger.warning('On Message Handler Not Set', RingLogger.tags.DEBUG);
            }
        }

        function setLocalStorageItem(key, data) {
            var storageItem = {
                id: tabId,
                data: data,
                timestamp: now()
            };

            localStorage.setItem(key, JSON.stringify(storageItem));
        }

        function getLocalStorageRaw(key) {
            var json = localStorage ? localStorage.getItem(key) : null;
            var item = json ? JSON.parse(json) : {};
            return item;
        }


        function swapUnloadEvents() {
            // `beforeunload` replaced by `unload` (IE11 will be smart now)
            window.removeEventListener('beforeunload', unload, false);
            window.addEventListener('unload', unload, false);
        }

        function unload() {

        }

        function pad(num, width, padChar) {
            padChar = padChar || '0';
            var numStr = (num.toString());

            if (numStr.length >= width) {
                return numStr;
            }

            return new Array(width - numStr.length + 1).join(padChar) + numStr;
        }

        var generateId = function () {
            /*jshint bitwise: false*/
            return now().toString() + pad((Math.random() * 0x7FFFFFFF) | 0, 10);
        };


        function broadcast(data) {
            if (!CrossTab.supported) {
                NotSupported();
            }

            var message = {
                data: data,
                origin: tabId
            };

            setLocalStorageItem('__CROSSTAB', message);

        }

        this.on = function(name, callback){
            callbacks[name] = callback;
        };

        this.setId = function(id){
            tabId = id;
        };

        this.getId = function(){
            return tabId;
        };

        this.broadcast = broadcast;

        this.init = function(){
            // --- Check if crosstab is supported ---
            CrossTab.supported = !!localStorage && window.addEventListener;

            if (!CrossTab.supported) {
                CrossTab.broadcast = NotSupported;
            } else {

                tabId = generateId();
                // ---- Setup Storage Listener
                window.addEventListener('storage', onStorageEvent, false);
                // start with the `beforeunload` event due to IE11
                window.addEventListener('beforeunload', unload, false);
                // swap `beforeunload` to `unload` after DOM is loaded
                window.addEventListener('DOMContentLoaded', swapUnloadEvents, false);
            }
        };


    }


    chatTabSync.$inejct = ['Storage', 'utilsFactory', 'CHAT_GENERAL_CONSTANTS', 'SystemEvents'];

        function chatTabSync(Storage, utilsFactory, CHAT_GENERAL_CONSTANTS, SystemEvents) {

            var isSharedWorkerSupported = !!window.SharedWorker;
            var isLocalStorageSupported = !!window.localStorage;
            var myTabId, worker, corssTab, tabSender;

            var sendViaSharedWorker = function(type, data){
                try{
                    worker.port.postMessage({origin : myTabId, data : angular.extend(data, { type : type})});
                }catch(e){
                    RingLogger.alert('Tab Sync Exception',e, RingLogger.tags.CHAT);
                }

            };

            var sendViaLocalStorage = function(type, data){
                try {
                    corssTab.broadcast(angular.extend(data, {type: type}));
                }catch(e){
                    RingLogger.alert('Tab Sync Exception',e, RingLogger.tags.CHAT);
                }
            };

            var initSharedWorker = function(){
                myTabId = utilsFactory.getUniqueID('t');

                worker = new SharedWorker(CHAT_GENERAL_CONSTANTS.SHARED_WORKER_PATH);

                worker.port.addEventListener('message', function(event) {
                    var message = event.data;
                    if (message.origin !== myTabId) {

                        RingLogger.debug('TAB DATA RECEIVED VIA SHARED WORKER', message, RingLogger.tags.TAB_DATA_RECEIVED);
                        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAB_SYNC_NEW_DATA, message.data);
                    }

                }.bind(this), false);

                worker.port.start();

            };


            var initShareViaLocalStorage = function(){
                corssTab = new CrossTab();
                corssTab.init();

                myTabId = corssTab.getId();

                corssTab.on('message', function (message) {
                    if (message.origin !== myTabId) {

                        RingLogger.debug('TAB DATA RECEIVED VIA LOCAL STORAGE', message, RingLogger.tags.TAB_DATA_RECEIVED);

                        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAB_SYNC_NEW_DATA, message.data );
                    }
                });
            };

            var _sendData = function(type, data){

                if(!!tabSender ){
                    tabSender.call(this, type, data);
                }

            };

            var _init = function(){

                if( isSharedWorkerSupported ){
                    initSharedWorker();
                    tabSender = sendViaSharedWorker;

                }
                else if( isLocalStorageSupported) {
                    initShareViaLocalStorage();
                    tabSender = sendViaLocalStorage;

                }else{
                    tabSender = function(){};
                    RingLogger.alert('LOCAL STORAGE NOT SUPPORTED, CROSS TAB SENDING FAIED', RingLogger.tags.TAG_CHAT);
                }
            };

            return {

                init : _init,
                sendData : _sendData
            }
        }
        chatTabSync.$inject = ['Storage', 'utilsFactory', 'CHAT_GENERAL_CONSTANTS', 'SystemEvents'];

})();

(function () {
    'use strict';

    openBox.$inject = ['ChatFactory', 'PullerSubscriber', 'tagChatFactory', 'tagChatManager', 'rgDropdownService', 'utilsFactory', 'Auth', 'ChatHelper', 'rgScrollbarService', '$rootScope'];
    function openBox( ChatFactory, PullerSubscriber, tagChatFactory, tagChatManager, rgDropdownService , utilsFactory, Auth, ChatHelper, rgScrollbarService, $rootScope) {
        return {
            link: function (scope, element, attrs) {
                element.on("click", function (event) {

                    var boxId = !attrs.boxId ? false : attrs.boxId;
                    var isTagChat = attrs.isTagChat == "true" ? true : false;

                    if( !boxId ){
                        RingLogger.alert('Invalid ChatBoxId to open box', RingLogger.tags.CHAT);
                        return;
                    }

                    if( attrs.openChatBox == Auth.currentUser().getKey() ){
                        RingLogger.alert('Same User ChatBox', RingLogger.tags.CHAT);
                        return;
                    }

                    rgDropdownService.close();

                    var tagObject, tagChatBoxOpened = false;
                    if( isTagChat ){
                        tagObject = tagChatFactory.getTag(boxId);

                        if( !!tagObject && tagObject.isTagSafeToShow()){

                            if(!tagChatFactory.isTagRegistered(boxId)) {
                                tagChatManager.requestForIp(boxId)
                            }
                            tagChatBoxOpened = true;
                            ChatFactory.openTagChatBox(boxId, true);
                        }

                    }else{

                        ChatFactory.openChatBox(boxId, true);
                        PullerSubscriber.requestForIp(boxId);

                    }

                    var box = ChatFactory.getBoxByUId(boxId);

                    if(!!box){
                        box.loadHistoryMessages();

                        ChatHelper.decreaseUnreadCount(box);
                        

                        if( tagChatBoxOpened ){
                            box.setTitle( tagObject.getTagName() );
                        }
                        
                    }

                    utilsFactory.safeDigest(scope);

                    event.preventDefault();
                    event.stopPropagation();
                });
            }
        };
    }

    openChatBox.$inject = ['ChatFactory', 'PullerSubscriber', 'utilsFactory', 'Auth', '$rootScope', 'ChatHelper'];
    function openChatBox(ChatFactory, PullerSubscriber, utilsFactory, Auth, $rootScope, ChatHelper) {
        return {
            link: function (scope, element, attrs) {
                element.on("click", function (event) {

                    if( !attrs.openChatBox ){
                        RingLogger.alert('Invalid ChatBoxId to open box', RingLogger.tags.CHAT);
                        return;
                    }
                    if( attrs.openChatBox == Auth.currentUser().getKey() ){
                        RingLogger.alert('Same User ChatBox', RingLogger.tags.CHAT);
                        return;
                    }

                    utilsFactory.safeDigest(scope);

                    ChatFactory.openChatBox(attrs.openChatBox, true);

                    //PullerSubscriber.requestForIp(attrs.openChatBox);
                    var box = ChatFactory.getBoxByUId(attrs.openChatBox);

                    if(box.getUser().friendshipStatus()==1){
                        //this is friend
                        PullerSubscriber.requestForIp(attrs.openChatBox);
                    }else{
                        //this is not friend yet
                        var permission = Auth.getPermission();
                        if(permission.ancht ==1){
                            PullerSubscriber.requestForIp(attrs.openChatBox);
                        }else{
                            var box =ChatFactory.getBoxByUId(attrs.openChatBox);
                            box.blocked = true;
                        }
                    }

                    if(!!box){
                        box.loadHistoryMessages();
                        ChatHelper.decreaseUnreadCount(box);
                    }

                    event.preventDefault();
                    event.stopPropagation();
                });
            }
        };
    }




    openTagChatBox.$inject =  [ 'ChatFactory', 'tagChatApiService', 'tagChatFactory', 'tagChatManager', 'Auth', '$rootScope', 'ChatHelper'];
    function openTagChatBox( ChatFactory, tagChatApiService, tagChatFactory, tagChatManager, Auth, $rootScope, ChatHelper) {

        return {
            link: function (scope, element, attrs) {
                element.on("click", function () {
                    var tagId = attrs.openTagChatBox;

                    if( tagId <= 0){
                        RingLogger.alert('Invalid TagId to open box', RingLogger.tags.TAG_CHAT);
                        return;
                    }

                    if( attrs.openChatBox == Auth.currentUser().getKey() ){
                        RingLogger.alert('Same User ChatBox', RingLogger.tags.CHAT);
                        return;
                    }

                    var tagObject = tagChatFactory.getTag(tagId);

                    var box = ChatFactory.openTagChatBox(tagId, true);

                    box.setTitle( tagObject.getTagName() );

                    if( !!tagObject && tagObject.isTagSafeToShow()){

                        if(!tagChatFactory.isTagRegistered(tagId)){

                            tagChatFactory.setTagChatInitiator(tagId);

                            if(!!tagObject){

                                tagChatApiService.createOrGetTagFromAuth(tagObject, tagObject.getMemberUserIds())
                                    .then(function(response){
                                        response.isInitiated = true;
                                        tagChatManager.doOnTagChatRequestStartResponse(response);
                                    });

                            }

                        }else{
                            RingLogger.print("Skipping Initiator Request", RingLogger.tags.TAG_CHAT);
                        }
                    }

                    if(!!box){
                        box.loadHistoryMessages();  
                        ChatHelper.decreaseUnreadCount(box);                      
                    }
                });
            }
        };
    }


    makeVisibleChatBox.$inject = ['ChatFactory','$rootScope'];
    function makeVisibleChatBox(ChatFactory,$rootScope) {
        /*
         * Description: directive to make the hidden chatbox visible
         * param: userId (which is the key for the stackmap)
         * Scope: level 2 childscope of chatController scope
         * Event: no event is broadcasting/emitting
         * Dependency: ChatFactory
         * Date: 04-04-15
         * Developed By: rabbi
         * */

        return {
            link: function (scope, element, attrs) {
                element.on("click", function () {

                    scope.rbox.value.isFocused = true; // to make reordered box on focused
                    ChatFactory.makeVisibleChatBox(attrs.makeVisibleChatBox);
                    $rootScope.$broadcast("focusOn", scope.rbox.value.getKey());
                    element.parent().parent().children().eq(0).removeClass('blink'); // for removing blink class when user clicks on hidden box
                });
            }
        };
    }


    showHiddenBoxes.$inject = ['ChatFactory','$rootScope'];
    function showHiddenBoxes(ChatFactory,$rootScope) {
        return {
            link: function (scope, element, attrs) {
                element.on("click", function () {
                    ChatFactory.openChatBox(attrs.openChatBox);
                });
            }
        };
    }

    closeBox.$inject = ['ChatFactory','chatHistoryFactory', 'tagChatFactory'];
    function closeBox(ChatFactory,chatHistoryFactory, tagChatFactory) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                element.on('click', function () {
                    //RingLogger.log(scope.box.value.object.getKey());
                    ChatFactory.closeChatBox(scope.box.value.getKey()); //removes corresponding box from boxes stack using userId which is the key
                    chatHistoryFactory.removeOpenBox(scope.box.value.getKey());

                    var tagObject = tagChatFactory.getTag(scope.box.value.getKey());
                    if( !!tagObject ){
                        tagObject.initMessages();
                    }

                    scope.$parent.$digest();
                });
            }
        }; // return object for directive factory function
    }

    minimizeBox.$inject = ['ChatFactory'];
    function minimizeBox(ChatFactory) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                element.on('click', function (event) {
                    if(!!scope.box.value.blinkOn && !scope.box.value.isMinimized){//true false: if blinking is on then it won't minimize
                        //blink on and not minimized
                        scope.$broadcast("blinkerOff", scope.box.value.getKey());
                        scope.$broadcast("focusOn", scope.box.value.getKey());
                    } else if(!!scope.box.value.blinkOn && !!scope.box.value.isMinimized){//true true:
                        //blink on and minimized
                        ChatFactory.minimizeBox(scope.box.value.getKey());
                        scope.$broadcast("blinkerOff", scope.box.value.getKey());
                        scope.$broadcast("focusOn", scope.box.value.getKey());//won't work this focus event as the event gets fired before digest is finished so it gets the element hidden
                    } else if(!scope.box.value.blinkOn && !scope.box.value.isMinimized){// false true:
                        //blink off and not minimized
                        ChatFactory.minimizeBox(scope.box.value.getKey());

                    } else if(!scope.box.value.blinkOn && !!scope.box.value.isMinimized){ // false false:
                        //blink off and minimized
                        ChatFactory.minimizeBox(scope.box.value.getKey());
                        scope.$broadcast("focusOn", scope.box.value.getKey());//won't work this focus event as the event gets fired before digest is finished so it gets the element hidden
                    }
                    //ChatFactory.minimizeBox(scope.box.value.getKey());
                    scope.$digest();
                    event.stopPropagation();
                });
            }
        }; // return object for directive factory function
    }

    maximizeBox.$inject = ['ChatFactory'];
    function maximizeBox(ChatFactory) {
        return {
            scope: false,
            restrict: 'A',
            link: function (scope, element, attrs) {

            }
        }; // return object for directive factory function
    }

    tagChatEdit.$inject = ['ChatFactory', 'rgDropdownService' , '$compile'];
    function tagChatEdit(ChatFactory, rgDropdownService, $compile) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {


                element.on('click', function (event) {
                    scope.showDropdown = !scope.showDropdown;
                    event.stopPropagation();
                });

            },
            controller : [ '$scope', 'tagChatFactory', 'tagChatManager', 'Auth', 'Ringalert', '$compile',
                function($scope, tagChatFactory, tagChatManager, Auth, Ringalert, $compile){

                    $scope.showDropdown = false;


                    $scope.hasTagObjectLock = function(tagId){

                        var tagObject = tagChatFactory.getTag(tagId);
                        if( !!tagObject){
                            return tagObject.hasObjectLock();
                        }
                        return false;
                    };

                    $scope.getTagDDControl = function(tagId){
                        var tagObject = tagChatFactory.getTag(tagId);
                        //var currentUserMemberObject = tagObject.getMember(Auth.currentUser().getKey());
                        var currentUserMemberObject = tagObject.getMember(Auth.loginData.uId);
                        return {
                            tagId : tagId,
                            isOwner : !!currentUserMemberObject ? currentUserMemberObject.isOwner() : false
                        };
                    };


                    $scope.tagMemberDDActions = tagMemberDDActions;
                    $scope.tagMemberDDHtml = 'pages/partials/tag-chat/member-actions-dropdown.html';

                    // edit, view or delete
                    function tagMemberDDActions(actionObj) {
                        switch(actionObj.action) {
                            case 'edit':
                            case 'view':
                                rgDropdownService.close();

                                return function() {
                                    return {tagId: actionObj.tagId};
                                };


                                break;
                            case 'delete':

                                rgDropdownService.close();

                                var tagObject = tagChatFactory.getTag(actionObj.tagId);

                                tagObject.setObjectLock();

                                tagChatManager.leaveFromTag(actionObj.tagId, currentUser.getKey()).then(function(response){

                                    tagObject.removeObjectLock();
                                    Ringalert.show(response, 'info');


                                }, function(response){

                                    tagObject.removeObjectLock();
                                    Ringalert.show(response, 'error');

                                });

                                break;
                            default:
                                RingLogger.log('Err. no matching action');
                        }
                    }



                }]
        }; // return object for directive factory function
    }

    chatScrollBottom.$inject = ['$rootScope', 'rgScrollbarService'];
    function chatScrollBottom($rootScope, rgScrollbarService) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                scope.$on("ScrollToBottom",function(event, userId){
                    if(userId == scope.box.value.getKey()){
                        //element[0].scrollTop = element[0].scrollHeight;
                        event.preventDefault();
                        rgScrollbarService.scrollTo(scope, 100);                            
                        
                    }
                });
                // to grab the event when user opens the chat box first time and
                // as it is on another scope, that doesn't meet the parent child relationship
                // we had to do it in $rootScope.
                $rootScope.$on("ScrollToBottom",function(event, userId){
                    if(userId == scope.box.value.getKey()){
                        //element[0].scrollTop = element[0].scrollHeight;
                        event.preventDefault();
                        rgScrollbarService.scrollTo(scope, 100);    

                    }
                });

                $rootScope.$on("ScrollToUnread",function(event, userId){
                    if(userId == scope.box.value.getKey()){
                        event.preventDefault();
                        rgScrollbarService.scrollTo(scope, '.status-Unread', 'down');
                    }
                });

            }
        }; // return object for directive factory function
    }

    chatBlinker.$inject = ['$window','chatHistoryFactory'];
    function chatBlinker($window,chatHistoryFactory) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                //var blinkerTimerFunction;
                if(scope.box.value.blinkOn === true){
                    element.addClass('blink');
                }
                scope.$on('blinkerEvent', function (event, userId) {
                    if(userId.toString() === scope.box.value.getKey()){
                        //if(!blinkerTimerFunction){
                        if(scope.box.value.isMinimized){
                            //blinkerTimerFunction = $window.setInterval(function () {
                            //    element.css({border: '2px solid red'});
                            if(scope.box.value.isFocused === false) {// doesn't matter it is focused or not if minimised it will blink
                                element.addClass('blink');
                                scope.box.value.blinkOn = true;
                            }
                            //},500);
                        } else {
                            //blinkerTimerFunction = $window.setInterval(function () {
                            //    element.css({border: '2px solid red'});
                            if(scope.box.value.isFocused === false) {
                                element.addClass('blink');
                                scope.box.value.blinkOn = true;
                            }
                            //},500);
                        }
                        chatHistoryFactory.updateBox(scope.box.value);
                        //}
                        //scope.$watch('box.value.isFocused', function (newValue, oldValue ) {
                        //    RingLogger.log(box.value.isFocused);
                        //    if(newValue === true && blinkerTimerFunction !== false){
                        //        $window.clearInterval(blinkerTimerFunction);
                        //        blinkerTimerFunction = false;
                        //    }
                        //});
                    }
                    //TODO have to handle blinking for hidden boxes
                    // this has been handled with another directive named chatBlinkerH
                    //if(scope.rbox){
                    //    if(userId === scope.$parent.$parent.rbox.value.getKey()){
                    //        element.addClass('blink');
                    //    }
                    //}
                });
                scope.$on('blinkerOff', function (event, userId) {
                    if(userId.toString() === scope.box.value.getKey()){
                        //element.css({border: 'none'});
                        element.removeClass('blink');
                        scope.box.value.blinkOn = false;
                        chatHistoryFactory.updateBox(scope.box.value);
                        //if(blinkerTimerFunction){
                        //    $window.clearInterval(blinkerTimerFunction);
                        //    blinkerTimerFunction = false;
                        //}
                    }
                });
            }
        }; // return object for directive factory function
    }


    chatBlinkerH.$inject = [ '$window','chatHistoryFactory' ];
    function chatBlinkerH($window,chatHistoryFactory) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                scope.$on('blinkerEvent', function (event, userId) {
                    if(userId.toString() === scope.rbox.value.getKey()){
                        element.addClass('blink');
                        element.parent().parent().children().eq(0).addClass('blink');
                        //RingLogger.log(element.parent().parent());
                        chatHistoryFactory.updateBox(scope.rbox.value);//might cause problem, didn't have enough time to be sure, will dig out later
                    }
                });
            }
        }; // return object for directive factory function
    }

    chatSelectEmo.$inject = ['ChatPacketSenderService'];
    function chatSelectEmo(ChatPacketSenderService) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {

                scope.selectEmoticon = function(emoticon){
                    //if(emoticon.isSticker() || emoticon.isLargeEmoticon()){

                    //ChatPacketSenderService.processAndSendMessage(scope.box.value, emoticon.symbol());

                    //}else{
                    scope.messageText = scope.messageText + emoticon.symbol();
                    //}

                };
            }
        }; // return object for directive factory function
    }

    chatBindOutsideClick.$inject = ['$document', 'utilsFactory'];
    function chatBindOutsideClick($document, utilsFactory) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                element.bind('click', function(e) {
                    e.stopPropagation();
                });
                $document.bind('click', function() {
                    scope.showHidden = false;
                    utilsFactory.safeDigest(scope);
                    //scope.$apply(scope.showHidden);
                });
            }
        }; // return object for directive factory function
    }

    sharedContent.$inject = ['utilsFactory'];
    function sharedContent(utilsFactory){
        return {
            restrict: 'A',
            link : function(scope){

                scope.initMessageData = function(){
                    scope.messageData = {ogData : {}, locationData :{} };
                };

                scope.resetOgInfo = function(){
                    scope.messageData.ogData = {};
                    scope.ogStatus = {preview : false, loading: false, filterOnProgress: false};
                };

                scope.resetMessageLocation = function(){
                    scope.messageData.locationData = { description : '', lat : '', lng: ''};
                };

                scope.resetMessageText = function(){
                    scope.messageText = "";
                };

                scope.resetBottomMenu = function(){
                    scope.showBottomMenu = false;
                };

                scope.resetMessageInput = function(digest){

                    scope.initMessageData();

                    scope.resetBottomMenu();
                    scope.resetMessageText();
                    scope.resetOgInfo();
                    scope.resetMessageLocation();

                    if(!!digest){
                        utilsFactory.safeDigest(scope);

                    }
                };

                scope.resetMessageInput(false);
            }
        };
    }

    angular
        .module('ringid.chat')
        .directive('openBox', openBox)
        .directive('openChatBox', openChatBox)
        .directive('openTagChatBox',openTagChatBox)
        .directive('makeVisibleChatBox', makeVisibleChatBox)
        .directive('showHiddenBoxes', showHiddenBoxes)
        .directive('closeBox', closeBox)
        .directive('minimizeBox', minimizeBox)
        .directive('maximizeBox', maximizeBox)
        .directive('tagChatEdit', tagChatEdit)
        .directive('chatScrollBottom', chatScrollBottom)
        .directive('chatBlinkerH', chatBlinkerH)
        .directive('chatBindOutsideClick', chatBindOutsideClick)
        .directive('sharedContent', sharedContent);

        // end of module definition
})(); // end of self invoking anonymous function, this is used to avoid the conflict of name of the module

/**
 * Created by ibrahim on 4/01/16.
 */
(function () {
    'use strict';

    /** Helpers **/
    function getMessagePacketIdForHistoryRequest(message){
        var packetId = message.key;

        if( message.status == 'status_update'){
            try{
                packetId = packetId.split('_')[0];
            }catch(e){
                RingLogger.alert("History PacketID Split Error", RingLogger.tags.CHAT);
            }
        }

        return packetId;
    }

    function doSendHistoryRequest(scope, requestMethod, chatBox, direction, packetId, limit){

        var boxId = chatBox.getKey();

        scope.historyLoading = true;

        requestMethod.call(this, boxId, direction, packetId, limit)
            .then(function(response){
                if(!!response.sucs){
                    scope.historyLoading = false;
                }
            }, function(){
                scope.historyLoading = false;
                chatBox.hasHistoryMessage = true;
            });
    }

    /** **/


    chatBoxUi.$inject = ['ChatFactory', 'tagOfflineChatManager', 'utilsFactory', 'TAG_CHAT_GENERAL_CONSTANTS', 'rgScrollbarService', '$rootScope'];
    function chatBoxUi(ChatFactory, tagOfflineChatManager, utilsFactory, TAG_CHAT_GENERAL_CONSTANTS, rgScrollbarService, $rootScope){

            var templateUrl = 'pages/chatbox.html';

            return {
                restrict: 'E',
                replace: true,
                scope : true,
                templateUrl  : templateUrl,
                link : function(scope){


                    var doHistoryRequest = function(boxId){

                        var chatBox = ChatFactory.getBoxByUId(boxId);

                        if(!!chatBox && !!chatBox.nonDomBox){
                            var bottomMessage = chatBox.getBottomMessage();
                            var topMessage = chatBox.getTopMessage();

                            //var bottomPacketId = chatBox.messageMaxPacketId,
                            //    topPacketId = chatBox.messageMinPacketId;

                            var topPacketId, bottomPacketId;

                            if( !topMessage && !bottomMessage){
                                topPacketId = bottomPacketId = ChatFactory.getUUIDPacketId();
                            }else{
                                //bottomPacketId = getMessagePacketIdForHistoryRequest(bottomMessage);
                                //topPacketId = getMessagePacketIdForHistoryRequest(topMessage);
                                bottomPacketId = chatBox.messageMinPacketId;
                                topPacketId = chatBox.messageMaxPacketId
                            }

                            if( !chatBox.hasHistoryMessage ){

                                var historyRequestMethod = tagOfflineChatManager.getHistoryRequestMethodByBox(chatBox);

                                var isSameMessage = ( topPacketId == bottomPacketId );

                                var limit = 20;

                                doSendHistoryRequest(scope, historyRequestMethod, chatBox, TAG_CHAT_GENERAL_CONSTANTS.PAGE_DIRECTION.UP, bottomPacketId, limit);

                                if(!isSameMessage){
                                    doSendHistoryRequest(scope, historyRequestMethod, chatBox, TAG_CHAT_GENERAL_CONSTANTS.PAGE_DIRECTION.DOWN, topPacketId, limit);
                                }
                            }
                        }

                        utilsFactory.safeDigest(scope);

                    };


                    utilsFactory.onCustomEvent('CHAT_HISTORY_LOADED', function(chatHistoryLoadedData){
                        
                        doHistoryRequest(chatHistoryLoadedData.boxId);
                    });
                }


            };
    }

    function extraChatBoxes(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/extra-chatboxes.html'

        };
    }

    singleChatBox.$inject = ['rgScrollbarService', 'utilsFactory'];
    function singleChatBox(rgScrollbarService, utilsFactory){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-chatbox.html',
            link : function(scope, elem, attr){
                var doSomethingOnMessageReceived = function(data){
                    if( data.boxId.toString() == scope.box.key){
                        rgScrollbarService.recalculate(scope);
                        rgScrollbarService.hasScroll(scope);


                        if( data.scroll === 'bottom' || data.type == 'received'){
                            setTimeout(function(){
                                rgScrollbarService.scrollTo(scope, 100);
                                utilsFactory.safeDigest(scope);
                            },101);
                        }else{

                            //if( data.type == 'received' ){
                            //    rgScrollbarService.scrollTo(scope, '.status-Received', 'top');
                            //}
                        }

                        utilsFactory.safeDigest(scope);
                    }
                };

                utilsFactory.onCustomEvent('NEW_MESSAGE_PUSHED', function(data){
                    data['type'] = 'pushed';
                    doSomethingOnMessageReceived(data);
                });

                utilsFactory.onCustomEvent('MESSAGE_RECEIVED', function(event){
                    scope.$broadcast("blinkerEvent", event.boxId);
                    event['type'] = 'received';
                    doSomethingOnMessageReceived(event);
                });

                utilsFactory.onCustomEvent('SINGLE_BOX_UPDATED',function(data){
                    var box = data.box;

                    if(box.getKey() == scope.box.value.getKey()){

                        utilsFactory.safeDigest(scope);
                    }
                });



            }

        };
    }
    function chatBoxTopBar(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-topbar.html'

        };
    }
    function chatBoxTopBarMenu(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-topbar-menu.html',
            link : function(scope){

                var box = scope.box.value;

                scope.hideTopbar = true;

                setTimeout(function(){
                    scope.hideTopbar = false;
                    scope.$rgDigest();
                }, 3000);

                //box.hideSuggestion = true;
                //
                //setTimeout(function(){
                //    if(box.value ){
                //        box.hideSuggestion = false;
                //        scope.$rgDigest();
                //    }
                //}, 10000);

                scope.shouldShowLastOnlineBar = function(){
                    return ( box.offlineStatus && box.lastSeenBar && !!box.getUser().lastOnline && box.getUser().lastOnline() );
                };

                scope.shouldShowFriendSuggestion = function(){
                    return (!box.hideSuggestion & !box.isTagChat && !!box.getUser() && box.getUser().friendshipStatus() != 1 ) && !box.offlineStatus;
                };

                scope.shouldShowChatBoxTopbarMenu = function(){
                    return !box.isTagChat && ( scope.shouldShowLastOnlineBar() || scope.shouldShowFriendSuggestion() );
                };


            }

        };
    }
    function chatBoxUrlPreview(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-url-preview.html'

        };
    }
    chatBoxBottom.$inject = ['utilsFactory', '$document'];
    function chatBoxBottom(utilsFactory, $document){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-bottom.html',
            link : function(scope, elem, attr){

                scope.toggleMenu = function(){
                    scope.showBottomMenu = !scope.showBottomMenu;
                    utilsFactory.safeDigest(scope);
                };

                //elem.on('mouseover', function(){
                //    scope.showBottomHover = true;
                //    utilsFactory.safeDigest(scope);
                //
                //});
                //
                //elem.on('mouseleave', function(){
                //    scope.showBottomHover = false;
                //    utilsFactory.safeDigest(scope);
                //
                //});

            }

        };
    }

    function chatBoxLocationInfo(){
        return {
            restrict: 'E',
            replace: true,
            link : function(scope){

            },
            templateUrl: 'pages/partials/chat/chatbox-location-info.html'

        };
    }


    chatBoxBottomMenu.$inject = ['utilsFactory'];
    function chatBoxBottomMenu(utilsFactory){
        return {
            restrict: 'E',
            replace: true,
            link : function(scope, elem, attr){

                elem.on('mouseover', function(){
                    scope.$parent.bottomMenuHover = true;

                });

                elem.on('mouseleave', function(){
                    scope.$parent.bottomMenuHover = false;

                });

            },
            templateUrl: 'pages/partials/chat/chatbox-bottom-menu.html'

        };
    }

    chatBoxMiddle.$inject = ['rgScrollbarService', '$rootScope', 'utilsFactory']
    function chatBoxMiddle(rgScrollbarService, $rootScope, utilsFactory){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-middle.html',
            link : function(scope){

                utilsFactory.onCustomEvent('CHAT_HISTORY_LOADED', function(chatHistoryLoadedData){
                        
                    rgScrollbarService.recalculate(scope);
                    rgScrollbarService.hasScroll(scope);
                    $rootScope.$broadcast('ScrollToBottom', chatHistoryLoadedData.boxId);
                });
            }

        };
    }
    chatSingleMessage.$inject = ['utilsFactory', '$ringbox'];
    function chatSingleMessage(utilsFactory, $ringbox){
        return {
            restrict: 'E',
            replace: true,
            link : function(scope,element, attr){
                var singleMessageUpdatedEventReference = utilsFactory.onCustomEvent('SINGLE_MESSAGE_UPDATED',function(data){
                    var message = data.message;
                    if(message.key == scope.message.key){
                        utilsFactory.safeDigest(scope);
                    }
                });
                var boxInstance;
                scope.openRingboxContent = function (message) {
                    boxInstance = $ringbox.open({
                        type : 'remote',
                        scopeData:{
                            message : message
                        },
                        resolve: {
                            data : {}
                        },
                        onBackDropClickClose: true,
                        templateUrl : 'pages/partials/chat/media-preview.html'
                    });
                };
                utilsFactory.onCustomEvent('SINGLE_MESSAGE_TIMEDOUT', function(data){
                    var box = data.box;
                    if(!!boxInstance){
                        boxInstance.close();
                    }
                });
                scope.$on("$destroy", function () {
                    utilsFactory.removeCustomEvent('SINGLE_MESSAGE_UPDATED', singleMessageUpdatedEventReference);
                });



            },
            templateUrl: 'pages/partials/chat/message/single.html'

        };
    }

    function chatFileUploadProgress(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/message/upload-progress.html'

        };
    }

    singleMessageStatus.$inject = ['CHAT_GLOBAL_VALUES', 'utilsFactory'];
    function singleMessageStatus(CHAT_GLOBAL_VALUES, utilsFactory){

        var getMessageStatusText = function(isTagChat, messageStatus){
            var statusText = !messageStatus ? 'Pending' : messageStatus;

            if(isTagChat && statusText === 'Sent') {
                statusText = 'Delivered';
            }

            //statusText += ' ' + messageTime;

            return statusText;

        };

        var getMessageTime = function(messageDate){
            var localTime = messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff;
            var localFormatedTime = utilsFactory.chatVerbalDate(localTime);
            return localFormatedTime;
        };

        return {
            restrict: 'E',
            replace: true,
            link : function(scope, elem, attrs){

                scope.$watch("message.status", function(){

                    scope.message.statusText = getMessageStatusText(
                        scope.box.value.isTagChat,
                        scope.message.status
                    );
                    scope.message.statusDate = getMessageTime(scope.message.messageDate);
                    scope.message.statusUserName = scope.message.user.getName();

                });

            },
            template: '<div class="t-chat" ><p ><span title="{{ message.statusUserName }}">{{ message.statusUserName }}</span>  {{ message.statusDate }}  <a data-tooltip-post=" {{message.statusText}} " class=" {{message.statusText}} "></a></p></div>'
        };
    }

    chatHistoryLoader.$inject = ['tagOfflineChatManager', 'tagChatFactory', 'TAG_CHAT_GENERAL_CONSTANTS'];
    function chatHistoryLoader(tagOfflineChatManager, tagChatFactory, TAG_CHAT_GENERAL_CONSTANTS){

        return {
            restrict: 'E',
            replace: true,
            link : function(scope, elem, attrs){
                scope.historyLoading = false;
                //scope.noMoreHistoryMessageText = "Group conversion has not yet started";

                elem.on('click', function(){
                    //scope.historyLoading = true;
                    var chatBox = scope.box.value;
                    var bottomMessage = chatBox.getBottomMessage();

                    var bottomPacketId;

                    if( !bottomMessage){
                        bottomPacketId = tagChatFactory.getUUIDPacketId();
                    }else{
                        bottomPacketId = chatBox.messageMinPacketId;
                    }

                    var historyRequestMethod = tagOfflineChatManager.getHistoryRequestMethodByBox(chatBox);

                    doSendHistoryRequest(scope, historyRequestMethod, chatBox, TAG_CHAT_GENERAL_CONSTANTS.PAGE_DIRECTION.UP, bottomPacketId, 10);


                    //var message = scope.box.value.getBottomMessage(),
                    //    boxId = scope.box.key,
                    //    offlineRequester;
                    //
                    //if(scope.box.value.isTagChat){
                    //    offlineRequester = tagOfflineChatManager.getHistoryMessagesMultipleTimes;
                    //}else{
                    //    offlineRequester = tagOfflineChatManager.getFriendHistoryMessagesMultipleTimes;
                    //}
                    //
                    ////var requestPacketId = scope.box.value.messageMinPacketId;
                    //var requestPacketId = !message ? '' : message.key;
                    //
                    //if ( requestPacketId == ''){
                    //    requestPacketId = tagChatFactory.getUUIDPacketId();
                    //}
                    ////if( !!message){
                    ////    requestPacketId = message.key;//tagChatFactory.getUUIDPacketId(message.messageDate, true);
                    ////}
                    //
                    //if( requestPacketId != ''){
                    //
                    //    scope.historyLoading = true;
                    //    scope.$rgDigest();
                    //
                    //    offlineRequester( boxId, TAG_CHAT_GENERAL_CONSTANTS.PAGE_DIRECTION.UP, requestPacketId )
                    //        .then(function(response){
                    //            if(!!response.sucs){
                    //                scope.historyLoading = false;
                    //            }
                    //        }, function(){
                    //            scope.historyLoading = false;
                    //        });
                    //}



                });
            },
            templateUrl: 'pages/partials/chat/history-loader-view.html'

        };
    }

    /* Single Page Directives */

    function singlePageChatUI(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/home.html',
            controller : 'ChatHistoryController'

        };
    }

    function chatSinglePageTop(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/top.html'

        };
    }

    function chatSinglePageLeft(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/left.html'

        };
    }

    function chatSinglePageRight(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/right.html'

        };
    }

    function chatLeftSingleBox(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/left-single-box.html'

        };
    }

    function chatRightSingleBox(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/right-single-box.html'

        };
    }

    function chatMessageBox(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/message-box.html'

        };
    }

    function chatBoxTopBarStatus(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-topbar-status.html',
            link : function(scope, elem){

            }

        };
    }

    angular
        .module('ringid.chat')
        .directive('chatBoxUi', chatBoxUi)
        .directive('chatBoxTopBar', chatBoxTopBar)
        .directive('chatBoxMiddle', chatBoxMiddle)
        .directive('chatBoxBottom', chatBoxBottom)
        .directive('extraChatBoxes', extraChatBoxes)
        .directive('chatBoxUrlPreview', chatBoxUrlPreview)

        .directive('chatBoxTopBarStatus', chatBoxTopBarStatus)
        .directive('chatBoxTopBarMenu', chatBoxTopBarMenu)
        .directive('chatBoxBottomMenu', chatBoxBottomMenu)
        .directive('chatBoxLocationInfo', chatBoxLocationInfo)

        .directive('chatSingleMessage', chatSingleMessage)
        .directive('chatFileUploadProgress', chatFileUploadProgress)

        .directive('singleMessageStatus', singleMessageStatus)
        .directive('chatHistoryLoader', chatHistoryLoader)

        .directive('singleChatBox', singleChatBox)

        /* Single Page Directives */

        .directive('chatSinglePageTop', chatSinglePageTop)

        .directive('chatSinglePageLeft', chatSinglePageLeft)
        .directive('chatLeftSingleBox', chatLeftSingleBox)

        .directive('chatSinglePageRight', chatSinglePageRight)
        .directive('chatRightSingleBox', chatRightSingleBox)

        .directive('chatMessageBox', chatMessageBox)

        .directive('singlePageChatUI', singlePageChatUI);


})();

/**
 * Created by mahbubul on 8/23/15.
 */

(function(){
    'use strict';

        var chatApp;

        try {
            chatApp = angular.module('ringid.chat');
        } catch (e) {

        }

        chatApp.directive('chatFocus', chatFocusDirective);

        chatFocusDirective.$inject = ['fileUploadService',
            'chatHistoryFactory', '$document', '$rootScope',
             'utilsFactory','Auth',
             'CHAT_GLOBAL_VALUES',
            'ChatHelper', 'CHAT_GENERAL_CONSTANTS',
            'settings','ChatSeenSend', 'ChatPacketSenderService', 'SystemEvents', 'chatTabSync', 'Ringalert'];

        function chatFocusDirective(fileUploadService,
                 chatHistoryFactory, $document, $rootScope,
                 utilsFactory,Auth,
                 CHAT_GLOBAL_VALUES,
                 ChatHelper, CHAT_GENERAL_CONSTANTS,
                 settings,ChatSeenSend, ChatPacketSenderService, SystemEvents, chatTabSync, Ringalert

            ) {
                return {
                    controller: ['$scope','ChatSeenSend', 'ChatHelper', 'Auth', 'rgScrollbarService', function ($scope,ChatSeenSend, ChatHelper, Auth, rgScrollbarService) {
                        $scope.onViewedCalled = function (message) {
                            //console.log('rrr');
                            //var messages = $scope.box.value.getMessages();
                            var box = $scope.box.value;
                            var isTagChat = $scope.box.value.isTagChat;
                            var messages = [{key: message.key, value: message}];
                            var filterMessagesByViewPort = function(messages){
                                var filteredMessages = [];
                                for(var index = 0, length = messages.length; index < length; index++){
                                    if(messages[index].value.user.getKey() !== Auth.loginData.uId
                                        && messages[index].value.status !== "Deleted"
                                        && messages[index].value.status !== "Played"
                                        && messages[index].value.status !== "Viewed"
                                        && messages[index].value.status !== "status_update"
                                        && messages[index].value.seenSent != true
                                    ) {
                                        filteredMessages.push(messages[index]);
                                    }
                                }
                                return filteredMessages;
                            };
                            if(angular.isArray(messages) && messages.length>0){
                                //todo filter by viewport
                                messages = filterMessagesByViewPort(messages);
                                //messages = filterMessageByMessageType(messages);
                                if(messages.length <1){
                                    return;
                                }
                                //ChatHelper.decreaseUnreadCount(box,messages.length);
                                ChatSeenSend.sendSeenPacket(box, messages);

                                if( !isTagChat ){//f2f
                                    ChatHelper.startTimerOthers($scope, messages);
                                }
                            }// end of empty message check logic
                        };
                        $scope.showUnreadMessages = function () {
                            RingLogger.print("Unread Messages shown",RingLogger.tags.CHAT);
                            var box = $scope.box.value;

                            ChatHelper.decreaseUnreadCount(box);

                            $rootScope.$broadcast("ScrollToBottom",box.getKey());                                                

                        };
                    }],
                    link: function(scope, element, attrs) {
                        scope.uploadBoxValue = scope.box.value.getKey();

                        scope.uploadAction = function (actionObj) {

                            RingLogger.print(actionObj,RingLogger.tags.CHAT);
                            var keyOrPacketId = utilsFactory.getUniqueID("ring");
                            var dummyMsgObj = {
                                key             :   keyOrPacketId,
                                uploadProgress  :   actionObj.uploadFile.getProgress,
                                uploading       :   true,
                                message         :   " ",
                                mediaUrl        :   actionObj.uploadFile.getPreview(),
                                //messageDate     :   parseInt(new Date().getTime()),
                                messageDate     :   parseInt(new Date().getTime() + CHAT_GLOBAL_VALUES.serverTimeDiff),
                                messageType     :   CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.IMAGE,
                                packetId        :   keyOrPacketId,
                                sessionId       :   utilsFactory.getToken,
                                timeout         :   0,
                                status          :   0,
                                getMessageTime  : function(){
                                    var localTime = dummyMsgObj.messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff;
                                    var localFormatedTime = utilsFactory.chatVerbalDate(localTime);
                                    return localFormatedTime;
                                },
                                fileUploadObject : actionObj.uploadFile

                            };
                            scope.box.value.pushDummyMessage(dummyMsgObj,Auth.currentUser(),true);

                            fileUploadService.setScopeForDigest(scope);

                            utilsFactory.safeDigest(scope);

                            var afterUploadCallback = function(imgData) {
                                RingLogger.print(imgData, RingLogger.tags.CHAT);

                                fileUploadService.removeScope(scope);

                                if( !!imgData.sucs ){

                                    var box = scope.box.value;
                                    var isTagChat = box.isTagChat;
                                    var isBoxOffline = box.offlineStatus;
                                    var mediaData = { url : imgData.url, caption : imgData.caption, width: imgData.iw, height: imgData.ih };
                                    var msg = settings.imBase + imgData.url;

                                    box.removeMessage(keyOrPacketId);

                                    if(!isTagChat){
                                        ChatHelper.updateFriendPresence(box.getKey());
                                    }

                                    ChatHelper.updateBoxSessionIfRequired(box.getKey(), box);
                                    ChatPacketSenderService.processAndSendMessage(box, msg, CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.IMAGE, {mediaData : mediaData});//messageType = 7 for image file

                                    scope.resetMessageInput();
                                    utilsFactory.safeDigest(scope);

                                    scope.$broadcast("ScrollToBottom", scope.box.value.getKey());

                                }

                            };
                            var uploadFailedCallback = function(response){
                                Ringalert.show({mg:'Image Upload Failed, please try again'}, 'error');
                                box.removeMessage(keyOrPacketId);
                            };

                            actionObj.uploadFile.fetchMeta(function(){

                                dummyMsgObj.message = actionObj.uploadFile.getPreview();
                                dummyMsgObj.uploading = true;

                                actionObj.uploadFile.initUpload().then(function(imgData){
                                    dummyMsgObj.uploading = false;
                                    afterUploadCallback(imgData);
                                }, function(response){
                                    console.log(response);
                                    dummyMsgObj.uploading = false;
                                    uploadFailedCallback(response);
                                });

                            });
                        };

                        utilsFactory.onCustomEvent('BOX_CAM_UPLOAD', function(data){
                            scope.uploadAction(data);
                        });

                        $document.on('click', function(event) {
                            //if(scope.box.value.getKey() !== attrs.chatFocus) // can't receive clicked element for other elements, while this event fires double for clicked element
                            scope.box.value.isFocused = false;
                            //RingLogger.log("removed:"+scope.box.value.getKey() +":"+ scope.box.value.isFocused);
                        });


                        var messages = scope.box.value.getMessages();
                        var box = scope.box.value;
                        var isTagChat = scope.box.value.isTagChat;

                        var filterMessageByMessageType = function(messages){
                            var filteredMessages = [];
                            for(var index = 0, length = messages.length; index < length; index++){
                                switch (messages[index].value.messageType){
                                    case 2 :
                                    case 3 :
                                    case 4 :
                                    case 5 :
                                    case 6 :
                                        filteredMessages.push(messages[index]);
                                        break;
                                }
                            }
                            return filteredMessages;
                        };
                        var filterMessagesByViewPort = function(messages){
                            var filteredMessages = [];
                            for(var index = 0, length = messages.length; index < length; index++){
                                if(messages[index].value.user.getKey() !== Auth.loginData.uId
                                    && messages[index].value.status !== "Deleted"
                                    && messages[index].value.status !== "Played"
                                    && messages[index].value.status !== "Viewed"
                                    && messages[index].value.status !== "status_update"
                                    && messages[index].value.seenSent != true
                                ) {
                                    filteredMessages.push(messages[index]);
                                }
                            }
                            return filteredMessages;
                        };


                        var updateMessagesStatus = function(messages){
                            var messagesToUpdate = [];
                            for(var index = 0, length = messages.length; index < length; index++){
                                if ( messages[index].value.status == 'Unread' && ( !messages[index].value.timeout || messages[index].value.timeout == 0 )  ){
                                    messages[index].value.status = 'Received';
                                    messagesToUpdate.push(messages[index].value);
                                }
                            }

                            chatHistoryFactory.updateMessages(messagesToUpdate, box.getKey());

                        };

                        var decreaseGlobalUnreadCount = function(boxId){
                           chatHistoryFactory.removeUnreadMessageInfoByBoxId(boxId)                            
                        };
                        /* for handling the focus on another tab : starts*/
                        utilsFactory.onCustomEvent(SystemEvents.CHAT.TAB_SYNC_NEW_DATA, function(data){

                            if(CHAT_GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.SECRET_CHAT_TIMER == data.type){
                                RingLogger.information('TAB_FOCUS_TIMER', data, RingLogger.tags.CHAT);
                                if(data.boxId == box.getKey()){
                                    if(angular.isArray(messages) && messages.length>0){
                                        updateMessagesStatus(messages);

                                        //todo filter by viewport
                                        var filteredMessages;
                                        filteredMessages = filterMessagesByViewPort(messages);
                                        filteredMessages = filterMessageByMessageType(filteredMessages);
                                        if(filteredMessages.length <1){
                                            return;
                                        }

                                        decreaseGlobalUnreadCount(data.boxId);
                                        box.updateUnreadCount();

                                        //ChatHelper.decreaseUnreadCount(box,messages.length);
                                        //ChatSeenSend.sendSeenPacket(box, messages);

                                        if( !isTagChat ){//f2f
                                            ChatHelper.startTimerText(scope, filteredMessages);
                                        }
                                    }// end of empty message check logic
                                }
                            }

                        });
                        /* for handling the focus on another tab : ends*/
                        /*for handling use case when user is focused by default:starts*/
                        utilsFactory.onCustomEvent('WAS_FOCUSED', function (data) {
                            var chatBox = data.box;
                            var filteredMessages = data.filteredMessages;
                            if(chatBox.getKey() == box.getKey()) {
                                if (!chatBox.isTagChat) {//f2f
                                    ChatHelper.startTimerText(scope, filteredMessages);
                                }
                                /* for sending the focus to another tab {secretTimer}*/
                                chatTabSync.sendData(CHAT_GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.SECRET_CHAT_TIMER, {boxId: chatBox.getKey()});
                            }
                        });
                        /*for handling use case when user is focused by default:ends*/

                        var onFocusCallback = function (event) {
                            event.stopPropagation();

                            var boxId = scope.box.value.getKey();
                            var box = scope.box.value;

                            var needDigest = false;
                            if( box.unreadCount > 0){
                                decreaseGlobalUnreadCount(boxId);    
                                box.updateUnreadCount();
                                needDigest = true;
                            }

                            RingLogger.print('Focus Called', RingLogger.tags.CHAT);
                            if( !scope.bottomMenuHover && !scope.bottomMenuButtonHover){
                                scope.showBottomMenu = false;
                                needDigest = true;                                
                            }

                            if(needDigest){
                                utilsFactory.safeDigest(scope);
                            }

                            
                            for(var i=0; i<scope.boxes.length; i++){
                                scope.boxes[i].value.isFocused = false;
                            }
                            //handling the case while user is clicking the minimize button then onclick will fire and for this case we need to make isFocused false for that box

                            if (box.isMinimized === true) {
                                box.isFocused = false;
                            } else {
                                box.isFocused = true;
                            }
                            scope.$broadcast("blinkerOff", boxId);
                            scope.$broadcast("focusOn", boxId);

                           
                            
                            if(angular.isArray(messages) && messages.length>0){
                                updateMessagesStatus(messages);

                                //todo filter by viewport
                                var filteredMessages;
                                filteredMessages = filterMessagesByViewPort(messages);
                                filteredMessages = filterMessageByMessageType(filteredMessages);
                                if(filteredMessages.length <1){
                                    return;
                                }


                                //ChatHelper.decreaseUnreadCount(box,messages.length);
                                ChatSeenSend.sendSeenPacket(box, filteredMessages);

                                if( !isTagChat ){//f2f
                                    ChatHelper.startTimerText(scope, filteredMessages);
                                }
                                /* for sending the focus to another tab {secretTimer}*/
                                chatTabSync.sendData(CHAT_GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.SECRET_CHAT_TIMER, {boxId : box.getKey()});
                            }// end of empty message check logic

                            event.stopPropagation();
                            //scope.$digest();
                        };

                        element.on('click', onFocusCallback);
                    }
                };
        }


        //.directive('chatRFocus', ['$document', function ($document) {
        //    return {
        //        restrict: 'A',
        //        link: function (scope, element, attrs) {
        //            //$document.on('click', function(event) {
        //            //    //if(scope.box.value.getKey() !== attrs.chatFocus) // can't receive clicked element for other elements, while this event fires double for clicked element
        //            //    scope.rbox.value.isFocused = false;
        //            //    //RingLogger.log("removed:"+scope.box.value.getKey() +":"+ scope.box.value.isFocused);
        //            //});
        //            element.on('click', function (event) {
        //                //for(var i=0; i<scope.boxes.length; i++){
        //                //    scope.boxes[i].value.isFocused = false;
        //                //}
        //                //handling the case while user is clicking the minimize button then onclick will fire and for this case we need to make isFocused false for that box
        //
        //                //if (scope.rbox.value.isMinimized === true) {
        //                //    scope.rbox.value.isFocused = false;
        //                //} else {
        //                //    scope.rbox.value.isFocused = true;
        //                //}
        //                //scope.$broadcast("blinkerOff", scope.rbox.value.getKey());
        //                //scope.$broadcast("focusOn", scope.rbox.value.getKey());
        //
        //                //RingLogger.log("applied:"+scope.box.value.getKey() +":"+ scope.box.value.isFocused);
        //                //RingLogger.log(scope.boxes);
        //                //event.stopPropagation();
        //            });
        //        }
        //    }; // return object for directive factory function
        //}]);

        //.directive('chatMessageViewed'['ChatSeenSend', 'ChatHelper',
        //    function(ChatSeenSend, ChatHelper){
        //    return{
        //        link: function(scope, element, attrs){
        //            var onViewedCallback = function(event){
        //                console.log('rrr');
        //                var messages = scope.box.value.getMessages();
        //                var box = scope.box.value;
        //                var isTagChat = scope.box.value.isTagChat;
        //                if(angular.isArray(messages) && messages.length>0){
        //                    //todo filter by viewport
        //                    messages = filterMessagesByViewPort(messages);
        //                    messages = filterMessageByMessageType(messages);
        //                    if(messages.length <1){
        //                        return;
        //                    }
        //                    ChatSeenSend.sendSeenPacket(box, messages);
        //
        //                    if( !isTagChat ){//f2f
        //                        ChatHelper.startTimerText(scope, messages);
        //                    }
        //                }// end of empty message check logic
        //                //event.stopPropagation();
        //            };
        //            element.on('click', function(){console.log("bangla")});
        //        }
        //    };
        //}])

})();

/**
 * Created by mahbubul on 8/23/15.
 */
(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}

    chatApp
        .directive('messageDirective', ['Auth', 'profileFactory', '$compile', 'chatHistoryFactory','$interval', 'ChatHelper', 'utilsFactory',
            function (Auth, profileFactory, $compile, chatHistoryFactory,$interval, ChatHelper, utilsFactory) {

            return {
                restrict: 'A',
                scope: true,

                link: function (scope, element, attrs) {

                    var box = scope.$eval(attrs.messageBox);
                    box = box.value;
                    var message = scope.$eval(attrs.messageMsg);
                    //var first_children = element.children();
                    var avatorDom;
                    var dateLineDom;

                    var takeDecisionForShowingMessageUserAvator  = function(){
                        if(box.isConsicutive(message.key)){
                            return false;
                        }else{
                            return true;
                        }
                    };
                    scope.message.takeDecisionForShowingMessageUserAvator = takeDecisionForShowingMessageUserAvator;
                    scope.message.showAvator = takeDecisionForShowingMessageUserAvator();
                    //if( message.status !== 'status_update'){

                        if (message.user.isCurrentUser()) {
                            element.addClass('cm-box-r');
                            if( message.status !== 'status_update') {
                                //if (box.isConsicutive(message.key)) {
                                //
                                //    element.addClass('c-right');
                                //
                                //    first_children.addClass("chat-c chat-bgy");
                                //} else {
                                avatorDom = angular.element('<img ng-show="message.showAvator" class="chat-img-r chat-img" src="' + message.user.avatar('thumb') + '" />');
                                var compiledAvatorDom = $compile(avatorDom)(scope);
                                element.append(compiledAvatorDom);
                                //element.append('<img ng-show="scope.message.showAvator" class="chat-img-r chat-img" src="'+message.user.avatar()+'" />');
                                //first_children.addClass("chat-r icon-c-left cm-sty");
                                //}
                            }
                        } else {
                            element.addClass('cm-box');
                            if( message.status !== 'status_update') {
                                //if (box.isConsicutive(message.key)) {
                                //    element.addClass('c-left');
                                //
                                //    first_children.addClass("chat-c chat-bgw");
                                //} else {
                                avatorDom = angular.element('<img ng-show="message.showAvator" class="chat-img-l chat-img" src="' + message.user.avatar('thumb') + '" />');
                                var compiledAvatorDom = $compile(avatorDom)(scope);
                                element.prepend(compiledAvatorDom);
                                //element.prepend('<img ng-show="scope.message.showAvator" class="chat-img-l chat-img" src="'+message.user.avatar()+'" />');
                                //first_children.addClass("chat-l  icon-c-right");
                                //}
                            }
                        }
                    //}


                    var takeDecisionForShowingDate = function () {
                        var currentMessageDate = Math.floor(message.messageDate / (1000*3600*24))
                        if(box.previousDate != currentMessageDate ){
                            box.previousDate = currentMessageDate;
                            RingLogger.print("PPP: "+box.previousDate+":::",RingLogger.tags.CHAT);
                            RingLogger.print("PPP: "+scope.$id+":::",RingLogger.tags.CHAT);
                            //var today = Math.floor(Date.now() / (1000*3600*24));
                            //if(today === box.previousDate){
                            //    dateLineDom = angular.element('<div class="line"><div class="line-m">Today</div></div><div class="clear"></div>');
                            //}else{
                            //    dateLineDom = angular.element('<div class="line"><div class="line-m">{{ message.messageDate | date }}</div></div><div class="clear"></div>');
                            //}
                            //var compiledDateLineDom = $compile(dateLineDom)(scope);
                            //element.prepend(compiledDateLineDom);
                            return true;
                        } else{
                            return false;
                        }
                    };
                    scope.message.takeDecisionForShowingDate = takeDecisionForShowingDate;
                    scope.message.showDate = takeDecisionForShowingDate();

                    //if(box.previousDate !== Math.floor(message.messageDate / (1000*3600*24)) ){
                    //    box.previousDate = Math.floor(message.messageDate / (1000*3600*24)) ;
                    //    var today = Math.floor(Date.now() / (1000*3600*24));
                    //    if(today === box.previousDate){
                    //        dateLineDom = angular.element('<div class="line"><div class="line-m">Today</div></div><div class="clear"></div>');
                    //    }else{
                    //        dateLineDom = angular.element('<div class="line"><div class="line-m">{{ message.messageDate | date }}</div></div><div class="clear"></div>');
                    //    }
                    //    var compiledDateLineDom = $compile(dateLineDom)(scope);
                    //    element.prepend(compiledDateLineDom);
                    //}
                    dateLineDom = angular.element('<div class="line" ng-show="message.showDate"><div class="line-m">{{ message.messageDate | date }}</div></div><div ng-show="message.showDate" class="clear"></div>');
                    var compiledDateLineDom = $compile(dateLineDom)(scope);
                    element.prepend(compiledDateLineDom);

                    scope.$on('timeoutDelete', function (event,messageKey,timeoutCount) {

                        if(messageKey === message.key){
                            RingLogger.log(messageKey+":"+timeoutCount);
                            if(timeoutCount>0){
                                //scope.message.text = scope.message.text + ""+timeoutCount;
                                scope.message.timeout = timeoutCount;
                                //document.querySelector('.timer-l').children('p').innerHtml(timeoutCount);
                            }else{
                                //Timer ends now what???
                                var messageUserKey = message.user.getKey();
                                if(messageUserKey == Auth.loginData.uId){
                                    //this is for self message
                                    //scope.message.text = "This message is Timed Out";
                                    scope.message.timeout = 0;
                                    //scope.message.setTextPartition();
                                    //for keeping track that this message is timed out
                                    // we're adding a property to meesage object and storing that in localstorage
                                    scope.message.secretTimedOut = true;
                                    switch (scope.message.messageType) {
                                        case 2:
                                        case 3:
                                        case 4://this is for location
                                        case 5://this is for url
                                        case 6:
                                            scope.message.status = 'Deleted';
                                            break;
                                        case 8:
                                            scope.message.status = 'Played';
                                        case 7:
                                        case 9:
                                        case 10:
                                            scope.message.status = 'Viewed';
                                            break;
                                    }// end of switch for messageType
                                    chatHistoryFactory.updateMessage(scope.message, box.getKey());
                                }else{
                                    //this is for others message
                                    //box.removeMessage(messageKey);
                                    //chatHistoryFactory.removeMessage(messageKey,box.getKey());
                                    ChatHelper.deleteMessageFromOwn(box, message);
                                    utilsFactory.triggerCustomEvent("SINGLE_MESSAGE_TIMEDOUT", {box: box});
                                    //scope.message.text = "This message is Timed Out";
                                    //scope.message.timeout = 0;
                                    //scope.message.setTextPartition();
                                    //for keeping track that this message is timed out
                                    //we're adding a property to meesage object and storing that in localstorage
                                    //scope.message.secretTimedOut = true;
                                    //chatHistoryFactory.updateMessage(scope.message, box.getKey());
                                }
                            }
                            //scope.$digest();
                        }
                        //event.stopPropagation();
                    });
                }
            };
        }])

        .directive('editMessage', ['$rootScope', 'CHAT_GLOBAL_VALUES',
            function ($rootScope, CHAT_GLOBAL_VALUES) {

                return {
                    restrict: 'EA',
                    link: function (scope, element, attrs) {
                        element.on('click', function (event) {
                            $rootScope.$broadcast('editMessageEvent', attrs.editMessage, scope.message);
                        });
                        var calculateOneHourFilter = function(messageDate){
                            var currentTime = Math.floor(Date.now());
                            var messageDateInLocalTime = messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff;
                            var diff = currentTime - messageDateInLocalTime;
                            var oneHour = 1000 * 3600;
                            if(diff > oneHour)
                                return false;
                            else
                                return true;
                        };

                        scope.message.canEdit = function(){
                            return (scope.message.user.isCurrentUser() &&
                            calculateOneHourFilter(scope.message.messageDate) &&
                            ([4, 6, 7, 8, 9, 10].indexOf(scope.message.messageType) === -1) &&
                            !(scope.message.timeout>0 || scope.message.secretTimedOut == true)&&
                            (['Deleted', 'status_update', 'Viewed', 'Played'].indexOf(scope.message.status) === -1));

                        };
                    }
                }; // return object for directive factory function

        }])

        .directive('retryMessage', [ 'ChatPacketSenderService', 'CHAT_STATES', 'ChatApiService',
            function ( ChatPacketSenderService, CHAT_STATES, ChatApiService) {

                return {
                    restrict: 'EA',
                    link: function (scope, element, attrs) {
                        element.on('click', function (event) {
                            ChatPacketSenderService.retryMessage(scope.box.value, scope.message, scope.messageData);
                            //ChatPacketSenderService.processAndSendMessage(scope.box.value, scope.messageText, messageType, scope.messageData);
                        });

                    }
                }; // return object for directive factory function

            }])

        .directive('deleteMessage', ['Storage', 'PacketDataParse',
            'utilsFactory', 'Auth', 'globalSocketFactory',
            'CHAT_PACKET_FORMAT', 'tagChatFactory',
            'tagChatApiService', 'CHAT_GLOBAL_VALUES', 'ChatApiService', 'ChatHelper',

            function (Storage, PacketDataParse,
                      utilsFactory, Auth, globalSocketFactory,
                      CHAT_PACKET_FORMAT, tagChatFactory,
                      tagChatApiService, CHAT_GLOBAL_VALUES,
                      ChatApiService, ChatHelper

            ) {

                return {
                    restrict: 'EA',
                    link: function (scope, element, attrs) {

                        scope.message.canDelete = function(){
                            return (['status_update'].indexOf(scope.message.status) === -1);
                        };

                        element.on('click', function (event) {
                            ChatHelper.deleteMessageFromOwn(scope.box.value, scope.message);
                            if(scope.message.user.getKey().toString() === Auth.loginData.uId.toString()) {
                                if (scope.box.value.isTagChat) {// for tagChat

                                    var tagId = scope.box.value.getKey();
                                    var tagObject = tagChatFactory.getTag(tagId);
                                    var messagePacketId = scope.message.key;
                                    var packetId = tagChatFactory.getUUIDPacketId();

                                    for(var index = 0; index < 5; index++) {
                                        setTimeout(function(){
                                            tagChatApiService.deleteTagMultipleMsgInChatServer(Auth.loginData.uId, tagObject, packetId, [messagePacketId])
                                        }, 100);
                                    }


                                } else {// for individual chat
                                    if(scope.message.secretTimedOut != true || scope.message.timeout>0){// checking if it was not a secret Message as delete message packet won't be sent for secret message

                                        scope.box.value.sendTabUpdate(scope.message);

                                        var deleteObject = ChatApiService.getF2FMessageDeleteObject(scope.box.value, scope.message.key);

                                        for(var index = 0; index < 5; index++){
                                            setTimeout(function() {
                                                ChatApiService.sendViaGlobalChatSocket(deleteObject, CHAT_PACKET_FORMAT.DELETE_PKT_OFFLINE);
                                            }, 100);
                                        }
                                    }
                                }
                            }

                        });
                    }


                }; // return object for directive factory function
            }])
        .directive('chatMessageReact',  ['profileFactory', function (profileFactory) {
            return {
                restrict: 'A',
                link: function (scope, element, attrs) {
                    var message = scope.$eval(attrs.chatMessageReact);

                    var SClasses = ['status_pending','status_delivered','status_seen','status_sent'];

                    var doUpdateStatus = function(){

                        if( message.status == 'status_update'){
                            element.addClass('status_update');

                        } else{
                            if(message.user.isCurrentUser()){
                                element.addClass('status_received');
                            }else{
                                if(SClasses[message.status]){
                                    element.addClass(SClasses[message.status]);
                                }
                            }
                        }
                    };

                    if(!angular.isObject(message.user)){

                        profileFactory.getUserDetailsByUId(message.user).then(function (userObj) {
                            if (!!userObj) {
                                message.user = userObj;
                                doUpdateStatus();
                            }
                        });

                    }else{
                        doUpdateStatus();
                    }
                }
            }; // return object for directive factory function
        }])
        /*
         * Description: directive to send message from individual chatbox textarea
         * param: userId (which is the key for the stackmap)
         * Dependency: ChatFactory
         * Scope: same scope as chatController
         * Event: emitting ScrollToBottom event which will be grabbed to make the scroll to bottom at new messages is sent
         * Date: 01-04-15
         * Developed By: rabbi
         * */
        .directive('sendMessageDirective', ['ChatFactory','$timeout','PacketDataParse',
            'PullerSubscriber', 'tagChatApiService', 'tagChatFactory', 'tagChatManager','$$connector', 'OPERATION_TYPES', 'AUTH_SERVER_ACTIONS',
            'CHAT_GENERAL_CONSTANTS', 'ChatPacketSenderService', 'ChatHelper', 'utilsFactory', 'SystemEvents', 'Ringalert',

            function (ChatFactory,$timeout,PacketDataParse,
                      PullerSubscriber, tagChatApiService, tagChatFactory, tagChatManager,$$connector, OPERATION_TYPES, AUTH_SERVER_ACTIONS,
                      CHAT_GENERAL_CONSTANTS, ChatPacketSenderService, ChatHelper, utilsFactory, SystemEvents, Ringalert

            ) {
                return {
                    restrict: 'A',
                    link: function (scope, element, attrs) {
                        scope.messageText = "";

                        scope.selectedLocation = function(){
                            
                            scope.$emit("ScrollToBottom", scope.box.value.getKey());    

                            utilsFactory.getUserLocation().then(function(location){
                                if( location.sucs ){
                                    scope.messageData.locationData = location;

                                    ChatHelper.updateBoxSessionIfRequired(scope.box.value.getKey(), scope.box.value);

                                    if( !!location.lat && location.lat != 9999) {
                                        ChatPacketSenderService.processAndSendMessage(scope.box.value, '', CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.LOCATION_SHARE, scope.messageData);                                        
                                    }else{
                                        RingLogger.alert('Location Lat not found.', location,  RingLogger.tags.CHAT);                                        
                                    }                    

                                    scope.$rgDigest();
                                    scope.$emit("ScrollToBottom", scope.box.value.getKey());    

                                }else{
                                    Ringalert.show({mg: 'Please Enable Browser Location Tracking.'}, 'error');
                                    RingLogger.alert(location.error, RingLogger.tags.CHAT);
                                }                            
                            })                            

                            scope.resetMessageInput(true);                            
                        };


                        scope.selectEmoticonChat = function (emoticon) {

                            if (emoticon.isSticker() || emoticon.isLargeEmoticon()) {
                                scope.resetMessageInput();

                                /*checking online of offline :starts*/
                                if(!scope.box.value.isTagChat) { // as there is offline status on tagchat, so there is no need to check offlinestatus for tagchat

                                    var friendId = scope.box.value.getKey();

                                    ChatHelper.updateFriendPresence(friendId, scope.box.value);

                                }

                                /*checking online of offline :ends*/
                                if(scope.box.value.offlineStatus === true){

                                    // offline
                                    ChatPacketSenderService.processAndSendOfflineMessage(scope.box.value, emoticon.srcWithoutBase(), 6);//messageType=6 for sticker

                                } else{

                                    // online
                                    ChatHelper.updateBoxSessionIfRequired(scope.box.value.getKey(), scope.box.value);
                                    ChatPacketSenderService.processAndSendMessage(scope.box.value, emoticon.srcWithoutBase(), 6);//messageType=6 for sticker

                                    scope.messageText = "";
                                }

                                utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_SUBMITTED, { boxId : scope.box.value.getKey() });

                                scope.messageText = "";

                                scope.$emit("ScrollToBottom", scope.box.value.getKey());

                            }else{

                                scope.messageText = scope.messageText +""+ emoticon.symbol();

                                element[0].focus();
                            }
                        };

                        var bindEvent = function () {
                            element.on('keyup', function (event) {

/*############################: ReDesign of message sending/typing: starts:(14-12-2015) :########################################################################*/

                                var messageType = CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.TEXT;

                                if(!!scope.messageData.locationData.lat){
                                    messageType =  CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.LOCATION_SHARE;
                                }else if(!!scope.messageData.ogData.url){
                                    messageType =  CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.LINK_SHARE;
                                }

                                var sendTypingPacket = function(){

                                    var doSendTypingPacket = function() {
                                        if (scope.box.value.isTyping() === false) {
                                            ChatPacketSenderService.sendTypingPacket(scope.box.value);
                                            scope.box.value.setTypingBool(true);
                                            $timeout(function () {
                                                scope.box.value.setTypingBool(false);
                                            }, 5000);
                                        }
                                    };

                                    //checking 3min passed since last communication

                                    if(!scope.box.value.checkWaitingTimePassed()){
                                        if( scope.box.value.isTagChat) {
                                            doSendTypingPacket();

                                        }else {
                                            if(scope.box.value.offlineStatus === false) {
                                                doSendTypingPacket();
                                            }
                                        }
                                    }
                                };


                                if(scope.box.value.isTagChat){//tagChat

                                    //there is no message sending to offline for tagChat

                                    if(event.which === 13){//sending message
                                        scope.messageText = scope.messageText.replace(/\n/g, '');

                                        if(scope.messageText !== ''){//empty message checking

                                            //var utf8String = scope.messageText.utf8Encode();

                                            if( scope.box.value.checkWaitingTimePassed()){//checks if time has passed. if passed then request the register process

                                                //TODO there might have been produce an issue where one register request is sent and before getting response another message is tried to be sent so another register request is sent. what will be the use case for that situartion?

                                                var tagId = scope.box.value.getKey();
                                                tagChatManager.requestForIp(tagId);

                                            }


                                            if(element.attr('messageKey')){
                                                scope.box.value.editMessageKey = element.attr('messageKey');
                                                element.removeAttr('messageKey');
                                                scope.box.value.editMessageDate = element.attr('messageDate');
                                                element.removeAttr('messageDate');
                                                element.removeClass('editing');
                                            }

                                            ChatPacketSenderService.processAndSendMessage(scope.box.value, scope.messageText, messageType, scope.messageData);
                                            utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_SUBMITTED, { boxId : scope.box.value.getKey() });

                                            scope.resetMessageInput(true);

                                            scope.$emit("ScrollToBottom", scope.box.value.getKey());

                                        }// end of empty message checking

                                    // end of tagChat sending message

                                    }else{//sending typing
                                        sendTypingPacket();

                                    }//end of tagChat send typing

                                //end of tagChat

                                }else{//friendChat

                                    // check message or typing first
                                    if(event.which === 13){

                                        // for sending messages
                                        if(scope.messageText !==''){//checking for empty message
                                            scope.messageText = scope.messageText.replace(/\n/g, '');

                                            //check online/offline second
                                            //var utf8String = scope.messageText.utf8Encode();
                                            var friendId = scope.box.value.getKey();

                                            //online/offline decision is taken so now handle
                                            //TODO here might be a problem, cause it is not sending depending on current taken decision but sending depending on previously taken decision;
                                            //TODO though it is taking decision every time. we are doing this way because if we wait for current decision there is a waiting time on user experience.

                                            if(element.attr('messageKey')){
                                                scope.box.value.editMessageKey = element.attr('messageKey');
                                                element.removeAttr('messageKey');
                                                scope.box.value.editMessageDate = element.attr('messageDate');
                                                element.removeAttr('messageDate');
                                            }

                                            if(scope.box.value.offlineStatus === true){
                                                //offline
                                                // for offline we don't need to check 3min passing either
                                                ChatPacketSenderService.processAndSendOfflineMessage(scope.box.value, scope.messageText, messageType, false, scope.messageData);

                                            }else{
                                                //online
                                                ChatHelper.updateBoxSessionIfRequired(scope.box.value.getKey(), scope.box.value);
                                                ChatPacketSenderService.processAndSendMessage(scope.box.value, scope.messageText, messageType, scope.messageData);
                                            }

                                            utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_SUBMITTED, { boxId : scope.box.value.getKey() });

                                            element.removeClass('editing');
                                            scope.$emit("ScrollToBottom", scope.box.value.getKey());
                                            scope.resetMessageInput(true);
                                        }
                                    }else {
                                        sendTypingPacket();
                                    }

                                }
                            });
                        };

                        var unbindEvent = function () {
                            element.off('keyup');
                        };

                        bindEvent();

                        scope.$on('$destroy', unbindEvent);

                        if(scope.box.value.isFocused === true){
                            element[0].focus();
                        }


                        scope.$on('editMessageEvent', function (event, boxKey, messageObj) {
                            if(scope.box.value.getKey() == boxKey){

                                var messageType = messageObj.messageType;

                                switch (messageType){

                                    case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.TEXT:
                                        scope.messageText = messageObj.text;
                                        break;

                                    case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.LOCATION_SHARE:
                                        scope.locationData = messageObj.locationInfo;
                                        break;

                                    case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.LINK_SHARE:
                                        var jsonObject = angular.fromJson(messageObj.text);
                                        scope.messageText = messageObj.ogData.message || messageObj.ogData.description
                                        break;

                                    //case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.STICKER:
                                    //case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.IMAGE:
                                    //case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.CAMERA_IMAGE:
                                    //case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.AUDIO:
                                    //case CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.VIDEO:

                                }

                                element.addClass('editing');
                                element.attr('messageKey', messageObj.key);
                                element.attr('messageDate', messageObj.messageDate);

                                utilsFactory.safeDigest(scope);
                            }
                        });
                    }

                }; // return object for directive factory function
            }]);


})();

/**
 * Created by mahbubul on 8/23/15.
 */
(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}


    chatApp.directive('chatSubscriber', chatSubscriber);

    chatSubscriber.$inject = ['SystemEvents','fileUploadService', 'PullerSubscriber','ChatFactory', 'profileFactory',
        'PacketDataParse','userFactory','utilsFactory','$interval','$timeout','globalSocketFactory',
        'Storage','CHAT_PACKET_FORMAT','Auth','chatHistoryFactory',
        'TAG_CHAT_PACKET_TYPE', 'TAG_CHAT_GENERAL_CONSTANTS',
        'tagChatFactory', 'tagChatApiService', 'tagChatManager', 'tagChatHelper','CHAT_GLOBAL_VALUES',
        'tagChatPacketProcessor', 'ChatHelper', 'ChatPacketSenderService'];

    function chatSubscriber(SystemEvents, fileUploadService, PullerSubscriber,ChatFactory, profileFactory,
                  PacketDataParse,userFactory,utilsFactory,$interval,$timeout,globalSocketFactory,
                  Storage,CHAT_PACKET_FORMAT,Auth,chatHistoryFactory,
                  TAG_CHAT_PACKET_TYPE, TAG_CHAT_GENERAL_CONSTANTS,
                  tagChatFactory, tagChatApiService, tagChatManager, tagChatHelper,CHAT_GLOBAL_VALUES,
                  tagChatPacketProcessor, ChatHelper, ChatPacketSenderService
        ) {

        function safeExecute(func) {
            try {
                func.call();
            } catch (e) {
                RingLogger.alert(e.stack, 'chat-safe-execute', RingLogger.tags.CHAT);
            }
        }

        return {
            scope: false,
            restrict: 'A',
            link: function (scope, element, attrs) {

                scope.offlineConfirmReceived = false;

                var chatDataReceivedCallback = function(event, dataObj){
                    var byteData = dataObj.byteData;
                    var ip;
                    var packetType = PacketDataParse.getPacketType(byteData);

                    safeExecute(function(){
                        switch (packetType){
                            //case 2:
                            case 2: // for unregister receiving packet; when friend sends unregister packet to chat server and it sends to the friend

                                var unregisterObject = PacketDataParse.parsePacket(byteData,2,CHAT_PACKET_FORMAT.FRIEND_UNREGISTER_PKT.FORMAT);
                                var box = ChatFactory.getBoxByUId(unregisterObject.userId);
                                if(unregisterObject.userId === box.getKey()){
                                    ChatFactory.closeChatBox(box.getKey());
                                }
                                break;

                            case 3: // for receiving confirm register packet; when friend sends register packet to chat server and it sends to both user and the friend

                                var confirmRegisterObject = PacketDataParse.parsePacket(byteData, 3, CHAT_PACKET_FORMAT.REGISTER_CONFIRM_PKT.FORMAT);
                                var box = ChatFactory.getBoxByUId(confirmRegisterObject.friendId);
                                //box.nonDomBox = true;

                                /*setting serverTimeDiff: starts*/
                                CHAT_GLOBAL_VALUES.serverTimeDiff = confirmRegisterObject.serverDate - Date.now();
                                /*setting serverTimeDiff: ends*/

                                if(!box){
                                    box = ChatFactory.creatNonDomBox(confirmRegisterObject.friendId, false);//false for isTagChat flag
                                }

                                box.setPort(confirmRegisterObject.port);
                                box.lastCommunicationTime = Math.floor(Date.now() / 1000);

                                ChatHelper.sendAfterRegisterIdlePacket(box.getKey(), box);

                                //Sending Idle Packet In Accroding to New Change.
                                //box.initInterval();


                                ChatPacketSenderService.sendIdlePacket(box);

                                ChatPacketSenderService.sendTemporaryMessages(box);


                                //$timeout(function(){
                                //    while(angular.isArray(box.tempMessageArray) && box.tempMessageArray.length >0){
                                //        var individualMsgObject = box.tempMessageArray.shift();
                                //        // Need to reset ip and port, because while this message was pushed in temp array then ip,port was for that time,
                                //        // and 3 minutes has passed so we've requested another request and server is sending binding port again, which might
                                //        // not be the same as was before. so we're resetting the ip and port for those messages individually
                                //        individualMsgObject.ip = box.getIp();
                                //        individualMsgObject.port = box.getPort();
                                //
                                //        ChatPacketSenderService.processAndSendMessage(box, individualMsgObject, individualMsgObject.messageType, individualMsgObject.messageData);
                                //
                                //        //var pkt = PacketDataParse.constructPacket(individualMsgObject, 5, CHAT_PACKET_FORMAT.CHAT_MSG.FORMAT);
                                //        //globalSocketFactory.send(pkt);
                                //    }
                                //
                                //}, 3000);

                                utilsFactory.triggerCustomEvent(SystemEvents.CHAT.CHAT_REGISTER, { friendId : confirmRegisterObject.friendId });


                                break;
                            case 4://idle : previous:10
                                //var idleObject = PacketDataParse.processIdlePacket(byteData);
                                var idleObject = PacketDataParse.parsePacket(byteData,10,CHAT_PACKET_FORMAT.IDLE_PKT.FORMAT);
                                var box = ChatFactory.getBoxByUId(idleObject.userId);
                                //box.lastCommunicationTime = Math.floor(Date.now() / 1000);
                                //chatHistoryFactory.updateBox(box);
                                if(box)
                                    box.setFriendTypingBool(false);//optional: it just changes user status to idle; while typing to idle it might  need to change to remove typing status
                                //RingLogger.print(idleObject, RingLogger.tags.CHAT);
                                break;
                            case 5: //typing : previous:9
                                //var typingObject = PacketDataParse.processIdlePacket(byteData);
                                var typingObject = PacketDataParse.parsePacket(byteData,9,CHAT_PACKET_FORMAT.TYPING_PKT.FORMAT);

                                var boxId;
                                if( typingObject.userId == Auth.currentUser().getKey() ){
                                    boxId = typingObject.friendId;
                                }else{
                                    boxId = typingObject.userId;
                                }

                                var box = ChatFactory.getBoxByUId(boxId);
                                //if user closes the box in the mean time then reopen it
                                //if(!box){
                                //    ChatFactory.openChatBox(typingObject.userId);
                                //    box = ChatFactory.getBoxByUId(typingObject.userId);
                                //}
                                if(box){ // no need to open box for typing, if box is closed; and for this scenario no need to update box
                                    box.setFriendTypingBool(true);
                                    box.lastCommunicationTime = Math.floor(Date.now() / 1000);
                                    chatHistoryFactory.updateBox(box);
                                    $timeout(function () {
                                        box.setFriendTypingBool(false);
                                    },3000);
                                }
                                break;
                            case 6: //for receiving msg from sender : previous:5
                                break; /* Handled In Tag Chat */
                                //var message = PacketDataParse.processChatMsgPacket(byteData);
                                var message = PacketDataParse.parsePacket(byteData,6,CHAT_PACKET_FORMAT.CHAT_MSG.FORMAT);
                                var box = ChatFactory.getBoxByUId(message.userId);// this method returns undefined if box is not found in boxes stackmap
                                //if user closes the box in the mean time then reopen it
                                if(!box){
                                    ChatFactory.openChatBox(message.userId);
                                    box = ChatFactory.getBoxByUId(message.userId);
                                    PullerSubscriber.requestForIp(box.getKey()); //here getKey() returns either userId or tagId
                                    /* if box is not found which means user closed the box, in that case we have to load message history from localstorage */
                                    box.loadHistoryMessages();

                                }

                                if( !box.isSamePacketId(message.packetId) ){
                                    ChatHelper.increaseUnreadCount(box,1);
                                }

                                message.user  = userFactory.getUser(message.userId);
                                var userId = box.getKey();
                                message.status = 'Received';
                                message.tag_chat = false;//for inserting into localhistory so that while getting from localstorage it can parse message and show correct image
                                box.pushMessage(message, box.getKey(), true);
                                box.nonDomBox = true;
                                //box.isMinimized = false;
                                box.lastCommunicationTime = Math.floor(Date.now() / 1000);
                                box.setFriendTypingBool(false);//optional: it just changes user status to idle; while typing to idle it might  need to change to remove typing status

                                chatHistoryFactory.updateBox(box);
                                scope.$broadcast("blinkerEvent", userId);
                                //scope.$broadcast("ScrollToBottom", userId);
                                var deliverObject = {
                                    sessionId: utilsFactory.getToken,
                                    //sessionId: '12345678',
                                    ip: box.getIp(),
                                    port: box.getPort(),
                                    packetId: message.packetId,
                                    packetType: 15, // 6 is for delivered packet and 7 for seen packet : previous:6
                                    userId: message.friendId,
                                    friendId: message.userId,
                                    messageDate: parseInt(new Date().getTime() + CHAT_GLOBAL_VALUES.serverTimeDiff),
                                    platform : 5
                                };
                                //var constructDeliverPacket = PacketDataParse.constructDeliverPacket(deliverObject);
                                var constructDeliverPacket = PacketDataParse.constructPacket(deliverObject,15,CHAT_PACKET_FORMAT.DELIVER_PKT.FORMAT);
                                RingLogger.print(message, RingLogger.tags.CHAT);
                                globalSocketFactory.send(constructDeliverPacket);
                                //box.send(constructDeliverPacket); // sending deliver response as a token of receiving packet
                                break;
                            case 7: //for receiving edit msg from sender : previous:43
                                break; /* Handled In Tag Chat */
                                //var message = PacketDataParse.processChatMsgPacket(byteData);
                                var message = PacketDataParse.parsePacket(byteData,7,CHAT_PACKET_FORMAT.CHAT_MSG.FORMAT);
                                var box = ChatFactory.getBoxByUId(message.userId);// this method returns undefined if box is not found in boxes stackmap
                                //if user closes the box in the mean time then reopen it
                                if(!box){
                                    ChatFactory.openChatBox(message.userId);
                                    box = ChatFactory.getBoxByUId(message.userId);
                                    PullerSubscriber.requestForIp(box.getKey()); //here getKey() returns either userId or tagId
                                    /* if box is not found which means user closed the box, in that case we have to load message history from localstorage */
                                    box.loadHistoryMessages();
                                }
                                ChatHelper.increaseUnreadCount(box,1);
                                message.user  = userFactory.getUser(message.userId);
                                var userId = box.getKey();
                                message.status = 'Edited';
                                message.tag_chat = false;//for inserting into localhistory so that while getting from localstorage it can parse message and show correct image
                                box.pushMessage(message, box.getKey(), true);
                                box.nonDomBox = true;
                                //box.isMinimized = false;
                                box.lastCommunicationTime = Math.floor(Date.now() / 1000);
                                box.setFriendTypingBool(false);//optional: it just changes user status to idle; while typing to idle it might  need to change to remove typing status
                                chatHistoryFactory.updateBox(box);
                                scope.$broadcast("blinkerEvent", userId);
                                //scope.$broadcast("ScrollToBottom", userId);
                                var deliverObject = {
                                    sessionId: utilsFactory.getToken,
                                    //sessionId: '12345678',
                                    ip: box.getIp(),
                                    port: box.getPort(),
                                    packetId: message.packetId,
                                    packetType: 15, // 6 is for delivered packet and 7 for seen packet: previous:6
                                    userId: message.friendId,
                                    friendId: message.userId,
                                    messageDate: parseInt(new Date().getTime() + CHAT_GLOBAL_VALUES.serverTimeDiff)
                                };
                                //var constructDeliverPacket = PacketDataParse.constructDeliverPacket(deliverObject);
                                var constructDeliverPacket = PacketDataParse.constructPacket(deliverObject,15,CHAT_PACKET_FORMAT.DELIVER_PKT.FORMAT);
                                //RingLogger.log(message);
                                RingLogger.print(message,RingLogger.tags.CHAT);
                                globalSocketFactory.send(constructDeliverPacket);
                                //box.send(constructDeliverPacket); // sending deliver response as a token of receiving packet

                                break;
                            case 15: //deliver packet receiving : previous:6
                                //var deliverObject = PacketDataParse.processDeliverPacket(byteData);
                                var deliverObject = PacketDataParse.parsePacket(byteData,6,CHAT_PACKET_FORMAT.DELIVER_PKT.FORMAT);

                                var boxId;
                                if( deliverObject.userId == Auth.currentUser().getKey() ){
                                    boxId = deliverObject.friendId;
                                }else{
                                    boxId = deliverObject.userId;
                                }

                                var box = ChatFactory.getBoxByUId(boxId);
                                //if user closes the box in the mean time then reopen it
                                if(!box){
                                    //ChatFactory.openChatBox(boxId);
                                    ChatFactory.creatNonDomBox(boxId, false);//false for isTagChat flag
                                    box = ChatFactory.getBoxByUId(boxId);
                                    box.nonDomBox = false;//we don't want to reopen and show the box to user for getting deliver/seen/delete packet
                                    PullerSubscriber.requestForIp(box.getKey()); //here getKey() returns either userId or tagId
                                    /* if box is not found which means user closed the box, in that case we have to load message history from localstorage */
                                    box.loadHistoryMessages();
                                }
                                box.lastCommunicationTime = Math.floor(Date.now() / 1000);
                                chatHistoryFactory.updateBox(box);

                                var msgObj    = box.getMessage(deliverObject.packetId);
                                if(!!msgObj){
                                    if( msgObj.status != 'Seen'
                                        && msgObj.status != 'Deleted'
                                        && msgObj.status != 'Viewed'
                                        && msgObj.status != 'Played'){
                                        msgObj.status = 'Delivered';
                                    }
                                    chatHistoryFactory.updateMessage(msgObj, box.getKey());
                                    box.sendTabUpdate(msgObj);
                                }


                                //var msgObj = box.getMessages();
                                //for(var j= 0; j < msgObj.length; j++){
                                //    if(deliverObject.packetId === msgObj[j].key){
                                //        //RingLogger.print('fun', RingLogger.tags.CHAT);
                                //        msgObj[j].value.status = 'Delivered';
                                //        chatHistoryFactory.updateMessage(msgObj[j].value, box.getKey());
                                //    }
                                //}
                                //RingLogger.print(msgObj[0].value.status, RingLogger.tags.CHAT);
                                //RingLogger.print(deliverObject, RingLogger.tags.CHAT);
                                break;
                            case 16: // sent packet receiving : previous:8
                                //var seenObject = PacketDataParse.processDeliverPacket(byteData);
                                var sentObject = PacketDataParse.parsePacket(byteData,7,CHAT_PACKET_FORMAT.SENT_PKT.FORMAT);

                                var boxId;
                                if( sentObject.userId == Auth.currentUser().getKey() ){
                                    boxId = sentObject.friendId;
                                }else{
                                    boxId = sentObject.userId;
                                }

                                var box = ChatFactory.getBoxByUId(boxId);
                                //if user closes the box in the mean time then reopen it
                                if(!box){
                                    //ChatFactory.openChatBox(boxId);
                                    ChatFactory.creatNonDomBox(boxId, false);//false for isTagChat flag
                                    box = ChatFactory.getBoxByUId(boxId);
                                    box.nonDomBox = false;//we don't want to reopen and show the box to user for getting deliver/seen/delete packet
                                    PullerSubscriber.requestForIp(box.getKey()); //here getKey() returns either userId or tagId
                                    /* if box is not found which means user closed the box, in that case we have to load message history from localstorage */
                                    box.loadHistoryMessages();
                                }
                                box.lastCommunicationTime = Math.floor(Date.now() / 1000);
                                chatHistoryFactory.updateBox(box);

                                var msgObj    = box.getMessage(sentObject.packetId);
                                if(!!msgObj){
                                    if( msgObj.status != 'Seen'
                                        && msgObj.status != 'Deleted'
                                        && msgObj.status != 'Viewed'
                                        && msgObj.status != 'Played'){
                                        msgObj.status = 'Delivered';
                                    }

                                    chatHistoryFactory.updateMessage(msgObj, box.getKey());
                                    box.sendTabUpdate(msgObj);
                                }

                                //var msgObj = box.getMessages();
                                //for(var j= 0; j < msgObj.length; j++){
                                //    if(sentObject.packetId === msgObj[j].key){
                                //        //RingLogger.print('fun', RingLogger.tags.CHAT);
                                //        //we have to show message status delivered even in case of sent
                                //        //msgObj[j].value.status = 'Sent';
                                //        msgObj[j].value.status = 'Delivered';
                                //        chatHistoryFactory.updateMessage(msgObj[j].value, box.getKey());
                                //    }
                                //}
                                break;
                            case 17: // seen packet receiving : previous:7
                                //var seenObject = PacketDataParse.processDeliverPacket(byteData);

                                //var seenObject = PacketDataParse.parsePacket(byteData,7,CHAT_PACKET_FORMAT.SEEN_PKT.FORMAT);
                                var seenObject = tagChatPacketProcessor.parseRawPacket(byteData);

                                var boxId, sendConfirmation = true;
                                if( seenObject.userId == Auth.currentUser().getKey() ){
                                    boxId = seenObject.friendId;
                                    sendConfirmation = false;
                                }else{
                                    boxId = seenObject.userId;
                                }

                                var box = ChatFactory.getBoxByUId(boxId);
                                var ip = box.ip;
                                var port = box.port;

                                //if user closes the box in the mean time then reopen it
                                if(!box){
                                    //ChatFactory.openChatBox(boxId);
                                    ChatFactory.creatNonDomBox(boxId, false);//false for isTagChat flag
                                    box = ChatFactory.getBoxByUId(boxId);
                                    box.nonDomBox = false;//we don't want to reopen and show the box to user for getting deliver/seen/delete packet
                                    PullerSubscriber.requestForIp(box.getKey()); //here getKey() returns either userId or tagId
                                    /* if box is not found which means user closed the box, in that case we have to load message history from localstorage */
                                    box.loadHistoryMessages();
                                }
                                box.lastCommunicationTime = Math.floor(Date.now() / 1000);
                                chatHistoryFactory.updateBox(box);

                                for(var index = 0; index < seenObject.messages.length; index++){
                                    var aBoxMessage = box.getMessage(seenObject.messages[index].packetId);
                                    if(!!aBoxMessage){
                                        if(seenObject.messages[index].status == 3){
                                            aBoxMessage.status = 'Seen';
                                            ChatHelper.startTimerText(scope, [{key:seenObject.messages[index].packetId, value: aBoxMessage}]);
                                        }
                                        else if (seenObject.messages[index].status == 4){
                                            aBoxMessage.status = 'Viewed';
                                            ChatHelper.startTimerOthers(scope, [{key:seenObject.messages[index].packetId, value: aBoxMessage}]);
                                        }

                                        chatHistoryFactory.updateMessage(aBoxMessage, box.getKey());
                                        box.sendTabUpdate(aBoxMessage);
                                    }

                                }

                                if(sendConfirmation){
                                    ChatHelper.sendChatSeenConfirmation(ip, port,
                                        Auth.currentUser().getKey(), seenObject.userId, seenObject.packetId
                                    );
                                }

                                break;

                            case 18:
                                var seenConfirmObject = PacketDataParse.parsePacket(byteData,18,CHAT_PACKET_FORMAT.SEEN_PKT_CONFIRM.FORMAT);
                                RingLogger.information('SEEN_PACKET_CONFIRMATION', seenConfirmObject);

                                break;

                            case 19://delete(multiple) : previous:24
                                //var deleteObject = PacketDataParse.processDeletePacket(byteData);
                                var deleteObject = PacketDataParse.parsePacket(byteData,19,CHAT_PACKET_FORMAT.DELETE_PKT.FORMAT);

                                var boxId,
                                    sendConfirmation = true,
                                    ownMessage = false;
                                if( deleteObject.userId == Auth.currentUser().getKey() ){
                                    boxId = deleteObject.friendId;
                                    sendConfirmation = false;
                                    ownMessage = true;
                                }else{
                                    boxId = deleteObject.userId;
                                }

                                var box = ChatFactory.getBoxByUId(boxId);
                                //if user closes the box in the mean time then reopen it
                                if(!box){
                                    //ChatFactory.openChatBox(boxId);
                                    ChatFactory.creatNonDomBox(boxId, false);//false for isTagChat flag
                                    box = ChatFactory.getBoxByUId(boxId);
                                    box.nonDomBox = false;//we don't want to reopen and show the box to user for getting deliver/seen/delete packet
                                    PullerSubscriber.requestForIp(box.getKey()); //here getKey() returns either userId or tagId
                                    /* if box is not found which means user closed the box, in that case we have to load message history from localstorage */
                                    box.loadHistoryMessages();
                                }
                                box.lastCommunicationTime = Math.floor(Date.now() / 1000);
                                chatHistoryFactory.updateBox(box);

                                for (var k = 0; k < deleteObject.noOfMessages; k++) {
                                    var msgKey = deleteObject.packetData[k].packetId;
                                    var msgObj    = box.getMessage(msgKey);
                                    if(!!msgObj){

                                        if( !ownMessage ){
                                            msgObj.text   = 'This message has been deleted';
                                            msgObj.setTextPartition();
                                            msgObj.status = 'Deleted';

                                        }else{
                                            box.removeMessage(msgKey);
                                        }

                                        chatHistoryFactory.updateMessage(msgObj, box.getKey());
                                        box.sendTabUpdate(msgObj);
                                    }
                                }

                                //var msgObj = box.getMessages();
                                //for (var k = 0; k < deleteObject.noOfMessages; k++){
                                //    for(var j= 0; j < msgObj.length; j++){
                                //        //if(deleteObject.packetId === msgObj[j].key){
                                //        if(deleteObject.packetData[k].packetId === msgObj[j].key){
                                //            //RingLogger.print('fun', RingLogger.tags.CHAT);
                                //
                                //            break;
                                //        }
                                //    }
                                //}

                                if( sendConfirmation ){
                                    //send delete confirm packet
                                    var deleteConfirmObject = {
                                        sessionId: utilsFactory.getToken,
                                        //sessionId: '12345678',
                                        ip: box.getIp(),
                                        port: box.getPort(),
                                        packetId: deleteObject.packetId,
                                        packetType: 20, // 24 is for delete friend chat packet and 25 for delete confirm friend chat packet : previous:25
                                        userId: deleteObject.friendId,
                                        friendId: deleteObject.userId
                                    };
                                    //var constructDeleteConfirmPacket = PacketDataParse.constructDeliverPacket(deleteConfirmObject);
                                    var constructDeleteConfirmPacket = PacketDataParse.constructPacket(deleteConfirmObject,20, CHAT_PACKET_FORMAT.DELETE_CONFIRM_PKT.FORMAT);
                                    globalSocketFactory.send(constructDeleteConfirmPacket);
                                    //box.send(constructDeleteConfirmPacket);
                                }

                                break;
                            case 20://delete confirmation : previous:25
                                //var deleteConfirmObject = PacketDataParse.processDeliverPacket(byteData);
                                var deleteConfirmObject = PacketDataParse.parsePacket(byteData, 20, CHAT_PACKET_FORMAT.DELETE_CONFIRM_PKT.FORMAT);
                                var box = ChatFactory.getBoxByUId(deleteConfirmObject.userId);
                                //if user closes the box in the mean time then reopen it
                                if(!box){
                                    //ChatFactory.openChatBox(deleteConfirmObject.userId);
                                    ChatFactory.creatNonDomBox(deleteConfirmObject.userId, false);//false for isTagChat flag
                                    box = ChatFactory.getBoxByUId(deleteConfirmObject.userId);
                                    box.nonDomBox = false;//we don't want to reopen and show the box to user for getting deliver/seen/delete packet
                                    PullerSubscriber.requestForIp(box.getKey()); //here getKey() returns either userId or tagId
                                    /* if box is not found which means user closed the box, in that case we have to load message history from localstorage */
                                    box.loadHistoryMessages();
                                }
                                box.lastCommunicationTime = Math.floor(Date.now() / 1000);
                                chatHistoryFactory.updateBox(box);

                                break;
                            case 94://offline confirmation[get request confirmation] which is sent from server : previous:23
                                //var offlineConfirmationObject = PacketDataParse.processOfflineConfirmPacket(byteData);
                                var offlineConfirmationObject = PacketDataParse.parsePacket(byteData, 94, CHAT_PACKET_FORMAT.OFFLINE_CONFIRM_PKT.FORMAT);
                                /*setting serverTimeDiff: starts*/
                                CHAT_GLOBAL_VALUES.serverTimeDiff = offlineConfirmationObject.messageDate - Date.now();
                                /*setting serverTimeDiff: ends*/
                                //TODO might need to do something here when we've got offline confirmation.(ideal thing which is to be done is, stop sending offline request )
                                scope.offlineConfirmReceived = true;


                                RingLogger.print(offlineConfirmationObject, RingLogger.tags.CHAT);
                                //RingLogger.log('offline confirmation');
                                RingLogger.print("Offline: offline confirmation received",RingLogger.tags.CHAT);
                                break;
                            case 95: // friend offline[unread] message : previous:20
                                break;
                                var offlineMessageObject = PacketDataParse.parsePacket(byteData, 95, CHAT_PACKET_FORMAT.FRIEND_OFFLINE_PKT.FORMAT);
                                RingLogger.print('offline msg', offlineMessageObject, RingLogger.tags.CHAT);
                                var packetIds = [];
                                var messageObjects = {};
                                for(var j=0; j<offlineMessageObject.noOfMessages; j++){
                                    //var offlinePacketType = offlineMessageObject.packetData[j].packetType;
                                    // no need to send any confirmation for these packets individually
                                    // offline message confirmation packet will be sent with all packetID list at the end
                                    // and there is only message packet(with multiple and broken) and delete packet will come in offline
                                    switch (offlineMessageObject.packetData[j].packetType){
                                        case 6://f2f chat message : previous:5
                                            if(offlineMessageObject.packetData[j].messageType != 0 && offlineMessageObject.packetData[j].messageType != 1){
                                                var userId = offlineMessageObject.packetData[j].userId;
                                                //need to open multiple boxes to show offline message from different users while the 1st user logs in
                                                var box = ChatFactory.getBoxByUId(userId);
                                                if(!box){
                                                    //ChatFactory.openChatBox(userId);
                                                    ChatFactory.creatNonDomBox(userId, false);//false for isTagChat flag
                                                    box = ChatFactory.getBoxByUId(userId);
                                                    box.nonDomBox = false;//we don't want to reopen and show the box to user for getting deliver/seen packet
                                                    // for inserting last messages from chat history
                                                    box.loadHistoryMessages();
                                                }
                                                if(offlineMessageObject.packetData[j].messageType ==0){
                                                    var msgObj = box.getMessages();
                                                    for(var k= 0; k < msgObj.length; k++){
                                                        if(offlineMessageObject.packetData[j].packetId === msgObj[k].key){
                                                            //RingLogger.print('fun', RingLogger.tags.CHAT);
                                                            msgObj[k].value.text = 'This message has been deleted';
                                                            msgObj[k].value.setTextPartition();
                                                            msgObj[k].value.status = 'Deleted';
                                                            chatHistoryFactory.updateMessage(msgObj[k].value, box.getKey());
                                                            packetIds.push(offlineMessageObject.packetData[j].packetId);
                                                            break;
                                                            //packetIds.push({
                                                            //    pacektId:offlineMessageObject.packetData[j].packetId,
                                                            //    userId: offlineMessageObject.packetData[j].userId,
                                                            //    messageDate: offlineMessageObject.packetData[j].messageDate
                                                            //});
                                                        }
                                                    }
                                                }else{
                                                    if( !box.isSamePacketId(offlineMessageObject.packetData[j].packetId) ){
                                                        ChatHelper.increaseUnreadCount(box);
                                                    }
                                                    offlineMessageObject.packetData[j].status = 'Received';
                                                    box.nonDomBox = true;//we don't want to reopen and show the box to user for getting deliver/seen packet; but we do want to open for message
                                                    box.pushMessage(offlineMessageObject.packetData[j], box.getKey());
                                                    //box.lastCommunicationTime = Math.floor(Date.now() / 1000);// this is the offline last communiction time which may cause problem for chat server commucation
                                                }

                                                chatHistoryFactory.updateBox(box);
                                                packetIds.push(offlineMessageObject.packetData[j].packetId);

                                                //messageObjects.push({
                                                //    pacektId:offlineMessageObject.packetData[j].packetId,
                                                //    userId: offlineMessageObject.packetData[j].userId,
                                                //    messageDate: offlineMessageObject.packetData[j].messageDate
                                                //});

                                            }
                                            break;
                                        //we dont need this delete packet id as it is coming with messagetype 0,

                                    }//end of each message switch block
                                }// end of each message loop
                                if(packetIds.length > 0){
                                    var loginData = Storage.getData("loginData");
                                    var friendOfflineConfirmObject = {
                                        ip: loginData.oIP,
                                        port: loginData.oPrt,
                                        packetType: 96, // packetType is 58 for offline[unread] message getting confirmation : previous:58
                                        tag_chat: false,
                                        userId : loginData.uId,// used to construct packetData for sending
                                        packetId : offlineMessageObject.packetId,// used to construct packetData for sending
                                        noOfMessages : packetIds.length, // this is the noOfMessage of offline message object which is known here as noOfPackets
                                        packetIds : packetIds,
                                        platform : 5
                                    };
                                    //var constructOfflineConfirmPacket2 = PacketDataParse.constructOfflineConfirmPacket2(friendOfflineConfirmObject);
                                    var friendOfflineConfirmPacket = PacketDataParse.constructPacket(friendOfflineConfirmObject, 96, CHAT_PACKET_FORMAT.FRIEND_OFFLINE_CONFIRM_PKT.FORMAT);
                                    globalSocketFactory.send(friendOfflineConfirmPacket);
                                    //RingLogger.log("offline confirmation sent");
                                    //RingLogger.log(offlineMessageObject);
                                    RingLogger.print("offline confirmation sent",RingLogger.tags.CHAT);
                                    RingLogger.print(offlineMessageObject,RingLogger.tags.CHAT);
                                }else{
                                    //RingLogger.log("no offline confirmation sent");
                                    //RingLogger.log(offlineMessageObject);
                                    RingLogger.print("no offline confirmation sent",RingLogger.tags.CHAT);
                                    RingLogger.print(offlineMessageObject,RingLogger.tags.CHAT);
                                }
                                break;
                            default :
                                //RingLogger.log('Tag Chat Packet, Passing to TagChat Subscriber', packetType);
                                break;
                        }//end of switch(packetType)
                    });

                    //utilsFactory.triggerCustomEvent("SINGLE_MESSAGE_UPDATED", {message: message});
                    scope.$digest();//we might not need it in future
                    //ChatFactory.processInMessage(message);
                };
                scope.$on('chatDataReceived',chatDataReceivedCallback);//end of scope.$on 'chatDataReceived'
            } //end of link function
        }; // return object for directive factory function
    }


})();

/**
 * Created by mahbubul on 8/23/15.
 */
(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
        //console.log('rrradlsfja;ls');
    } catch (e) {
        //console.log('bbbbbbbbbb');
        chatApp = angular
            .module('ringid.chat', [
                'ringid.config',
                'ringid.common.stacked_map',
                'ngWebSocket',
                'ringid.utils',
                'ringid.common.chat_factory',
                'ngStorage',
                'ringid.common.rgemoticon_directive',
                'ringid.puller',
                'ringid.connector',
                'ringid.common.rgupload_directive',
                'ringid.tagchat'
            ]);
    }
    chatApp
        .directive('setTimeout', ['ChatFactory','$compile','$document', function (ChatFactory, $compile, $document) {
            return {
                restrict: 'EA',
                //replace: true,
                template: '<a><span class="icon-timer-s"></span></a>',
                link: function (scope, element, attrs) {
                    //var showTimeout = false,
                    var timeoutBarCompiledDom,
                        openTimeoutPopup = function () {
                            scope.showTimeout = true;
                            scope.closeSettingPopup();
                            $document.bind('click', closeTimeoutPopup);

                            var timeoutBarDom = angular.element('<set-timeout-bar ></set-timeout-bar>');
                            timeoutBarCompiledDom = $compile(timeoutBarDom)(scope);
                            //element.append(timeoutBarCompiledDom);
                            //element.parent().parent().next().prepend(timeoutBarCompiledDom);
                            element.parent().parent().parent().next().prepend(timeoutBarCompiledDom);
                        },
                        closeTimeoutPopup = function () {
                            scope.showTimeout = false;
                            $document.unbind('click', closeTimeoutPopup);
                            if(timeoutBarCompiledDom)
                                timeoutBarCompiledDom.remove();
                        };
                    scope.closeTimeoutPopup = function () {
                        closeTimeoutPopup();
                    };
                    scope.showTimeout = false;

                    element.on('click', function (event) {
                        //console.log('cl');
                        console.dir(scope.showTimeout);
                        if (!scope.showTimeout) {
                            openTimeoutPopup();
                        } else {
                            closeTimeoutPopup();
                        }
                        event.stopPropagation();
                    });

                }
            }; // return object for directive factory function
        }])
        .directive('setTimeoutBar', ['ChatFactory','$compile', function (ChatFactory,$compile) {
            return {
                restrict: 'E',
                //replace: true,
                template:'<div class="timeout-area-with-popup"><div class="timeoutDivnew">\n\
<span class="enable-secret-chat">Enable Secret Chat:</span><div class="switchnew"><input class="float-left" ng-model="box.value.secretChat" type="checkbox"><label><i></i></label></div>\n\
<a href="#" ng-click="cancel($event)" ng-disabled="!box.value.secretChat" class="correct-sec icon-close-b"></a>\n\
<a href="#" ng-click="showValueBox($event)" class="timeout-sec icon-time"><p>sec</p><span>{{ timeout>4 ? timeout : 5}}</span></a></div></div>',
//<a href="#" ng-click="done($event)" ng-disabled="!box.value.secretChat" class="correct-icon-sec"></a>\n\
//<input class="timer-c" type="number" value="17" min="1" max="300" step="1" ng-model="timeout" ng-disabled="!box.value.secretChat" />\n\
//<br/>\n\
//<input class="btn-timer" type="button" ng-click="done($event)" value="Done" ng-disabled="!box.value.secretChat" />\n\
//<input class="btn-timer float-right" type="button" ng-click="cancel($event)" ng-disabled="!box.value.secretChat" value="Cancel"/>\n\
//</div>',
                link: function (scope, element, attrs) {
                    var timeoutVarriable = 0;
                    var timeoutVaueCompiledDom;

                    //element.on('keyup', function (event) {
                    //    scope.box.value.timeout = scope.timeout;
                    //});
                    scope.timeout = scope.box.value.timeout;
                    scope.showTimeoutBox = false;
                    //scope.secretChat = scope.box.value.secretChat;
                    //scope.box.value.secretChat = scope.secretChat;

                    //scope.done = function ($event) {
                    //    if(scope.timeout)
                    //        timeoutVarriable = parseInt(scope.timeout);
                    //    scope.box.value.timeout = timeoutVarriable;
                    //    //scope.box.value.secretChat = scope.secretChat;
                    //    //console.dir(scope.box.value.secretChat);
                    //    scope.closeTimeoutPopup();
                    //    //scope.showTimeout = true;
                    //    //element.remove();
                    //    //scope.$digest();
                    //    //scope.closeTimeoutPopup();
                    //    //element.remove();
                    //    if(!!$event)
                    //        $event.stopPropagation();
                    //};
                    scope.cancel = function ($event) {
                        //scope.box.value.timeout = 0;
                        //alert('cancel:'+scope.box.value.getKey())
                        scope.closeTimeoutPopup();
                        if(!!$event){
                            $event.preventDefault();
                            $event.stopPropagation();
                        }
                    };
                    scope.showValueBox = function ($event) {
                        if (!scope.showTimeoutBox) {
                            scope.showTimeoutBox = true;
                            var timeoutValueDom = angular.element('<set-timeout-Value ></set-timeout-Value>');
                            timeoutVaueCompiledDom = $compile(timeoutValueDom)(scope);
                            element.children(0).append(timeoutVaueCompiledDom);
                        } else{
                            scope.hideValueBox();
                        }

                        if(!!$event){
                            $event.preventDefault();
                            $event.stopPropagation();
                        }
                    };
                    scope.hideValueBox = function($event){
                        scope.showTimeoutBox = false;
                        if(timeoutVaueCompiledDom)
                            timeoutVaueCompiledDom.remove();
                        if(!!$event){
                            $event.preventDefault();
                            $event.stopPropagation();
                        }

                    };
                    element.on('click', function (event) {
                        //event.preventDefault();
                        event.stopPropagation();
                    });
                    //element.on('click', function (event) {
                    //    scope.showTimeout = false;
                    //    console.log('r:' + scope.showTimeout);
                    //    event.stopPropagation();
                    //});

                }
            }; // return object for directive factory function
        }])
        .directive('setTimeoutValue', ['ChatFactory', function (ChatFactory) {
            return {
                restrict: 'EA',
                templateUrl: 'pages/partials/chat-timeout-value-box.html',
                link: function (scope, element, attrs) {
                    //element.on('click', function (event) {
                    //    //console.log('cl');
                    //    if (!scope.showTimeout) {
                    //        openTimeoutPopup();
                    //    } else {
                    //        closeTimeoutPopup();
                    //    }
                    //    event.stopPropagation();
                    //});
                    scope.selectTimeout = function ($event, time) {
                        scope.box.value.timeout = scope.timeout = time;
                        scope.hideValueBox($event);
                        //scope.$digest();
                    }
                }
            }; // return object for directive factory function
        }])
        ;
})();
/**
 * Created by mahbubul on 2/4/16.
 */
/**
 * Created by mahbubul on 8/23/15.
 */
(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
        //console.log('rrradlsfja;ls');
    } catch (e) {
        //console.log('bbbbbbbbbb');
        chatApp = angular
            .module('ringid.chat', [
                'ringid.config',
                'ringid.common.stacked_map',
                'ngWebSocket',
                'ringid.utils',
                'ringid.common.chat_factory',
                'ngStorage',
                'ringid.common.rgemoticon_directive',
                'ringid.puller',
                'ringid.connector',
                'ringid.common.rgupload_directive',
                'ringid.tagchat'
            ]);
    }
    chatApp
        .directive('setting', ['ChatFactory','$compile','$document', function (ChatFactory, $compile, $document) {
            return {
                restrict: 'EA',
                //replace: true,
                template: '<a><span class="icon-g-settings"></span></a>',
                link: function (scope, element, attrs) {
                    //var showTimeout = false,
                    var settingBarCompiledDom,
                        openSettingPopup = function () {
                            scope.showSetting = true;
                            scope.closeTimeoutPopup();
                            $document.bind('click', closeSettingPopup);

                            var settingBarDom = angular.element('<setting-bar ></setting-bar>');
                            settingBarCompiledDom = $compile(settingBarDom)(scope);
                            //element.append(timeoutBarCompiledDom);
                            //element.parent().parent().next().prepend(timeoutBarCompiledDom);
                            element.parent().parent().parent().next().prepend(settingBarCompiledDom);
                        },
                        closeSettingPopup = function () {
                            scope.showSetting = false;
                            $document.unbind('click', closeSettingPopup);
                            if(settingBarCompiledDom)
                                settingBarCompiledDom.remove();
                        };
                    scope.closeSettingPopup = function () {
                        closeSettingPopup();
                    };
                    scope.showSetting = false;

                    element.on('click', function (event) {
                        //console.log('cl');
                        console.dir(scope.showSetting);
                        if (!scope.showSetting) {
                            openSettingPopup();
                        } else {
                            closeSettingPopup();
                        }
                        event.stopPropagation();
                    });

                }
            }; // return object for directive factory function
        }])
        .directive('settingBar', ['ChatFactory','$compile', function (ChatFactory,$compile) {
            return {
                restrict: 'E',
                //replace: true,
                //<span class="enable-block">Block:</span><div class="switch-enable-block"><input class="float-left" ng-model="box.value.blocked" type="checkbox"><label><i></i></label></div>\n\
                template:'<div class="timeout-area-with-popup"><div class="timeoutDivnew">\n\
<span class="secret-visible">Timer:</span><div class="switch-secret-visible"><input class="float-left" ng-model="box.value.isSecretVisible" type="checkbox"><label><i></i></label></div>\n\
<a href="#" ng-click="cancel($event)" ng-disabled="!box.value.secretChat" class="correct-sec icon-close-b"></a>\n\
</div></div>',
//<a href="#" ng-click="done($event)" ng-disabled="!box.value.secretChat" class="correct-icon-sec"></a>\n\
//<input class="timer-c" type="number" value="17" min="1" max="300" step="1" ng-model="timeout" ng-disabled="!box.value.secretChat" />\n\
//<br/>\n\
//<input class="btn-timer" type="button" ng-click="done($event)" value="Done" ng-disabled="!box.value.secretChat" />\n\
//<input class="btn-timer float-right" type="button" ng-click="cancel($event)" ng-disabled="!box.value.secretChat" value="Cancel"/>\n\
//</div>',
                link: function (scope, element, attrs) {
                    scope.cancel = function ($event) {
                        //scope.box.value.timeout = 0;
                        //alert('cancel:'+scope.box.value.getKey())
                        scope.closeSettingPopup();
                        if(!!$event){
                            $event.preventDefault();
                            $event.stopPropagation();
                        }
                    };
                    element.on('click', function (event) {
                        //event.preventDefault();
                        event.stopPropagation();
                    });

                }
            }; // return object for directive factory function
        }])
    ;
})();
/*
 * © Ipvision
 */

(function() {
	'use strict';
	var app = angular .module('ringid.tagchat', ['ringid']);

	app.filter('prettyJSON', function () {
		function prettyPrintJson(json) {
			return JSON ? JSON.stringify(json, null, '  ') : 'your browser doesnt support JSON so cant pretty print';
		}
		return prettyPrintJson;
	});

})();


/*
 * Md. Ibrahim Rashid
 * © Ipvision
 */

(function() {
	'use strict';

		var tagChatApp = angular.module('ringid.tagchat');

        var TAG_CHAT_GENERAL_CONSTANTS = {

            //Debug
            LOCAL_CHAT                      : false,
            LOCAL_CHAT_REG_IP               : '192.168.1.125',
            LOCAL_CHAT_REG_PORT             : 1500,
            LOCAL_CHAT_OFFLINE_IP           : '192.168.1.125',
            LOCAL_CHAT_OFFLINE_PORT         : 1200,

            API_VERSION                     : 3,
            API_VERSION_PORT_OFFSET         : 0,

            PACKET_IP_SIZE                  :  4,
            PACKET_PORT_SIZE                :  2,

            PACKET_DYNAMIC_ATTRIBUTE        : -1,
            PACKET_RAW_BYTE_ATTRIBUTE       : -2,


            ONE_BYTE_SIZE                   :  1,
            TWO_BYTE_SIZE                   :  2,
            FOUR_BYTE_SIZE                  :  4,
            EIGHT_BYTE_SIZE                 :  8,

            TAG_ID_NO_OF_TIME_DIGIT         : 10,
            TAG_ID_NO_OF_USER_ID_DIGIT      : 6,

            PACKET_MAX_SIZE                 : 512,
            AUTH_UID_LIST_LIMIT             : 15,


            /*** Timing Variables ***/


            ACTUAL_TAG_REGISTER_TIMEOUT     : 180,
            TAG_REGISTER_TIMEOUT            : 150, // 180 seconds actual value, giving some space
            API_FETCH_RETRY_COUNT           : 5,
            API_FETCH_RETRY_DELAY           : 3000 , // 3000 miliseconds
            RETRY_COUNT                     : 5,
            REQUEST_TIMEOUT                 : 3000 * 6,

            BOX_WAITING_TIME                : 180, // seconds

            UDP_SERVER_KEEP_ALIVE_INTERVAL  : 10000, // miliseconds

            REQUEST_CACHE_VALIDITY          : 3000, // miliseconds
            RESPONSE_CACHE_VALIDITY         : 3000, // miliseconds

            /** MAPS **/

            ATTRIBUTE_TYPE                  : { INTEGER : 1, STRING : 2, BYTE : 3 },

            MEMBER_STATUS                   : { MEMBER : 1, ADMIN : 2,  OWNER   : 3, REMOVED : 4, LEAVE : 5 },
            MEMBER_MOODS                    : { ONLINE : 1, AWAY  : 2,  OFFLINE : 3, DO_NOT_DISTURB : 4 },

            REGISTRATION_TYPES              : { CREATE : 1, ONLY_REGISTER : 2, CHAT_INVITE : 3 },

            MESSAGE_STATUS                  : { UNREAD : -1, DELETED : 0, SENT : 1, DELIVERED  : 2,  SEEN : 3, VIEWED : 4, PLAYED : 4 },
            MESSAGE_TYPES                   : {
                                                    DELETE_MESSAGE          : 0,
                                                    BLANK_MESSAGE           : 1,
                                                    PLAIN_MESSAGE           : 2,
                                                    EMOTICON_MESSAGE        : 3,
                                                    LOCATION_MESSAGE        : 4,
                                                    LINK_MESSAGE            : 5,
                                                    DOWNLOAD_STICKER_MESSAGE: 6,
                                                    IMAGE_FILE_FROM_GALLERY : 7,
                                                    AUDIO_FILE              : 8,
                                                    VIDEO_FILE              : 9,
                                                    IMAGE_FILE_FROM_CAMERA  : 10,
                                                    FILE_STREAM             : 11,
                                                    HISTORY_RE_FETCH        : 14,
                                                    GROUP_ACTIVITY          : 20
                                              },


            STATUS_MESSAGE_TYPES            : { TAG_MEMBER_ADD : 1,
                                                TAG_MEMBER_DELETE : 2,
                                                TAG_MEMBER_LEAVE : 3,
                                                TAG_MEMBER_STATUS_CHANGE_OWNER : 4,
                                                TAG_MEMBER_STATUS_CHANGE_ADMIN : 5,
                                                TAG_MEMBER_STATUS_CHANGE_MEMBER : 6,
                                                TAG_NAME_CHANGE : 7,
                                                TAG_PICTURE_CHANGE : 8,
                                                TAG_INFO_UPDATED : 9,
                                                TAG_ADMIN_ADD : 10  },

            PAGE_DIRECTION                  : { UP : 1, DOWN : 2 },

            ONLINE_STATUS                   : { OFFLINE : 1, ONLINE : 2, AWAY : 3},
            ONLINE_MOOD                     : { ALIVE : 1, DONT_DISTURB : 2, BUSY : 3, INVISIBLE: 4},
            SECRET_VISIBILITY               : { NON_VISIBLE : 0, VISIBLE : 1 },

            TAG_ACTIVITY_TYPE               : { DELETED : 0, ADDED : 1, LEAVE : 2, TAG_RENAME: 3, MEMBER_TYPE_CHANGE : 4, TAG_URL_RENAME : 5, TAG_CREATED : 6}



        };

        /** Generate Reverse Maps **/
        var itemKey, itemValue, itemPropKey, itemPropValue;
        for(itemKey in TAG_CHAT_GENERAL_CONSTANTS){
            itemValue = TAG_CHAT_GENERAL_CONSTANTS[itemKey]
            if(angular.isObject(itemValue)){
                TAG_CHAT_GENERAL_CONSTANTS[itemKey +'_VALUE'] = [];
                for( itemPropKey in itemValue){
                    itemPropValue = itemValue[itemPropKey];
                    TAG_CHAT_GENERAL_CONSTANTS[itemKey +'_VALUE'][itemPropValue] = itemPropKey
                }
            }
        }


        var FRIEND_CHAT_PACKET_TYPE = {
            
            FRIEND_CHAT_REGISTER 							    : 1,
            FRIEND_CHAT_UNREGISTER 							    : 2,
            FRIEND_CHAT_REGISTER_CONFIRMATION 					: 3,
            
            FRIEND_CHAT_IDLE 									: 4,
            FRIEND_CHAT_TYPING 									: 5,

            FRIEND_CHAT_MSG										: 6,
            FRIEND_CHAT_MSG_EDIT								: 7,
            FRIEND_CHAT_BROKEN_MSG								: 8,
            FRIEND_CHAT_BROKEN_MSG_EDIT							: 9,
            FRIEND_CHAT_MULTIPLE_MSG       						: 10,


            FRIEND_CHAT_DELIVERED 								: 15,
            FRIEND_CHAT_SENT 									: 16,
            FRIEND_CHAT_SEEN 									: 17,
            FRIEND_CHAT_SEEN_CONFIRMATION						: 18,

            FRIEND_CHAT_MULTIPLE_MSG_DELETE						: 19,

            FRIEND_CHAT_MSG_DELETE_CONFIRMATION 				: 20,

            FRIEND_BROKEN                         				: 24,
            FRIEND_BROKEN_CONFIRMATION            				: 25,

            FRIEND_CHAT_BLOCK                    				: 27,
            FRIEND_CHAT_UNBLOCK          				        : 28,
            FRIEND_CHAT_BLOCK_UNBLOCK_CONFIRMATION 				: 29


        };

		var TAG_CHAT_PACKET_TYPE = {

            TAG_CHAT_TAG_REGISTER 								: 41,
            TAG_CHAT_TAG_UNREGISTER 							: 42,
            TAG_CHAT_TAG_REGISTER_CONFIRMATION 					: 43,

            TAG_CHAT_TAG_INFORMATION				            : 46,
            TAG_CHAT_TAG_INFORMATION_CONFIRMATION               : 47,

            TAG_CHAT_TAG_MEMBER_ADD 							: 51,
            TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION 				: 52,

            TAG_CHAT_MEMBER_REMOVE_LEAVE 						: 53,
            TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION 			: 54,

            TAG_CHAT_TAG_MEMBER_TYPE_CHANGE 					: 55,
            TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION 		: 56,


            TAG_CHAT_IDLE 										: 61,
            TAG_CHAT_TYPING 									: 62,

            TAG_CHAT_MSG										: 63,
            TAG_CHAT_MSG_EDIT									: 64,
            TAG_CHAT_BROKEN_MSG									: 65,
            TAG_CHAT_BROKEN_MSG_EDIT							: 66,
            TAG_CHAT_MULTIPLE_MSG       						: 67,


            TAG_CHAT_DELIVERED 									: 68,
            TAG_CHAT_SENT 										: 69,
            TAG_CHAT_SEEN 										: 70,
            TAG_CHAT_SEEN_CONFIRMATION							: 71,

            TAG_CHAT_MULTIPLE_MSG_DELETE						: 72,

            TAG_CHAT_MSG_DELETE_CONFIRMATION 					: 73,


            TAG_CHAT_GENERAL_BROKEN_PACKET                      : 74,
            TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION         : 75

        };

        var OFFLINE_PACKET_TYPE = {

            OFFLINE_FRIEND_INFORMATION                                  : 91,
            OFFLINE_FRIEND_INFORMATION_CONFIRMATION                     : 92,

            OFFLINE_GET_REQUEST                                         : 93,
            OFFLINE_GET_REQUEST_CONFIRMATION                            : 94,
            OFFLINE_FRIEND_UNREAD_MESSAGE                               : 95,
            OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION                  : 96,
            OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST                      : 97,
            OFFLINE_FRIEND_HISTORY_MESSAGE                              : 98,
            OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION                 : 99,
            OFFLINE_GET_FRIEND_MESSAGE_STATUS                           : 100,
            OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION              : 101,

            OFFLINE_TAG_INFORMATION_ACTIVITY    					    : 104,

            OFFLINE_MY_TAG_LIST                 					    : 105,

            OFFLINE_TAG_UNREAD_MESSAGE                                  : 106,
            OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION                     : 107,

            OFFLINE_TAG_CREATE_TAG      							    : 108,
            OFFLINE_TAG_CREATE_TAG_CONFIRMATION 				        : 109,

            OFFLINE_TAG_HISTORY_MESSAGE_REQUEST                         : 110,
            OFFLINE_TAG_HISTORY_MESSAGE                                 : 111,

            OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS   	        	    : 112,
            OFFLINE_TAG_INFORMATION_WITH_MEMBERS				        : 113,

            OFFLINE_TAG_CONFIRMATION                                    : 117,

            OFFLINE_BROKEN_HISTORY_PACKET                               : 118,
            OFFLINE_BROKEN_PACKET                                       : 119,
            OFFLINE_BROKEN_PACKET_CONFIRMATION                          : 120
        };


        var TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP = {};

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER]                           = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION]                        = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD]                         = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_MULTIPLE_MSG_DELETE]                    = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_DELETE_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE]                    = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE]                 = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET]                  = TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG]                                    = [ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT, TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED, TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN ];

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_EDIT]                               = [ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT, TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED, TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN ];

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG]                             = [ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT, TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED, TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN ];

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG_EDIT]                        = [ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT, TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED, TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN ];

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED]                              = [TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN, TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN_CONFIRMATION];

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN]                                   = TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN_CONFIRMATION;


        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG]                           = OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST]                              = OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST_CONFIRMATION;
        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP

            [OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE]                       = OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET]                            = OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET_CONFIRMATION;
        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP

            [OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_HISTORY_PACKET]                    = OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE_REQUEST]              = OFFLINE_PACKET_TYPE.OFFLINE_TAG_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [OFFLINE_PACKET_TYPE.OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS]         = OFFLINE_PACKET_TYPE.OFFLINE_TAG_CONFIRMATION;

        /******************************************** F2F CONFIRMATIONS ********************************/

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_REGISTER]                            = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_REGISTER_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG]                                 = [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN];

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG_EDIT]                            = [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN ];

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG]                          = [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN ];

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG_EDIT]                     = [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN ];

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED]                           = [ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN_CONFIRMATION ];

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN]                                = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [FRIEND_CHAT_PACKET_TYPE.FRIEND_BROKEN]                                   = FRIEND_CHAT_PACKET_TYPE.FRIEND_BROKEN_CONFIRMATION;

        //TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
        //    [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BLOCK]                               = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BLOCK_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_INFORMATION]                          = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_INFORMATION_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE]                       = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST]              = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE]                      = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION;

        TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP
            [OFFLINE_PACKET_TYPE.OFFLINE_GET_FRIEND_MESSAGE_STATUS]                   = OFFLINE_PACKET_TYPE.OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION;


    var TAG_CHAT_PACKET_ATTRIBUTE = {
			PACKET_TYPE											: 1,
			USER_ID												: 2,
			FRIEND_ID 											: 3,
			PACKET_ID_LENGTH 									: 4,
			PACKET_ID 											: 5,
			PLATFORM 											: 6,
			CHAT_BINDING_PORT 									: 7,
			TAG_ID 												: 8,
			ONLINE_STATUS 										: 9,
			USER_MOOD 											: 10,
			MESSAGE_TYPE 										: 11,
			TIMEOUT 											: 12,
			LATITUDE 											: 13,
			LONGITUDE 											: 14,
			MESSAGE_LENGTH 										: 15,
			MESSAGE 											: 16,
			MESSAGE_DATE 										: 17,
			NO_OF_MESSAGE 										: 18,
			FULL_NAME_LENGTH 									: 19,
			FULL_NAME 											: 20,
			NO_OF_PACKET 										: 21,
			SEQUENCE_NO 										: 22,
			NO_OF_MEMBERS 										: 23,
			UPDATE_TIME 										: 24,
			SERVER_DATE 										: 25,
            LAST_ONLINE_TIME 									: 26,
            NO_OF_ITEMS                                         : 27,
            BLOCK_UNBLOCK_DATE                                  : 28,
            MESSAGE_STATUS                                      : 29,
            IS_ADD_TO_DB                                        : 30,

			TAG_NAME_LENGTH 									: 31,
			TAG_NAME 											: 32,
			TAG_PICTURE_URL_LENGTH 								: 33,
			TAG_PICTURE_URL 									: 34,
			TAG_MEMBER_TYPE 									: 35,
			TAG_MEMBER_ADDED_BY									: 36,
			TAG_NO_OF_MEMBERS 									: 37,
			TAG_NO_OF_BROKEN_PKT 								: 38,
            TAG_INFORMATION_UPDATE_FLAG                         : 39,
            TAG_INFORMATION_TAG_NO_OF_MEMBERS                   : 40,

            REGISTRATION_TYPE                                   : 41,
            PAGE_DIRECTION                                      : 42,
            PAGE_LIMIT                                          : 43,
            ACTIVITY_TYPE                                       : 45,
            ACTIVITY_VALUE_LENGTH                               : 46,
            ACTIVITY_VALUE                                      : 47,
            CHANGED_BY_USER_ID                                  : 48,

            FRIEND_APP_TYPE                                     : 60,
            FRIEND_DEVICE_TOKEN_LENGTH                          : 61,
            FRIEND_DEVICE_TOKEN                                 : 62,
            IS_SECRET_VISIBLE                                   : 63,

            APP_VERSION                                         : 64,

            RAW_DATA_BYTE                                       : 80

		};

        ////////////////////////////////////// ATTRIBUTE DEFINATION START //////////////////////////////////////

        var TAG_CHAT_PACKET_ATTRIBUTE_INFO = {};

        //#1
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE] = {
            NAME : 'PACKET_TYPE',
            VAR_NAME : 'packetType',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE : 1
        };

        //#2
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.USER_ID] = {
            NAME : 'USER_ID',
            VAR_NAME : 'userId',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE : 8
        };

        //#3
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID] = {
            NAME : 'FRIEND_ID',
            VAR_NAME : 'friendId',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE : 8
        };

        //#4
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH] = {
            NAME : 'PACKET_ID_LENGTH',
            VAR_NAME : 'packetIdLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE : 1
        };

        //#5
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID] = {
            NAME : 'PACKET_ID',
            VAR_NAME : 'packetId',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE : -1 //* DYNAMIC SIZE :: -1
        };

        //#6
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM] = {
            NAME : 'PLATFORM',
            VAR_NAME : 'platform',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#7
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.CHAT_BINDING_PORT] = {
            NAME : 'CHAT_BINDING_PORT',
            VAR_NAME : 'chatBindingPort',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  4
        };

        //#8
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID] = {
            NAME : 'TAG_ID',
            VAR_NAME : 'tagId',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  8
        };

        //#9
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.ONLINE_STATUS] = {
            NAME : 'ONLINE_STATUS',
            VAR_NAME : 'onlineStatus',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#10
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.USER_MOOD] = {
            NAME : 'USER_MOOD',
            VAR_NAME : 'userMood',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#11
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE] = {
            NAME : 'MESSAGE_TYPE',
            VAR_NAME : 'messageType',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#12
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TIMEOUT] = {
            NAME : 'TIMEOUT',
            VAR_NAME : 'timeout',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  2
        };

        //#13
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.LATITUDE] = {
            NAME : 'LATITUDE',
            VAR_NAME : 'latitude',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  4
        };

        //#14
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.LONGITUDE] = {
            NAME : 'LONGITUDE',
            VAR_NAME : 'longitude',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  4
        };

        //#15
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH] = {
            NAME : 'MESSAGE_LENGTH',
            VAR_NAME : 'messageLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  2
        };

        //#16
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE] = {
            NAME : 'MESSAGE',
            VAR_NAME : 'message',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE :  -1
        };

        //#17
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE] = {
            NAME : 'MESSAGE_DATE',
            VAR_NAME : 'messageDate',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  8
        };

        //#18
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE] = {
            NAME : 'NO_OF_MESSAGE',
            VAR_NAME : 'messagesLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            VAR_CONTAINER_NAME : 'messages',
            SIZE :  1
        };

        //#19
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH] = {
            NAME : 'FULL_NAME_LENGTH',
            VAR_NAME : 'fullNameLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#20
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.FULL_NAME] = {
            NAME : 'FULL_NAME',
            VAR_NAME : 'fullName',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE :  -1
        };

        //#21
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET] = {
            NAME : 'NO_OF_PACKET',
            VAR_NAME : 'packetsLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            VAR_CONTAINER_NAME : 'packets',
            SIZE :  1
        };

        //#22
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO] = {
            NAME : 'SEQUENCE_NO',
            VAR_NAME : 'sequenceNo',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#23
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_MEMBERS] = {
            NAME : 'NO_OF_MEMBERS',
            VAR_NAME : 'membersLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            VAR_CONTAINER_NAME : 'members',
            SIZE :  2
        };

        //#24
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.UPDATE_TIME] = {
            NAME : 'UPDATE_TIME',
            VAR_NAME : 'updateTime',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  8
        };

        //#25
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.SERVER_DATE] = {
            NAME : 'SERVER_DATE',
            VAR_NAME : 'serverDate',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  8
        };

        //#26
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.LAST_ONLINE_TIME] = {
            NAME : 'LAST_ONLINE_TIME',
            VAR_NAME : 'lastOnlineTime',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  8
        };

        //#27
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_ITEMS] = {
            NAME : 'NO_OF_ITEMS',
            VAR_NAME : 'noOfItems',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            VAR_CONTAINER_NAME : 'items',
            SIZE :  2
        };

        //#28
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.BLOCK_UNBLOCK_DATE] = {
            NAME : 'BLOCK_UNBLOCK_DATE',
            VAR_NAME : 'blockUnblockDate',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  8
        };

        //#29
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_STATUS] = {
            NAME : 'MESSAGE_STATUS',
            VAR_NAME : 'status',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#30
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.IS_ADD_TO_DB] = {
            NAME : 'IS_ADD_TO_DB',
            VAR_NAME : 'isAddToDb',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };


        //#31
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH] = {
            NAME : 'TAG_NAME_LENGTH',
            VAR_NAME : 'tagNameLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  2
        };

        //#32
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TAG_NAME] = {
            NAME : 'TAG_NAME',
            VAR_NAME : 'tagName',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE :  -1
        };

        //#33
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH] = {
            NAME : 'TAG_PICTURE_URL_LENGTH',
            VAR_NAME : 'tagPictureUrlLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#34
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL] = {
            NAME : 'TAG_PICTURE_URL',
            VAR_NAME : 'tagPictureUrl',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE :  -1
        };

        //#35
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE] = {
            NAME : 'TAG_MEMBER_TYPE',
            VAR_NAME : 'status',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#36
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_ADDED_BY] = {
            NAME : 'TAG_MEMBER_ADDED_BY',
            VAR_NAME : 'addedBy',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  8
        };

        //#37
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS] = {
            NAME : 'TAG_NO_OF_MEMBERS',
            VAR_NAME : 'tagMembersLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            VAR_CONTAINER_NAME : 'tagMembers',
            SIZE :  2
        };

        //#38
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_BROKEN_PKT] = {
            NAME : 'TAG_NO_OF_BROKEN_PKT',
            VAR_NAME : 'brokenPacketsLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            VAR_CONTAINER_NAME : 'brokenPackets',
            SIZE :  1
        };

        //#39
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TAG_INFORMATION_UPDATE_FLAG] = {
            NAME : 'TAG_INFORMATION_UPDATE_FLAG',
            VAR_NAME : 'updateFlag',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#40
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.TAG_INFORMATION_TAG_NO_OF_MEMBERS] = {
            NAME : 'TAG_INFORMATION_TAG_NO_OF_MEMBERS',
            VAR_NAME : 'tagMembersCount',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  2
        };

        //41
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.REGISTRATION_TYPE] = {
            NAME : 'REGISTRATION_TYPE',
            VAR_NAME : 'registrationType',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //42
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.PAGE_DIRECTION] = {
            NAME : 'PAGE_DIRECTION',
            VAR_NAME : 'pageDirection',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //43
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.PAGE_LIMIT] = {
            NAME : 'PAGE_LIMIT',
            VAR_NAME : 'pageLimit',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#45
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.ACTIVITY_TYPE] = {
            NAME : 'ACTIVITY_TYPE',
            VAR_NAME : 'activityType',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            CONDITIONAL : true,
            SIZE :  1
        };


        //#46
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.ACTIVITY_VALUE_LENGTH] = {
            NAME : 'ACTIVITY_VALUE_LENGTH',
            VAR_NAME : 'activityValueLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  2
        };

        //#47
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.ACTIVITY_VALUE] = {
            NAME : 'ACTIVITY_VALUE',
            VAR_NAME : 'activityValue',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE :  -1
        };

        //#48
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.CHANGED_BY_USER_ID] = {
            NAME : 'CHANGED_BY_USER_ID',
            VAR_NAME : 'changedByUserId',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  8
        };


        //#60
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_APP_TYPE] = {
            NAME : 'FRIEND_APP_TYPE',
            VAR_NAME : 'friendAppType',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };

        //#61
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_DEVICE_TOKEN_LENGTH] = {
            NAME : 'FRIEND_DEVICE_TOKEN_LENGTH',
            VAR_NAME : 'friendDeviceTokenLength',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  2
        };

        //#62
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_DEVICE_TOKEN] = {
            NAME : 'FRIEND_DEVICE_TOKEN',
            VAR_NAME : 'friendDeviceToken',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE :  -1
        };

        //#63
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE] = {
            NAME : 'IS_SECRET_VISIBLE',
            VAR_NAME : 'isSecretVisible',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  1
        };


        //#64
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.APP_VERSION] = {
            NAME : 'APP_VERSION',
            VAR_NAME : 'appVersion',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE :  2
        };


    //#80
        TAG_CHAT_PACKET_ATTRIBUTE_INFO[TAG_CHAT_PACKET_ATTRIBUTE.RAW_DATA_BYTE] = {
            NAME : 'RAW_DATA_BYTE',
            VAR_NAME : 'bytes',
            VAR_TYPE :  TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.BYTE,
            SIZE :  -2
        };



        ////////////////////////////////////// ATTRIBUTE DEFINATION END //////////////////////////////////////

		var TAG_CHAT_PACKET_INFO = {};

        /******************************************* Friend Chat Packets *******************************************/

        //#1
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_REGISTER ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM

            ]
            //1, 2, 3, 4, 5, 6
        };


        //#3
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_REGISTER_CONFIRMATION ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.CHAT_BINDING_PORT,
                TAG_CHAT_PACKET_ATTRIBUTE.SERVER_DATE

            ]
            //1, 3, 4, 5, ...
        };

        //#6
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TIMEOUT,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                TAG_CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM,


            ]
            //1, 2, 3, 4, 5, ...
        };

        //#7
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG_EDIT ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TIMEOUT,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                TAG_CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM

            ]
            //1, 2, 3, 4, 5, ...
        };

        //#8
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TIMEOUT,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                TAG_CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM,

            ]
            //1, 2, 3, 4, 5, ...
        };

        //#9
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG_EDIT ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TIMEOUT,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                TAG_CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM,

            ]
            //1, 2, 3, 4, 5, ...

        };

        //#10
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MULTIPLE_MSG ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.TIMEOUT,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                    TAG_CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE
                ]

            ]
            //1, 2, 3, 4, 5, ...

        };

        //#15
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM
            ]
            //1, 2, 3, 4, 5
        };

        //#16
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
            ]
            //1, 2, 3, 4, 5
        };


        //#17
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_STATUS
                ],
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM
            ]
            //1, 2, 8, 4, 5, 6
        };

        //#18
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN_CONFIRMATION ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
            ]
            //1, 2, 3, 4, 5
        };

        //#24
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_BROKEN] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO,
                TAG_CHAT_PACKET_ATTRIBUTE.RAW_DATA_BYTE


            ]
            //1, 2, 3, 4, 5, 21, 22, 80
        };

        //#25
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_BROKEN_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO
            ]
            //1 2, 3, 4, 5, 22
        };

        //#27
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BLOCK] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.BLOCK_UNBLOCK_DATE,
                TAG_CHAT_PACKET_ATTRIBUTE.IS_ADD_TO_DB


            ]
            //1, 2, 3, 4, 5, 28, 30
        };

        //#28
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_UNBLOCK] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.BLOCK_UNBLOCK_DATE
            ]
            //1, 2, 3, 4, 5, 28
        };


        //#29
        TAG_CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BLOCK_UNBLOCK_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
            ]
            //1 2, 3, 4, 5
        };

        /******************************************* Friend Chat Packets *******************************************/

		//#41
		TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER ] =
		{

			FORMAT:[
				TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
				TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
				TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM
			]
			//1, 2, 8, 4, 5, 6
		};

        //#42
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_UNREGISTER] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.ONLINE_STATUS,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_MOOD

            ]
            //1, 2, 8, 9, 10
        };


        //#43
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER_CONFIRMATION ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.CHAT_BINDING_PORT,
                TAG_CHAT_PACKET_ATTRIBUTE.SERVER_DATE
            ]
            //1, 8, 4, 5, 7, 25
        };

        //#46
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.ACTIVITY_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_NAME,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL


            ]
            //1, 2, 8, 4, 5, 45, [31, 32], [33, 34]
        };

        //#47
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION_CONFIRMATION ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID

            ]
            //1, 2, 8, 4, 5
        };

        //#51
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.FULL_NAME,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE
                ]

            ]
            //1, 2, 8, 4, 5, 37, 2, 19, 20, 35
        };

        //#52
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID

            ]
            //1, 2, 8, 4, 5
        };

        //#53
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.USER_ID
                ]
            ]
            //1, 2, 8, 4, 5, 37, 2
        };

        //#54
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
            ]
            //1, 2, 8, 4, 5
        };

        //#55
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE
                ]

            ]
            //1, 2, 8, 4, 5, 37, 2, 35
        };

        //#56
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID

            ]
            //1, 2, 8, 4, 5
        };



        //#61
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_IDLE ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM
            ]
            //1, 2, 8, 6
        };

        //#62
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TYPING ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM

            ]
            //1, 2, 8, 6
            /* No Need for PacketId because no confirmation packet is sent */

        };

        //#63
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE

            ]
            //1, 2, 8, 4, 5, 11, 13, 14, 15, 16, 17
        };

        //#64
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_EDIT ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE

            ]
            //1, 2, 8, 4, 5, 19, 20, 11, 13, 14, 15, 16, 17
        };


        //#65
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE

            ]
            //1, 2, 8, 4, 5, 21, 22, 19, 20, 11, 15, 16, 17
        };

        //#66
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG_EDIT ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE

            ]
            //1, 2, 8, 4, 5, 21, 22, 19, 20, 11, 15, 16, 17
        };

        //#67
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MULTIPLE_MSG ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE

            ]
            //1, 2, 8, 4, 5, 18, 1, 4, 5, 11, 15, 16, 17
        };



         //#68
		TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED ] =
		{

			FORMAT:[
				TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
				TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
				TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
			]
			//1, 2, 3, 8, 4, 5
		};

		//#69
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
            ]
            //1, 8, 4, 5
        };

        //#70
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN ] =
		{

			FORMAT:[
				TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
				TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
				TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
			]
			//1, 2, 3, 8, 4, 5
		};

        //#71
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN_CONFIRMATION ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
            ]
            //1, 8, 4, 5
        };


        //#72
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MULTIPLE_MSG_DELETE ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
                ]

            ]
            //1, 2, 8, 4, 5, 38, 4, 5
        };



        //#73
		TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_DELETE_CONFIRMATION ] =
		{

			FORMAT:[
				TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
				TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
			]
			//1, 2, 3, 8, 4, 5
		};



        //#74
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO,
                TAG_CHAT_PACKET_ATTRIBUTE.RAW_DATA_BYTE


            ]
            //1, 8, 4, 5, 21, 22, 80
        };


        //#75
        TAG_CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO
            ]
            //1 2, 8, 4, 5, 22
        };


        //#91
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_INFORMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.FULL_NAME,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM,
                TAG_CHAT_PACKET_ATTRIBUTE.ONLINE_STATUS,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_APP_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_DEVICE_TOKEN_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_DEVICE_TOKEN,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_MOOD
            ]
            //1 2, 3, 4, 5, ...
        };

        //#92
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_INFORMATION_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM
            ]
            //1 3, 4, 5
        };


        //#93
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.UPDATE_TIME,
                TAG_CHAT_PACKET_ATTRIBUTE.BLOCK_UNBLOCK_DATE,
                TAG_CHAT_PACKET_ATTRIBUTE.APP_VERSION,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM
            ]
            //1 2, 8, 4, 5, 28, 22,
        };


        //#94
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.SERVER_DATE
            ]
            //1, 4, 5, 25
        };


        //#95
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.TIMEOUT,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                    TAG_CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE
                ]

            ]
            //1 2, 4, 5, 18, [1, 2, 4, 5, ...]
        };



        //#96
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
                ]


            ]
            //1 2, 4, 5, 21,[ 4, 5]
        };

        //#97
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PAGE_DIRECTION,
                TAG_CHAT_PACKET_ATTRIBUTE.PAGE_LIMIT,
                //TAG_CHAT_PACKET_ATTRIBUTE.APP_VERSION,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM
            ]
            //1 2, 3, 4, 5, 6
        };

        //#98
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.TIMEOUT,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                    TAG_CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_STATUS
                ],
                TAG_CHAT_PACKET_ATTRIBUTE.PAGE_DIRECTION
            ]
            //1 2, 8, 4, 5, 18, [1, 2, 4, 5,...]
        };

        //#99
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID

            ]
            //1 2, 4, 5
        };


        //#100
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_GET_FRIEND_MESSAGE_STATUS] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
                ],
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM


            ]
            //1 2, 4, 5,...
        };

        //#101
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.FRIEND_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
                ]

            ]
            //1 2, 4, 5,...
        };



        // #104
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_INFORMATION_ACTIVITY ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_ITEMS,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.ACTIVITY_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.ACTIVITY_VALUE_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.ACTIVITY_VALUE,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.CHANGED_BY_USER_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.UPDATE_TIME
                ]

            ]
            //1, 8, 4, 5, 44, 45, 2, 46, 47, 48, 24
        };

        //#105
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_MY_TAG_LIST ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_ITEMS,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_NAME,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_ADDED_BY,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_INFORMATION_TAG_NO_OF_MEMBERS
                ]

            ]
            //1, 4, 5, 27, 8, 31, 32, 33, 34, 35, 40
        };



        //#106
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE

                ]

            ]
            //1 2, 8, 4, 5, 18, [1, 2, 4, 5, 15, 16, 17]
        };


        //#107
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
                ]


            ]
            //1 2, 4, 5, 21,[ 4, 5]
        };

        //#108
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_NAME,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.FULL_NAME,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE
                ],
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM
            ]
            //1, 2, 8, 4, 5, 31, 32, 33, 34, 37, 2, 19, 20, 35, 6
        };

        //#109
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG_CONFIRMATION ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID
            ]
            //1, 8, 4, 5
        };


        //#110
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE_REQUEST] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PAGE_DIRECTION,
                TAG_CHAT_PACKET_ATTRIBUTE.PAGE_LIMIT,
                TAG_CHAT_PACKET_ATTRIBUTE.APP_VERSION,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM

            ]
            //1 2, 8, 4, 5, 42, 43, 6
        };


        //#111
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE,
                    TAG_CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE
                ],
                TAG_CHAT_PACKET_ATTRIBUTE.PAGE_DIRECTION
            ]
            //1 2, 8, 4, 5, 18, [1, 2, 4, 5, 15, 16, 17]
        };

        //#112
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM
            ]
            //1, 2, 8, 4, 5, 6
        };

        //#113
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_INFORMATION_WITH_MEMBERS ] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_NAME,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS,
                [
                    TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                    TAG_CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH,
                    TAG_CHAT_PACKET_ATTRIBUTE.FULL_NAME,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE,
                    TAG_CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_ADDED_BY
                ]
            ]
            //1, 2, 8, 4, 5, 31, 32, 33, 34, 37, 2, 19, 20, 35
        };


        //#117
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.TAG_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID

            ]
            //1 2, 4, 5, 21
        };



        //#118
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_HISTORY_PACKET] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO,
                TAG_CHAT_PACKET_ATTRIBUTE.RAW_DATA_BYTE


            ]
            //1, 2, 4, 5, 21, 22, 80
        };

        //#119
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET,
                TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO,
                TAG_CHAT_PACKET_ATTRIBUTE.RAW_DATA_BYTE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PLATFORM



            ]
            //1, 4, 5, 21, 22, 80, 6, 2
        };


        //#120
        TAG_CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET_CONFIRMATION] =
        {

            FORMAT:[
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                TAG_CHAT_PACKET_ATTRIBUTE.USER_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                TAG_CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                TAG_CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO
            ]
            //1 2, 4, 5, 22
    };


        var ALL_PACKET_TYPES = angular.extend({}, TAG_CHAT_PACKET_TYPE, FRIEND_CHAT_PACKET_TYPE, OFFLINE_PACKET_TYPE);
        var ALL_PACKET_TYPES_KEYS = Object.keys(ALL_PACKET_TYPES);
        for(var index = 0, length = ALL_PACKET_TYPES_KEYS.length; index < length; index++){
            try{
                TAG_CHAT_PACKET_INFO[ALL_PACKET_TYPES[ ALL_PACKET_TYPES_KEYS[index] ]]['PACKET_NAME'] = ALL_PACKET_TYPES_KEYS[index];
            }catch(e){
                TAG_CHAT_PACKET_INFO[ALL_PACKET_TYPES[ ALL_PACKET_TYPES_KEYS[index] ]] = { 'PACKET_NAME' :  ALL_PACKET_TYPES_KEYS[index] };
            }

        }





        tagChatApp.constant('TAG_CHAT_PACKET_TYPE', TAG_CHAT_PACKET_TYPE);

        tagChatApp.constant('FRIEND_CHAT_PACKET_TYPE', FRIEND_CHAT_PACKET_TYPE);

        tagChatApp.constant('OFFLINE_PACKET_TYPE', OFFLINE_PACKET_TYPE);

        tagChatApp.constant('FRIEND_CHAT_PACKET_TYPE', FRIEND_CHAT_PACKET_TYPE);

        tagChatApp.constant('TAG_CHAT_PACKET_ATTRIBUTE', TAG_CHAT_PACKET_ATTRIBUTE);

        tagChatApp.constant('TAG_CHAT_PACKET_ATTRIBUTE_INFO', TAG_CHAT_PACKET_ATTRIBUTE_INFO);

		tagChatApp.constant('TAG_CHAT_PACKET_INFO', TAG_CHAT_PACKET_INFO);

        tagChatApp.constant('TAG_CHAT_GENERAL_CONSTANTS', TAG_CHAT_GENERAL_CONSTANTS );

        tagChatApp.constant('TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP', TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP );



})();

/*
 * Md. Ibrahim Rashid
 * © Ipvision
 */

(function() {
	'use strict';

		var tagChatApp = angular.module('ringid.tagchat');

        var TAG_CHAT_LANG = {

            STATUS_MESSAGES : {

                SELF_ADD_MEMBER                                 : 'You added {new_member_name} as Group {new_member_type}.',
                SELF_ADD_MULTIPLE_MEMBER                        : 'You added {new_member_name} and {rest_count} as Group {new_member_type}.',

                SELF_REMOVE_MEMBER                              : 'You removed {old_member_name} from the group.',
                SELF_REMOVE_MULTIPLE_MEMBER                     : 'You removed {old_member_name} and {rest_count} from the group.',

                OTHER_ADD_MEMBER                                : '{member_name} added {new_member_name} as Group {new_member_type}.',
                OTHER_ADD_MULTIPLE_MEMBER                       : '{member_name} added {new_member_name} and {rest_count} as Group {new_member_type}.',

                OTHER_REMOVE_MEMBER                             : '{member_name} removed {old_member_name} from the group.',
                OTHER_REMOVE_MULTIPLE_MEMBER                    : '{member_name} removed {old_member_name} and {rest_count} from the group.',

                SELF_LEAVE_GROUP                                : 'You left this conversation.',
                OTHER_LEAVE_GROUP                               : '{member_name} left this conservation.',

                SELF_RENAME_GROUP                               : 'You named the group {group_name}.',
                OTHER_RENAME_GROUP                              : '{member_name} named the group {group_name}.',

                SELF_CHANGE_GROUP_PIC                           : 'You changed the group photo.',
                OTHER_CHANGE_GROUP_PIC                          : '{member_name} changed the group photo.',

                SELF_UPDATE_GROUP_INFO                          : 'You named the group {group_name} and changed the group photo.',
                OTHER_UPDATE_GROUP_INFO                         : '{member_name} named the group {group_name} and changed the group photo.',

                SELF_MEMBER_CHANGE_TO_ADMIN                     : 'You made {old_member_name} Group Admin.',
                OTHER_MEMBER_CHANGE_TO_ADMIN                    : '{member_name} made {old_member_name} as Admin.',

                SELF_MULTIPLE_MEMBER_CHANGE_TO_ADMIN            : 'You made {old_member_name} and {rest_count} as Group admin.',
                OTHER_MULTIPLE_MEMBER_CHANGE_TO_ADMIN           : '{member_name} made {old_member_name} and {rest_count} as Group admin.',


                SELF_ADMIN_CHANGE_TO_MEMBER                     : 'You removed {old_admin_name} from Admin.',
                OTHER_ADMIN_CHANGE_TO_MEMBER                    : '{admin_name} removed {old_admin_name} from Group Admin.',

                SELF_MULTIPLE_ADMIN_CHANGE_TO_MEMBER            : 'You removed {old_admin_name} and {rest_count} as Group admin.',
                OTHER_MULTIPLE_ADMIN_CHANGE_TO_MEMBER           : '{admin_name} removed {old_admin_name} and {rest_count} from Group Admin.',

                SELF_REMOVED_FROM_ADMIN_BY_SELF                 : 'You removed yourself from Admin',

                OTHER_REMOVED_FROM_ADMIN_BY_SELF                : '{admin_name} removed himself/herself from Admin',

                SELF_USER_ADDED_AS_OWNER                        : '{member_name} made you owner.',
                OTHER_USER_ADDED_AS_OWNER                       : '{member_name} made {admin_name} Owner. ',

                SELF_NOT_GROUP_MEMBER                           : 'You are no longer member of this group'

            },

            DEFAULT_FAILURE_MESSAGE : 'Request has not been processed successfully. Please try again',
            DEFAULT_SUCCESS_MESSAGE : 'Request has been processed successfully.'

        };

        tagChatApp.constant('TAG_CHAT_LANG', TAG_CHAT_LANG);


})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
    	.module('ringid.tagchat')
    	.service('tagChatApiService', tagChatApiService);

    	tagChatApiService.$inject = [
    		'$$connector',
    		'$q',
    		'OPERATION_TYPES', 'AUTH_SERVER_ACTIONS', 'TAG_CHAT_PACKET_TYPE','PLATFORM',
    		'globalSocketFactory', 'utilsFactory', 'tagChatPacketProcessor', 'tagChatFactory',
    		'TAG_CHAT_GENERAL_CONSTANTS', 'OFFLINE_PACKET_TYPE', 'FRIEND_CHAT_PACKET_TYPE',
    		'Auth', 'tagChatExceptions', 'settings', 'CHAT_GENERAL_CONSTANTS', 'chatTabSync'

    	];

    	function tagChatApiService(
    		$$connector,
    		$q,
    		OPERATION_TYPES, AUTH_SERVER_ACTIONS, TAG_CHAT_PACKET_TYPE, PLATFORM,
    		globalSocketFactory, utilsFactory, tagChatPacketProcessor, tagChatFactory,
    		TAG_CHAT_GENERAL_CONSTANTS, OFFLINE_PACKET_TYPE, FRIEND_CHAT_PACKET_TYPE,
			Auth, tagChatExceptions, settings, CHAT_GENERAL_CONSTANTS, chatTabSync


    	) {

			var ChatPacketException = tagChatExceptions.ChatPacketException;
    		var self = this;

            /* /////////////// Auth Calls ///////////////// */


    		self.createOrGetTagFromAuth = function(aTagObject, newMemberUIds, packetId){

				var returnPromise;

    			var requestObject = {
                    actn: AUTH_SERVER_ACTIONS.START_TAG_CHAT,
                    tid : aTagObject.getTagId(),
                    uIds : newMemberUIds,
					pckId : packetId
                };

    			if( !tagChatFactory.shouldProcessRequest(requestObject) ){
    				RingLogger.infoblack('Skipping Getting Ip/Register Port from Auth', requestObject, RingLogger.tags.TAG_CHAT);
    				returnPromise = { sucs : false };
    			}

				RingLogger.infoblack('START_TAG_CHAT', requestObject, RingLogger.tags.TAG_CHAT_REQUEST);

				tagChatFactory.setInTagChatRequestCache( tagChatFactory.getAuthRequestKey(requestObject.tid, requestObject.actn), requestObject );

    			returnPromise = $$connector.request(requestObject, OPERATION_TYPES.SYSTEM.REQUEST_TYPE.CHAT);

				return $q.when(returnPromise);

    		};

            self.addTagMembersInAuth = function(aTagObject, newMemberUIds){

				var returnPromise;

    			var requestObject = {
                    actn: AUTH_SERVER_ACTIONS.ADD_TAG_CHAT_MEMBERS,
                    tid : aTagObject.getTagId(),
                    chRp: aTagObject.getChatRegisterPort(),
                    chIp: aTagObject.getChatIp(),
                    uIds: newMemberUIds
                };

    			if( !tagChatFactory.shouldProcessRequest(requestObject) ){
    				RingLogger.warning('Skipping Add Tag Members in Auth Request', requestObject, RingLogger.tags.TAG_CHAT);
					returnPromise = { sucs : false };
				}

    			RingLogger.infoblack('ADD_TAG_CHAT_MEMBERS', requestObject, RingLogger.tags.TAG_CHAT_REQUEST);

				returnPromise =  $$connector.request(requestObject, OPERATION_TYPES.SYSTEM.REQUEST_TYPE.CHAT);

				return $q.when(returnPromise);

			};


    		function _getUIdGroups(uIds){
    			var uIdGroups = [];
    			if( uIds.length > TAG_CHAT_GENERAL_CONSTANTS.AUTH_UID_LIST_LIMIT ){

    				var aGroup = [];
    				var uIdsIndex = 0;

    				for(var index = 0; index < uIds.length; index++){
    					if( (uIdsIndex % TAG_CHAT_GENERAL_CONSTANTS.AUTH_UID_LIST_LIMIT ) === 0){
    						aGroup = [uIds[uIdsIndex]];
    						uIdGroups.push(aGroup);
    					}else{
    						aGroup.push(uIds[uIdsIndex]);
    					}

    					uIdsIndex++;
    				}

    			}else{
    				uIdGroups.push(uIds);
    			}

    			return uIdGroups;
    		}

    		function _sendMultipleAuthRequest(requestObject, requestType){
    			var uIdGroups = _getUIdGroups(requestObject.uIds);
    			var responses = [];
    			for(var index = 0; index < uIdGroups.length; index++){
    				var aRequestObject = angular.copy(requestObject);
    				aRequestObject.uIds = uIdGroups[index];
    				var response = $$connector.request(aRequestObject, requestType, true);
    				responses.push(response);
    			}
    			return $q.all(responses);
    		}

            /* /////////////// Chat Server Calls ////////// */


			//PACKET TYPE 15
			self.sendFriendChatDeliveryPacket = function(box, userId, friendId, packetId ){

				var offlineIpPort= _getOfflineIpPort();
				var ip = ( !!box && box.getIp() ) || offlineIpPort.ip,
					port = ( !!box && box.getPort() ) || offlineIpPort.port;

				if( !ip || !port ){
					RingLogger.infoblack('Sending Friend Delivery Ip/Port Exception ', box, RingLogger.tags.TAG_CHAT);
					return;
				}

				var packetType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED;
				var requestObject = {
					ip: ip,
					port: port,
					packetId: packetId,
					packetType: packetType,
					userId: userId,
					friendId: friendId
				};

				return _sendViaGlobalChatSocket(requestObject, packetType);


			};

    		//PACKET TYPE 41
    		self.registerTagInChatServer = function(userId, aTagObject, packetId, regType){

    			//if(!regType){
    			//	RingLogger.infoblack('Registration Type Not Defined for Tag', aTagObject, RingLogger.tags.TAG_CHAT);
    			//	return;
    			//}

                if( !aTagObject.getChatIp() || !aTagObject.getChatRegisterPort() ){
    				_noIpPortException(aTagObject, ' Tag Register Packet ');
                    return;
                }

    			var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER;

    			var requestObject = {
    				ip : aTagObject.getChatIp(),
    				port : aTagObject.getChatRegisterPort(),
    				packetId: packetId || tagChatFactory.getUUIDPacketId(),
    				packetType: packetType,

    				userId: userId,
    				tagId : aTagObject.getTagId(),
    				//registrationType : regType,
    				platform : PLATFORM.WEB

    				//sessionId  : utilsFactory.getToken, //234, hard coded value, might not be in use

    			};

    			/** Setting TagId as Key Instead of PacketId, because We need to stop multiple register request for same tagId **/
    			tagChatFactory.setInTagChatRequestCache(aTagObject.getTagId(), requestObject);

    			return _sendViaGlobalChatSocket(requestObject, packetType);

    		};

			//PACKET TYPE 46
			self.sendTagInformationToChatServer = function (userId, aTagObject, activityType, packetId){

				if( !aTagObject.getChatIp() || !aTagObject.getChatRegisterPort() ){
					_noIpPortException(aTagObject, ' Sending Tag Information Packet ');
					return;
				}

				var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION;

				var requestObject = {
					ip : aTagObject.getChatIp(),
					port : aTagObject.getChatBindingPort(),
					packetId: packetId || tagChatFactory.getUUIDPacketId(),

					packetType: packetType,
					activityType : activityType,
					userId: userId,
					tagId : aTagObject.getTagId(),
					tagName : aTagObject.getTagName().utf8Encode(),
					tagPictureUrl : aTagObject.getPictureUrl()
				};


				return _sendViaGlobalChatSocket(requestObject, packetType);

			};

			//PACKET TYPE 50
			self.getTagInformationWithMemberFromChatServer = function(userId, aTagObject, packetId){

				if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
					_noIpPortException(aTagObject, 'Get Tag Info Packet ');
					return;
				}

				var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_GET_TAG_INFORMATION_WITH_MEMBERS;

				var requestObject = {
					ip : aTagObject.getChatIp(),
					port : aTagObject.getChatBindingPort(),
					packetId: packetId || tagChatFactory.getUUIDPacketId(),

					packetType: packetType,

					userId: userId,
					tagId : aTagObject.getTagId()

				};

				return _sendViaGlobalChatSocket(requestObject, packetType);

			};

    		//PACKET TYPE 51
    		self.addTagMemberInChatServer = function(userId, aTagObject, tagMemberSerializedObjects, packetId){

    			if( !aTagObject.getChatIp() || !aTagObject.getChatRegisterPort() ){
    				_noIpPortException(aTagObject, 'add Tag Member Packet ');
                    return;
                }

                var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD;

    			var requestObject = {
    				ip : aTagObject.getChatIp(),
    				port : aTagObject.getChatBindingPort(),
    				packetId: packetId || tagChatFactory.getUUIDPacketId(),

    				packetType: packetType,

    				tagMembers : tagMemberSerializedObjects,
    				userId: userId,
    				tagId : aTagObject.getTagId()

    			};
				
    			

    			return _sendMultipleViaGlobalChatSocket(requestObject, packetType);

    		};

    		//PACKET TYPE 53
    		self.removeTagMembersFromChatServer = function(userId, aTagObject, tagMemberSerializedObjects, packetId ){

                if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
    				_noIpPortException(aTagObject, 'Remove Tag Member Packet ');
                    return;
                }

    			var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE;

    			var requestObject = {
    				ip : aTagObject.getChatIp(),
    				port : aTagObject.getChatBindingPort(),
    				packetId: packetId || tagChatFactory.getUUIDPacketId(),

    				packetType: packetType,

    				tagMembers : tagMemberSerializedObjects,
    				userId: userId,
    				tagId : aTagObject.getTagId()

    			};
				
    			tagChatFactory.setInTagChatRequestCache(requestObject.packetId, requestObject);
    			

    			return _sendMultipleViaGlobalChatSocket(requestObject, packetType);

    		};

    		//PACKET TYPE 55
    		self.changeTagMemberStatusInChatServer = function(userId, aTagObject, tagMemberSerializedObjects, packetId){

    			if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
    				_noIpPortException(aTagObject, 'Change Tag Member Status Packet ');
    				return;
    			}

    			var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE;

    			var requestObject = {
    				ip : aTagObject.getChatIp(),
    				port : aTagObject.getChatBindingPort(),
    				packetId: packetId || tagChatFactory.getUUIDPacketId(),

    				packetType: packetType,

    				tagMembers : tagMemberSerializedObjects,
    				userId: userId,
    				tagId : aTagObject.getTagId()

    			};

    			

    			return _sendMultipleViaGlobalChatSocket(requestObject, packetType);


    		};

    		//PACKET TYPE 61
    		self.sendTagIdlePacket = function(userId, aTagObject){

    			if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
    				//_noIpPortException(aTagObject, 'Send Tag Idle Packet');
    				return;
    			}

    			var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_IDLE;

    			var requestObject = {
    				ip : aTagObject.getChatIp(),
    				port : aTagObject.getChatBindingPort(),

    				packetType: packetType,
    				tagId : aTagObject.getTagId(),

    				userId : userId,
					platform  : PLATFORM.WEB

				};
				
    			return _sendViaGlobalChatSocket(requestObject, packetType);

    		};

    		//PACKET TYPE 62
    		self.sendTagMsgTypingPacket = function(userId, aTagObject){

    			if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
    				_noIpPortException(aTagObject, 'Sending Tag Msg Typing Packet');
    				return;
    			}

    			var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TYPING;

    			var requestObject = {
					ip        : aTagObject.getChatIp(),
					port      : aTagObject.getChatBindingPort(),
					packetType: packetType,
					tagId     : aTagObject.getTagId(),
					userId    : userId,
					platform  : PLATFORM.WEB

				};
				
    			return _sendViaGlobalChatSocket(requestObject, packetType);

    		};

			self.getSendTagMsgRequestObject = function(userId, aTagObject, aTagMessageObject, isOffline, isEdit){

				var ip, port;
				if(isOffline){
					var offlineIpPort = _getOfflineIpPort();
					ip = offlineIpPort.ip;
					port = offlineIpPort.port;
				}else{
					ip = aTagObject.getChatIp();
					port = aTagObject.getChatBindingPort();
				}

				if( !ip || !port ){
					if(!isOffline){
						throw ChatPacketException('Ip/port is not set for tag msg send for tagId ', aTagObject.getTagId());
					}else{
						throw ChatPacketException('Offline ip/port not set for tagId ', aTagObject.getTagId());
					}
				}

				var packetType = !isEdit ? TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG : TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_EDIT;

				var requestObject = {
					ip : aTagObject.getChatIp(),
					port : aTagObject.getChatBindingPort(),

					packetId: aTagMessageObject.getPacketId(),

					packetType: packetType,

					userId: userId,
					tagId : aTagObject.getTagId(),

					//fullName: aTagMessageObject.getFullName().utf8Encode(),

					messageType: aTagMessageObject.getMessageType(),
					messageDate: aTagMessageObject.getMessageDate(),
					message: aTagMessageObject.getMessageText()

				};

				return requestObject;

			};

    		//PACKET TYPE 63
    		self.sendTagMsgInChatServer = function(userId, aTagObject, aTagMessageObject, isOffline){

    			var requestObject = self.getSendTagMsgRequestObject(userId, aTagObject, aTagMessageObject, isOffline);
    			return _sendViaGlobalChatSocket(requestObject, requestObject.packetType);

    		};

    		//PACKET TYPE 64
    		self.editTagMsgInChatServer = function(userId, aTagObject, aTagMessageObject, isOffline){

				var requestObject = self.getSendTagMsgRequestObject(userId, aTagObject, aTagMessageObject, isOffline, true);
				return _sendViaGlobalChatSocket(requestObject, requestObject.packetType);

    		};

    		//PACKET TYPE 65
    		self.sendTagBrokenMsgInChatServer = function(userId, aTagObject, aTagMessageObject){

    		};

    		//PACKET TYPE 66
    		self.sendTagBrokenMsgEditInChatServer = function(userId, aTagObject, aTagMessageObject){

    		};

    		//PACKET TYPE 67
    		self.sendTagMultipleMsgInChatServer = function(userId, aTagObject, aTagMessageObject){

    		};

    		//PACKET TYPE 68
    		self.sendTagMsgDeliveredPacket = function(userId, aTagObject, aTagMessageObject){

    			if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
    				_noIpPortException(aTagObject, 'Sending Tag Msg Delivered Packet');
    				return;
    			}

    			var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED;

    			var requestObject = {
    				ip : aTagObject.getChatIp(),
    				port : aTagObject.getChatBindingPort(),

    				packetType: packetType,
    				userId: userId,
    				friendId : aTagMessageObject.getUserId(),

    				packetId: aTagMessageObject.getPacketId(),
    				tagId : aTagObject.getTagId()

    			};

    			

    			return _sendViaGlobalChatSocket(requestObject, packetType);
    		};

    		//PACKET TYPE 69
    		self.sendTagMsgSentPacket = function(aTagObject){

    			if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
    				_noIpPortException(aTagObject, 'Sending Tag Msg Sent Packet');
    				return;
    			}

    			var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT;

    			var requestObject = {
    				ip : aTagObject.getChatIp(),
    				port : aTagObject.getChatBindingPort(),
    				packetId: aTagObject.getPacketId(),

    				packetType: packetType,
    				tagId : aTagObject.getTagId()

    			};



    			return _sendViaGlobalChatSocket(requestObject, packetType);
    		};

    		//PACKET TYPE 70
    		self.sendTagMsgSeenPacket = function(userId, aTagObject, friendId, packetId){

    			if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
    				_noIpPortException(aTagObject, 'Sending Tag Msg Seen Packet');
    				return;
    			}

    			var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN;

    			var requestObject = {
    				ip : aTagObject.getChatIp(),
    				port : aTagObject.getChatBindingPort(),
    				packetId: packetId,

    				packetType: packetType,
    				userId : userId,
					friendId : friendId,
    				tagId : aTagObject.getTagId()

    			};

    			return _sendViaGlobalChatSocket(requestObject, packetType);

    		};

    		//PACKET TYPE 72
    		self.deleteTagMultipleMsgInChatServer = function(userId, aTagObject, packetId, messagePacketIds){

    			if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
    				_noIpPortException(aTagObject, 'delete Tag Msg Packet');
    				return;
    			}

    			var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MULTIPLE_MSG_DELETE;

    			var packetsIds = [];
    			for(var index =0; index < messagePacketIds.length; index++){
    				packetsIds.push({packetId : messagePacketIds[index] });
    			}

    			var requestObject = {
    				ip : aTagObject.getChatIp(),
    				port : aTagObject.getChatBindingPort(),
    				packetType: packetType,

    				userId: userId,
    				tagId : aTagObject.getTagId(),

    				packetId: packetId,
    				packets : packetsIds


    			};


				tagChatFactory.setInTagChatRequestCache(requestObject.packetId, requestObject);

    			return _sendViaGlobalChatSocket(requestObject, packetType);

    		};

    		//PACKET TYPE 93
    		self.sendOfflineGetRequest = function(userId, updateTime, packetId){

    			var offlineIpPort = _getOfflineIpPort();
    			if( !offlineIpPort.ip || !offlineIpPort.port ){
    				console.log('Offline ip/port not set for offline get request for packet id ', packetId)
    				return;
    			}

    			var packetType = OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST;

    			var requestObject = {
    				ip : offlineIpPort.ip,
    				port : offlineIpPort.port,
    				packetType: packetType,
    				userId : userId,
    				packetId : packetId || tagChatFactory.getUUIDPacketId(),
    				updateTime : updateTime || 0,
					blockUnblockDate : 0,
					appVersion : settings.apiVersion,
    				platform : PLATFORM.WEB

    			};


    			return _sendViaGlobalChatSocket(requestObject, packetType);

    		};


			self.getFriendUnreadMessageConfirmationObject = function(userId, packetId, messagePacketIds){

				var offlineIpPort = _getOfflineIpPort();

				var ip = offlineIpPort.ip,
					port = offlineIpPort.port;

				var packetType = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION;

				var packetsIds = [];
				for(var index =0; index < messagePacketIds.length; index++){
					packetsIds.push({packetId : messagePacketIds[index] });
				}

				var requestObject = {
					ip : ip,
					port : port,
					packetId: packetId,
					userId : userId,
					packets : packetsIds,

					packetType: packetType,

				};

				return requestObject;

			};

			//PACKET TYPE 96
			self.sendFriendUnreadMessageConfirmation = function(userId, friendId, packetId ){

				var requestObject = self.getFriendUnreadMessageConfirmationObject(userId, friendId, packetId);
				return _sendViaGlobalChatSocket(requestObject, requestObject.packetType);
			};


			//PACKET TYPE 97
			self.getFriendHistoryMessageGetRequestObject = function(userId, friendId, pageDirection, packetId, pageLimit){

				var offlineIpPort = _getOfflineIpPort();
				if( !offlineIpPort.ip || !offlineIpPort.port ){
					console.log('Offline ip/port not set for history message get request for packet id ', packetId);
					return;
				}

				var packetType = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST;

				var requestObject = {
					ip : offlineIpPort.ip,
					port : offlineIpPort.port,
					packetType: packetType,
					userId : userId,
					friendId : friendId,
					packetId : packetId || tagChatFactory.getUUIDPacketId(),

					pageLimit : pageLimit || 10,

					pageDirection : pageDirection,
					appVersion : settings.apiVersion,
					platform : PLATFORM.WEB


				};

				return requestObject;

			};

			self.sendHistoryMessageGetRequest = function(userId, friendId, pageDirection, packetId, pageLimit){

				var requestObject = self.getFriendHistoryMessageGetRequestObject(userId, friendId, pageDirection, packetId, pageLimit);
				var packetType = requestObject.packetType;

				return _sendViaGlobalChatSocket(requestObject, packetType);

			};


			//PACKET TYPE 99
			self.sendFriendHistoryMessageOfflineConfirmation = function(userId, friendId, packetId ){

				var offlineIpPort = _getOfflineIpPort();

				var ip = offlineIpPort.ip,
					port = offlineIpPort.port;

				var packetType = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION;

				var requestObject = {
					ip : ip,
					port : port,
					packetId: packetId,

					packetType: packetType,
					friendId : friendId

				};

				return _sendViaGlobalChatSocket(requestObject, packetType);
			};


			//PACKET TYPE 104
			self.createTagInOfflineServer = function (userId, aTagObject, packetId){

				var offlineIpPort = _getOfflineIpPort();
				if( !offlineIpPort.ip || !offlineIpPort.port ){
					console.log('Offline ip/port not set for create tag for tag ', aTagObject);
					return;
				}

				var packetType = OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG;

				var requestObject = {
					ip : offlineIpPort.ip,
					port : offlineIpPort.port,
					packetId: packetId || tagChatFactory.getUUIDPacketId(),

					packetType: packetType,

					userId: userId,
					tagId : aTagObject.getTagId(),
					tagName : aTagObject.getTagName().utf8Encode(),
					tagPictureUrl : aTagObject.getPictureUrl(),
					tagMembers : aTagObject.getSerializedMembers(),
					platform : PLATFORM.WEB
				};

				return _sendViaGlobalChatSocket(requestObject, packetType);

			};

    		//PACKET TYPE 110
    		self.sendHistoryMessageGetRequest = function(userId, tagId, pageDirection, packetId, pageLimit){

    			var offlineIpPort = _getOfflineIpPort();
    			if( !offlineIpPort.ip || !offlineIpPort.port ){
    				console.log('Offline ip/port not set for history message get request for packet id ', packetId);
    				return;
    			}

    			var packetType = OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE_REQUEST;

    			var requestObject = {
    				ip : offlineIpPort.ip,
    				port : offlineIpPort.port,
    				packetType: packetType,
    				userId : userId,
    				tagId : tagId,
    				packetId : packetId || tagChatFactory.getUUIDPacketId(),

					pageLimit : pageLimit || 10,

					pageDirection : pageDirection,
					appVersion : settings.apiVersion,
					platform : PLATFORM.WEB


    			};

    			return _sendViaGlobalChatSocket(requestObject, packetType);

    		};

			//PACKET TYPE 114
			self.getTagInformationWithMemberFromOfflineServer = function(userId, tagId, packetId){

				var offlineIpPort = _getOfflineIpPort();
				if( !offlineIpPort.ip || !offlineIpPort.port ){
					console.log('Offline ip/port not set for get tag info with member for packetId ', packetId)
					return;
				}

				var packetType = OFFLINE_PACKET_TYPE.OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS;

				var requestObject = {
					ip : offlineIpPort.ip,
					port : offlineIpPort.port,
					packetId: packetId || tagChatFactory.getUUIDPacketId(),

					packetType: packetType,

					userId: userId,
					tagId : tagId,
					platform : PLATFORM.WEB

				};

				return _sendViaGlobalChatSocket(requestObject, packetType);

			};

    		//PACKET TYPE 119
    		self.sendOfflineBrokenPacket = function(userId, tagId, packetId){

    			//var offlineIpPort = _getOfflineIpPort();
    			//if( !offlineIpPort.ip || !offlineIpPort.port ){
    			//	console.log('Offline ip/port not set for history message get request for packet id ', packetId)
    			//	return;
    			//}
                //
    			//var packetType = OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE_REQUEST;
                //
    			//var requestObject = {
    			//	ip : offlineIpPort.ip,
    			//	port : offlineIpPort.port,
    			//	packetType: packetType,
    			//	userId : userId,
    			//	tagId : tagId,
    			//	packetId : packetId || tagChatFactory.getUUIDPacketId(),
                //
                //
    			//};
                //

                //
    			//return _sendViaGlobalChatSocket(requestObject, packetType);
    		};

			self.getTagCreateRequestObject = function(userId, aTagObject, packetId){

				var offlineIpPort = _getOfflineIpPort();
				if( !offlineIpPort.ip || !offlineIpPort.port ){
					console.log('Offline ip/port not set for create tag for tag ', aTagObject);
					return;
				}

				var packetType = OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG;

				var requestObject = {
					ip : offlineIpPort.ip,
					port : offlineIpPort.port,
					packetId: packetId || tagChatFactory.getUUIDPacketId(),

					packetType: packetType,

					userId: userId,
					tagId : aTagObject.getTagId(),
					tagName : aTagObject.getTagName().utf8Encode(),
					tagPictureUrl : aTagObject.getPictureUrl(),
					tagMembers : aTagObject.getSerializedMembers(),
					platform : PLATFORM.WEB
				};

				return requestObject;

			};


			/********************** Packet Confirmations **********************************/

    		//PACKET TYPE 43
            self.sendTagRegisterConfirmation = function(aTagObject, packetId){
                /*** Will Not be send from client side ***/

                if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
    				_noIpPortException(aTagObject, 'Sending Tag Register Confirmation');
                    return;
                }

                var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER_CONFIRMATION;

    			var requestObject = {
    				ip : aTagObject.getChatIp(),
    				port : aTagObject.getChatBindingPort(),
                    packetId: packetId,

    				packetType: packetType,
                    tagId : aTagObject.getTagId(),
                    serverDate : aTagObject.serverDate

    			};

    			return _sendViaGlobalChatSocket(requestObject, packetType);
            };

			//PACKET TYPE 47
			self.sendTagInformationConfirmation = function(userId, aTagObject, packetId){
				var offlineIpPort= _getOfflineIpPort();
				var ip = aTagObject.getChatIp() || offlineIpPort.ip,
					port = aTagObject.getChatBindingPort() || offlineIpPort.port;

				if( !ip || !port ){
					RingLogger.infoblack('Sending Tag Info Confirmation Ip/Port Exception ', aTagObject, RingLogger.tags.TAG_CHAT);
					return;
				}

				var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION_CONFIRMATION;

				var requestObject = {
					ip : ip,
					port : port,
					packetId: packetId,
					userId : userId,

					packetType: packetType,
					tagId : aTagObject.getTagId()

				};

				return  _sendViaGlobalChatSocket(requestObject, packetType);
			};



			//PACKET TYPE 52
			self.sendTagMemberAddConfirmation = function(userId, aTagObject, packetId){

				if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
					return;
				}

				var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION;

				var requestObject = {
					ip : aTagObject.getChatIp(),
					port : aTagObject.getChatBindingPort(),
					packetId: packetId,
					userId : userId,

					packetType: packetType,
					tagId : aTagObject.getTagId()

				};

				

				return  _sendViaGlobalChatSocket(requestObject, packetType);

			};

			//PACKET TYPE 54
			self.sendTagChatMemberRemoveLeaveConfirmation = function(userId, aTagObject, packetId){

				if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
					_noIpPortException(aTagObject, 'Sending Tag Remove Leave Confirmation');
					return;
				}

				var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION;

				var requestObject = {
					ip : aTagObject.getChatIp(),
					port : aTagObject.getChatBindingPort(),
					packetId: packetId,
					userId : userId,

					packetType: packetType,
					tagId : aTagObject.getTagId()

				};

				return _sendViaGlobalChatSocket(requestObject, packetType);
			};

			//PACKET TYPE 56
			self.sendTagMemberStatusChangeConfirmation = function(userId, aTagObject, packetId){

				if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
					_noIpPortException(aTagObject, 'Sending Tag Member status change confirmation');
					return;
				}

				var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION;

				var requestObject = {
					ip : aTagObject.getChatIp(),
					port : aTagObject.getChatBindingPort(),
					packetId: packetId,
					userId : userId,

					packetType: packetType,
					tagId : aTagObject.getTagId()

				};

				

				return _sendViaGlobalChatSocket(requestObject, packetType);
			};

			//PACKET TYPE 71
			self.sendTagMsgSeenConfirmation = function(userId, aTagObject, packetId){

			};

			//PACKET TYPE 73
			self.sendTagChatMsgDeleteConfirmation = function(userId, aTagObject, packetId, friendId){

				if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
					_noIpPortException(aTagObject, 'Sending Tag Msg Delete Confirmation');
					return;
				}

				var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_DELETE_CONFIRMATION;

				var requestObject = {
					ip : aTagObject.getChatIp(),
					port : aTagObject.getChatBindingPort(),
					packetId: packetId,

					userId: userId,

					packetType: packetType,
					tagId : aTagObject.getTagId(),
					friendId : friendId

				};

				return _sendViaGlobalChatSocket(requestObject, packetType);
			};

			//PACKET TYPE 75
			self.sendTagGeneralBrokenPacketConfirmation = function(userId, aTagObject, packetId, sequenceNo){

				if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
					RingLogger.infoblack(aTagObject, 'Sending Tag General Broken Confirmation', RingLogger.tags.TAG_CHAT);
					return;
				}


				var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION;

				var requestObject = {
					ip : aTagObject.getChatIp(),
					port : aTagObject.getChatBindingPort(),
					packetId: packetId,

					userId: userId,

					packetType: packetType,
					tagId : aTagObject.getTagId(),
					sequenceNo : sequenceNo

				};

				_sendViaGlobalChatSocket(requestObject, packetType);
			};

			//PACKET TYPE 105
			self.sendTagCreateConfirmation = function(userId, aTagObject, packetId){

				if( !aTagObject.getChatIp() || !aTagObject.getChatBindingPort() ){
					RingLogger.infoblack(aTagObject, 'Sending Tag Create Confirmation', RingLogger.tags.TAG_CHAT);
					return;
				}

				var packetType = OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG_CONFIRMATION;

				var requestObject = {
					ip : aTagObject.getChatIp(),
					port : aTagObject.getChatBindingPort(),
					packetId: packetId,

					packetType: packetType,
					tagId : aTagObject.getTagId(),
					userId : userId


				};

				return _sendViaGlobalChatSocket(requestObject, packetType);
			};

			//PACKET TYPE
			self.sendTagInformationToOfflineServer = function (userId, aTagObject, packetId){

				var offlineIpPort = _getOfflineIpPort();
				if( !offlineIpPort.ip || !offlineIpPort.port ){
					RingLogger.warning('Offline ip/port not set for create tag for tag ', aTagObject);
					return;
				}

				var packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION;

				var requestObject = {
					ip : offlineIpPort.ip,
					port : offlineIpPort.port,
					packetId: packetId || tagChatFactory.getUUIDPacketId(),

					packetType: packetType,

					userId: userId,
					tagId : aTagObject.getTagId(),
					tagName : aTagObject.getTagName().utf8Encode(),
					tagPictureUrl : aTagObject.getPictureUrl(),
					tagMembers : aTagObject.getSerializedMembers()
				};

				return _sendViaGlobalChatSocket(requestObject, packetType);

			};


			self.getTagUnreadMessageConfirmationObject = function(userId, packetId, messagePacketIds){

				var offlineIpPort = _getOfflineIpPort();
				if( !offlineIpPort.ip || !offlineIpPort.port ){
					RingLogger.warning('Offline ip/port not set for unread chat confirmation for packet id ', packetId, RingLogger.tags.TAG_CHAT);
					return;
				}

				var packetType = OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION;

				var packetsIds = [];
				for(var index =0; index < messagePacketIds.length; index++){
					packetsIds.push({packetId : messagePacketIds[index] });
				}

				var requestObject = {
					ip : offlineIpPort.ip,
					port : offlineIpPort.port,
					packetType: packetType,

					userId : userId,
					packetId : packetId,
					packets: packetsIds

				};

				return requestObject;

			};
    		//PACKET TYPE 107
            self.sendTagUnreadChatMsgConfirmation = function(userId, packetId, messagePacketIds){

				var requestObject = self.getTagUnreadMessageConfirmationObject(userId, packetId, messagePacketIds);
				
    			return _sendViaGlobalChatSocket(requestObject, requestObject.packetType);

            };

			//PACKET TYPE 117
			self.sendTagOfflineConfirmation = function(userId, tagId, packetId ){

				var offlineIpPort = _getOfflineIpPort();

				var ip = offlineIpPort.ip,
					port = offlineIpPort.port;

				var packetType = OFFLINE_PACKET_TYPE.OFFLINE_TAG_CONFIRMATION;

				var requestObject = {
					ip : ip,
					port : port,
					packetId: packetId,

					packetType: packetType,
					tagId : tagId

				};

				return _sendViaGlobalChatSocket(requestObject, packetType);
			};

    		//PACKET TYPE 120
    		self.sendOfflineBrokenPacketConfirmation = function(userId, packetId, sequenceNo){

    			var offlineIpPort = _getOfflineIpPort();
    			if( !offlineIpPort.ip || !offlineIpPort.port ){
    				RingLogger.warning('Offline Ip/port not set for sending offline broken packet confirmation', RingLogger.tags.TAG_CHAT);
    				return;
    			}

    			var packetType = OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET_CONFIRMATION;

    			var requestObject = {
    				ip :offlineIpPort.ip,
    				port : offlineIpPort.port,
    				packetType: packetType,

    				userId: userId,
    				packetId: packetId,
    				sequenceNo : sequenceNo

    			};

    			_sendViaGlobalChatSocket(requestObject, packetType);
    		};



    		/********************** Packet Confirmations **********************************/


    		self.sendToSelf = function ( constructedPacket ){

    			utilsFactory.triggerCustomEvent('sendTagChatPacketToSelf', { byteData : constructedPacket.buffer.slice(6) });

    		};

			self.sendViaGlobalChatSocket = _sendViaGlobalChatSocket;

			self.getPacket = _getPacket;

			self.getBrokenPacketObjects = _getBrokenPacketObjects;

			self.logRequestedPacketInfo = _logRequestedPacketInfo;
            self.sendPacketViaGlobalChatSocket = sendPacketViaGlobalChatSocket;

    		////////////////// Privates ///////////////

    		function _sendMultipleViaGlobalChatSocket(requestObject, packetType){

    			var packetSize = tagChatPacketProcessor.getPacketSizeByObject(requestObject, packetType);

    			if( packetSize > TAG_CHAT_GENERAL_CONSTANTS.PACKET_MAX_SIZE){

    				var requestSplittedObjects = tagChatPacketProcessor.splitAndGetMultipleObjects(requestObject, packetType);

    				if(!!requestSplittedObjects){
    					var packetId = requestSplittedObjects[0].packetId;

    					_sendViaGlobalChatSocket(requestSplittedObjects[0], packetType);

    					for(var index = 1; index < requestSplittedObjects.length; index++){
    						requestSplittedObjects[index].packetId = packetId + '_' + index;
    						_sendViaGlobalChatSocket(requestSplittedObjects[index], packetType);
    					}
    				}

    			}else{
    				return _sendViaGlobalChatSocket(requestObject, packetType);
    			}

    		}

			function _getPacket(requestObject, packetType){

				var requestObjectPacket = tagChatPacketProcessor.constructPacket(
					requestObject,
					packetType
				);

				return requestObjectPacket;
			}

			function _getBrokenPacketObjects(brokenPacketType, packet, requestObject) {

				var ip, port, packetType, userId,
					ipPort, packets,
					aBrokenPacket,
					packetsLength,
					brokenContainer,
					brokenPacketSplitter,
                    isMultipleBroken,
					brokenPackets = [];

				if (!requestObject) {
					requestObject = tagChatPacketProcessor.parseRawPacket(packet);
				}

				//ip = requestObject.ip;
				//port = requestObject.port;
				packetType = requestObject.packetType;
				//userId = requestObject.userId;

				if(!packet){
					packet = _getPacket(requestObject, packetType);
				}

				packet = packet.copy(6, packet.byteLength - 6);

				brokenContainer = tagChatPacketProcessor.getBrokenContainerByPacketType(brokenPacketType);

				brokenPacketSplitter = tagChatPacketProcessor.getBrokenPacketSplitter(
					brokenPacketType, packetType,
					requestObject,
					packet
				);

                isMultipleBroken = tagChatPacketProcessor.isMultipleBrokenPacket(packetType);

				packets = brokenPacketSplitter();

				packetsLength = packets.length;

				for (var index = 0; index < packetsLength; index++) {
					aBrokenPacket = angular.copy(requestObject);
					aBrokenPacket['platform'] = PLATFORM.WEB;
					aBrokenPacket['packetsLength'] = packetsLength;
					aBrokenPacket[brokenContainer] = packets[index][brokenContainer];
					aBrokenPacket['packetType'] = brokenPacketType;

                    if(!isMultipleBroken){
                        aBrokenPacket['sequenceNo'] = index;
                    }else{
                        //If UUID has strict length, then it might cause problem
                        aBrokenPacket['packetId'] = aBrokenPacket['packetId'] + '_' + index;
                    }

					brokenPackets.push(aBrokenPacket);
				}

				return brokenPackets;

			}

    		function _sendViaGlobalChatSocket(requestObject, packetType){

				var requestObjectPacket = _getPacket(requestObject, packetType);

				if(!!requestObjectPacket){
					globalSocketFactory.send(requestObjectPacket);
				}

				_logRequestedPacketInfo(packetType, requestObject);

    			return requestObjectPacket;
    		}

    		/***** *****/
            function sendPacketViaGlobalChatSocket(packet){
                if(!!packet){
                    globalSocketFactory.send(packet);
                }
            }

    		function _noIpPortException(aTagObject, name){
    			RingLogger.warning('Called From : ', name , 'TagID, No Ip/Register Port/Binding Port',  aTagObject.getChatIp(), aTagObject.getChatRegisterPort(), aTagObject.getChatBindingPort(), RingLogger.tags.TAG_CHAT );
    			utilsFactory.triggerCustomEvent('tagChatNoIpOrPort', { tagId : aTagObject.getTagId() });
    		}

    		function _getOfflineIpPort(){
    			var loginData = Auth.loginData,
					ip, port;

				if( TAG_CHAT_GENERAL_CONSTANTS.LOCAL_CHAT){
					ip = TAG_CHAT_GENERAL_CONSTANTS.LOCAL_CHAT_OFFLINE_IP;
					port = TAG_CHAT_GENERAL_CONSTANTS.LOCAL_CHAT_OFFLINE_PORT;
				}else{
					ip = loginData.oIP;
					port = loginData.oPrt + TAG_CHAT_GENERAL_CONSTANTS.API_VERSION_PORT_OFFSET;
				}

				return { ip: ip, port : port };
    		}

			function _logRequestedPacketInfo(packetType, packetObject){
				var packetName = tagChatPacketProcessor.getPacketName(packetType);
				RingLogger.infoblack(packetName,packetObject,RingLogger.tags.TAG_CHAT_REQUEST);

			}

    	}

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	var tagChatApp = angular.module('ringid.tagchat');

	tagChatApp.factory('tagChatModels', tagChatModels);


	tagChatModels.$inject = ['$$stackedMap',
        'profileFactory', 'userFactory', 'utilsFactory', 'Auth',
        'TAG_CHAT_GENERAL_CONSTANTS', 'AUTH_SERVER_CONFIG',
		'settings'];


	function tagChatModels($$stackedMap,
                           profileFactory, userFactory, utilsFactory, Auth,
						   TAG_CHAT_GENERAL_CONSTANTS, AUTH_SERVER_CONFIG,
							settings){

		var LOCAL_CHAT = TAG_CHAT_GENERAL_CONSTANTS.LOCAL_CHAT;
		var API_VERSION_PORT_OFFSET = TAG_CHAT_GENERAL_CONSTANTS.API_VERSION_PORT_OFFSET;

		function TagObject(){

            var self = this;

			var tag = {
				id : 0,
				name : 'Group',
				pictureUrl : '',
				userId : 0,
				packetId : 0,
				memberCount : 0, /*** Received From Server With Tag Object **/
				chIp : '',
				chRp : 0,
                chBp : 0,
                serverDate : 0,
				serverDateDiff : 0,

                /** Members means admin, member, owner **/
				members : $$stackedMap.createNew(),
				messages : $$stackedMap.createNew(),


                /*** our property ***/
                objectLock : false,
				lastCommunicationTime : 0,
				ownerUserId : 0,

				creationTime : 0,

			};



			this.getTagId = function(){
				return tag.id;
			};

			this.setTagId = function(tagId){
				tag.id = tagId;
				tag.creationTime = tagId.toString().substr(0, TAG_CHAT_GENERAL_CONSTANTS.TAG_ID_NO_OF_TIME_DIGIT);
			};

			this.getTagCreationTime = function(){
				return tag.creationTime;
			};

			this.getUserId = function(){
				return tag.userId;
			};

			this.setUserId = function(userId){
				tag.userId = userId;
			};

			this.getPacketId = function(){
				return tag.packetId;
			};

			this.setPacketId = function(packetId){
				tag.packetId = packetId;
			};

            this.renewPacketId = function(){
                self.setPacketId(utilsFactory.getUniqueID('tgrc'));
            };

			this.getChatIp = function(){
				if(!LOCAL_CHAT){
					return tag.chIp;
				}else{
					return TAG_CHAT_GENERAL_CONSTANTS.LOCAL_CHAT_REG_IP;

				}

				//return '192.168.1.138';
			};

			this.setChatIp = function(chIp){
				tag.chIp = chIp;
			};

			this.resetChatIp = function(chIp){
				tag.chIp = '';
			};

			this.getChatRegisterPort = function(){
				if(!LOCAL_CHAT){
					return !!tag.chRp ? tag.chRp + API_VERSION_PORT_OFFSET : tag.chRp;
				}else{
					return TAG_CHAT_GENERAL_CONSTANTS.LOCAL_CHAT_REG_PORT;
				}

				//return 1500;
			};

			this.setChatRegisterPort = function(chRp){
				tag.chRp = chRp;
			};

			this.resetChatRegisterPort = function(chRp){
				tag.chRp = 0;
			};

            this.getChatBindingPort = function(){
				return tag.chBp;
			};

            this.hasChatIp = function(){
                return !!tag.chIp;
            };

            this.hasChatBindingPort = function(){
                return !!tag.chBp;
            };

            this.hasChatRegisterPort = function(){
                return !!tag.chRp;
            };

            this.resetChatBindingPort = function(){
                tag.chBp = 0;
            };

			this.setChatBindingPort = function(chBp){
				tag.chBp = chBp;
			};

			this.getTagName = function(){
				return tag.name;
			};

			this.setTagName = function(tagName){
				tag.name = tagName;
			};

			this.setPictureUrl = function(pictureUrl){
				//Storing Picture File Name
				tag.pictureUrl = pictureUrl;
			};

			this.getPictureUrl = function(){
				//Returns Picture File Name
				return tag.pictureUrl.trim();
			};

			this.getPictureFullUrl = function(){
				if( this.getPictureUrl() != ""){
					return settings.imBase + this.getPictureUrl();
				}else{
					return "images/prof.png";
				}
				
			};

            this.setServerDate = function (serverDate) {
                tag.serverDate = serverDate;
				self.setServerDateDiff(serverDate - parseInt(new Date().getTime()));
            };

            this.getServerDate = function(){
                return tag.serverDate;
            };

			this.setServerDateDiff = function (serverDateDiff) {
				tag.serverDateDiff = serverDateDiff;
			};

			this.getServerDateDiff = function(){
				return tag.serverDateDiff;
			};


			this.getMembersCount = function(){
				return tag.memberCount;
			};


			this.setMembersCount = function(memberCount){
				tag.memberCount = memberCount;
			};

			this.isTagSafeToShow = function(){
				return (self.getMembersObjectMap().length() > 1) && self.isUserMember(Auth.currentUser().getKey());
			};





			/***************** Members **************/

			this.initMembers = function(){
				tag.members = $$stackedMap.createNew();
			};

			this.addMember = function(memberObj){
				if( !tag.members){
					tag.members = self.initMembers();
				}

				if(memberObj.isOwner()){
					tag.ownerUserId = memberObj.getId();
				}

				tag.members.save( memberObj.getId(), memberObj);
			};

			this.updateMember = function(updatedMemberObj){
				this.addMember( updatedMemberObj );
			};

			this.removeMember = function(memberObjOrId){
                if( memberObjOrId instanceof TagMember){
    				tag.members.remove(memberObjOrId.getId());
                }else{
                    tag.members.remove(memberObjOrId);
                }
			};

			this.membersLength = function(){
                if( !!tag.members ){
    				return tag.members.length();
                }
                return 0;
			};

			this.getMember = function(memberUserId){
				return tag.members.get(memberUserId);
			};

			this.getMemberObjects = function(){
				return tag.members.values();
			};

            this.getMemberUserIds = function(){
                return tag.members.keys();
            };

            this.getMembersObjectMap = function(){
                return tag.members;
            };

            this.setMembersObjectMap = function(memberObj){
                tag.members = memberObj;
            };

			this.initMemberObjects = function(){
				var tagMembers = tag.members.all();
				for(var index = 0; index < tag.members.length(); index++ ){
					var aTagMember = tagMembers[index].value;
					setTimeout(function(aTagMember){
						aTagMember.initUserObjects();

					}.bind(null, aTagMember), AUTH_SERVER_CONFIG.REQUEST_DELAY);
				}
			};

			this.getSerializedMembers = function(){
				var allTagMembers = tag.members.all();
				var serializedObjectArray = [];

				for(var tagMembersIndex = 0; tagMembersIndex < allTagMembers.length; tagMembersIndex++ ){
					var aTagMember = allTagMembers[ tagMembersIndex].value;

					serializedObjectArray.push(aTagMember.serialize());
				}

				return serializedObjectArray;
			};

			this.isUserMember = function(userId){
				/*** Returns if userId contains in members list, not actual member status ***/
				if(!tag.members){
					return false;
				}else{
					return !!tag.members.get(userId);
				}
			};

			this.isCurrentUserStatusAdmin = function(userId){
				var userObj = !!tag.members && tag.members.get(userId);
				if(!!userObj){
					return userObj.isAdmin();
				}
				return false;
			};

			this.isCurrentUserStatusMember = function(userId){
				var userObj = !!tag.members && tag.members.get(userId);
				if(!!userObj){
					return userObj.isMember();
				}
				return false;
			};

            this.setObjectLock = function(){
                tag.objectLock = true;
            };

            this.removeObjectLock = function(){
                tag.objectLock = false;
            };

            this.hasObjectLock = function(){
                return tag.objectLock;
            };

			this.getLastCommunicationTime = function(){
				return tag.lastCommunicationTime;
			};

			this.setLastCommunicationTime = function(lastCommunicationTime){
				tag.lastCommunicationTime = lastCommunicationTime;
			};

			this.resetLastCommunicationTime = function(){
				tag.lastCommunicationTime = 0;
			};

			this.updateLastCommunicationTime = function(){
				tag.lastCommunicationTime = Math.floor(Date.now() / 1000);
			};

			this.setOwnerUserId = function(ownerUserId){
				tag.ownerUserId = ownerUserId;
			};

			this.getOwnerUserId = function(){
				return tag.ownerUserId;
			};

			/*********** *************/

			this.initMessages = function(){
				tag.messages = $$stackedMap.createNew();
			};

			this.addMessage = function(messageObj){
				if( !tag.messages){
					tag.messages = self.initMessages();
				}
				tag.messages.save( messageObj.getPacketId(), messageObj);
			};

			this.removeMessage = function(messageObjOrId){
                if( messageObjOrId instanceof TagMessage){
    				tag.messages.remove(messageObjOrId.getId());
                }else{
                    tag.messages.remove(messageObjOrId);
                }
			};

			this.messagesLength = function(){
                if( !!tag.messages ){
    				return tag.messages.length();
                }
                return 0;
			};

			this.getMessage = function(messagePacketId){
				return tag.messages.get(messagePacketId);
			};

			this.getMessageObjects = function(){
				return tag.messages.values();
			};

            this.getMessageUserIds = function(){
                return tag.messages.keys();
            };

            this.getMessagesObjectMap = function(){
                return tag.messages;
            };

            this.setMessagesObjectMap = function(messageObj){
                tag.messages = messageObj;
            };

			this.debug = function(){
				return tag;
			};


			/**********  *************/

		}

        TagObject.prototype.copy = function(){

              var newTag = new TagObject();
              newTag.setTagId( this.getTagId() );
              newTag.setTagName( this.getTagName() );
              newTag.setPictureUrl( this.getPictureUrl() );
              newTag.setUserId( this.getUserId() );
              newTag.setPacketId( this.getPacketId() );
              newTag.setChatBindingPort( this.getChatBindingPort() );
              newTag.setChatIp( this.getChatIp() );
              newTag.setChatRegisterPort( this.getChatRegisterPort() );
              newTag.setServerDate( this.getServerDate() );

              newTag.setMembersObjectMap( this.getMembersObjectMap().copy() );

              return newTag;

        };

		TagObject.prototype.update = function(newTagObj){

			if( !!newTagObj.getTagName() ){
			  this.setTagName( newTagObj.getTagName() );
			}

			if( !!newTagObj.getPictureUrl() ){
				this.setPictureUrl( newTagObj.getPictureUrl() );
			}

			if( !!newTagObj.getUserId() ){
				this.setUserId( newTagObj.getUserId() );
			}

			if( !!newTagObj.getPacketId() ){
				this.setPacketId(  newTagObj.getPacketId() );
			}

			if( !! newTagObj.getChatBindingPort() ){
				this.setChatBindingPort( newTagObj.getChatBindingPort() );
			}

			if( !!newTagObj.getChatIp() ){
				this.setChatIp( newTagObj.getChatIp() );
			}

			if( !!newTagObj.getChatRegisterPort() ){
				this.setChatRegisterPort( newTagObj.getChatRegisterPort() );
			}

			if( !!newTagObj.getServerDate() ){
				this.setServerDate( newTagObj.getServerDate() );
			}

		};

		TagObject.prototype.sortBy = function(){
			return this.getTagCreationTime();
		};

		function TagMember(){

			var self = this;

			var tagMember = {
				tagId : 0,
				userId : 0,
				fullName : '',
				status : 0,
				statusValue : '',
				addedBy : 0,
				user : {},
				addedByUser : {}
			};

            this.initWithUserMapObject = function(anUserMapObject){

                self.setId( anUserMapObject.getKey() );
                self.setFullName( anUserMapObject.getName() );
                self.setUserObj(anUserMapObject);
            };

			this.setTagId = function(tagId){
				tagMember.tagId = tagId;
			};

			this.getTagId = function(){
				return tagMember.tagId;
			};

			this.setId = function(memberId){
				tagMember.userId = memberId.toString();
			};

			this.getId = function(){
				return tagMember.userId;
			};

			this.getUser = function(){
				return userFactory.getUser(tagMember.userId);
				//return tagMember.user;
			};

			this.setFullName = function(fullName){
				tagMember.fullName = fullName;
			};

			this.getFullName = function(){
				return tagMember.fullName;
			};

			this.getPictureUrl = function(){
				if( !self.getUser().getUserAvatar){
					return 'images/prof.png';
				}else{
					return settings.imBase +  self.getUser().getUserAvatar();
				}
			};

			this.getName = function(){
				if( tagMember.fullName !== ''){

					return tagMember.fullName;

				}else if(!!self.getUser()) {

					  return self.getUser().getName();
				}else{

					return tagMember.userId;
				}

			};

			this.getStatus = function(){
				return tagMember.status;
			};

			this.getStatusValue = function(){
				if( tagMember.status === TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN){
					return 'admin';
				}else if( tagMember.status === TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER){
					return 'member';
				}else{
					return 'owner';
				}
			};

			this.setStatus = function(status){
				tagMember.status = status;
			};

			this.setAddedBy = function(addedBy){
				tagMember.addedBy = addedBy;
			};

			this.getAddedBy = function(){
				return tagMember.addedBy;
			};

			this.getAddedByUser = function(){
				return userFactory.getUser(tagMember.addedBy);
				//return tagMember.addedByUser;
			};

			this.getAddedByUserName = function(){
				return !!self.getAddedByUser() && self.getAddedByUser().getName();
			};

			this.setAddedByUserObj = function(userObj){
				tagMember.addedByUser = userObj;
			};

			this.setUserObj = function(userObj){
				tagMember.user = userObj;
			};

            this.initUserObjects = function(){

				profileFactory.getUserDetailsByUId(tagMember.userId);

				setTimeout(function(tagMember){

					profileFactory.getUserDetailsByUId(tagMember.addedBy);

				}.bind(null, tagMember), AUTH_SERVER_CONFIG.REQUEST_DELAY);

            };

			this.isCurrentUser = function(){
				return self.getId() === Auth.currentUser().getKey();
			};

			this.isAdmin = function(){
				return tagMember.status == TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN;
			};

			this.isMember = function(){
				return tagMember.status == TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER;
			};

			this.isOwner = function(){
				return tagMember.status == TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.OWNER;
			};

			this.isRemoved = function(){
				return tagMember.status == TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.REMOVED;
			};

			this.makeAdmin = function(){
				tagMember.status = TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN;
			};

			this.makeMember = function(){
				tagMember.status = TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER;
			};

			this.makeOwner = function(){
				tagMember.status = TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.OWNER;
			};


			this.serialize = function(){
				return {
					userId : self.getId(),
					fullName : self.getName().utf8Encode(),
					status : self.getStatus(),
					addedBy : self.getAddedBy()
				};
			};

		}

		function TagMessage(){

			var self = this;

			var tagMessage = {
				tagId : 0,
				text: '',
				hrtime: '',
				status: '',
				messageDate: '',
				isDeleted: false,
				messageDateString: '',
				timeout: 0,
				userId : 0,
				fullName : '',
				type : 0,
				packetId : 0,


				/***** Derived *****/
				user : {},

				seenPacketSent : false,
				deliveredPacketSent : false,
				statusType : '',

				seenUsers : [],
				deliveredUsers : [],

				usersToChange : {},

				/*** Helper ****/
				tagName : ''


			};

			this.getTagId = function(){
				return tagMessage.tagId;
			};

			this.setTagId = function(tagId){
				tagMessage.tagId = tagId;
			};

			this.getHumanReadableTime = function(){
				return tagMessage.hrtime;
			};

			this.setHumanReadableTime = function(hrtime){
				tagMessage.hrtime = hrtime;
			};

			this.setFullName = function(fullName){
				tagMessage.fullName = fullName.substring(0, 127);;
			};

			this.getFullName = function(){
				return tagMessage.fullName;
			};

			this.getPacketId = function(){
				return tagMessage.packetId;
			};

			this.setPacketId = function(packetId){
				tagMessage.packetId = packetId;
			};

			this.getMessageText = function(messageText){
				return tagMessage.text;
			};

			this.setMessageText = function(messageText){
				tagMessage.text = messageText;
			};

			this.setStatus = function(messageStatus){
				tagMessage.status = messageStatus;
			};

			this.getStatus = function(){
				return tagMessage.status;
			};

			this.setMessageDate = function(messageDate){
				tagMessage.messageDate = messageDate;
			};

			this.getMessageDate = function(){
				return tagMessage.messageDate;
			};

			this.markAsDeleted = function(){
				tagMessage.isDeleted = true;
			};

			this.unMarkFromDeleted = function(){
				tagMessage.isDeleted = false;
			};

			this.getIsDeleted = function(){
				return tagMessage.isDeleted;
			};

			this.setMessageDateString= function(messageDateString){
				tagMessage.messageDateString = messageDateString;
			};
			this.setTimeout = function(timeout){
				tagMessage.timeout = timeout;

			};
			this.setUserId = function(userId){
				tagMessage.userId = userId;
			};

			this.getMessageDateString= function(){
				return tagMessage.messageDateString;
			};

			this.getTimeout = function(){
				return tagMessage.timeout;
			};

			this.getUserId = function(){
				return tagMessage.userId;
			};

			this.getUser = function(){
				return userFactory.getUser(tagMessage.userId);
			};

			this.getMessageType = function(){
				return tagMessage.type;
			};

			this.setMessageType = function(messageType){
				return tagMessage.type = messageType;
			};

			this.initUserObjects = function() {
				profileFactory.getUserDetailsByUId(tagMessage.userId).then(function (userObj) {
					if (!!userObj) {
						tagMessage.user = userObj;
					}
				});
			};

			this.getSeenPacketSent = function(){
				return tagMessage.seenPacketSent;
			};

			this.getDeliveredPacketSent = function(){
				return tagMessage.deliveredPacketSent;
			};

			this.setSeenPacketSent = function(seenPacketSent){
				tagMessage.seenPacketSent = seenPacketSent;
			};

			this.setDeliveredPacketSent = function( deliveredPacketSent ){
				tagMessage.deliveredPacketSent = deliveredPacketSent;
			};

			this.addSeenUserId = function(userId){
				tagMessage.seenUsers.push(userId);
			};

			this.addDeliveredUserId = function(userId){
				tagMessage.deliveredUsers.push(userId);
			};

			this.setUsersToChange = function(usersToChange){
				tagMessage.usersToChange = usersToChange;
			};

			this.getUsersToChange = function(usersToChange){
				return tagMessage.usersToChange;
			};

			this.setStatusType = function(statusType){
				tagMessage.statusType = statusType;
			};

			this.getStatusType = function(){
				return tagMessage.statusType;
			};

			this.getTagName = function(){
				return tagMessage.tagName;
			};

			this.setTagName = function(tagName){
				tagMessage.tagName = tagName;
			};


			this.serialize = function(){
				return {
					tagId : self.getTagId(),
					userId : self.getUserId(),
					user : self.getUserId(),
					packetId : self.getPacketId(),
					fullName : self.getFullName().utf8Encode(),
					status : self.getStatus(),
					statusType : self.getStatusType(),
					type : self.getMessageType(),
					hrtime : self.getHumanReadableTime(),
					messageDate : self.getMessageDate(),
					isDeleted : tagMessage.isDeleted,
					timeout : self.getTimeout(),
					text : self.getMessageText().utf8Encode(),

					seenPacketSent : self.getSeenPacketSent(),
					deliveredPacketSent : self.getDeliveredPacketSent(),
					usersToChange : Object.keys(tagMessage.usersToChange),

					messageType: self.getMessageType(),
					tag_chat : true,
					tagName : self.getTagName()

				};
			};
		}


		TagMessage.prototype.update = function(newTagMessageObj){

			if( !!newTagMessageObj.getFullName() ){
				this.setFullName( newTagMessageObj.getFullName() );
			}

			if( !!newTagMessageObj.getStatus() ){
				this.setStatus( newTagMessageObj.getStatus() );
			}

			if( !!newTagMessageObj.getStatusType() ){
				this.setStatusType( newTagMessageObj.getStatusType() );
			}

			if( !!newTagMessageObj.getMessageType() ){
				this.setMessageType( newTagMessageObj.getMessageType() );
			}

			if( !!newTagMessageObj.getMessageDate() ){
				this.setMessageDate( newTagMessageObj.getMessageDate() );
			}

			if( !!newTagMessageObj.getMessageText() ){
				this.setMessageText( newTagMessageObj.getMessageText() );
			}

			if( !!newTagMessageObj.getUsersToChange() ){
				this.setUsersToChange( newTagMessageObj.getUsersToChange() );
			}

			if( !!newTagMessageObj.getMessageType() ){
				this.setMessageType( newTagMessageObj.getMessageType() );
			}

			if( !!newTagMessageObj.getSeenPacketSent() ){
				this.setSeenPacketSent( newTagMessageObj.getSeenPacketSent() );
			}

			if( !!newTagMessageObj.getDeliveredPacketSent() ){
				this.setDeliveredPacketSent( newTagMessageObj.getDeliveredPacketSent() );
			}

			if( !!newTagMessageObj.getDeliveredPacketSent() ){
				this.setDeliveredPacketSent( newTagMessageObj.getDeliveredPacketSent() );
			}

			if( !!newTagMessageObj.getTimeout() ){
				this.setTimeout( newTagMessageObj.getTimeout() );
			}

			if( !!newTagMessageObj.getIsDeleted()){
				this.markAsDeleted();
			}

			if( !newTagMessageObj.getHumanReadableTime() ){
				this.setHumanReadableTime(newTagMessageObj.getHumanReadableTime());
			}



		};

		return {

			TagObject : TagObject,
			TagMember : TagMember,
			TagMessage: TagMessage

		};
	}


})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.tagchat')
		.factory('tagChatFactory', tagChatFactory);

		tagChatFactory.$inject = [
			'$$stackedMap', '$$connector',
			'TAG_CHAT_GENERAL_CONSTANTS', 'TAG_CHAT_PACKET_TYPE', 'TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP',
			'FRIEND_CHAT_PACKET_TYPE',
			'AUTH_SERVER_ACTIONS',
			'userFactory', 'friendsFactory', 'profileFactory',
			'Auth', 'utilsFactory',
			'CHAT_GLOBAL_VALUES',
			'tagChatModels', 'tagChatPacketProcessor'

		];

		function tagChatFactory(
			$$stackedMap, $$connector,
			TAG_CHAT_GENERAL_CONSTANTS, TAG_CHAT_PACKET_TYPE, TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP,
			FRIEND_CHAT_PACKET_TYPE,
			AUTH_SERVER_ACTIONS,
			userFactory, friendsFactory, profileFactory,
			Auth, utilsFactory,
			CHAT_GLOBAL_VALUES,
			tagChatModels, tagChatPacketProcessor

		) {

			var tagChatTags = $$stackedMap.createNew(true);
            var registeredTags = {};
			var tagInitiator = {};
			var tagChatRequestCache = {};
			var tagChatResponseCache = {};
			var tagIdleIntervals = {};




			var _startProcessRequest = true;

			return {
				createNewTag: _createNewTag,
				createNewTagMember : _createNewTagMember,
				createNewTagMessage : _createNewTagMessage,
				createTagStatusMessage : _createTagStatusMessage,

				addTagObject : _addTagObject,
				removeTagObject : _removeTagObject,

				getTags : _getTags,
				getTag : _getTag,
				generateNewTagId : getTagId,

				getOrCreateTag : _getOrCreateTag,
				getOrCreateMessage : _getOrCreateMessage,

				updateTag : _updateTag,

				getTagLastMessageObject : _getTagLastMessageObject,

                isTagRegistered : _isTagRegistered,
                markTagAsRegistered : _markTagAsRegistered,
				unRegisterTag : _unRegisterTag,
				updateTagRegisteredTime : _updateTagRegisteredTime,

				setTagChatInitiator : _setTagChatInitiator,
				resetTagChatInitiator : _resetTagChatInitiator,
				isTagChatInitiator : _isTagChatInitiator,

				setInTagChatRequestCache : _setInTagChatRequestCache,
				resetInTagChatRequestCache : _resetInTagChatRequestCache,
				resetInTagChatRequestCacheForAuth :_resetInTagChatRequestCacheForAuth,
				getFromTagChatRequestCache : _getFromTagChatRequestCache,
				getAuthRequestKey : _getAuthRequestKey,
				isInRequestCacheForAuth : _isInRequestCacheForAuth,
				isInRequestCacheForChat : _isInRequestCacheForChat,

				setInTagChatResponseCache : _setInTagChatResponseCache,
				resetFromTagChatResponseCache : _resetFromTagChatResponseCache,
				getFromTagChatResponseCache : _getFromTagChatResponseCache,

				setInTagChatResponseCacheForAuth :_setInTagChatResponseCacheForAuth,
				isInTagChatResponseCacheForAuth: _isInTagChatResponseCacheForAuth,

				getIdleIntervalIdByTagId : _getIdleIntervalIdByTagId,
				setIdleIntervalIdByTagId : _setIdleIntervalIdByTagId,
				resetIdleIntervalIdByTagId : _resetIdleIntervalIdByTagId,

				hasReceivedConfirmation : _hasReceivedConfirmation,

				shouldProcessRequest : _shouldProcessRequest,


				startProcessingRequest : _startProcessRequest,

				getUUIDPacketId : _getUUIDPacketId


				/*** Temp Usages For Testing ***/

			};

			///////////////////////////  ///////////////////////////

			function getTagId(){

				var userId = Auth.currentUser().getKey().toString();

				var currentTime = new Date().getTime().toString();

				var tagId = currentTime.substr(0, TAG_CHAT_GENERAL_CONSTANTS.TAG_ID_NO_OF_TIME_DIGIT );

				tagId += userId.substr(userId.length - TAG_CHAT_GENERAL_CONSTANTS.TAG_ID_NO_OF_USER_ID_DIGIT );

				return tagId;
			}

			function _getTags(){
				return tagChatTags;
			}

			function _getTag(key){
				return tagChatTags.get(key);
			}

			function _removeTagObject(key){
				return tagChatTags.remove(key);
			}

			function _createNewTag(object, tagObject){

				if( !tagObject){
					tagObject = new tagChatModels.TagObject();
				}

				if( !object.tagId ){
					tagObject.setTagId( getTagId() );
				}else{
					tagObject.setTagId( object.tagId );
				}

				if(!!object.packetId){
					tagObject.setPacketId( object.packetId );
				}

				if(!!object.userId){
				 tagObject.setUserId( object.userId );
				}

				if(!!object.tagName){
					tagObject.setTagName( object.tagName );
				}

				if(!!object.tagPictureUrl){
					tagObject.setPictureUrl( object.tagPictureUrl );
				}

				if(!!object.chIp){
					tagObject.setChatIp( object.chIp );
				}

				if(!!object.chRp){
					tagObject.setChatRegisterPort( object.chRp );
				}

				if(!!object.serverDate){
					tagObject.setServerDate(object.serverDate);
				}

				if(!!object.tagMembersCount){
					tagObject.setMembersCount(object.tagMembersCount);
				}

				return tagObject;
			}

			function _createNewTagMember(tagId, object, userObjectInit){
				var tagMemberObject = new tagChatModels.TagMember();

                if( !!tagId){
				    tagMemberObject.setTagId( tagId );
                }

                if(!!object){

                    if(!!object.userId){
                        tagMemberObject.setId( object.userId );
                    }

                    if(!!object.fullName){
                        tagMemberObject.setFullName( object.fullName );
                    }

                    if(!!object.addedBy){
                        tagMemberObject.setAddedBy( object.addedBy );

                    }

                    if(!!object.status){
                        tagMemberObject.setStatus( object.status );
                    }else{
                        tagMemberObject.setStatus( TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER );
                    }

                    //if(!!userObjectInit){
                    //    tagMemberObject.initUserObjects();
                    //}
                }

				return tagMemberObject;

			}

			function _createNewTagMessage(tagId, object, userObjectInit){

				var tagMessageObject = new tagChatModels.TagMessage();

                if( !!tagId){
				    tagMessageObject.setTagId( tagId );
                }

                if(!!object){

                    if(!!object.userId){
                        tagMessageObject.setUserId( object.userId );
                    }

					if(!!object.user){
						tagMessageObject.setUserId( object.user );
					}

					if(!!object.fullName){
						tagMessageObject.setFullName( object.fullName );
					}

                    if(!!object.message){
                        tagMessageObject.setMessageText( object.message );
                    }

                    if(!!object.hrtime){
                        tagMessageObject.setHumanReadableTime( object.hrtime );
                    }

					if(!!object.messageDate){
                        tagMessageObject.setMessageDate( object.messageDate );
                    }

					if(!!object.isDeleted){
                        tagMessageObject.markAsDeleted( object.isDeleted );
                    }

					if(!!object.messageDateString){
                        tagMessageObject.setMessageDateString( object.messageDateString );
                    }

					if(!!object.timeout){
                        tagMessageObject.setTimeout( object.timeout );
                    }

					if(!!object.messageType){
                        tagMessageObject.setMessageType( object.messageType );
                    }

                    if(!!object.status){
                        tagMessageObject.setStatus( object.status );
                    }

					if(!!object.packetId){
						tagMessageObject.setPacketId( object.packetId );
					}

					if(!!object.usersToChange){
						tagMessageObject.setUsersToChange( object.usersToChange );
					}

					if(!!object.statusType){
						tagMessageObject.setStatusType( object.statusType );
					}

					if(!!object.tagName){
						tagMessageObject.setTagName( object.tagName );
					}


					/**** ****/

                    //if(!!userObjectInit){
                    //    tagMessageObject.initUserObjects();
                    //}
                }

				return tagMessageObject;

			}

			function _createTagStatusMessage(packetId, tagId, userId, messageType, usersToChangeArray, restInfo){

				var statusMessageObject = {};

				var tagObject = _getTag(tagId);

				if(!!tagObject){
					var messageDate;
					if( !restInfo.messageDate ){

						messageDate = parseInt(new Date().getTime()) + tagObject.getServerDateDiff();
					}else{
						messageDate = restInfo.messageDate;
					}


					profileFactory.getUserDetailsByUId(userId);
					var userObject = userFactory.getUser(userId);

					statusMessageObject = {
						message: '',
						fullName : userObject.getName(),
						status: 'status_update',
						statusType : messageType,
						tagName : !!restInfo ? restInfo.tagName : '',
						messageDate: messageDate,
						messageType : 2,
						tag_chat: true,
						userId : userId,
						user : userId,
						packetId : packetId

					};

					statusMessageObject.usersToChange = {};

					if( usersToChangeArray.length > 0) {

						for (var index = 0; index < usersToChangeArray.length; index++) {

							var changedUserObject = usersToChangeArray[index];
							var tagMemberObject = _createNewTagMember(tagObject.getTagId(), changedUserObject, true);
							statusMessageObject.usersToChange[tagMemberObject.getName()] = true;
						}
					}

					var tagMessage = _createNewTagMessage(tagId, statusMessageObject);

					return tagMessage;

				}

				return false;

			}

			function _getTagLastMessageObject(messageObject){

				var tagLastMessageObject = {
					key : messageObject.key,
					text : messageObject.text,
					messageType : messageObject.messageType,
					messageDate : messageObject.messageDate

				};

				return tagLastMessageObject;

			}

			function _addTagObject(aNewTagObject){

				if( !(aNewTagObject instanceof tagChatModels.TagObject ) ){
					console.error('Please provide tagChatModels.TagObject() Instance');
					return false;
				}

                var aFactoryTagObj = tagChatTags.get(aNewTagObject.getTagId());
                if( !!aFactoryTagObj ){

                    aFactoryTagObj.update( aNewTagObject );

                }else{
    				tagChatTags.add(aNewTagObject.getTagId(), aNewTagObject);
                }

				return true;

			}

			function _getOrCreateTag(tagId, newTagInfo ){

				if(!newTagInfo){
					newTagInfo = {tagId : tagId};
				}

				var tagObj = _getTag( tagId );
				if( !tagObj ){
					tagObj = _createNewTag(newTagInfo);
				}else{
					tagObj = _createNewTag(newTagInfo, tagObj);
				}

				tagChatTags.save(tagId, tagObj);
				return tagObj;
			}

			function _updateTag(tagId, newTagInfo, oldTagObj ){

				if(!oldTagObj){
					oldTagObj = _getTag( tagId );
				}

				oldTagObj = _createNewTag(newTagInfo, oldTagObj);
				tagChatTags.save(tagId, oldTagObj);

				return oldTagObj;
			}

			function _getOrCreateMessage(tagId, newTagMessageInfo ){

				var newTagInfo = {tagId : tagId};

				if(!newTagMessageInfo){
					newTagMessageInfo = {tagId : tagId};
				}

				var tagObj = _getTag( tagId );

				if( !tagObj ){
					tagObj = _createNewTag(newTagInfo);
					tagChatTags.save(tagId, tagObj);
				}

				var newTagMessageObj = _createNewTagMessage(tagId, newTagMessageInfo, true);

				var oldTagMessageObj = tagObj.getMessage(newTagMessageInfo.packetId);

				if( !oldTagMessageObj){
					oldTagMessageObj = newTagMessageObj;

					tagObj.addMessage(oldTagMessageObj);

				}else{
					oldTagMessageObj.update(newTagMessageObj);
				}

				return oldTagMessageObj;
				//
				//var event = document.createEvent('Event');
				//event.initEvent('tagmessageupdated', true, true);
				//document.dispatchEvent(event);
                //
				//return tagObj;
			}


            function _updateTagRegisteredTime(tagId, updateTime){
                registeredTags[tagId] = updateTime || new Date().getTime()/1000;

				//RingLogger.debug('Tag Reg Time updated.', tagId, RingLogger.tags.TAG_CHAT);
            }

			function _isTagRegisteredValid(tagId){

				if( !registeredTags[tagId] ){
					return false;
				}

				if( ( (new Date().getTime()/1000) - registeredTags[tagId] )  > TAG_CHAT_GENERAL_CONSTANTS.TAG_REGISTER_TIMEOUT  ){
					return false;
				}

				return true;
			}

            function _isTagRegistered(tagId){
                return !!registeredTags[tagId] && _isTagRegisteredValid(tagId);
            }

			function _unRegisterTag(tagId){
				delete registeredTags[tagId];
			}

            function _markTagAsRegistered(tagId){

                _updateTagRegisteredTime(tagId);

				utilsFactory.triggerCustomEvent('tagregistered', { tagId : tagId });

                //var timeout = setTimeout(function(){
                //    if( !_isTagRegisteredValid(tagId)  ){
					//	clearTimeout(timeout);
                //        delete registeredTags[tagId];
                //
                //        console.log(tagId, ' deleted from registered tag');
                //
                //        var tagObject = tagChatTags.get(tagId);
                //        if(!!tagObject){
					//		tagObject.resetChatIp();
					//		tagObject.resetChatRegisterPort();
                //            tagObject.resetChatBindingPort();
					//		tagObject.resetLastCommunicationTime();
                //        }
                //
					//	utilsFactory.triggerCustomEvent('tagunregistered', { tagId : tagId });
                //
                //    }else{
					//	console.log('tag valid', tagId);
					//}
                //}, TAG_CHAT_GENERAL_CONSTANTS.TAG_REGISTER_TIMEOUT);
            }

			function _setTagChatInitiator(tagId){
				tagInitiator[tagId] = true;

				// todo need to check race condition
				setTimeout(function(){
					console.log();
					RingLogger.debug("Tag Initiator Reseted", RingLogger.tags.TAG_CHAT);

					tagInitiator[tagId] = false;
				}, TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY);
			}

			function _resetTagChatInitiator(tagId){
				tagInitiator[tagId] = false;
			}

			function _isTagChatInitiator(tagId){
				return !!tagInitiator[tagId];
			}


			/****************************** TagChat Request Cache Start *******************************/

			function _getAuthRequestKey(tagId, actionId){
				return tagId + '-' + actionId;
			}

			function _setInTagChatRequestCache(packetId, requestObject){
				if(!_startProcessRequest){ return; }

				tagChatRequestCache[packetId] = requestObject;
				//RingLogger.debug('SET : KEY {0} : VALUE: {1}'.format(packetId, requestObject), RingLogger.tags.CHAT_REQUEST_CACHE);
				_initTagChatRequestCacheClearInterval(packetId);
			}

			function _resetInTagChatRequestCache(packetId){
				//RingLogger.debug('RESET : KEY {0}'.format(packetId), RingLogger.tags.CHAT_REQUEST_CACHE);
				delete tagChatRequestCache[packetId];
			}

			function _getFromTagChatRequestCache(key){
				return tagChatRequestCache[key];
			}

			function _isInRequestCacheForChat(packetId){
				return !!_getFromTagChatRequestCache(packetId);
			}

			function _isInRequestCacheForAuth(tagId, actn){
				var key = _getAuthRequestKey(tagId, actn);
				return !!_getFromTagChatRequestCache(key);
			}

			function _resetInTagChatRequestCacheForAuth(tagId, actn){
				var key = _getAuthRequestKey(tagId, actn);
				_resetInTagChatRequestCache(key);
			}

			function _initTagChatRequestCacheClearInterval(key){
			 	setTimeout(function(){

					// RingLogger.info('Request Cache Cleared for ', key , RingLogger.tags.TAG_CHAT_REQUEST);

					_resetInTagChatRequestCache(key);
				}, TAG_CHAT_GENERAL_CONSTANTS.REQUEST_CACHE_VALIDITY);
			}

			/****************************** TagChat Request Cache End *******************************/

			/****************************** TagChat Response Cache Start *******************************/

			function _getTagChatResponseCacheKey(packetId, responseObject){

				if( responseObject.packetType == TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED ||
					responseObject.packetType == FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED ||
					responseObject.packetType == FRIEND_CHAT_PACKET_TYPE.TAG_CHAT_SENT ||
					responseObject.packetType == FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT
				){
					var packetIdParts = packetId.split('_');
					if( packetIdParts.length == 2){
						responseObject.packetId = packetIdParts[0];
						responseObject.sequenceNo = packetIdParts[1];
					}
				}


				if(!responseObject.sequenceNo){
					responseObject.sequenceNo = 0;
				}

				return packetId + '_' + responseObject.sequenceNo +'_' + responseObject.packetType;
			}

			function _setInTagChatResponseCache(packetId, responseObject){
				var key = _getTagChatResponseCacheKey(packetId, responseObject);

				tagChatResponseCache[key] = responseObject;
				//RingLogger.debug('SET : KEY {0} : VALUE: {1}'.format(key, responseObject), RingLogger.tags.CHAT_RESPONSE_CACHE);
				_initTagChatResponseCacheClearInterval(key);
			}

			function __doResetFromTagChatResponseCache(key){
				//RingLogger.debug('RESET : KEY {0}'.format(key), RingLogger.tags.CHAT_RESPONSE_CACHE);
				delete tagChatResponseCache[key];
			}

			function _resetFromTagChatResponseCache(packetId, packetType){
				var key = _getTagChatResponseCacheKey(packetId, { packetType : packetType});
				__doResetFromTagChatResponseCache(key);
			}

			function _getFromTagChatResponseCache(responseObject){
				var key = _getTagChatResponseCacheKey(responseObject.packetId, responseObject);
				return tagChatResponseCache[key];
			}

			function _initTagChatResponseCacheClearInterval(key){
			 	setTimeout(function(){
					// console.log('Response Cache Cleared for ', key);
					__doResetFromTagChatResponseCache(key);
				}, TAG_CHAT_GENERAL_CONSTANTS.RESPONSE_CACHE_VALIDITY);
			}


			function _setInTagChatResponseCacheForAuth(tagId, actnId){
				_setInTagChatResponseCache(tagId, { packetType : actnId} );
			}

			function _isInTagChatResponseCacheForAuth(tagId, actnId){
				return !!_getFromTagChatResponseCache({ packetId : tagId, packetType : actnId});
			}

			/****************************** TagChat Response Cache End *******************************/

			/****************************** TagChat Confirmation Methods Start *******************************/


			function __hasReceivedConfirmationByConfirmationPacketType(confirmationPacketType, packetId, sequenceNo){
				var responseObject = {
					packetId : packetId,
					packetType : confirmationPacketType,
					sequenceNo : sequenceNo
				};

				return !!_getFromTagChatResponseCache(responseObject);
			}
			function _hasReceivedConfirmation(packetId, packetType, sequenceNo){

				if(!sequenceNo){
					sequenceNo = 0;
				}

				var confirmationPacketType = TAG_CHAT_PACKET_TYPE_CONFIRMATION_MAP[packetType];
				if( !confirmationPacketType ){
					console.warn('Confirmation Packet Type Not Defined');
				}else{
					var receivedConfirmation = false;
					if( angular.isArray(confirmationPacketType)){
						for(var index = 0, length = confirmationPacketType.length; index < length; index++){
							if( __hasReceivedConfirmationByConfirmationPacketType(confirmationPacketType[index], packetId, sequenceNo)){
								receivedConfirmation = true;
								break;
							}
						}
					}else{
						receivedConfirmation = __hasReceivedConfirmationByConfirmationPacketType(confirmationPacketType, packetId, sequenceNo);
					}
				}

				return receivedConfirmation;
			}

			/****************************** TagChat Confirmation Methods End *******************************/


			function _getIdleIntervalIdByTagId(tagId){
				return tagIdleIntervals[tagId];
			}

			function _setIdleIntervalIdByTagId(tagId, intervalId){
				tagIdleIntervals[tagId] = intervalId;
			}

			function _resetIdleIntervalIdByTagId(tagId){
				delete tagIdleIntervals[tagId];
			}


			/****************************** TagChat Should Process Request *******************************/

			function _shouldProcessRequest(request){

				if(!request.actn){
					//Chat Request

				}else{
					//Auth Request
					var tagId = request.tid || request.tagId;

					var isInRequestCache = _isInRequestCacheForAuth(tagId, request.actn);

					return !isInRequestCache;

				}

			}

			function _getRingPacketId(){
				return utilsFactory.getUniqueID('tagc');
			}

			function _getUUIDPacketId(packetTime, isPacketIdStamp){
				var timestamp;

				if( !isPacketIdStamp && !packetTime){
					packetTime = new Date().getTime();
					timestamp =  parseInt(packetTime + CHAT_GLOBAL_VALUES.serverTimeDiff);

				}else{
					timestamp = packetTime;
				}

				if( !timestamp){
					RingLogger.alert('Invalid Timestamp', RingLogger.tags.CHAT);
				}

				return PacketIDGenerator.create(Auth.currentUser().getKey(), timestamp, isPacketIdStamp);
			}

		}
})();

/*
 * © Ipvision
 * @Ibrahim Rashid
 * Tyring to build an optimized serializer for localstorage
 */

(function() {
	'use strict';

	angular
		.module('ringid.tagchat')
		.factory('tagChatStorage', tagChatStorage);

		tagChatStorage.$inject = [
			'Storage', 'Auth', 'utilsFactory'

		];

		function tagChatStorage(
			Storage, Auth, utilsFactory

		) {

			var StorageObjectModel = {
				packets : {}
			};

			function _init(){
				var localStorageObjectModel = __readFromLocalStorage();
				if(!localStorageObjectModel){					
					__writeToLocalStorage(StorageObjectModel );	
				}else{
					StorageObjectModel  = angular.fromJson(localStorageObjectModel);
				}

			}

			function _getStoreKey(){
				return 'tagc-store-' + Auth.currentUser().getKey();
			}

			function __writeToLocalStorage(data){
				Storage.setData(_getStoreKey(), angular.toJson(data));
			}

			function __readFromLocalStorage(){
				return Storage.getData(_getStoreKey());
			}

			function _savePacket(packetId, packetData){
				StorageObjectModel.packets[packetId] = utilsFactory.arrayBuffer2String(packetData.buffer.slice(6));
				__writeToLocalStorage(StorageObjectModel);
			}

			function _getPacket(packetId){				
				return utilsFactory.string2ArrayBuffer(StorageObjectModel.packets[packetId]);
			}

			function _getAllPackets(){
				return StorageObjectModel.packets;
			}

			if(Auth.isLoggedIn()){
				//_init();
			}

			return {

				savePacket : _savePacket,
				getPacket  : _getPacket,
				getAllPackets : _getAllPackets
			}

			

		}
})();

/* jshint RingLogger: true*/

(function() {
	'use strict';

	angular
		.module('ringid.tagchat')
		.factory('tagChatManager', tagChatManager);

	tagChatManager.$inject = [
		 	'$$connector', '$q', '$timeout',
			'Auth',
			'tagChatFactory',
			'tagChatApiService', 'tagChatPacketProcessor', 'tagChatUI', 'tagChatHelper',
			'ChatFactory', 'chatHistoryFactory',
			'userFactory', 'utilsFactory', 'profileFactory', 'tagChatStorage',
			'OPERATION_TYPES' ,'Ringalert', 'TAG_CHAT_GENERAL_CONSTANTS', 'TAG_CHAT_PACKET_TYPE', 'TAG_CHAT_LANG', 'AUTH_SERVER_ACTIONS',
			'OFFLINE_PACKET_TYPE', 'FRIEND_CHAT_PACKET_TYPE',
			'chatPacketResender', 'chatUtilsFactory'

	];

	function tagChatManager (

			 $$connector, $q, $timeout,
			 Auth,
			 tagChatFactory,
			 tagChatApiService, tagChatPacketProcessor, tagChatUI, tagChatHelper,
			 ChatFactory, chatHistoryFactory,
			 userFactory, utilsFactory, profileFactory, tagChatStorage,
			 OPERATION_TYPES, Ringalert, TAG_CHAT_GENERAL_CONSTANTS, TAG_CHAT_PACKET_TYPE, TAG_CHAT_LANG,AUTH_SERVER_ACTIONS,
			 OFFLINE_PACKET_TYPE, FRIEND_CHAT_PACKET_TYPE,
			 chatPacketResender, chatUtilsFactory

	) {

		var callXTimeAfterYIntervalStopOnSuccess = utilsFactory.callXTimeAfterYIntervalStopOnSuccess;
		var hasReceivedConfirmation = tagChatFactory.hasReceivedConfirmation;
		var _executeAfterTagRegisterEvent = tagChatHelper.executeAfterTagRegisterEvent;

		var ChatPacketSender = chatPacketResender.ChatPacketSender;


		utilsFactory.onCustomEvent('tagChatNoIpOrPort', function(data){
			_registerTag(data.tagId, TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.ONLY_REGISTER);
		});

		utilsFactory.onCustomEvent('RE_REGISTER_TAG', function(data){

			tagChatFactory.unRegisterTag(data.tagId);
			_registerTag(data.tagId, TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.CHAT_INVITE);
		});

		/** Open Previously Open Box One time when tag list gets updated **/
		//var previouslyOpenTagChatBoxes = chatHistoryFactory.getAllOpenBoxes();
		//var doOpenPreviouslyOpenedBoxes = function(){
		//	_openPreviouslyOpenedBoxes();
		//};
		//
		//
		//utilsFactory.onCustomEvent('taglistupdated', doOpenPreviouslyOpenedBoxes);

		function _requestForIp(tagId){

			var tagObject = tagChatFactory.getOrCreateTag(tagId);

			if(!!tagObject){

				tagChatApiService.createOrGetTagFromAuth(tagObject, tagObject.getMemberUserIds())
					.then(function(response){
						response.isInitiated = true;
						_doOnTagChatRequestStartResponse(response);
					});
			}
		}

		//function _updateChatBoxInfo(tagId, openedBox, info){
		//	if ( !openedBox){
		//		openedBox = ChatFactory.getBoxByUId(tagId);
		//	}
        //
		//	if ( !!openedBox ){
		//		if( !!info.chIp ){
		//			openedBox.setIp( info.chIp );
		//		}
        //
		//		if( !!info.chRp ){
		//			openedBox.setRPort(info.chRp);
		//		}
        //
		//		if( !!info.chatBindingPort){
		//			openedBox.setPort(info.chatBindingPort);
		//		}
        //
         //       //openedBox.updateLastCommunicationTime();
        //
         //   }
		//}

		function _updateTagIpPort(tagId, updateInfo){

			var ip = updateInfo.chIp,
				port = updateInfo.chRp,
				tagObject = tagChatFactory.getTag(updateInfo.tid),
				chatBox = ChatFactory.getBoxByUId(updateInfo.tid);

			tagObject.setChatIp(ip);
			tagObject.setChatRegisterPort(port);

			if(!!chatBox ){
				chatBox.setIp(updateInfo.chIp);
				chatBox.setRPort(updateInfo.chRp);
			}
		}

		function _updateTagBindingPort(tagId, updateInfo){
			var tagObject = tagChatFactory.getTag(updateInfo.tid),
				chatBox = ChatFactory.getBoxByUId(updateInfo.tid),
				bindingPort = updateInfo.chatBindingPort;

			if(bindingPort){

				if(tagObject){
					tagObject.setChatBindingPort(bindingPort);
				}

				if(chatBox){
					chatBox.setRPort(bindingPort);
				}
			}
		}

        //function _updateExpiredChatBoxInfo(response){
        //
			//var tagObject, openedBox;
        //
			//if(!response.sucs){ return; }
        //
        //    tagObject = tagChatFactory.getOrCreateTag(response.tid);
        //    tagObject.setChatIp(response.chIp);
        //    tagObject.setChatRegisterPort(response.chRp);
        //
        //    _registerTag(response.tid, TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.ONLY_REGISTER);
        //
        //    openedBox = ChatFactory.getBoxByUId(response.tid);
        //    _openTagChatBoxIfClosed(response.tid, openedBox);
        //
        //    _updateChatBoxInfo( response.tid, openedBox, response);
        //
        //}

		function _doOnTagChatRequestStartResponse(response){

			if(!response.sucs){ return; }

			_updateTagIpPort(response.tid, response);

			if(response.isInitiated){
				_registerTag(response.tid, TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.CHAT_INVITE);
			}else{
				_registerTag(response.tid, TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.ONLY_REGISTER);
			}

			RingLogger.print('Tag Chat Request Start ', response, RingLogger.tags.TAG_CHAT);
		}

		function _subscribeForAuthUpdate(){

			var tagObject,
				openedBox;

			$$connector.subscribe(function (message) {
				RingLogger.print('tag-update', message, RingLogger.tags.TAG_CHAT);

				var tagId = message.tid;

				if( !!message.sucs && tagChatFactory.startProcessingRequest){
					switch (message.actn){

						case OPERATION_TYPES.SYSTEM.TAG_CHAT.TAG_CHAT_UPDATE_START:

							RingLogger.print('Received Auth Update Start', message, RingLogger.tags.TAG_CHAT);

							if( tagChatFactory.isInRequestCacheForAuth(tagId, AUTH_SERVER_ACTIONS.START_TAG_CHAT) ){
								RingLogger.print('Skipping update start coz, Self Request ', tagId , RingLogger.tags.TAG_CHAT);
								return;
							}

							if( tagChatFactory.isInTagChatResponseCacheForAuth(tagId, message.actn)){
								RingLogger.print('Skipping update start coz, Already Received an Update Start Within 15sec for ', tagId , RingLogger.tags.TAG_CHAT);
								return;
							}

							var tagObject = tagChatFactory.getTag(tagId);

                            if( !tagObject ){

								tagObject = tagChatFactory.getOrCreateTag(tagId);

								openedBox = ChatFactory.getBoxByUId(tagId);
								if( !openedBox){
									openedBox = ChatFactory.creatNonDomBox(tagId, true);
								}

								_updateTagIpPort(tagId, message);

								_requestForTagInformationMultipleTimes(tagId).then(function(response){
									if( response.sucs ){

										if(!tagChatFactory.isTagRegistered(tagId)){
											_registerTag(tagId);
										}
									}
								});

							}else{

								_updateTagIpPort(tagId, message);

								if(!tagChatFactory.isTagRegistered(tagId)){
									_registerTag(tagId);
								}
							}

							break;

						case OPERATION_TYPES.SYSTEM.TAG_CHAT.TAG_CHAT_UPDATE_ADD_MEMBER:

							RingLogger.print('Received Auth Add Member ', message, RingLogger.tags.TAG_CHAT);

							if( tagChatFactory.isInRequestCacheForAuth(tagId, AUTH_SERVER_ACTIONS.ADD_TAG_CHAT_MEMBERS) ){
								RingLogger.print('Skipping update add member coz, Self Request ', tagId , RingLogger.tags.TAG_CHAT);
								return;
							}

							if( tagChatFactory.isInTagChatResponseCacheForAuth(message.tid, message.actn)){
								RingLogger.print('Skipping auth add member coz, Already Received an add memebr Within 15sec for ', message.tid , RingLogger.tags.TAG_CHAT);
								return;
							}

							tagChatFactory.setInTagChatResponseCacheForAuth(message.tid, message.actn);

							var tagObject = tagChatFactory.getTag(tagId);

							if( !tagObject ){

								tagObject = tagChatFactory.getOrCreateTag(tagId);

								openedBox = ChatFactory.getBoxByUId(tagId);
								if( !openedBox){
									openedBox = ChatFactory.creatNonDomBox(tagId, true);
								}

								_requestForTagInformationMultipleTimes(tagId).then(function(response){
									if( response.sucs ){

										if(!tagChatFactory.isTagRegistered(tagId)){
											_registerTag(tagId);
										}
									}
								});

							}else{

								if(!tagChatFactory.isTagRegistered(tagId)){
									_registerTag(tagId);
								}
							}

							if( !!message.uIds ){
								angular.forEach(message.uIds, function(aMessageUId){

									tagObject.addMember(tagChatFactory.createNewTagMember(tagObject.getTagId(),
										{ userId : aMessageUId }, true
									));
								});

							}else{
								RingLogger.error('No Member Info Send Via Auth Update', message, RingLogger.tags.TAG_CHAT);
							}

							break;


						default:
							RingLogger.error("This message shouldn't be printed", RingLogger.tags.TAG_CHAT);
					}
				}else{

					RingLogger.print(message, RingLogger.tags.TAG_CHAT);
				}

			}, { action : [
				OPERATION_TYPES.SYSTEM.TAG_CHAT.TAG_CHAT_UPDATE_START,
				OPERATION_TYPES.SYSTEM.TAG_CHAT.TAG_CHAT_UPDATE_ADD_MEMBER
			]});
		}


		/******************************* Auth Server Communication Start ******************************/

		function _getIpPortForTag(tagId, tagObject){

			if(!tagObject){
				tagObject = tagChatFactory.getTag(tagId);
			}

			var success = false,
				deferred = $q.defer(),
				packetId = utilsFactory.getUniqueID();

			var doCreateOrGetTagFromAuth = function(){

				tagChatApiService.createOrGetTagFromAuth(tagObject, tagObject.getMemberUserIds(), packetId)
					.then(function(response){
						if( !!response.sucs && !!response.tid){
							_updateTagIpPort(response.tid, response);

							success = true;
						}else{
							success = false;
						}

					}, function(response){
						success = false;
					});
			};

			callXTimeAfterYIntervalStopOnSuccess(
				function(){
					if( !success ) {
						doCreateOrGetTagFromAuth();
					}
				},
				function(currentExecutionCount){
					if(success){
						deferred.resolve(success);
					}
					return success;
				},
				function(){
					deferred.resolve(success);
				},
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
			);

			return deferred.promise;

		}

		/******************************* Auth Server Communication End ******************************/

		/******************************* Chat Server Communication Start ******************************/

		function __doRequestForTagRegister(tagObject, regType){
			var currentUser = Auth.currentUser();

			if( !tagChatFactory.getFromTagChatRequestCache(tagObject.getTagId()) ){
				tagChatApiService.registerTagInChatServer(currentUser.getKey(), tagObject, null, regType);
				return true;
			}

			RingLogger.information('Skipping Register Request as One Request is Already in Progress for tagId ', tagObject.getTagId(),  RingLogger.tags.TAG_CHAT);

			return false;

		}

		function _registerTag(tagId, regType){

			if( !tagChatFactory.isTagRegistered(tagId)  ){

				var tagObject = tagChatFactory.getTag(tagId);

				if( !tagObject){
					RingLogger.print('Tag Nai, Register Korlam na'  , RingLogger.tags.TAG_CHAT);
					return -1;
				}

				if( tagObject.membersLength() < 2){
					RingLogger.print('Member List Length < 2, Chat Session Initiate Korlam na.'  , RingLogger.tags.TAG_CHAT);
					return -1;
				}

				if( tagObject.hasChatRegisterPort() ){

					__doRequestForTagRegister(tagObject, regType);

				}else{

					if( !tagChatFactory.isInRequestCacheForAuth(tagId, AUTH_SERVER_ACTIONS.START_TAG_CHAT) ) {

						_getIpPortForTag(tagId, tagObject).then(function(sucs){
							if( sucs ){

								RingLogger.print('Got Ip Port Info', RingLogger.tags.TAG_CHAT);

								if( !tagChatFactory.isTagRegistered(tagId)  ){
									tagObject = tagChatFactory.getTag(tagId);
									__doRequestForTagRegister(tagObject, regType);
								}

							}else{
								RingLogger.print('Failed to get Ip port from Auth For Tag', tagObject.getTagId(),sucs , RingLogger.tags.TAG_CHAT);
							}
						});

					}else{
						RingLogger.print('Skipping Ip/Port Get Request as One Request is Already in Progress', tagObject.getTagId(), RingLogger.tags.TAG_CHAT);
					}

				}
				return true;
			}
			return false;

		}

		/******************************* Chat Server Communication End ******************************/

		/******************************* TAG CRUD Start ******************************/
		function _createTag( object ) {
			/***
			 * @param tagObject
			 * tagObject = { tagId : '', uIds : [] }
			 */

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				aTag,
				aTagMemberObjectParam,
				aTagMemberObject,
				aTagAdminObjectParam,
				aTagAdminObject,
				authFailed;



			/************ Create Tag Object **************/

			object.tagMembersCount =  object.memberUIds.length + object.adminUIds.length +  1;
			aTag = tagChatFactory.createNewTag(object);


			/************ Add Tag Owner Start **************/

			aTagMemberObjectParam = {
				userId : currentUser.getKey(),
				addedBy : currentUser.getKey(),
				status : TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.OWNER
			};

			aTagMemberObject = tagChatFactory.createNewTagMember(aTag.getTagId(), aTagMemberObjectParam, true);
			aTag.addMember( aTagMemberObject );

			/************ Add Tag Owner End **************/


			/************ Add Tag Members Start **************/

			for(var tagMemberIndex = 0; tagMemberIndex < object.memberUIds.length; tagMemberIndex++ ){
				var aTagMemberUId = object.memberUIds[tagMemberIndex];

				aTagMemberObjectParam = {
					userId : aTagMemberUId,
					addedBy : currentUser.getKey(),
					status : TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER
				};

				aTagMemberObject = tagChatFactory.createNewTagMember(aTag.getTagId(), aTagMemberObjectParam, true);
				aTag.addMember( aTagMemberObject );
			}

			/************ Add Tag Members End **************/

			/************ Add Tag Admins Start **************/

			for(var tagAdminIndex = 0; tagAdminIndex < object.adminUIds.length; tagAdminIndex++ ){
				var aTagAdminUId = object.adminUIds[tagAdminIndex];

				aTagAdminObjectParam = {
					userId : aTagAdminUId,
					addedBy : currentUser.getKey(),
					status : TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN
				};

				aTagAdminObject = tagChatFactory.createNewTagMember(aTag.getTagId(), aTagAdminObjectParam, true);
				aTag.addMember( aTagAdminObject );
			}

			/************ Add Tag Admins End **************/

			/************ Create Tag In Auth Start **************/

			aTag.setObjectLock();
			tagChatFactory.addTagObject(aTag);


			//tagChatFactory.setTagChatInitiator(aTag.getTagId());

            object.uIds = object.adminUIds.concat(object.memberUIds);

			var doTagChatCreateRequestInAuth = function(){

				tagChatApiService.createOrGetTagFromAuth(aTag, object.uIds).then(function(response) {
					response.isInitiated = true;
					_doOnTagChatRequestStartResponse(response);
				});
			};



			/************ Create Tag In Auth  End  **************/

			var _doAfterTagCreateInChat = function(){
				doTagChatCreateRequestInAuth();
			};


			/************ Send Tag & Members In Chat Start **************/

			try{

				var requestObject, requestObjectPacket, aChatResender, aChatSender,aChatSenderInstance;

				requestObject = tagChatApiService.getTagCreateRequestObject(currentUser.getKey(), aTag);

				aChatSender = new ChatPacketSender();
				aChatSender.setPacketObject(requestObject);
				aChatSender.setBrokenPacketType(OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET);
				aChatSenderInstance = aChatSender.getInstance();


				aChatSenderInstance.on('success', function(response){

				   if( !!response.sucs ){

					   aTag.removeObjectLock();
					   _doAfterTagCreateInChat();

					   //tagChatStorage.savePacket(tagCreatePacketId, requestObjectPacket);

					   deferred.resolve({ sucs: true });
				   }
				});
				aChatSenderInstance.on('failure', function(response){

					tagChatFactory.removeTagObject(aTag.getTagId());

					deferred.reject({ sucs : false , msg : 'Unable create tag in offline server.'});
					RingLogger.alert('Unable create tag in offline server ', aTag.getTagId(), RingLogger.tags.TAG_CHAT);
				});

				aChatSenderInstance.start();


			}catch(e){
				RingLogger.alert('Tag Create  Exception ', e, RingLogger.tags.TAG_CHAT);

				tagChatFactory.removeTagObject(aTag.getTagId());

				deferred.reject({ sucs : false , msg : 'Unable create tag in offline server.'});
				RingLogger.alert('Unable create tag in offline server ', aTag.getTagId(), RingLogger.tags.TAG_CHAT);

			}


			/************ Send Tag & Members In Chat End **************/


			return deferred.promise;

		}

		function __getMembersForCRUD(oldTagObj, memberUIdsToSet, adminUIdsToSet){

			var currentUser = Auth.currentUser(),
				oldTagMemberListCopy,  oldTagMembersAndAdminsMap,
				allOldTagMembersAndAdminsMap, aTagMemberObject,
				statusChanged, aNewMember,
				newTagMemberObject, aNewAdmin,
				newTagAdminObject,
				serializedMemberAdminsToRemove = [],
				serializedMemberAdminsToStatusChange = [],
				serializedNewMemberAdminsToAdd = [],
				membersAdminToAddOnSuccess = [],
				membersAdminToRemoveOnSuccess = [],
				membersAdminToUpdateOnSuccess = [],
				newMemberUIdsToSetCache = {},
				newAdminUIdsToSetCache = {},
				oldMembersUIdCache = {};


			oldTagMemberListCopy = oldTagObj.getMembersObjectMap().copy();
			oldTagMembersAndAdminsMap = oldTagMemberListCopy;
			allOldTagMembersAndAdminsMap = oldTagMembersAndAdminsMap.all();

			angular.forEach(memberUIdsToSet, function(aMemberUId){
				newMemberUIdsToSetCache[aMemberUId] = true;
			});

			angular.forEach(adminUIdsToSet, function(anAdminUId){
				newAdminUIdsToSetCache[anAdminUId] = true;
			});

			for(var oldTagMembersAndAdminsMapIndex = 0; oldTagMembersAndAdminsMapIndex < allOldTagMembersAndAdminsMap.length; oldTagMembersAndAdminsMapIndex++ ){

				aTagMemberObject = allOldTagMembersAndAdminsMap[oldTagMembersAndAdminsMapIndex].value;
				if( aTagMemberObject.isOwner() ){
					continue;
				}

				oldMembersUIdCache[ aTagMemberObject.getId() ] = true;

				if( !newAdminUIdsToSetCache[ aTagMemberObject.getId()] && !newMemberUIdsToSetCache[ aTagMemberObject.getId() ]){
					//Now Not In Member And Admin, remove this user

					//Admin to Remove List
					serializedMemberAdminsToRemove.push(aTagMemberObject.serialize());

					membersAdminToRemoveOnSuccess.push(aTagMemberObject);

				}else
				{

					statusChanged = false;
					if( aTagMemberObject.isAdmin() ){
						//Previously Admin

						if(  !!newMemberUIdsToSetCache[ aTagMemberObject.getId() ] ){
							//Now In Member

							//Change Status To Member
							aTagMemberObject.makeMember();

							statusChanged = true;

						}

					}else if( aTagMemberObject.isMember() ){
						//Previously Member

						if(  !!newAdminUIdsToSetCache[ aTagMemberObject.getId() ] ){
							//Now In Admin

							//Change Status To Member
							aTagMemberObject.makeAdmin();

							statusChanged = true;

						}
					}

					if(statusChanged){

						//Add to Status Change List
						//Only { userId : userId } needed, using serialize for generic interface
						serializedMemberAdminsToStatusChange.push(aTagMemberObject.serialize());

						membersAdminToUpdateOnSuccess.push(aTagMemberObject);
					}

				}

			}

			angular.forEach(memberUIdsToSet, function(aMemberUId){

				if( !oldMembersUIdCache[aMemberUId] && aMemberUId !== currentUser.getKey() ){
					//New Member

					aNewMember = userFactory.getUser(aMemberUId);

					newTagMemberObject = tagChatFactory.createNewTagMember(
						oldTagObj.getTagId(),
						{ 	userId : aMemberUId, addedBy : currentUser.getKey(),
							fullName : aNewMember.getName(),
							status : TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER
						},
						true
					);
					membersAdminToAddOnSuccess.push(newTagMemberObject);

					serializedNewMemberAdminsToAdd.push( newTagMemberObject.serialize() );

				}
			});

			angular.forEach(adminUIdsToSet, function(anAdminUId){

				if( !oldMembersUIdCache[anAdminUId] && anAdminUId !== currentUser.getKey() ){
					//New Admin

					aNewAdmin = userFactory.getUser(anAdminUId);

					newTagAdminObject = tagChatFactory.createNewTagMember(
						oldTagObj.getTagId(),
						{ 	userId : anAdminUId, addedBy : currentUser.getKey(),
							fullName : aNewAdmin.getName(),
							status : TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN
						},
						true
					);

					membersAdminToAddOnSuccess.push(newTagAdminObject);

					serializedNewMemberAdminsToAdd.push( newTagAdminObject.serialize() );

				}
			});


			return {
				serializedMemberAdminsToRemove : serializedMemberAdminsToRemove,
				serializedMemberAdminsToStatusChange : serializedMemberAdminsToStatusChange,
				serializedNewMemberAdminsToAdd : serializedNewMemberAdminsToAdd,
				membersAdminToAddOnSuccess : membersAdminToAddOnSuccess,
				membersAdminToRemoveOnSuccess : membersAdminToRemoveOnSuccess,
				membersAdminToUpdateOnSuccess : membersAdminToUpdateOnSuccess

			};


		}

		function __hasTagUpdated(oldTagObj, newTagName, newPictureFileName,
								 serializedNewMemberAdminsToAdd, serializedMemberAdminsToRemove, serializedMemberAdminsToStatusChange){

			if( (serializedNewMemberAdminsToAdd.length > 0) 		||
				(serializedMemberAdminsToRemove.length > 0) 		||
				(serializedMemberAdminsToStatusChange.length > 0) 	||
				(oldTagObj.getTagName() !== newTagName) 			||
				( oldTagObj.getPictureUrl() !== newPictureFileName)

			){
				return true;
			}
			return false;

		}


		function __addNewMembers(oldTagObj, serializedNewMemberAdminsToAdd, membersAdminToAddOnSuccess){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				addTagMembersInAuthFailed,
				serializedNewMemberAdminsUserIds,
				addTagMemberInChatServerChatSocketCallPacketId,
				addTagMemberInChatServerChatSocketCallSuccessStatus,
				tagMemberAddConfirmation;

			if( serializedNewMemberAdminsToAdd.length > 0 ){

				/**************************** Handle New Members in Auth *********************************/

				addTagMembersInAuthFailed = false;

				serializedNewMemberAdminsUserIds = serializedNewMemberAdminsToAdd.keyValues('userId');

				tagChatApiService.addTagMembersInAuth( oldTagObj, serializedNewMemberAdminsUserIds
				).then(function(response){
						RingLogger.print(response, 'tagchat-update-auth-result', RingLogger.tags.TAG_CHAT);

				}, function(response){
						RingLogger.alert(response, 'tagchat-update-auth-result-failed', RingLogger.tags.TAG_CHAT);

						deferred.reject({ sucs : false , mg : 'Auth Update Failed'});
						addTagMembersInAuthFailed = true;
				});


				/**************************** Handle New Members in Chat *********************************/

				addTagMemberInChatServerChatSocketCallPacketId = tagChatFactory.getUUIDPacketId();
				addTagMemberInChatServerChatSocketCallSuccessStatus = false;
				var serverCurrentTime = chatUtilsFactory.getChatServerCurrentTime();


				callXTimeAfterYIntervalStopOnSuccess(
					function(){

						if(addTagMemberInChatServerChatSocketCallSuccessStatus){
							return;
						}

						var isRegisterRequired = _registerTag(oldTagObj.getTagId(), TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.ONLY_REGISTER);

						var doAddTagMemberInChatServerChatSocketCall = function(){
							tagChatApiService.addTagMemberInChatServer( currentUser.getKey(),
								oldTagObj,
								serializedNewMemberAdminsToAdd,
								addTagMemberInChatServerChatSocketCallPacketId
							);
						};

						_executeAfterTagRegisterEvent(oldTagObj.getTagId(), doAddTagMemberInChatServerChatSocketCall, null, !isRegisterRequired);

					},
					function (currentExecutionCount) {

						RingLogger.print('Retry Count', currentExecutionCount, 'update-tag-tag-chat-new-member-add-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

						if( addTagMembersInAuthFailed ){
							deferred.reject({ sucs : false , mg : 'Failed to send tag new member add packet to auth server.'});
							return true;
						}

						tagMemberAddConfirmation =
							hasReceivedConfirmation(addTagMemberInChatServerChatSocketCallPacketId, TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD);

						if( tagMemberAddConfirmation && !addTagMemberInChatServerChatSocketCallSuccessStatus){
							addTagMemberInChatServerChatSocketCallSuccessStatus = true;

							angular.forEach(membersAdminToAddOnSuccess, function(aMemberToAdd){
								oldTagObj.addMember(aMemberToAdd);
							});

							oldTagObj.setMembersCount( oldTagObj.getMembersCount() + membersAdminToAddOnSuccess.length);

							tagChatUI.showTagMembersAddStatusMessage(oldTagObj.getTagId(),
								currentUser.getKey(),
								serializedNewMemberAdminsToAdd,
								serverCurrentTime,
								addTagMemberInChatServerChatSocketCallPacketId
							);

							deferred.resolve({ sucs : true , mg : 'Member( '+ membersAdminToAddOnSuccess.length +' ) Added in ' + oldTagObj.getTagName() });

						}

						return tagMemberAddConfirmation;
					},
					function(){
						deferred.reject({ sucs : false , mg : 'Unable to send tag new member add packet to chat server.'});

						RingLogger.alert('Unable to send tag new member add packet to chat server', oldTagObj.getTagId(), ' tag-chat-new-member-add-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

					},
					TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
					TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
				);


			}else{
				deferred.resolve({ sucs: false});
			}

			return deferred.promise;

		}

		function __removeOldMembers(oldTagObj, serializedMemberAdminsToRemove, membersAdminToRemoveOnSuccess){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				removeTagMemberInChatServerChatSocketCallPacketId,
				removeTagMemberInChatServerChatSocketCallSuccessStatus;

			if( serializedMemberAdminsToRemove.length > 0){


				/**************************** Handle Old Members Remove in Chat *********************************/

				removeTagMemberInChatServerChatSocketCallPacketId = tagChatFactory.getUUIDPacketId();

				removeTagMemberInChatServerChatSocketCallSuccessStatus = false;

				var serverCurrentTime = chatUtilsFactory.getChatServerCurrentTime();


				callXTimeAfterYIntervalStopOnSuccess(
					function(){

						if(removeTagMemberInChatServerChatSocketCallSuccessStatus){
							return;
						}

						var isRegisterRequired = _registerTag(oldTagObj.getTagId(), TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.ONLY_REGISTER);

						var doRemoveTagMembersInChatServerChatSocketCall = function(){
							tagChatApiService.removeTagMembersFromChatServer(
								currentUser.getKey(),
								oldTagObj,
								serializedMemberAdminsToRemove,
								removeTagMemberInChatServerChatSocketCallPacketId
							);
						};


						_executeAfterTagRegisterEvent(oldTagObj.getTagId(), doRemoveTagMembersInChatServerChatSocketCall, null, !isRegisterRequired);

					},
					function (currentExecutionCount) {

						RingLogger.print('Retry Count', currentExecutionCount, 'update-tag-tag-chat-member-remove-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

						var tagMemberRemoveConfirmation =
							hasReceivedConfirmation(removeTagMemberInChatServerChatSocketCallPacketId, TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE);

						if( tagMemberRemoveConfirmation && !removeTagMemberInChatServerChatSocketCallSuccessStatus ){
							removeTagMemberInChatServerChatSocketCallSuccessStatus = true;

							angular.forEach(membersAdminToRemoveOnSuccess, function(aMemberToRemove){
								oldTagObj.removeMember(aMemberToRemove);
							});

							oldTagObj.setMembersCount( oldTagObj.getMembersCount() - membersAdminToRemoveOnSuccess.length);

							tagChatUI.showTagMembersRemoveStatusMessage(oldTagObj.getTagId(),
								currentUser.getKey(),
								serializedMemberAdminsToRemove,
								serverCurrentTime,
								removeTagMemberInChatServerChatSocketCallPacketId

							);

							deferred.resolve({ sucs : true , mg : 'Member( '+ membersAdminToRemoveOnSuccess.length +' ) Removed from ' + oldTagObj.getTagName() });

						}

						return tagMemberRemoveConfirmation;
					},
					function(){
						deferred.reject({ sucs : false , mg : 'Unable to send tag member remove packet to chat server.'});
						RingLogger.alert('Unable to send tag  member remove packet to chat server', oldTagObj.getTagId(), ' tag-chat-new-member-add-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

					},
					TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
					TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
				);

			}else{
				deferred.resolve({ sucs: false});
			}

			return deferred.promise;
		}

		function __changeMemberStatus(oldTagObj, serializedMemberAdminsToStatusChange, membersAdminToUpdateOnSuccess){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				tagMemberStatusChangeInChatServerChatSocketCallPacketId,
				tagMemberStatusChangeInChatServerChatSocketCallSuccessStatus,
				tagMemberStatusChangeInChatServerChatSocketCallConstructedRawPacketObject;

			var serverCurrentTime = chatUtilsFactory.getChatServerCurrentTime();


			if( serializedMemberAdminsToStatusChange.length > 0){


				/**************************** Handle Old TagMember Status Change in Chat *********************************/

				tagMemberStatusChangeInChatServerChatSocketCallPacketId = tagChatFactory.getUUIDPacketId();
				tagMemberStatusChangeInChatServerChatSocketCallSuccessStatus = false;
				tagMemberStatusChangeInChatServerChatSocketCallConstructedRawPacketObject = {};

				callXTimeAfterYIntervalStopOnSuccess(
					function(){

						if(tagMemberStatusChangeInChatServerChatSocketCallSuccessStatus){
							return;
						}

						var isRegisterRequired = _registerTag(oldTagObj.getTagId(), TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.ONLY_REGISTER);

						var doTagMembersStatusChangeInChatServerChatSocketCall = function(){
							tagMemberStatusChangeInChatServerChatSocketCallConstructedRawPacketObject = tagChatApiService.changeTagMemberStatusInChatServer(
								currentUser.getKey(),
								oldTagObj,
								serializedMemberAdminsToStatusChange,
								tagMemberStatusChangeInChatServerChatSocketCallPacketId
							);
						};


						_executeAfterTagRegisterEvent(oldTagObj.getTagId(), doTagMembersStatusChangeInChatServerChatSocketCall, null, !isRegisterRequired);

					},
					function (currentExecutionCount) {

						RingLogger.print('Retry Count', currentExecutionCount, 'update-tag-tag-chat-member-status-change-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

						var tagMemberStatusChangeConfirmation =
							hasReceivedConfirmation(tagMemberStatusChangeInChatServerChatSocketCallPacketId, TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE);

						if( tagMemberStatusChangeConfirmation && !tagMemberStatusChangeInChatServerChatSocketCallSuccessStatus){

							//tagChatApiService.sendToSelf( tagMemberStatusChangeInChatServerChatSocketCallConstructedRawPacketObject );

							tagMemberStatusChangeInChatServerChatSocketCallSuccessStatus = true;

							angular.forEach(membersAdminToUpdateOnSuccess, function(aMemberToUpdate){
								oldTagObj.updateMember(aMemberToUpdate);
							});

							tagChatUI.showMemberTypeChangeStatusMessage(oldTagObj.getTagId(),
								currentUser.getKey(),
								serializedMemberAdminsToStatusChange,
								serverCurrentTime,
								tagMemberStatusChangeInChatServerChatSocketCallPacketId
							);

							deferred.resolve({ sucs : true , mg : 'Member( '+ membersAdminToUpdateOnSuccess.length +' ) Status Updated for ' + oldTagObj.getTagName() });

						}

						return tagMemberStatusChangeConfirmation;
					},
					function(){

						deferred.reject({ sucs : false , mg : 'Unable to send tag member status change packet to chat server.'});
						RingLogger.alert('Unable to send tag  member status change packet to chat server', oldTagObj.getTagId(), ' tag-chat-member-status-change-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);


					},
					TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
					TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
				);

			}else{
				deferred.resolve({ sucs: false});
			}

			return deferred.promise;
		}

		function __updateTagInformation(oldTagObj, newTagName, newPictureFileName){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				oldTagName = oldTagObj.getTagName(),
				oldTagPictureUrl = oldTagObj.getPictureUrl(),
				tagNameUpdated = oldTagObj.getTagName() !== newTagName,
				tagPictureUrlUpdated =oldTagObj.getPictureUrl() !== newPictureFileName,
				tagInfoUpdateConstructedRawPacketObject = {},
				tagInfoUpdated = tagNameUpdated || tagPictureUrlUpdated,
				tagInfoChangeStatusMessageType,
				activityType,
				updateTagInfoTagNameInChatServerChatSocketCallPacketId,
				updateTagInfoTagNameInChatServerChatSocketCallSuccessStatus,
				updateTagInfoTagPictureUrlUpdatedInChatServerChatSocketCallPacketId,
				updateTagInfoTagPictureUrlInChatServerChatSocketCallSuccessStatus;

			if( tagInfoUpdated  ){

				/**************************** Handle tag info update in Chat *********************************/

				tagInfoChangeStatusMessageType = tagChatUI.getTagInfoChangeStatusMessage(oldTagObj.getTagId(),
					{ tagName : newTagName || "", tagPictureUrl: newPictureFileName || "" }
				);

				//Reflect Changes
				if(tagNameUpdated){
					oldTagObj.setTagName( newTagName );
					activityType = TAG_CHAT_GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_RENAME;

					updateTagInfoTagNameInChatServerChatSocketCallPacketId = tagChatFactory.getUUIDPacketId();
					updateTagInfoTagNameInChatServerChatSocketCallSuccessStatus = false;

					callXTimeAfterYIntervalStopOnSuccess(
						function(){

							if(updateTagInfoTagNameInChatServerChatSocketCallSuccessStatus){
								return;
							}

							var isRegisterRequired = _registerTag(oldTagObj.getTagId(), TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.ONLY_REGISTER);

							var doUpdateTagInfo = function(){
								tagInfoUpdateConstructedRawPacketObject = tagChatApiService.sendTagInformationToChatServer(
									currentUser.getKey(),
									oldTagObj,
									activityType,
									updateTagInfoTagNameInChatServerChatSocketCallPacketId
								);
							};

							_executeAfterTagRegisterEvent(oldTagObj.getTagId(), doUpdateTagInfo, null, !isRegisterRequired);

						},
						function (currentExecutionCount) {

							RingLogger.print('Retry Count', currentExecutionCount, 'update-tag-send-tag-chat-info-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

							var tagInfoTagNameSendConfirmation =
								hasReceivedConfirmation(updateTagInfoTagNameInChatServerChatSocketCallPacketId, TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION);

							if( tagInfoTagNameSendConfirmation && !updateTagInfoTagNameInChatServerChatSocketCallSuccessStatus){
								updateTagInfoTagNameInChatServerChatSocketCallSuccessStatus = true;

								tagChatUI.showTagInfoChangeStatusMessage(oldTagObj.getTagId(),
									currentUser.getKey(),
									{ statusMessageType : tagInfoChangeStatusMessageType, tagName : newTagName }
								);

								deferred.resolve({ sucs : true , mg : 'Updated Group Info of ' + oldTagObj.getTagName() });
							}

							return tagInfoTagNameSendConfirmation;
						},
						function(){

							//Revert Changes
							if(tagNameUpdated){
								oldTagObj.setTagName( oldTagName );
							}

							deferred.reject({ sucs : false , mg : 'Unable to send tag info tag name change packet to chat server.'});
							RingLogger.alert('Unable to send tag  member info tag name change packet to chat server', oldTagObj.getTagId(), ' update-tag-tag-chat-info-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

						},
						TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
						TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
					);
				}

				if( tagPictureUrlUpdated){

					oldTagObj.setPictureUrl( newPictureFileName );
					activityType = TAG_CHAT_GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_URL_RENAME;

					updateTagInfoTagPictureUrlUpdatedInChatServerChatSocketCallPacketId = tagChatFactory.getUUIDPacketId();
					updateTagInfoTagPictureUrlInChatServerChatSocketCallSuccessStatus = false;

					callXTimeAfterYIntervalStopOnSuccess(
						function(){

							if(updateTagInfoTagPictureUrlInChatServerChatSocketCallSuccessStatus){
								return;
							}

							var isRegisterRequired = _registerTag(oldTagObj.getTagId(), TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.ONLY_REGISTER);

							var doUpdateTagInfo = function(){
								tagInfoUpdateConstructedRawPacketObject = tagChatApiService.sendTagInformationToChatServer(
									currentUser.getKey(),
									oldTagObj,
									activityType,
									updateTagInfoTagPictureUrlUpdatedInChatServerChatSocketCallPacketId
								);
							};

							_executeAfterTagRegisterEvent(oldTagObj.getTagId(), doUpdateTagInfo, null, !isRegisterRequired);

						},
						function (currentExecutionCount) {

							RingLogger.print('Retry Count', currentExecutionCount, 'update-tag-send-tag-chat-info-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

							var tagInfoTagPictureUrlSendConfirmation =
								hasReceivedConfirmation(updateTagInfoTagNameInChatServerChatSocketCallPacketId, TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION);

							if( tagInfoTagPictureUrlSendConfirmation && !updateTagInfoTagPictureUrlInChatServerChatSocketCallSuccessStatus){
								updateTagInfoTagPictureUrlInChatServerChatSocketCallSuccessStatus = true;

								tagChatUI.showTagInfoChangeStatusMessage(oldTagObj.getTagId(),
									currentUser.getKey(),
									{ statusMessageType : tagInfoChangeStatusMessageType, tagName : newTagName }
								);

								deferred.resolve({ sucs : true , mg : 'Updated Group Info of ' + oldTagObj.getTagName() });
							}

							return tagInfoTagPictureUrlSendConfirmation;
						},
						function(){

							if( tagPictureUrlUpdated){
								oldTagObj.setPictureUrl( oldTagPictureUrl );
							}

							deferred.reject({ sucs : false , mg : 'Unable to send tag info tag picture url packet to chat server.'});
							RingLogger.alert('Unable to send tag info tag picture url packet to chat server', oldTagObj.getTagId(), ' update-tag-tag-chat-info-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

						},
						TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
						TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
					);
				}



			}else{
				deferred.resolve({ sucs: false});
			}

			return deferred.promise;

		}

		function _updateTag(oldTagObj, newTagName, newPictureFileName, memberUIdsToSet, adminUIdsToSet){

			var currentUser = Auth.currentUser(),
				membersForCRUD,
				serializedNewMemberAdminsToAdd,
				membersAdminToAddOnSuccess,
				serializedMemberAdminsToRemove,
				membersAdminToRemoveOnSuccess,
				serializedMemberAdminsToStatusChange,
				membersAdminToUpdateOnSuccess;


			var deferred = $q.defer();

			/****************************  Get MemberUId Diff *********************************/
				membersForCRUD = __getMembersForCRUD(oldTagObj, memberUIdsToSet, adminUIdsToSet);
				serializedNewMemberAdminsToAdd = membersForCRUD.serializedNewMemberAdminsToAdd;
				membersAdminToAddOnSuccess = membersForCRUD.membersAdminToAddOnSuccess;

				serializedMemberAdminsToRemove = membersForCRUD.serializedMemberAdminsToRemove;
				membersAdminToRemoveOnSuccess = membersForCRUD.membersAdminToRemoveOnSuccess;

				serializedMemberAdminsToStatusChange = membersForCRUD.serializedMemberAdminsToStatusChange;
				membersAdminToUpdateOnSuccess = membersForCRUD.membersAdminToUpdateOnSuccess;


			/****************************  Register Tag For Update *********************************/

				var needRegistering = false;

				if(__hasTagUpdated(oldTagObj, newTagName, newPictureFileName, serializedNewMemberAdminsToAdd, serializedMemberAdminsToRemove, serializedMemberAdminsToStatusChange)){
					needRegistering =  _registerTag(oldTagObj.getTagId(), TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.ONLY_REGISTER);
				}else{
					deferred.resolve({sucs: false});
				}


				var successCount = 0;

				function doUpdate(){

					/****************************  Handle New Members *********************************/
					__addNewMembers(oldTagObj, serializedNewMemberAdminsToAdd, membersAdminToAddOnSuccess).then(function(response){
						if(!!response.sucs){
							successCount++;
							deferred.notify(response);
						}
					}, deferred.reject);



					/**************************** Handle Old Members Remove *********************************/
					__removeOldMembers(oldTagObj, serializedMemberAdminsToRemove, membersAdminToRemoveOnSuccess).then(function(response){
						if(!!response.sucs){
							successCount++;
							deferred.notify(response);
						}
					}, deferred.reject);

					/**************************** Handle Current Member Status Change *********************************/
					__changeMemberStatus(oldTagObj, serializedMemberAdminsToStatusChange, membersAdminToUpdateOnSuccess).then(function(response){
						if(!!response.sucs){
							successCount++;
							deferred.notify(response);
						}
					}, deferred.reject);


					/**************************** Handle Tag Info Update *********************************/
					__updateTagInformation(oldTagObj, newTagName, newPictureFileName).then(function(response){
						if(!!response.sucs){
							successCount++;
							deferred.notify(response);
						}
					}, deferred.reject);

				}

				if(!needRegistering){
					doUpdate();

				}else{
					_executeAfterTagRegisterEvent(oldTagObj.getTagId(), function(){

						doUpdate();

					}, !needRegistering);
				}



				setTimeout(function(){
					if( !successCount ){
						deferred.reject({ sucs: false });
					}else{
						deferred.resolve({ sucs: true });
					}

				}, 18000);


			return deferred.promise;


		}
		/******************************* TAG CRUD End ******************************/

		/******************************* TAG Member CRUD Start ******************************/

		function _leaveFromTag(tagId){
			var tagObject = tagChatFactory.getTag(tagId);

			var currentOwner = tagObject.getMember(Auth.currentUser().getKey());

			return _removeTagMember(tagId, [ currentOwner.serialize() ], [currentOwner] );
		}

		function _removeTagMember(tagId, tagMemberUserIdsToRemove, membersAdminToRemoveOnSuccess){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				tagObject = tagChatFactory.getTag(tagId),
				isSuccess = false;

			var doRemove = function(){

				var removeTagMemberInChatServerChatSocketCallPacketId = tagChatFactory.getUUIDPacketId();
				var removeTagMemberInChatServerChatSocketCallSuccessStatus = false;

				callXTimeAfterYIntervalStopOnSuccess(
					function(){

						tagObject = tagChatFactory.getTag(tagId);

						var doRemoveTagMembersInChatServerChatSocketCall = function(){
							tagChatApiService.removeTagMembersFromChatServer(
								currentUser.getKey(),
								tagObject,
								tagMemberUserIdsToRemove,
								removeTagMemberInChatServerChatSocketCallPacketId
							);
						};

						doRemoveTagMembersInChatServerChatSocketCall();


					},
					function (currentExecutionCount) {

						RingLogger.print('Retry Count', currentExecutionCount, 'leave-tag-tag-chat-member-remove-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

						var tagMemberRemoveConfirmation =
							hasReceivedConfirmation(removeTagMemberInChatServerChatSocketCallPacketId, TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE);

						if( tagMemberRemoveConfirmation && !removeTagMemberInChatServerChatSocketCallSuccessStatus ){
							removeTagMemberInChatServerChatSocketCallSuccessStatus = true;

							tagObject = tagChatFactory.getTag(tagId);

							var statusMsg = 'Member( '+ membersAdminToRemoveOnSuccess.length +' ) Removed from ' + tagObject.getTagName();

							for(var index = 0; index < membersAdminToRemoveOnSuccess.length; index++ ){
								var aMemberToRemove = membersAdminToRemoveOnSuccess[index];

								if( aMemberToRemove.getId() === currentUser.getKey() ){

									statusMsg = 'You left from (' + tagObject.getTagName() + ') conversation ';

									deferred.resolve({ sucs : true , mg :  statusMsg });

								}

								tagObject.removeMember(aMemberToRemove);

							}

							deferred.resolve({ sucs : true , mg :  statusMsg });
						}

						return tagMemberRemoveConfirmation;
					},
					function(){
						deferred.reject({ sucs : false , mg : 'Unable to send tag member remove packet to chat server.'});
						RingLogger.alert('Unable to send tag  member remove packet to chat server', tagObject.getTagId(), ' tag-chat-new-member-add-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

					},
					TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
					TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
				);

			};

			var needRegistering = _registerTag(tagId, TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.ONLY_REGISTER);

			if(!needRegistering){
				doRemove();

			}else{
				_executeAfterTagRegisterEvent(tagId, function(){
					doRemove();

				}, !needRegistering);
			}

			setTimeout(function(){
				if( !isSuccess ){
					deferred.reject({ sucs: false });
				}else{
					deferred.resolve({ sucs: true });
				}

			}, 25000);

			return deferred.promise;
		}

		function _changeTagMemberStatus(tagId, serializedStatusToChangeMembers, membersAdminToUpdateOnSuccess){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				tagObject = tagChatFactory.getTag(tagId),
				isSuccess = false,
				needRegistering = _registerTag(tagId, TAG_CHAT_GENERAL_CONSTANTS.REGISTRATION_TYPES.ONLY_REGISTER);

			var doChangeMembershipStatus = function (){

				var tagMemberStatusChangeInChatServerChatSocketCallPacketId = tagChatFactory.getUUIDPacketId();
				var tagMemberStatusChangeInChatServerChatSocketCallSuccessStatus = false;

				callXTimeAfterYIntervalStopOnSuccess(
					function(){

						var doTagMembersStatusChangeInChatServerChatSocketCall = function(){
							tagChatApiService.changeTagMemberStatusInChatServer(
								currentUser.getKey(),
								tagObject,
								serializedStatusToChangeMembers,
								tagMemberStatusChangeInChatServerChatSocketCallPacketId
							);
						};

						doTagMembersStatusChangeInChatServerChatSocketCall();

					},
					function (currentExecutionCount) {

						RingLogger.print('Retry Count', currentExecutionCount, 'tag-chat-member-status-change-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);

						var tagMemberStatusChangeConfirmation =
							hasReceivedConfirmation(tagMemberStatusChangeInChatServerChatSocketCallPacketId, TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE);

						if( tagMemberStatusChangeConfirmation && !tagMemberStatusChangeInChatServerChatSocketCallSuccessStatus){
							tagMemberStatusChangeInChatServerChatSocketCallSuccessStatus = true;

							angular.forEach(membersAdminToUpdateOnSuccess, function(aMemberToUpdate){
								tagObject.updateMember(aMemberToUpdate);
							});

							deferred.resolve({ sucs : true , mg : 'Member( '+ serializedStatusToChangeMembers.length +' ) Status Updated for ' + tagObject.getTagName() });

						}

						return tagMemberStatusChangeConfirmation;
					},
					function(){

						deferred.reject({ sucs : false , mg : 'Unable to send tag member status change packet to chat server.'});
						RingLogger.alert('Unable to send tag  member status change packet to chat server', tagObject.getTagId(), ' tag-chat-member-status-change-in-chat-retry-count' , RingLogger.tags.TAG_CHAT);


					},
					TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
					TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
				);

			};

			if(!needRegistering){
				doChangeMembershipStatus();

			}else{
				_executeAfterTagRegisterEvent(tagId, function(){

					doChangeMembershipStatus();

				}, !needRegistering);
			}

			setTimeout(function(){
				if( !isSuccess ){
					deferred.reject({ sucs: false });
				}else{
					deferred.resolve({ sucs: true });
				}

			}, 25000);

			return deferred.promise;


		}


		/******************************* TAG Member CRUD End ******************************/


		function _initTagIdleInterval(tagId, tagObject){
			var currentUser = Auth.currentUser(),
				tagIdleIntervalId;

			if(!tagObject){
				tagObject = tagChatFactory.getTag(tagId);
			}

			tagIdleIntervalId = tagChatFactory.getIdleIntervalIdByTagId(tagId);

			if(!!tagIdleIntervalId){
				clearInterval(tagIdleIntervalId);
				tagChatFactory.resetIdleIntervalIdByTagId(tagId);
				RingLogger.print('Net Tag Idle Interval Init, Clearing Old Interval', tagId, RingLogger.tags.TAG_CHAT);
			}

			tagChatFactory.setIdleIntervalIdByTagId(tagId, tagIdleIntervalId);

			tagIdleIntervalId = setInterval(function () {

				var currentTime = Math.floor(Date.now()/1000);
				var diff = currentTime - tagObject.getLastCommunicationTime();

				 //RingLogger.print('tag ', tagId, ' idle interval ', diff, ' ', TAG_CHAT_GENERAL_CONSTANTS.BOX_WAITING_TIME , RingLogger.tags.TAG_CHAT);

				if(diff < TAG_CHAT_GENERAL_CONSTANTS.BOX_WAITING_TIME){

					//RingLogger.print('Sending Tag Idle Packet from Tag manager ', RingLogger.tags.TAG_CHAT);
					tagChatApiService.sendTagIdlePacket(currentUser.getKey(), tagObject);


				}else{

					clearInterval(tagIdleIntervalId);
					tagChatFactory.resetIdleIntervalIdByTagId(tagId);
					RingLogger.print('Tag Idle Interval Cleared', tagId);
				}

			},TAG_CHAT_GENERAL_CONSTANTS.UDP_SERVER_KEEP_ALIVE_INTERVAL);



		}

		function _requestForTagInformationMultipleTimes(tagId){

			var returnPromise;

			var defer = $q.defer();

			var currentUser = Auth.currentUser(),
				requestCacheKey = tagId + '-' + OFFLINE_PACKET_TYPE.OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS,
				tagInfoWithMemberGetPacketId;

			returnPromise = defer.promise;

			if(!!tagChatFactory.isInRequestCacheForChat(requestCacheKey)){
				returnPromise = { sucs : false, timeout : false };
			}

			tagChatFactory.setInTagChatRequestCache(requestCacheKey, {});

			tagInfoWithMemberGetPacketId =  tagChatFactory.getUUIDPacketId();

			callXTimeAfterYIntervalStopOnSuccess(
				function(){

					tagChatApiService.getTagInformationWithMemberFromOfflineServer(currentUser.getKey(), tagId, tagInfoWithMemberGetPacketId);

				},
				function () {

					var tagInfoWithMemberReceived =  hasReceivedConfirmation(tagInfoWithMemberGetPacketId, OFFLINE_PACKET_TYPE.OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS);

					var tagObject = tagChatFactory.getTag(tagId);

					if(!tagObject.membersLength()){
						tagChatFactory.resetFromTagChatResponseCache(tagInfoWithMemberGetPacketId, OFFLINE_PACKET_TYPE.OFFLINE_TAG_INFORMATION_WITH_MEMBERS);
						return false;
					}

					if( tagInfoWithMemberReceived ){
						defer.resolve({sucs : true, timeout : false});
					}

					return tagInfoWithMemberReceived;
				},
				function(){
					defer.resolve({sucs : false, timeout : true });
					RingLogger.print('Failed to get tag information for tag id', tagId, RingLogger.tags.TAG_CHAT);

				},
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
			);

			return $q.when(returnPromise);

		}

		function _sendTagMessageDeliveryPacketMultipleTimes(tagId, packetId, tagMessageModelObject){

			var currentUser = Auth.currentUser();
			var currentUserId = currentUser.getKey();

			callXTimeAfterYIntervalStopOnSuccess(
				function () {
					var tagObject = tagChatFactory.getTag(tagId);
					tagChatApiService.sendTagMsgDeliveredPacket(currentUserId, tagObject, tagMessageModelObject);
				},
				function (currentExecutionCount) {
					//RingLogger.print('Retry Count', currentExecutionCount , RingLogger.tags.TAG_CHAT  );

					var success = hasReceivedConfirmation(packetId, TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED);
					if (success) {
						//RingLogger.print('stopped on success');
					}
					return success;
				},
				function(){
					//RingLogger.print('Failed to send tag msg delivered packet for ', packetId);
				},
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT-2,
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
			);

		}

		function _sendFriendMessageDeliveryPacketMultipleTimes(friendId, chatBox, packetId){

			var currentUser = Auth.currentUser();
			var currentUserId = currentUser.getKey();

			callXTimeAfterYIntervalStopOnSuccess(
				function () {
					tagChatApiService.sendFriendChatDeliveryPacket(chatBox, currentUserId, friendId, packetId)
				},
				function (currentExecutionCount) {
					//RingLogger.print('Retry Count', currentExecutionCount , RingLogger.tags.TAG_CHAT  );

					var success = hasReceivedConfirmation(packetId, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED);
					if (success) {
						//RingLogger.print('stopped on success');
					}
					return success;
				},
				function(){
					//RingLogger.print('Failed to send tag msg delivered packet for ', packetId);
				},
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT-2,
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
			);

		}



		/***************** Helpers ************************/

		function _executeAfterX(func, wait, immidiate){
			if(!immidiate){
				setTimeout(func, wait);
			}else{
				func.call();
			}
		}

		function _executeXTimesAfterY(func, wait, immidiate, noOfTimes){
			var count = 0, intervalRef;

			if(!noOfTimes){
				noOfTimes = TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT;
			}

			if(!!immidiate){
				func.call();
				count = 1;
			}

			intervalRef = setInterval(function(){
				count++;
				func.call();
				if( count === noOfTimes ){
					clearInterval(intervalRef);
					console.log('Interval Cleared');
				}
			}, wait);

		}


		/**** ****/


		function _openPreviouslyOpenedBoxes(tagId){


			callXTimeAfterYIntervalStopOnSuccess(
				function(){

					var tagObject = tagChatFactory.getTag(tagId);

					if( !!tagObject && tagObject.isTagSafeToShow()){
						var tagChatBox = ChatFactory.getBoxByUId(tagId);
						_openTagChatBoxIfClosed(tagId, tagChatBox);
					}

				},
				function(iterationCount){
					//RingLogger.information('TRY BOX OPEN',  tagId,  RingLogger.tags.TAG_CHAT);

					var tagObject = tagChatFactory.getTag(tagId);

					if( !!tagObject && tagObject.isTagSafeToShow()){
						return true;
					}
					return false;
				},
				function(){
					// RingLogger.information('PREVIOUS BOX OPEN FAILED ',  tagId,  RingLogger.tags.TAG_CHAT);
				},
				5,
				5000
			);

		}


		// function _loadBoxHistory(box, tagId){

		// 		/* if box is not found which means user closed the box, in that case we have to load message history from localstorage */
		// 	var historyMessages = chatHistoryFactory.getMessages(box.getKey());
		// 	if(historyMessages){
		// 		for(var h=0; h<historyMessages.length; h++){
		// 			var aHistoryMessage = historyMessages[h];

		// 			profileFactory.getUserDetailsByUId(aHistoryMessage.user);
		// 			var userObj = userFactory.getUser(aHistoryMessage.user);

		// 			/** If the msg contains in local storage then this will not be pushed again**/
		// 			var key = aHistoryMessage.key || aHistoryMessage.packetId;
		// 			//chatHistoryFactory.setInLocalStorageChatMsgMap(key);

		// 			/** Optimization Needed duplicate msg in box and tagModels , tag.api service uses model data **/
		// 			tagChatFactory.getOrCreateMessage(tagId, aHistoryMessage);

		// 			box.pushMessage(aHistoryMessage, userObj);



		// 		}
		// 	}

		// }

		function _openTagChatBoxIfClosed(tagId, box){

			//RingLogger.print('Open Tag chat box', tagId, box, RingLogger.tags.TAG_CHAT);

			var shouldLoadHistory = false;

			if(!box){
				shouldLoadHistory = true;

				var tagObject = tagChatFactory.getOrCreateTag(tagId);

				if( tagObject.isTagSafeToShow()){

					ChatFactory.openTagChatBox(tagId);
					box = ChatFactory.getBoxByUId(tagId);

					var users = tagObject.getMemberUserIds();

					if(!tagChatFactory.isTagRegistered(tagId) ){

						tagChatApiService.createOrGetTagFromAuth(tagObject, users || []).then(function(response){
							var tagObject = tagChatFactory.getTag(response.tid);
							tagObject.setChatIp(response.chIp);
							tagObject.setChatRegisterPort(response.chRp);

							box.setIp(response.chIp);
							box.setRPort(response.chRp);

						});

					}else{

						box.setIp(tagObject.getChatIp());
						box.setRPort(tagObject.getChatRegisterPort());
						box.setPort(tagObject.getChatBindingPort());
						box.setTitle(tagObject.getTagName());

					}

				}else{
					box = ChatFactory.creatNonDomBox(tagId, true);

					box.setIp(tagObject.getChatIp());
					box.setRPort(tagObject.getChatRegisterPort());
					box.setPort(tagObject.getChatBindingPort());
					box.setTitle(tagObject.getTagName());

				}

			}

			if(shouldLoadHistory){
				box.loadHistoryMessages();
			}

			return box;

		}

		function _sendTemporaryStoredMessages(tagId, chatBox){
			var currentUser = Auth.currentUser();

			var doSendTemporaryStoredMesssage = function(){
				if(!chatBox){
					chatBox = ChatFactory.getBoxByUId(tagId);
				}

				while(angular.isArray(chatBox.tempMessageArray) && chatBox.tempMessageArray.length >0){
					var individualMsgObject = chatBox.tempMessageArray.shift();
					individualMsgObject.ip = chatBox.getIp();
					individualMsgObject.port = chatBox.getPort();

					//ChatFactory.sendMessage(chatBox, individualMsgObject, individualMsgObject.messageType, individualMsgObject.messageData);

					//var tagObject = tagChatFactory.getTag(tagId);
					//if( !!tagObject){
					//	//var tagMessageObject = tagChatFactory.createNewTagMessage(tagObject.getTagId(), individualMsgObject);
					//	//tagChatApiService.sendTagMsgInChatServer(currentUser.getKey(), tagObject,  tagMessageObject);
					//}else{
					//	RingLogger.warn('Unable to find tag Object', RingLogger.tags.TAG_CHAT);
					//}
				}
			};

			setTimeout(doSendTemporaryStoredMesssage, 1000);
		}

		function _sendTagIdlePacket(tagId){
			var tagObject = tagChatFactory.getTag(tagId);
			if(!!tagObject){
				tagChatApiService.sendTagIdlePacket(Auth.currentUser().getKey(), tagObject);
			}
		}



		return {

			createTag: _createTag,
			updateTag : _updateTag,


			leaveFromTag : _leaveFromTag,
			removeTagMember  : _removeTagMember,
			changeTagMemberStatus : _changeTagMemberStatus,
			subscribeForAuthUpdate : _subscribeForAuthUpdate,

			doOnTagChatRequestStartResponse : _doOnTagChatRequestStartResponse,
			registerTag : _registerTag,

			initTagIdleInterval: _initTagIdleInterval,

			openTagChatBoxIfClosed : _openTagChatBoxIfClosed,
			openPreviouslyOpenedBoxes : _openPreviouslyOpenedBoxes,

			requestForTagInformationMultipleTimes : _requestForTagInformationMultipleTimes,
			sendTagMessageDeliveryPacketMultipleTimes : _sendTagMessageDeliveryPacketMultipleTimes,
			sendFriendMessageDeliveryPacketMultipleTimes : _sendFriendMessageDeliveryPacketMultipleTimes,
			sendTemporaryStoredMessages : _sendTemporaryStoredMessages,
			sendTagIdlePacket : _sendTagIdlePacket,
			requestForIp : _requestForIp,
			getIpPortForTag : _getIpPortForTag,

			/** Need to move in helper file **/
			executeXTimesAfterY : _executeXTimesAfterY,
			executeAfterX : _executeAfterX


		};


	}

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.tagchat')
		.factory('tagOfflineChatManager', tagOfflineChatManager);

	tagOfflineChatManager.$inject = [
		 	'$$connector', '$q', '$timeout',
			'Auth',
			'tagChatFactory',
			'tagChatApiService', 'tagChatPacketProcessor', 'tagChatUI', 'tagChatHelper',
			'ChatFactory', 'chatHistoryFactory',
			'userFactory', 'utilsFactory', 'profileFactory', 'tagChatStorage',
			'OPERATION_TYPES' ,'Ringalert',
			'TAG_CHAT_GENERAL_CONSTANTS', 'TAG_CHAT_PACKET_TYPE',
			'TAG_CHAT_LANG', 'AUTH_SERVER_ACTIONS',
			'CHAT_GLOBAL_VALUES',
			'OFFLINE_PACKET_TYPE', 'chatPacketResender', 'chatUtilsFactory' ];

	function tagOfflineChatManager (

			 $$connector, $q, $timeout,
			 Auth,
			 tagChatFactory,
			 tagChatApiService, tagChatPacketProcessor, tagChatUI, tagChatHelper,
			 ChatFactory, chatHistoryFactory,
			 userFactory, utilsFactory, profileFactory, tagChatStorage,
			 OPERATION_TYPES, Ringalert,
			 TAG_CHAT_GENERAL_CONSTANTS, TAG_CHAT_PACKET_TYPE,
			 TAG_CHAT_LANG, AUTH_SERVER_ACTIONS,
			 CHAT_GLOBAL_VALUES,
			 OFFLINE_PACKET_TYPE, chatPacketResender, chatUtilsFactory
	) {


		var callXTimeAfterYIntervalStopOnSuccess = utilsFactory.callXTimeAfterYIntervalStopOnSuccess;
		var hasReceivedConfirmation = tagChatFactory.hasReceivedConfirmation;
		var executeAfterTagRegisterEvent = tagChatHelper.executeAfterTagRegisterEvent;
		var ChatPacketResender = chatPacketResender.ChatPacketResender;
		var ChatPacketSender = chatPacketResender.ChatPacketSender;



		var _checkAndStopIfDuplicateRequest = function(tagId, requestPacketType){

			var requestCacheKey = tagId + '-' + requestPacketType;

			if(!!tagChatFactory.isInRequestCacheForChat(requestCacheKey)){
				return true;
			}

			tagChatFactory.setInTagChatRequestCache(requestCacheKey, {});

			return false;
		};

		var _getUnreadMessagesMultipleTimes = function(){

			var currentUser = Auth.currentUser(),
				requestPacketType = OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST,
				offlineUpdateTime = CHAT_GLOBAL_VALUES.offlineUpdateTime;

			if( _checkAndStopIfDuplicateRequest(0, requestPacketType)){
				RingLogger.information('Frequent Offline Get Request Rejected ', RingLogger.tags.TAG_CHAT);
				return;
			}

			var requestServerTime = chatUtilsFactory.getChatServerCurrentTime();


			var tagOfflineUnreadMessagesGetPacketId =  tagChatFactory.getUUIDPacketId();

			callXTimeAfterYIntervalStopOnSuccess(
				function(){

					tagChatApiService.sendOfflineGetRequest(currentUser.getKey(), offlineUpdateTime, tagOfflineUnreadMessagesGetPacketId);

				},
				function () {

					var offlineConfirmationReceived =  hasReceivedConfirmation(tagOfflineUnreadMessagesGetPacketId,
						OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST);

					if( !!offlineConfirmationReceived){
						CHAT_GLOBAL_VALUES.offlineUpdateTime = requestServerTime;
						//chatHistoryFactory.saveChatGeneralInfo({offlineUpdateTime : new Date().getTime()})
					}

					return offlineConfirmationReceived;
				},
				function(){

					RingLogger.information('Failed to get unread messages', RingLogger.tags.TAG_CHAT);

				},
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
			);



		};

		var _getHistoryMessagesMultipleTimes = function(tagId, pageDirection, packetId, limit){

			var defer = $q.defer();

			var returnPromise = defer.promise;

			var limit = limit || 10;

			var currentUser = Auth.currentUser(),
				requestPacketType = OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE_REQUEST;

			var duplicateCheckPacketId = tagId;
			if(!!packetId){
				duplicateCheckPacketId += '-' + packetId;
			}

			if( _checkAndStopIfDuplicateRequest(duplicateCheckPacketId, requestPacketType)){
				RingLogger.information('Frequent History Get Request Rejected for Tag ', tagId, RingLogger.tags.TAG_CHAT);
				returnPromise = { sucs : false };
			}

			var tagHistoryMessagesGetPacketId =  packetId || tagChatFactory.getUUIDPacketId();

			callXTimeAfterYIntervalStopOnSuccess(
				function(){

					tagChatApiService.sendHistoryMessageGetRequest(currentUser.getKey(), tagId,
						pageDirection, tagHistoryMessagesGetPacketId, limit);


				},
				function () {

					var historyGetConfirmationReceived =  hasReceivedConfirmation(tagHistoryMessagesGetPacketId,
						OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE_REQUEST);

					if( historyGetConfirmationReceived ){
						defer.resolve({ sucs : true });
					}

					return historyGetConfirmationReceived;
				},
				function(){

					RingLogger.information('Failed to get tag history messages for tag id', tagId, RingLogger.tags.TAG_CHAT);
					defer.reject({ sucs : false });

				},
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
				TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
			);



			return $q.when(returnPromise);


		};


		var _getFriendHistoryMessagesMultipleTimes = function(friendId, pageDirection, packetId, limit){

			var defer = $q.defer();

			var returnPromise = defer.promise;

			var limit = limit || 10;

			var currentUser = Auth.currentUser(),
				currentUserId = currentUser.getKey(),
				requestPacketType = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST;

			var duplicateCheckPacketId = friendId;
			if(!!packetId){
				duplicateCheckPacketId += '-' + packetId;
			}

			if( _checkAndStopIfDuplicateRequest(duplicateCheckPacketId, requestPacketType)){
				RingLogger.debug('Frequent History Get Request Rejected for Friend ', friendId, RingLogger.tags.TAG_CHAT);
				returnPromise = { sucs : false };
			}

			var friendHistoryMessagesGetPacketId =  packetId || tagChatFactory.getUUIDPacketId();

			var friendHistoryMessageRequestObject = tagChatApiService.getFriendHistoryMessageGetRequestObject(currentUserId, friendId, pageDirection, friendHistoryMessagesGetPacketId, limit);

			var chatPacketResender = new ChatPacketResender();
			chatPacketResender.setPacketType(requestPacketType);
			chatPacketResender.setPacketId(friendHistoryMessagesGetPacketId);
			chatPacketResender.setPacketObject(friendHistoryMessageRequestObject);

			chatPacketResender.on('success', function(response){
				defer.resolve(response);
			});

			chatPacketResender.on('failure', function(response){
				defer.reject(response);
			});

			chatPacketResender.start();

			return $q.when(returnPromise);

		};


		var _sendTagUnreadMessageConfirmation = function(userId, messagePacketIds){

			var packetId = tagChatFactory.getUUIDPacketId();

			var requestObject = tagChatApiService.getTagUnreadMessageConfirmationObject(userId, packetId, messagePacketIds );

			try{

				var aChatSender = new ChatPacketSender();
				aChatSender.setPacketObject( requestObject );
				aChatSender.setBrokenPacketType( requestObject.packetType );
				aChatSender.setIgnoreConfirmation(true);
				aChatSender.getInstance().start();


			}catch(e){
				RingLogger.alert('Tag Unread Message Confirmation  Exception ', e, RingLogger.tags.TAG_CHAT);

			}

		};

		var sendFriendUnreadMessageOfflineConfirmation = function(userId, packetId, messagePacketIds){

			var requestObject = tagChatApiService.getFriendUnreadMessageConfirmationObject(userId, packetId, messagePacketIds );

			try{

				var aChatSender = new ChatPacketSender();

				aChatSender.setPacketObject( requestObject );
				aChatSender.setBrokenPacketType( requestObject.packetType );
				aChatSender.setIgnoreConfirmation(true);

				aChatSender.getInstance().start();


			}catch(e){
				RingLogger.alert('Friend Unread Message Offline Confiramtion Exception ', e, RingLogger.tags.TAG_CHAT);

			}
		};

		var getHistoryRequestMethodByBox = function(chatBox){

			var historyRequestMethod;
			if(chatBox.isTagChat){
				historyRequestMethod = _getHistoryMessagesMultipleTimes
			}else{
				historyRequestMethod = _getFriendHistoryMessagesMultipleTimes
			}
			return historyRequestMethod
		};

		return {
			getUnreadMessagesMultipleTimes : _getUnreadMessagesMultipleTimes,
			getHistoryMessagesMultipleTimes : _getHistoryMessagesMultipleTimes,
			getFriendHistoryMessagesMultipleTimes : _getFriendHistoryMessagesMultipleTimes,
			getHistoryRequestMethodByBox : getHistoryRequestMethodByBox,
			sendTagUnreadMessageConfirmation : _sendTagUnreadMessageConfirmation,
			sendFriendUnreadMessageOfflineConfirmation : sendFriendUnreadMessageOfflineConfirmation
		};

	}

})();

(function() {
    'use strict';

    angular
        .module('ringid.tagchat')
        .factory('tagChatSubscriber', tagChatSubscriber);

    tagChatSubscriber.$inject = [
            'SystemEvents','ChatFactory', 'profileFactory',
            'PacketDataParse','utilsFactory','$timeout',
            'Auth','chatHistoryFactory',
            'TAG_CHAT_PACKET_TYPE', 'TAG_CHAT_GENERAL_CONSTANTS',
            'tagChatPacketProcessor', 'tagChatFactory', 'tagChatApiService', 'tagChatManager', 'tagChatUI', 'tagChatHelper','CHAT_GLOBAL_VALUES',
            'AUTH_SERVER_ACTIONS', 'FRIEND_CHAT_PACKET_TYPE', 'OFFLINE_PACKET_TYPE', 'ChatHelper', 'tagOfflineChatManager', 'ChatApiService',
            "ChatPacketSenderService", "chatUtilsFactory", 'ChatSeenSend','CHAT_GENERAL_CONSTANTS','chatTabSync'
        ];

    function tagChatSubscriber (

        SystemEvents, ChatFactory, profileFactory,
        PacketDataParse,utilsFactory,$timeout,
        Auth,chatHistoryFactory,
        TAG_CHAT_PACKET_TYPE, TAG_CHAT_GENERAL_CONSTANTS,
        tagChatPacketProcessor, tagChatFactory, tagChatApiService, tagChatManager, tagChatUI, tagChatHelper,CHAT_GLOBAL_VALUES,
        AUTH_SERVER_ACTIONS, FRIEND_CHAT_PACKET_TYPE, OFFLINE_PACKET_TYPE, ChatHelper, tagOfflineChatManager, ChatApiService,
        ChatPacketSenderService, chatUtilsFactory, ChatSeenSend,CHAT_GENERAL_CONSTANTS,chatTabSync

    ) {

        var DEBUG = true;
        var LOG_DUPLICATE = true;

        var packetProcessorMap = {};
        var brokenPacketMap = {};

        var initTagIdleInterval = tagChatManager.initTagIdleInterval;

        //var executeAfterTagRegisterEvent = tagChatHelper.executeAfterTagRegisterEvent;
        //var registerTagIfNecessaryInChat = tagChatManager.registerTagIfNecessaryInChat;
        //var executeXTimesAfterY = tagChatManager.executeXTimesAfterY;
        //var callXTimeAfterYIntervalStopOnSuccess = utilsFactory.callXTimeAfterYIntervalStopOnSuccess;

        //var hasReceivedConfirmation = tagChatFactory.hasReceivedConfirmation;

        var packetTypeDebug = {};

        //case 3: for receiving f2f register confirmation
        packetProcessorMap[FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_REGISTER_CONFIRMATION] = {
            processor : function(){},
            scopeUpdate : true
        };

        //case 6 : for receiving f2f chat
        packetProcessorMap[FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG] = {
            processor : _processFriendChatNewMessage,
            scopeUpdate : true
        };

        //case 7 : for receiving f2f chat
        packetProcessorMap[FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG_EDIT] = {
            processor : _processFriendChatEditMessage,
            scopeUpdate : true
        };

        //case 8 : for receiving f2f chat broken
        packetProcessorMap[FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG] = {
            processor : _processFriendBrokenPacketChatMessage,
            scopeUpdate : true
        };

        //case 9 : for receiving f2f chat broken edit
        packetProcessorMap[FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG_EDIT] = {
            processor : _processFriendEditBrokenPacketChatMessage,
            scopeUpdate : true
        };

        //case 15 : for receiving f2f chat delivered
        packetProcessorMap[FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED] = {
            processor : function(){},
            scopeUpdate : true
        };

        //case 16 : for receiving f2f chat delivered
        packetProcessorMap[FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT] = {
            processor : function(){},
            scopeUpdate : true
        };

        //case 18 : for receiving Tag Register
        packetProcessorMap[FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN_CONFIRMATION] = {
            processor : _processFriendChatSeenConfirmation,
            scopeUpdate : true
        };

        //case 41 : for receiving Tag Register
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER] = {
            processor : _processTagRegister,
            scopeUpdate : true
        };

        //case 42 : for receiving Tag UnRegister
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_UNREGISTER] = {
            processor : _processTagUnRegister,
            scopeUpdate : true
        };

        //case 43 : for receiving Tag register confirmation
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER_CONFIRMATION] = {
            processor : _processTagRegisterConfirmation,
            scopeUpdate : true
        };

        //case 46 : for receiving TagInformation
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION] = {
            processor : _processTagInformation,
            scopeUpdate : true
        };

        //case 47 : for receiving  Tag Information Confirmation
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION_CONFIRMATION] = {
            processor : _processTagInformationConfirmation,
            scopeUpdate : true
        };

        //case 51 : for receiving tag member add
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD] = {
            processor : _processTagMemberAddUpdate,
            scopeUpdate : true
        };

        //case 52 : for receiving tag member add confirmation
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION] = {
            processor : _processTagMemberAddConfirmation,
            scopeUpdate : true
        };


        //case 53 : for Tag member remove leave
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE] = {
            processor : _processTagMemberRemoveLeave,
            scopeUpdate : true
        };

        //case 54 : for Tag member remove leave confirmation
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION] = {
            processor : _processTagMemberRemoveLeaveConfirmation,
            scopeUpdate : true
        };

        //case 55 : for Tag Member Type Change
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE] = {
            processor : _processTagMemberStatusChange,
            scopeUpdate : true
        };

        //case 56 : for Tag Member Type Change confirmation
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION] = {
            processor : _processTagMemberStatusChangeConfirmation,
            scopeUpdate : true
        };

        //case 61: tagChat idle
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_IDLE] = {
            processor : _processTagChatIdleUpdate,
            scopeUpdate : false
        };

        //case 62: tagChat typing
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_TYPING] = {
            processor : _processTagChatTypingUpdate,
            scopeUpdate : true
        };

        //case 63 : for receiving Tag Chat Msg
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG] = {
            processor : _processTagChatNewMessage,
            scopeUpdate : true
        };

        //case 64 : for receiving Tag Chat Edit Msg
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_EDIT] = {
            processor : _processTagChatEditMessage,
            scopeUpdate : true
        };

        //case 65 : for broken chat message for tag
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG] = {
            processor : _processTagBrokenPacketChatMessage,
            scopeUpdate : true
        };

        //case 66 : for broken chat message edit for tag
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG_EDIT] = {
            processor : _processTagEditBrokenPacketChatMessage,
            scopeUpdate : true
        };


        //case 67 : for broken chat multiple message  for tag
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_MULTIPLE_MSG] = {
            processor : _processTagMultipleChatMessage,
            scopeUpdate : true
        };

        //case 68: tagChat deliver packet receiving
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED] = {
            processor : _processTagChatDeliveredUpdate,
            scopeUpdate : true
        };

        //case 69: tagChat sent packet receiving
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT] = {
            processor : _processTagChatSentUpdate,
            scopeUpdate : true
        };

        //case 70: tagChat seen packet receiving
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN] = {
            processor : _processTagChatSeenUpdate,
            scopeUpdate : true
        };

        //case 71: tagChat seen confirmation packet receiving
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN_CONFIRMATION] = {
            processor : _processTagChatSeenConfirmationUpdate,
            scopeUpdate : true
        };

        //case 72 : for receiving TagChat Multiple Delete
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_MULTIPLE_MSG_DELETE] = {
            processor : _processTagChatMultipleDelete,
            scopeUpdate : true
        };

        //case 73: delete confirmation
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_DELETE_CONFIRMATION] = {
            processor : _processTagChatMsgDeleteConfirmation,
            scopeUpdate : true
        };

        //case 74 : for receiving Tag General Broken Packet
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET] = {
            processor : _processTagBrokenPacket,
            scopeUpdate : true
        };


        //case 75 : for receiving Tag General Broken Confirmation Packet
        packetProcessorMap[TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION] = {
            processor : _processTagBrokenConfirmationPacket,
            scopeUpdate : true
        };

        //case 94 : for receiving Oflfine Packet Confirmation
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST_CONFIRMATION] = {
            processor : _processOfflineGetRequestConfirmation,
            scopeUpdate : true
        };

        //case 95 : for receiving Offline Friend Unread
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE] = {
            processor : _processOfflineFriendUnreadMessages,
            scopeUpdate : true
        };

        //case 98 : for receiving friend offline history message
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE] = {
            processor : _processFriendHistoryMessage,
            scopeUpdate : true
        };

        //case 99 : for receiving friend offline history message Confirmation
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION] = {
            processor : _processGetFriendHistoryMessageConfirmation,
            scopeUpdate : true
        };

        //case 104 : for receiving Offline Tag Inforamtion Activity
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_TAG_INFORMATION_ACTIVITY] = {
            processor : _processTagInformationOfflineActivity,
            scopeUpdate : true
        };

        //case 105 : for receiving Offline My Tag List
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_MY_TAG_LIST] = {
            processor : _processMyTagList,
            scopeUpdate : true
        };

        //case 106 : for receiving Tag Unread Message
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE] = {
            processor : _processTagUnreadMessage,
            scopeUpdate : true
        };

        //case 107 : for receiving Tag Unread Message Confirmation
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION] = {
            processor : _processTagUnreadMessageConfirmation,
            scopeUpdate : true
        };

        //case 108 : for receiving Offline Tag Create
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG] = {
            processor : _processTagCreate,
            scopeUpdate : true
        };

        //case 109 : for Offline tag create confirmation
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG_CONFIRMATION] = {
            processor : _processTagCreateConfirmation,
            scopeUpdate : true
        };

        //case 110 : for receiving Tag History Message Request
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE_REQUEST] = {
            processor : _processTagHistoryMessageRequest,
            scopeUpdate : true
        };

        //case 111 : for receiving Tag History Message
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE] = {
            processor : _processTagHistoryMessage,
            scopeUpdate : true
        };

        //case 112 : for receiving Get Tag Information With Member
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS] = {
            processor : _processGetTagInformationWithMember,
            scopeUpdate : true
        };

        //case 113 : for receiving Tag Information With Member
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_TAG_INFORMATION_WITH_MEMBERS] = {
            processor : _processTagInformationWithMember,
            scopeUpdate : true
        };

        //case 117 : for receiving Tag Offline Confirmation
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_TAG_CONFIRMATION] = {
            processor : _processTagOfflineConfirmation,
            scopeUpdate : true
        };

        //case 118 : for receiving offline broken history packet
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_HISTORY_PACKET] = {
            processor : _processOfflineBrokenHistoryPacket,
            scopeUpdate : true
        };

        //case 119 : for receiving offline broken packet
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET] = {
            processor : _processOfflineBrokenPacket,
            scopeUpdate : true
        };

        //case 120 : for receiving offline broken packet
        packetProcessorMap[OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET_CONFIRMATION] = {
            processor : _processOfflineBrokenPacketConfirmation,
            scopeUpdate : true
        };


        return {

            processUpdates : _processUpdates,
            processPacketData : _processPacketData

        };

        ////////////////////////////////////////////////


        function safeExecute(func) {
            try {
                func.call();
            } catch (e) {
                RingLogger.alert(e.stack, 'tag-chat-safe-execute', RingLogger.tags.TAG_CHAT);
            }
        }
        function getPacketProcessorInfo(packetType){
            return packetProcessorMap[packetType];
        }
        function _checkForDuplicatePacket(parsedPacketObject){
            var oldParsedObject = tagChatFactory.getFromTagChatResponseCache(parsedPacketObject);

            if( !!oldParsedObject ){

                //RingLogger.information('Ignoring Duplicate Packet', parsedPacketObject, RingLogger.tags.TAG_CHAT);
                return true;

            }else{

                tagChatFactory.setInTagChatResponseCache(parsedPacketObject.packetId, parsedPacketObject);
                return false;

            }
        }
        function _processPacketData(packet){
            return _processUpdates(null, { byteData : packet });
        }

        function __logReceivedPacketInfo(packetType, packetObject){
            var packetName = tagChatPacketProcessor.getPacketName(packetType);
            RingLogger.information(packetName,packetObject,RingLogger.tags.TAG_CHAT_RESPONSE);

        }

        function _processUpdates(event, dataObj) {

            var byteData = dataObj.byteData;
            var packetType = PacketDataParse.getPacketType(byteData);

            var packetProcessorInfo = getPacketProcessorInfo(packetType);

            if( !packetProcessorInfo ){
                RingLogger.warning('Packet Processor Not Implemented. Packet Type ', packetType, RingLogger.tags.TAG_CHAT);
                return false;
            }

            var parsedPacketObject = tagChatPacketProcessor.parseRawPacket(byteData);


            DEBUG && LOG_DUPLICATE && __logReceivedPacketInfo(packetType, parsedPacketObject);
            //packetProcessorInfo.PACKET_NAME = getPacketName(parsedPacketObject.packetType);
            //RingLogger.info('Received Chat Packet', packetProcessorInfo.PACKET_NAME ,RingLogger.tags.TAG_CHAT);
            //RingLogger.print('Parsed Packet Object', parsedPacketObject, RingLogger.tags.TAG_CHAT);


            if(!tagChatFactory.startProcessingRequest ||
                !parsedPacketObject ||
                (!!parsedPacketObject.packetId && _checkForDuplicatePacket(parsedPacketObject)) ){

                return;
            }



            //if(!packetTypeDebug[parsedPacketObject.packetType]){
            //    packetTypeDebug[parsedPacketObject.packetType] = 0;
            //}
            //
            //packetTypeDebug[parsedPacketObject.packetType]++;


            //RingLogger.print('PacketType Debug Log', packetTypeDebug, RingLogger.tags.TAG_CHAT);


            safeExecute(function(){
                DEBUG && !LOG_DUPLICATE &&  __logReceivedPacketInfo(packetType, parsedPacketObject);
                packetProcessorInfo.processor.call(this, parsedPacketObject);
            });

            return packetProcessorInfo.scopeUpdate;

        }


        ////////////////////////////////////////// Tag Chat Update Processors //////////////////////////////////

        //case 6 : for receiving F2F New Message
        function _processFriendChatNewMessage(parsedPacketObject){

            if( !parsedPacketObject.fromHistory && chatHistoryFactory.isInLocalStorageChatMsgMap(parsedPacketObject.packetId) ){
                return;
            }

            var friendId = parsedPacketObject.friendId;
            var packetId = parsedPacketObject.packetId;
            var userId =  parsedPacketObject.userId;
            var boxId = parsedPacketObject.boxId;

            var sendConfirmation = !parsedPacketObject.fromHistory;

            var currentUserId = Auth.currentUser().getKey();
            var scrollType;
            
            if( !boxId ){
                boxId = parsedPacketObject.userId;
            }

            if( boxId == currentUserId){
                boxId = parsedPacketObject.friendId;
                sendConfirmation = false;
            }

            var chatBox = ChatFactory.getBoxByUId(boxId);

            if( !parsedPacketObject.fromHistory && parsedPacketObject.messageType === TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.DELETE_MESSAGE ){

                if( parsedPacketObject.userId == currentUserId ){

                    if( chatBox ){
                        chatBox.removeMessage(packetId);
                    }

                    chatHistoryFactory.removeMessage(packetId, boxId);

                }else{

                    var msgObj;
                    if( chatBox ){
                        msgObj = chatBox.getMessage(packetId);
                    }else{
                        msgObj = chatHistoryFactory.getMessage(boxId, packetId);
                    }

                    if(!!msgObj){
                        msgObj.text = 'This message has been deleted';
                        msgObj.status = 'Deleted';
                        chatHistoryFactory.updateMessage(msgObj, boxId);
                    }

                }

            }else if( parsedPacketObject.messageType > TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.BLANK_MESSAGE ){

                if( !chatBox){

                    ChatFactory.openChatBox(boxId);
                    ChatApiService.requestForIp(boxId);
                    ChatHelper.loadHistoryMessageForF2FChat(boxId, chatBox);

                }else if( !parsedPacketObject.fromHistory){

                    chatBox.nonDomBox = true;
                }

                chatBox = ChatFactory.getBoxByUId(boxId);

                safeExecute(function () {
                  
                    chatBox.setFriendTypingBool(false);

                    if(parsedPacketObject.fromHistory){
                        parsedPacketObject.seenSent = true;
                    }else{
                        scrollType = 'bottom'    
                    }


                    if( !parsedPacketObject.fromHistory || !parsedPacketObject.fromOffline){

                        __updateLastCommunicationTime(userId, chatBox);

                        if( !!chatBox && !chatBox.isFocused ){
                            parsedPacketObject.status = 'Unread';
                            scrollType = 'unread'
                        }else{
                            parsedPacketObject.status = parsedPacketObject.status || 'Received';
                        }
                    }
                
                    parsedPacketObject.tag_chat = false;

                    var friendId = chatBox.getKey();

                    if (parsedPacketObject.status == 'Edited' || !chatBox.isSamePacketId(packetId) ) {

                        parsedPacketObject.user = profileFactory.getUserObjectByUId(userId);

                        if(parsedPacketObject.status == 'Unread') {
                            // ChatHelper.increaseUnreadCount(chatBox, 1);                            
                            ChatFactory.increaseUnreadMessageCount(boxId, parsedPacketObject.packetId);
                            chatBox.updateUnreadCount();
                        }

                        chatBox.pushMessage(parsedPacketObject, chatBox.getKey());

                        if(sendConfirmation) {
                            tagChatManager.sendFriendMessageDeliveryPacketMultipleTimes(friendId, chatBox, packetId);
                            if(chatBox.isFocused){//for sending seen packet if box is on focused
                                var filteredMessages = [{key: parsedPacketObject.packetId, value:chatBox.getMessage(parsedPacketObject.packetId)}];
                                ChatSeenSend.sendSeenPacket(chatBox, filteredMessages);
                                utilsFactory.triggerCustomEvent("WAS_FOCUSED", {box: chatBox, filteredMessages: filteredMessages});
                            }
                            //tagChatApiService.sendFriendChatDeliveryPacket(chatBox, currentUserId, friendId, packetId)
                        }

                        chatHistoryFactory.updateBox(chatBox);

                    }

                    if(!parsedPacketObject.fromHistory){
                        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED, { boxId : boxId, scroll : scrollType });
                    }


                });

            }

        }

        //case 7 : for receiving Tag Chat Edit Msg
        function _processFriendChatEditMessage(parsedPacketObject){

            RingLogger.print('friend chat : new friend edit msg received ', parsedPacketObject, RingLogger.tags.TAG_CHAT );

            parsedPacketObject.status = 'Edited';
            _processFriendChatNewMessage(parsedPacketObject);

        }

        //case 8 : for receiving broken f2f chat message
        function _processFriendBrokenPacketChatMessage(parsedPacketObject){
            //RingLogger.information('tag broken tag chat packet', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            var genericSequenceNo = parsedPacketObject.sequenceNo;
            var key = parsedPacketObject.packetId + "_" + genericSequenceNo;

            if( !brokenPacketMap[key]){
                brokenPacketMap[key] = parsedPacketObject;

                //Found All Packets For this Packet Id
                if( __hasReceivedAllBrokenPacket(parsedPacketObject.packetId, parsedPacketObject.packetsLength )  ){

                    safeExecute(function() {

                        var combinedParsedPacketObject = __getCombinedParsedPacketFromTextBrokenPacket( parsedPacketObject.packetId, parsedPacketObject.packetsLength);

                        if(!combinedParsedPacketObject.originPacketType){
                            combinedParsedPacketObject.originPacketType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG;
                            _processFriendChatNewMessage(combinedParsedPacketObject);
                        }else{
                            _processFriendChatEditMessage(combinedParsedPacketObject);
                        }

                        __clearBrokenPacketsMap(parsedPacketObject.packetId, parsedPacketObject.packetsLength);

                    });

                }

                var packetId = key;
                var currentUserId = Auth.currentUser().getKey();
                var friendId = parsedPacketObject.userId;

                var chatBox = ChatFactory.getBoxByUId(friendId);
                if(!chatBox){
                    ChatApiService.requestForIp(friendId);
                    ChatHelper.executeAfterRegisterEvent(friendId, function(){
                        var chatBox = ChatFactory.getBoxByUId(friendId);
                        tagChatApiService.sendFriendChatDeliveryPacket(chatBox, currentUserId, friendId, packetId);
                    });
                }else{
                    tagChatApiService.sendFriendChatDeliveryPacket(chatBox, currentUserId, friendId, packetId);
                }


            }else{
                console.info('Ignoring Duplicate Packets');
            }

        }

        //case 9 : for receiving broken edit f2f chat message
        function _processFriendEditBrokenPacketChatMessage(parsedPacketObject){
            //RingLogger.information('tag edit broken tag chat packet', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            parsedPacketObject.originPacketType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG_EDIT;

            _processFriendBrokenPacketChatMessage(parsedPacketObject);
        }


        //case 15 : for receiving f2f delivered
        function _processFriendDeliveredConfirmation(parsedPacketObject){
        }

        //case 18 : for receiving f2f seen confirmation
        function _processFriendChatSeenConfirmation(parsedPacketObject){
        }

        //case 41 : for receiving Tag Register
        function _processTagRegister(parsedPacketObject){
            //RingLogger.information('received get tag register ', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }
        //case 42 : for receiving Tag UnRegister
        function _processTagUnRegister(parsedPacketObject){
            //RingLogger.information('received get tag unregister ', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }
        //case 43 : for receiving Tag register confirmation
        function _processTagRegisterConfirmation(parsedPacketObject){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                tagId = parsedPacketObject.tagId;

            /*setting serverTimeDiff: starts*/
            CHAT_GLOBAL_VALUES.serverTimeDiff = parsedPacketObject.serverDate - Date.now();
            /*setting serverTimeDiff: ends*/
            var tagObject = tagChatFactory.getOrCreateTag(tagId);

            if(!!tagObject){
                tagObject.setChatBindingPort(parsedPacketObject.chatBindingPort);

                tagChatFactory.markTagAsRegistered(tagObject.getTagId());

                if(tagChatFactory.isTagChatInitiator(tagId)){
                    var tagMessageObject = tagChatHelper.getTagEmptyMessageObject(tagId);
                    tagChatApiService.sendTagMsgInChatServer(currentUserId, tagObject, tagMessageObject, true);
                }


                var chatBox = __getChatBox(tagId, tagObject);

                chatBox.setPort(parsedPacketObject.chatBindingPort);

                __updateLastCommunicationTime(tagId, chatBox, tagObject);

                ChatHelper.sendAfterRegisterIdlePacket(tagId, chatBox);

                //ChatFactory.sendIdlePacket(chatBox);

                //chatBox.initInterval();

                //tagObject.updateLastCommunicationTime();

                //initTagIdleInterval( parsedPacketObject.tagId, tagObject);

                ChatPacketSenderService.sendTemporaryMessages(chatBox);

                //tagChatManager.sendTemporaryStoredMessages(parsedPacketObject.tagId, chatBox);

                utilsFactory.triggerCustomEvent('taglistupdated');

            }else{
                RingLogger.error('Invalid Tag Register Confirmation Info', parsedPacketObject, RingLogger.tags.TAG_CHAT);
            }


        }
        //case 44 : for receiving Tag Create
        function _processTagCreate(parsedPacketObject){
            //RingLogger.information('tag create', parsedPacketObject, RingLogger.tags.TAG_CHAT );

            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                tagId = parsedPacketObject.tagId,
                aNewTag, chatBox;

            var chatBox = __getChatBox(tagId, aNewTag);

            if( !parsedPacketObject.fromHistory && !parsedPacketObject.fromOffline) {

                aNewTag = tagChatFactory.createNewTag(parsedPacketObject);
                tagChatFactory.addTagObject(aNewTag);

                __updateLastCommunicationTime(tagId, chatBox, aNewTag);

                tagChatFactory.addTagObject(aNewTag);

                if( parsedPacketObject.tagMembers.length > 0){
                    __addMembersToTagObject(aNewTag, parsedPacketObject.tagMembers, parsedPacketObject.userId);
                }
            }

            chatBox.updateBoxMessageMinMaxPacketId(parsedPacketObject);

            //tagChatApiService.sendTagInformationToOfflineServer( currentUserId, aNewTag, parsedPacketObject.packetId );

            utilsFactory.triggerCustomEvent('taglistupdated');


        }
        //case 45 : for create tag confirmation
        function _processTagCreateConfirmation(parsedPacketObject){
            //RingLogger.information('tag create confirmation ', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 46 : for receiving TagInformation
        function _processTagInformation(parsedPacketObject){
            //RingLogger.information('new tag info', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                tagId = parsedPacketObject.tagId,
                packetId, oldTagObject, aNewTag, chatBox;

            packetId = parsedPacketObject.packetId;
            oldTagObject = tagChatFactory.getTag(tagId);

            if(!!oldTagObject){
                tagChatUI.showTagInfoChangeStatusMessage(tagId,
                    parsedPacketObject.userId,
                    parsedPacketObject
                );

                if( !parsedPacketObject.fromHistory){
                    aNewTag = tagChatFactory.updateTag(tagId, parsedPacketObject, oldTagObject);
                }


            }else{

                if( !parsedPacketObject.fromHistory) {
                    aNewTag = tagChatFactory.createNewTag(parsedPacketObject);
                    tagChatFactory.addTagObject(aNewTag);
                }
            }

            if( !parsedPacketObject.fromHistory && !parsedPacketObject.fromOffline) {
                var chatBox = __getChatBox(tagId, aNewTag);
                __updateLastCommunicationTime(tagId, chatBox, aNewTag);

                tagChatApiService.sendTagInformationConfirmation( currentUserId, aNewTag, packetId );
            }

            utilsFactory.triggerCustomEvent('taglistupdated');


        }

        //case 47 : for receiving  Tag Information Confirmation
        function _processTagInformationConfirmation(parsedPacketObject){
            //RingLogger.information('tag info confirmation', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 51 : for receiving tag member add
        function _processTagMemberAddUpdate(parsedPacketObject){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                tagId = parsedPacketObject.tagId,
                tagObject, chatBox;

            //RingLogger.information('received new tag member ', parsedPacketObject, RingLogger.tags.TAG_CHAT );

            tagObject = tagChatFactory.getOrCreateTag(tagId);

            tagChatUI.showTagMembersAddStatusMessage(tagId,
                parsedPacketObject.userId,
                parsedPacketObject.tagMembers,
                parsedPacketObject.messageDate,
                parsedPacketObject.packetId,
                tagObject
            );

            if(!!tagObject && !parsedPacketObject.fromHistory){

                __addMembersToTagObject(tagObject, parsedPacketObject.tagMembers, parsedPacketObject.userId);

                chatBox = __getChatBox(tagId, tagObject);
                __updateLastCommunicationTime(tagId, chatBox, tagObject);

                tagChatApiService.sendTagMemberAddConfirmation(currentUserId, tagObject, parsedPacketObject.packetId);
            }

        }

        //case 52 : for receiving tag member add confirmation
        function _processTagMemberAddConfirmation(parsedPacketObject){
            //RingLogger.information('received new tag member add confirmation ', parsedPacketObject, RingLogger.tags.TAG_CHAT );

        }

        //case 53 : for Tag member remove leave
        function _processTagMemberRemoveLeave(parsedPacketObject){
            if(!parsedPacketObject.tagMembers){
                return;
            }

            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                chatBox, packetId, tagObject, currentUserRemoved,
                tagId = parsedPacketObject.tagId;

            //RingLogger.information('tag member remove leave ', parsedPacketObject, RingLogger.tags.TAG_CHAT );

            packetId = parsedPacketObject.packetId;
            delete parsedPacketObject.packetId;

            tagObject = tagChatFactory.getOrCreateTag(parsedPacketObject.tagId);

            tagChatUI.showTagMembersRemoveStatusMessage(parsedPacketObject.tagId,
                parsedPacketObject.userId,
                parsedPacketObject.tagMembers,
                parsedPacketObject.messageDate,
                packetId,
                tagObject
            );

            if(!parsedPacketObject.fromHistory){
                currentUserRemoved = __removeMembersFromTagObject(tagObject, parsedPacketObject.tagMembers);
                if(currentUserRemoved){
                    __doAfterCurrentUserRemovedFromTag(tagId);
                }

                chatBox = __getChatBox(tagId, tagObject);
                __updateLastCommunicationTime(tagId, chatBox, tagObject);

                tagChatApiService.sendTagChatMemberRemoveLeaveConfirmation(currentUserId, tagObject, packetId);

            }
        }

        //case 54 : for Tag member remove leave confirmation
        function _processTagMemberRemoveLeaveConfirmation(parsedPacketObject){
            //RingLogger.information('tag member remove leave confirmation ', parsedPacketObject, RingLogger.tags.TAG_CHAT );
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                tagId = parsedPacketObject.tagId;

            if( parsedPacketObject.userId === currentUserId ){
                tagChatFactory.unRegisterTag(tagId);
            }

        }

        //case 55 : for Tag Member Type Change
        function _processTagMemberStatusChange(parsedPacketObject){
            if(!parsedPacketObject.tagMembers){
                return;
            }

            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                chatBox, tagObject,
                tagId = parsedPacketObject.tagId;


            //RingLogger.information('tag member status change update', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            /** Ignore Packet If its already in local storage **/
            //if( chatHistoryFactory.isInLocalStorageChatMsgMap(parsedPacketObject.packetId) ){
            //    return;
            //}

            tagObject = tagChatFactory.getOrCreateTag(tagId);

            tagChatUI.showMemberTypeChangeStatusMessage(tagId,
                parsedPacketObject.userId,
                parsedPacketObject.tagMembers,
                parsedPacketObject.messageDate,
                parsedPacketObject.packetId
            );

            if( !parsedPacketObject.fromHistory){
                __updateMemberStatusInTagObject(tagObject, parsedPacketObject.tagMembers);

                chatBox = __getChatBox(tagId, tagObject);
                __updateLastCommunicationTime(tagId, chatBox, tagObject);
            }

            utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED,{ boxId : tagId });

        }

        //case 56 : for Tag Member Type Change confirmation
        function _processTagMemberStatusChangeConfirmation(parsedPacketObject){
            //RingLogger.information('tag member status change confirmation', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 61: tagChat idle
        function _processTagChatIdleUpdate(parsedPacketObject){
            //RingLogger.information('tag chat idle packet ', parsedPacketObject);
            //var chatBox = ChatFactory.getBoxByUId(parsedPacketObject.tagId);
            //chatHistoryFactory.updateBox(chatBox);

        }

        //case 62: tagChat typing
        function _processTagChatTypingUpdate(parsedPacketObject){
            //RingLogger.information('tag chat typing packet ', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            var chatBox, tagObject,
                tagId = parsedPacketObject.tagId;

            tagObject = tagChatFactory.getTag(tagId);

            safeExecute(function () {
                if (!!tagObject) {

                    chatBox = __getChatBox(tagId, tagObject);

                    if( chatBox ){
                        __updateLastCommunicationTime(tagId, chatBox, tagObject);
                        chatBox.setFriendTypingBool(true);

                        $timeout(function () {
                            chatBox.setFriendTypingBool(false);
                        }, 3000);

                        chatHistoryFactory.updateBox(chatBox);

                        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED,{ boxId : tagId });

                    }
                }
            });
        }

        //case 63 : for receiving Tag Chat Msg
        function _processTagChatNewMessage(parsedPacketObject){
            //RingLogger.information('tag chat : new tag msg received ', parsedPacketObject, RingLogger.tags.TAG_CHAT );

            if( !parsedPacketObject.fromHistory && chatHistoryFactory.isInLocalStorageChatMsgMap(parsedPacketObject.packetId) ){
                return;
            }

            var tagId = parsedPacketObject.tagId;
            var tagObject = tagChatFactory.getTag(tagId);

            if(!tagObject){
                tagChatManager.requestForTagInformationMultipleTimes(tagId);
                tagObject = tagChatFactory.getOrCreateTag(tagId);
            }

            var chatBox = ChatFactory.getBoxByUId(tagId);
            var scrollType;

            if( parsedPacketObject.messageType === TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.DELETE_MESSAGE ){

                if( parsedPacketObject.userId == Auth.currentUser().getKey() ){

                    if( chatBox ){
                        chatBox.removeMessage(parsedPacketObject.packetId);
                    }
                    chatHistoryFactory.removeMessage(parsedPacketObject.packetId, tagId);

                }else{

                    var msgObj;
                    if( chatBox ){
                        msgObj = chatBox.getMessage(parsedPacketObject.packetId);
                    }else{
                        msgObj = chatHistoryFactory.getMessage(tagId, parsedPacketObject.packetId);
                    }

                    if(!!msgObj){
                        msgObj.text = 'This message has been deleted';
                        msgObj.status = 'Deleted';
                        chatHistoryFactory.updateMessage(msgObj, tagId);
                    }
                }

                if( chatBox ){
                    chatBox.removeMessage(parsedPacketObject.packetId);
                }
                chatHistoryFactory.removeMessage(parsedPacketObject.packetId, parsedPacketObject.tagId);


            }else if(!(parsedPacketObject.fromHistory || parsedPacketObject.fromUnread) && parsedPacketObject.fromOffline &&
                        parsedPacketObject.messageType === TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.BLANK_MESSAGE  &&
                        !tagChatFactory.isTagRegistered(parsedPacketObject.tagId) &&
                        tagChatHelper.hasChatSession(parsedPacketObject.messageDate))
            {

                tagChatManager.requestForTagInformationMultipleTimes(parsedPacketObject.tagId);

            }else if( parsedPacketObject.messageType > TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.BLANK_MESSAGE ){


                chatBox = tagChatManager.openTagChatBoxIfClosed(parsedPacketObject.tagId, chatBox);
                
                safeExecute(function () {
                    
                    if( !parsedPacketObject.fromHistory ){
                        scrollType = 'bottom'    
                    }
                    

                    if( !parsedPacketObject.fromHistory || !parsedPacketObject.fromOffline){
                        if( !!chatBox && !chatBox.isFocused ){
                            parsedPacketObject.status = 'Unread';
                            scrollType = 'unread'
                        }else{
                            parsedPacketObject.status = parsedPacketObject.status || 'Received';
                        }
                    }

                    parsedPacketObject.tag_chat = true;

                    var tagId = chatBox.getKey();

                    if (!chatBox.isSamePacketId(parsedPacketObject.packetId) ) {

                        parsedPacketObject.user = profileFactory.getUserObjectByUId(parsedPacketObject.userId);

                        if(!parsedPacketObject.fromHistory && !!tagObject && tagObject.isTagSafeToShow()){
                            chatBox.nonDomBox = true;
                            __updateLastCommunicationTime(tagId, chatBox);
                        }

                        var tagMessageModelObject = tagChatFactory.getOrCreateMessage(parsedPacketObject.tagId, parsedPacketObject);
                        tagMessageModelObject.setStatus(parsedPacketObject.status);

                        if(parsedPacketObject.fromHistory){
                            parsedPacketObject.seenSent = true;
                        }
                        else{

                            if( tagMessageModelObject.getStatus() == 'Unread'){
                                // ChatHelper.increaseUnreadCount(chatBox, 1);
                                ChatFactory.increaseUnreadMessageCount(tagId, parsedPacketObject.packetId);
                                chatBox.updateUnreadCount();
                            }
                        }

                        chatBox.pushMessage(parsedPacketObject, chatBox.getKey());

                        if( !parsedPacketObject.fromOffline ) {
                            var packetId = parsedPacketObject.packetId;
                            tagChatManager.sendTagMessageDeliveryPacketMultipleTimes(parsedPacketObject.tagId, packetId, tagMessageModelObject);
                        }

                        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED, { boxId : tagId, scroll : scrollType } );

                        chatHistoryFactory.updateBox(chatBox);


                    }

                });

            }

        }

        //case 64 : for receiving Tag Chat Edit Msg
        function _processTagChatEditMessage(parsedPacketObject){

            RingLogger.print('tag chat : new tag edit msg received ', parsedPacketObject, RingLogger.tags.TAG_CHAT );

            parsedPacketObject.status = 'Edited';
            _processTagChatNewMessage(parsedPacketObject);

        }

        //case 65 : for broken chat message for tag
        function _processTagBrokenPacketChatMessage(parsedPacketObject){
            //RingLogger.information('tag broken tag chat packet', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            var genericSequenceNo = parsedPacketObject.sequenceNo;
            var key = parsedPacketObject.packetId + "_" + genericSequenceNo;

            if( !brokenPacketMap[key]){
                brokenPacketMap[key] = parsedPacketObject;

                //Found All Packets For this Packet Id
                if( __hasReceivedAllBrokenPacket(parsedPacketObject.packetId, parsedPacketObject.packetsLength )  ){


                    safeExecute(function() {

                        var combinedParsedPacketObject = __getCombinedParsedPacketFromTextBrokenPacket( parsedPacketObject.packetId, parsedPacketObject.packetsLength);

                        if(!combinedParsedPacketObject.originPacketType){
                            combinedParsedPacketObject.originPacketType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG;
                            _processTagChatNewMessage(combinedParsedPacketObject);
                        }else{
                            _processTagChatEditMessage(combinedParsedPacketObject);
                        }

                    });

                }

            }else{
                console.info('Ignoring Duplicate Packets');
            }

        }

        //case 66 : for broken chat message edit for tag
        function _processTagEditBrokenPacketChatMessage(parsedPacketObject){
            //RingLogger.information('tag edit broken tag chat packet', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            parsedPacketObject.originPacketType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG_EDIT;

            _processTagBrokenPacketChatMessage(parsedPacketObject);
        }

        //case 67 : for broken chat multiple message  for tag
        function _processTagMultipleChatMessage(parsedPacketObject){
            //RingLogger.information('tag multiple chat message', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 68: tagChat deliver packet receiving
        function _processTagChatDeliveredUpdate(parsedPacketObject){

            //RingLogger.information('tag chat delivered packet ', parsedPacketObject, RingLogger.tags.TAG_CHAT  );
            var tagId = parsedPacketObject.tagId;
            var tagObject = tagChatFactory.getTag(parsedPacketObject.tagId);

            var chatBox = __getChatBox(tagId, tagObject);


            safeExecute(function () {
                __updateLastCommunicationTime(tagId, chatBox, tagObject);

                var boxMessageObject = chatBox.getMessage(parsedPacketObject.packetId);
                if (!!boxMessageObject) {

                    if( boxMessageObject.status !== 'Seen' ){
                        boxMessageObject.status = 'Delivered';
                    }

                    //boxMessageObject.addDeliveredUserId(parsedPacketObject.userId);
                    chatHistoryFactory.updateMessage(boxMessageObject, chatBox.getKey());
                }

                if(!!tagObject){
                    var tagMessageObject = tagObject.getMessage(parsedPacketObject.packetId);
                    if( !!tagMessageObject ){
                        if( tagMessageObject.getStatus() !== 'Seen'){
                            tagMessageObject.setStatus('Delivered');
                        }

                        //tagMessageObject.addDeliveredUserId(parsedPacketObject.userId);
                    }    
                }
                

                chatHistoryFactory.updateBox(chatBox);
            });

        }

        //case 69: tagChat sent packet receiving
        function _processTagChatSentUpdate(parsedPacketObject){

            //RingLogger.information('tag chat sent packet ', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            var tagObject, chatBox,
                tagId = parsedPacketObject.tagId;

            tagObject = tagChatFactory.getTag(tagId);

            chatBox = ChatFactory.getBoxByUId(tagId);

            safeExecute(function () {

                //chatBox = tagChatManager.openTagChatBoxIfClosed(tagId, chatBox);
                chatBox = __getChatBox(tagId, chatBox);

                __updateLastCommunicationTime(tagId, chatBox, tagObject);

                var boxMessageObject = chatBox.updateMessageStatus(parsedPacketObject.packetId, 'Sent');
                if (!!boxMessageObject) {
                    chatHistoryFactory.updateMessage(boxMessageObject, chatBox.getKey());
                }

                if(!!tagObject){
                    var tagMessageObject = tagObject.getMessage(parsedPacketObject.packetId);
                    if (!!tagMessageObject) {
                        tagMessageObject.setStatus('Sent');
                    }    
                }
                

                chatHistoryFactory.updateBox(chatBox);
            });
        }

        //case 70: tagChat seen packet receiving
        function _processTagChatSeenUpdate(parsedPacketObject){
            //RingLogger.information('tag chat seen packet ', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            var tagObject,
                tagId = parsedPacketObject.tagId,
                chatBox;

            tagObject = tagChatFactory.getTag(tagId);
            chatBox = ChatFactory.getBoxByUId(tagId);

            safeExecute(function () {
                __updateLastCommunicationTime(tagId, chatBox, tagObject);

                //chatBox = tagChatManager.openTagChatBoxIfClosed(tagId, chatBox);
                chatBox = __getChatBox(tagId, chatBox);

                var boxMessageObject = chatBox.updateMessageStatus(parsedPacketObject.packetId, 'Seen');
                if (!!boxMessageObject) {
                    //boxMessageObject.addSeenUserId(parsedPacketObject.userId);
                    chatHistoryFactory.updateMessage(boxMessageObject, chatBox.getKey());
                }


                if( !!tagObject){
                    var tagMessageObject = tagObject.getMessage(parsedPacketObject.packetId);
                    if (!!tagMessageObject) {
                        tagMessageObject.setStatus('Seen');
                        //tagMessageObject.addSeenUserId(parsedPacketObject.userId);
                    }    
                }
                

                chatHistoryFactory.updateBox(chatBox);
            });

        }

        //case 71: tagChat seen confirmation packet receiving
        function _processTagChatSeenConfirmationUpdate(parsedPacketObject){
            //RingLogger.information('tag message seen confirmation', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 72 : for receiving TagChat Multiple Delete
        function _processTagChatMultipleDelete(parsedPacketObject){
            //RingLogger.information('tag multiple delete', parsedPacketObject, RingLogger.tags.TAG_CHAT);

            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey();

            if( !angular.isArray(parsedPacketObject.packets) ){
                return;
            }

            _doProcessTagChatMultipleDelete(parsedPacketObject.tagId, parsedPacketObject.userId, parsedPacketObject.packets);

            var tagObject = tagChatFactory.getTag(parsedPacketObject.tagId);
            if(!!tagObject){
                tagChatApiService.sendTagChatMsgDeleteConfirmation(currentUserId, tagObject,
                    parsedPacketObject.packetId,
                    parsedPacketObject.userId);
            }

            
        }

        //case 73: delete confirmation
        function _processTagChatMsgDeleteConfirmation(parsedPacketObject){

            //RingLogger.information('tag chat delete confirmation packet ', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            var deleteRequestObject = tagChatFactory.getFromTagChatRequestCache(parsedPacketObject.packetId);
            if(!!deleteRequestObject){
                _doProcessTagChatMultipleDelete(parsedPacketObject.tagId, parsedPacketObject.userId, deleteRequestObject.packets);
            }


        }

        //case 74 : for receiving Tag General Broken Packet
        function _processTagBrokenPacket(parsedPacketObject){
            //RingLogger.information('tag broken packet', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                isProcessed, chatBox, tagObject,
                tagId = parsedPacketObject.tagId;

            isProcessed = _doProcessTagBrokenPacket(parsedPacketObject);

            if(isProcessed){
                tagObject = tagChatFactory.getTag(tagId);
                tagChatApiService.sendTagGeneralBrokenPacketConfirmation(currentUserId,
                    tagObject, parsedPacketObject.packetId, parsedPacketObject.sequenceNo );

                chatBox = __getChatBox(tagId);
                //__updateLastCommunicationTime(tagId, chatBox, tagObject);
            }
        }

        //case 75 : for receiving Tag General Broken Confirmation Packet
        function _processTagBrokenConfirmationPacket(parsedPacketObject){
            //RingLogger.information('tag chat broken packet confirmation', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 94 : for receiving Tag General Broken Confirmation Packet
        function _processOfflineGetRequestConfirmation(parsedPacketObject){
            //RingLogger.information('offline get request confirmation', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 95 : for receiving Offline Friend Unread
        function _processOfflineFriendUnreadMessages(parsedPacketObject){
            var currentUser = Auth.currentUser(),
                boxIds = {},
                currentUserId = currentUser.getKey();

            var packetId = parsedPacketObject.packetId,
                packetIds = [];

            for(var index = 0; index < parsedPacketObject.messages.length; index++){
                var anUnreadMessage = parsedPacketObject.messages[index];

                anUnreadMessage.fromOffline = true;
                anUnreadMessage.status = 'Unread';

                _processFriendChatNewMessage(anUnreadMessage);

                boxIds[anUnreadMessage.userId] = true;

                if( anUnreadMessage.messageType != TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.BLANK_MESSAGE ){
                    packetIds.push(anUnreadMessage.packetId);
                }
            }

            var boxIdList = Object.keys(boxIds);
            for(var index = 0, length = boxIdList.length; index < length; index++){
                utilsFactory.triggerCustomEvent('NEW_MESSAGE_PUSHED', { boxId : boxIdList[index]});
            }

            if( packetIds.length > 0){
                tagOfflineChatManager.sendFriendUnreadMessageOfflineConfirmation(currentUserId, packetId, packetIds);
            }


        }

        //case 98 : for receiving Friend History Message
        function _processFriendHistoryMessage(parsedPacketObject){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey();

            var packetId = parsedPacketObject.packetId,
                friendId = parsedPacketObject.friendId,
                packetIds = [];

            var chatBox = ChatFactory.getBoxByUId(friendId);
            if(!chatBox){
                chatBox = ChatFactory.creatNonDomBox(friendId);
            }

            if(!parsedPacketObject.messages.length && parsedPacketObject.pageDirection != TAG_CHAT_GENERAL_CONSTANTS.PAGE_DIRECTION.DOWN){

                chatBox.hasHistoryMessage = false;

            }else{


                var preProcessMessageDate = chatUtilsFactory.getChatServerCurrentTime();
                var lowestMessageDate = preProcessMessageDate;
                var processed = false;

                for(var index = 0; index < parsedPacketObject.messages.length; index++){
                    var aHistoryMessage = parsedPacketObject.messages[index];

                    if(aHistoryMessage.messageType == TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.HISTORY_RE_FETCH ){
                        _doRequestForHistoryMessage(friendId, TAG_CHAT_GENERAL_CONSTANTS.PAGE_DIRECTION.UP, packetId);

                    }else if( aHistoryMessage.messageType != TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.DELETE_MESSAGE ){

                        processed = true;

                        if(aHistoryMessage.userId.toString() === currentUserId.toString()){

                            aHistoryMessage.status = _getMessageStatus( aHistoryMessage.status ) || 'Delivered';

                            aHistoryMessage.friendId = friendId;

                        }else{

                            if( aHistoryMessage.status < TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_STATUS.SEEN){
                                aHistoryMessage.status = 'Unread';
                            }else{
                                aHistoryMessage.status = 'Received';
                            }

                            aHistoryMessage.friendId = currentUserId;
                        }

                        aHistoryMessage.boxId = friendId;
                        aHistoryMessage.fromOffline = true;
                        aHistoryMessage.fromHistory = true;

                        _processFriendChatNewMessage(aHistoryMessage);

                    }

                    if( aHistoryMessage.messageDate < lowestMessageDate ){
                        lowestMessageDate = aHistoryMessage.messageDate;
                    }

                    packetIds.push(aHistoryMessage.packetId);

                }

                if( processed ) {

                    chatBox.hasHistoryMessage = true;
                    utilsFactory.triggerCustomEvent('NEW_MESSAGE_PUSHED', {boxId: friendId});

                }else{

                    if( lowestMessageDate != preProcessMessageDate ){
                        var newPacketId = tagChatFactory.getUUIDPacketId(lowestMessageDate, true);
                        _doRequestForHistoryMessage(friendId, TAG_CHAT_GENERAL_CONSTANTS.PAGE_DIRECTION.UP, newPacketId);
                    }

                }
            }


            tagChatApiService.sendFriendHistoryMessageOfflineConfirmation(currentUserId, friendId, packetId );


        }

        function _processGetFriendHistoryMessageConfirmation(parsedPacketObject){
        }

        //case 104 : for receiving tag Information Offline Activity
        function _processTagInformationOfflineActivity(parsedPacketObject){

            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                packetId = parsedPacketObject.packetId,
                tagId = parsedPacketObject.tagId;

            if( parsedPacketObject.items.length > 0 ){

                for(var index= 0, length = parsedPacketObject.items.length; index < length; index++ ){
                    var item = parsedPacketObject.items[index];
                    _processAGroupActivity(tagId, packetId, item);
                }

            }

            tagChatApiService.sendTagOfflineConfirmation(currentUserId, tagId, packetId );
        }

        //case 105 : for receiving offline Tag List
        function _processMyTagList(parsedPacketObject){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                packetId = parsedPacketObject.packetId,
                aTagObject;

            for(var index = 0; index < parsedPacketObject.items.length; index++){
                aTagObject = tagChatFactory.createNewTag(parsedPacketObject.items[index]);
                tagChatFactory.addTagObject(aTagObject);

                setTimeout(function(tagId){
                    tagChatManager.requestForTagInformationMultipleTimes(tagId).then(function(response){
                        if(!response.sucs && response.timeout){
                            tagChatManager.requestForTagInformationMultipleTimes(tagId);
                        }
                    });
                }.bind(this, aTagObject.getTagId()), 100);

            }

            utilsFactory.triggerCustomEvent('MY_TAG_LIST_RECEIVED');

            tagChatApiService.sendTagOfflineConfirmation(currentUserId, 0, packetId );
        }

        //case 106 : for receiving Tag Unread Message
        function _processTagUnreadMessage(parsedPacketObject){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                packetId = parsedPacketObject.packetId,
                packetIds = [];

            for(var index = 0; index < parsedPacketObject.messages.length; index++){
                var anUnreadMessage = parsedPacketObject.messages[index];
                anUnreadMessage.status = 'Unread';
                anUnreadMessage.fromUnread = true;
                anUnreadMessage.fromOffline = true;

                if( anUnreadMessage.messageType == TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.GROUP_ACTIVITY){

                    _processGroupActivityMessage(anUnreadMessage);
                }else{
                    _processTagChatNewMessage(anUnreadMessage);
                }

                if( anUnreadMessage.messageType != TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.BLANK_MESSAGE ){
                    packetIds.push(anUnreadMessage.packetId);
                }
            }

            if( packetIds.length > 0){
                tagOfflineChatManager.sendTagUnreadMessageConfirmation(currentUserId, packetIds);
            }


            //RingLogger.information('tag unread message', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 107 : for receiving Tag Unread Message Confirmation
        function _processTagUnreadMessageConfirmation(parsedPacketObject){
            //RingLogger.information('tag unread message confirmation', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 110 : for receiving Tag History Message Request
        function _processTagHistoryMessageRequest(parsedPacketObject){
            //RingLogger.information('tag history message request', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 111 : for receiving Tag History Message
        function _processTagHistoryMessage(parsedPacketObject){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey();

            //RingLogger.information('tag history message ', parsedPacketObject, RingLogger.tags.TAG_CHAT );

            var packetId = parsedPacketObject.packetId,
                tagId = parsedPacketObject.tagId,
                packetIds = [];

            var chatBox = __getChatBox(tagId);

            if(!parsedPacketObject.messages.length && parsedPacketObject.pageDirection != TAG_CHAT_GENERAL_CONSTANTS.PAGE_DIRECTION.DOWN){

                chatBox.hasHistoryMessage = false;

            }else{


                var packetIds = [];
                var preProcessMessageDate = chatUtilsFactory.getChatServerCurrentTime();;
                var lowestMessageDate = preProcessMessageDate;
                var processed = false;


                for(var index = 0; index < parsedPacketObject.messages.length; index++){
                    var aHistoryMessage = parsedPacketObject.messages[index];
                    aHistoryMessage.tagId = tagId;
                    aHistoryMessage.fromHistory = true;

                    if( aHistoryMessage.messageType == TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.GROUP_ACTIVITY){

                        processed = true;
                        _processGroupActivityMessage(aHistoryMessage);

                    }else if(parsedPacketObject.messages.messageType == TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.HISTORY_RE_FETCH) {

                        _doRequestForHistoryMessage(tagId, TAG_CHAT_GENERAL_CONSTANTS.PAGE_DIRECTION.UP, aHistoryMessage.packetId);

                    }else if( aHistoryMessage.messageType != TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.DELETE_MESSAGE ) {

                        processed = true;

                        if (aHistoryMessage.userId === currentUserId) {
                            aHistoryMessage.status = 'Seen';
                        } else {
                            aHistoryMessage.status = 'Received';
                        }

                        aHistoryMessage.tagId       = tagId;
                        aHistoryMessage.fromOffline = true;
                        aHistoryMessage.fromHistory = true;

                        _processTagChatNewMessage(aHistoryMessage);

                    }

                    if( aHistoryMessage.messageDate < lowestMessageDate ){
                        lowestMessageDate = aHistoryMessage.messageDate;
                    }

                    packetIds.push(aHistoryMessage.packetId);

                }

                if( processed ){

                    chatBox.hasHistoryMessage = true;

                    utilsFactory.triggerCustomEvent('NEW_MESSAGE_PUSHED', { boxId : tagId});

                }else{

                    if( lowestMessageDate != preProcessMessageDate ){
                        var newPacketId = tagChatFactory.getUUIDPacketId(lowestMessageDate, true);
                        _doRequestForHistoryMessage(tagId, TAG_CHAT_GENERAL_CONSTANTS.PAGE_DIRECTION.UP, newPacketId, false);
                    }
                }

            }


            tagChatApiService.sendTagOfflineConfirmation(currentUserId, tagId, packetId );

        }

        //case 112 : for receiving Get Tag Information With Member
        function _processGetTagInformationWithMember(parsedPacketObject){
            //RingLogger.information('received get tag information ', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 113 : for receiving Tag Information With Member
        function _processTagInformationWithMember(parsedPacketObject){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                tagId = parsedPacketObject.tagId;

            //RingLogger.information('new tag information with member', parsedPacketObject, RingLogger.tags.TAG_CHAT );

            var tagObject = tagChatFactory.getOrCreateTag(tagId, parsedPacketObject);

            __addMembersToTagObject(tagObject, parsedPacketObject.tagMembers);

            var chatBox = __getChatBox(tagId, tagObject);

            if( tagChatFactory.isTagRegistered(tagId)){
                __updateLastCommunicationTime(tagId, chatBox, tagObject);
            }

            tagChatApiService.sendTagOfflineConfirmation(currentUserId, tagId, parsedPacketObject.packetId);

            utilsFactory.triggerCustomEvent('taglistupdated');

        }

        //case 117 : for receiving Tag Offline Confirmation
        function _processTagOfflineConfirmation(parsedPacketObject){
            //RingLogger.information('tag offline confirmation ', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }

        //case 118 : for receiving offline broken history packet
        function _processOfflineBrokenHistoryPacket(parsedPacketObject){
            //RingLogger.information('offline broken history packet', parsedPacketObject, RingLogger.tags.TAG_CHAT );

            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                isProcessed, chatBox;

            parsedPacketObject.fromOffline = true;
            parsedPacketObject.fromHistory = true;

            isProcessed = _doProcessTagBrokenPacket(parsedPacketObject);

            if(isProcessed){
                tagChatApiService.sendOfflineBrokenPacketConfirmation(currentUserId,
                    parsedPacketObject.packetId, parsedPacketObject.sequenceNo );

            }
        }

        //case 119 : for receiving offline broken packet
        function _processOfflineBrokenPacket(parsedPacketObject){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                isProcessed, chatBox,
                tagId = parsedPacketObject.tagId;

            //RingLogger.information('offline broken packet', parsedPacketObject, RingLogger.tags.TAG_CHAT );

            parsedPacketObject.fromOffline = true;

            isProcessed = _doProcessTagBrokenPacket(parsedPacketObject);

            if(isProcessed){
                tagChatApiService.sendOfflineBrokenPacketConfirmation(currentUserId,
                    parsedPacketObject.packetId, parsedPacketObject.sequenceNo );

            }
        }

        //case 120 : for receiving offline broken packet
        function _processOfflineBrokenPacketConfirmation(parsedPacketObject){
            //RingLogger.information('offline broken packet confirmation', parsedPacketObject, RingLogger.tags.TAG_CHAT );
        }


        /***************** Helper Processors  ****************/


        function _processAGroupActivity(tagId, packetId, activityItem){
            /*
            * activityItem signature : { changedByUserId:'', userId : '', status : '', activityValue : '' }
            *
            * */

            if( activityItem.changedByUserId == activityItem.userId
                && activityItem.status == TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.OWNER ){
                /* case : IbrahimRashid made IbrahimRashid owner */
                return;
            }

            switch (activityItem.activityType){

                case TAG_CHAT_GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.DELETED :
                    _processTagMemberRemoveLeave( {

                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagMembers : [{userId: activityItem.userId}],
                        fromHistory : activityItem.fromHistory

                    });
                    break;
                case TAG_CHAT_GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.ADDED :
                    _processTagMemberAddUpdate({

                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagMembers : [{userId: activityItem.userId, status : activityItem.status, fullName : activityItem.activityValue}],
                        fromHistory : activityItem.fromHistory
                    });
                    break;
                case TAG_CHAT_GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.LEAVE :
                    _processTagMemberRemoveLeave( {

                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagMembers : [{userId: activityItem.userId}],
                        fromHistory : activityItem.fromHistory

                    });
                    break;
                case TAG_CHAT_GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_RENAME:
                    _processTagInformation({
                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagName : activityItem.activityValue,
                        fromHistory : activityItem.fromHistory

                    });
                    break;
                case TAG_CHAT_GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.MEMBER_TYPE_CHANGE :
                    _processTagMemberStatusChange({
                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagMembers : [{userId: activityItem.userId, status : activityItem.status }],
                        fromHistory : activityItem.fromHistory
                    });
                    break;
                case TAG_CHAT_GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_URL_RENAME :
                    _processTagInformation({
                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagPictureUrl : activityItem.activityValue,
                        fromHistory : activityItem.fromHistory
                    });

                    break;

                case TAG_CHAT_GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_CREATED :
                    _processTagCreate({
                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagName : activityItem.activityValue,
                        tagMembers : [],
                        fromHistory : activityItem.fromHistory
                    });
                    break;
            }

        }


        function _processGroupActivityMessage(groupActivityMessage){

            RingLogger.information('GROUP ACTIVITY MSG', groupActivityMessage, RingLogger.tags.TAG_CHAT_RESPONSE);

            var activityType = groupActivityMessage.packetType;
            var userId = groupActivityMessage.userId;
            var tagId = groupActivityMessage.tagId;
            var packetId = groupActivityMessage.packetId;
            var activityDate = groupActivityMessage.messageDate;

            var message;
            try{
                message = angular.fromJson(groupActivityMessage.message);
            }catch(e){
                RingLogger.alert('INVALID JSON IN GROUP ACTIVITY MESSAGE', groupActivityMessage.message, RingLogger.tags.TAG_CHAT);
                return;
            }

            var activityItem = {
                changedByUserId : groupActivityMessage.userId,
                userId          : message.mId,
                status          : message.mT,
                activityValue   : message.n,
                activityType    : activityType,
                activityDate    : activityDate,
                fromHistory     : groupActivityMessage.fromHistory || false
            };

            _processAGroupActivity(tagId, packetId, activityItem);

        }


        function _processTagChatMsgDelete(parsedPacketObject){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                chatBox, tagObject,
                tagId = parsedPacketObject.tagId;

            //RingLogger.information('tag chat delete packet ', parsedPacketObject, RingLogger.tags.TAG_CHAT  );

            //if( chatHistoryFactory.isInLocalStorageChatMsgMap(parsedPacketObject.packetId) ){
            //    var messages = chatHistoryFactory.getMessages(tagId);
            //    if(!!messages){
            //        var tmpMsg = messages.get(parsedPacketObject.packetId);
            //        if(!!tmpMsg && tmpMsg.status === 'Deleted'){
            //            return;
            //        }
            //    }
            //}

            chatBox = ChatFactory.getBoxByUId(tagId);

            //chatBox = tagChatManager.openTagChatBoxIfClosed(tagId, chatBox);
            chatBox = __getChatBox(tagId);

            tagObject = tagChatFactory.getTag(parsedPacketObject.tagId);

            safeExecute(function () {

                if( tagChatFactory.isTagRegistered(tagId)){
                    __updateLastCommunicationTime(tagId, chatBox, tagObject);
                }

                if( parsedPacketObject.userId === currentUserId ){

                    if( !!chatBox ){
                        chatBox.removeMessage(parsedPacketObject.packetId);
                    }
                    chatHistoryFactory.removeMessage(parsedPacketObject.packetId, parsedPacketObject.tagId);

                }else{
                    var boxMessageObject = chatBox.updateMessageStatus(parsedPacketObject.packetId, 'Deleted');
                    if (!!boxMessageObject) {
                        boxMessageObject.text = 'This message has been deleted';
                        boxMessageObject.setTextPartition();
                        chatHistoryFactory.updateMessage(boxMessageObject, chatBox.getKey());

                    }

                    if(!!tagObject){
                        var tagMessageObject = tagObject.getMessage(parsedPacketObject.packetId);
                        if (!!tagMessageObject) {
                            tagMessageObject.setStatus('Deleted');
                            tagMessageObject.markAsDeleted();
                        }
                    }
                }

                chatHistoryFactory.updateBox(chatBox);
            });
        }

        function _doProcessTagChatMultipleDelete(tagId, userId, packets){

            var singleTagChatMsgDeleteParam = {
                tagId : tagId,
                userId : userId
            };

            for(var index = 0 ; index < packets.length; index++){
                var aPacket = packets[index];
                singleTagChatMsgDeleteParam.packetId = aPacket.packetId;
                _processTagChatMsgDelete(singleTagChatMsgDeleteParam);
            }
        }

        function _doProcessTagBrokenPacket(parsedPacketObject){

            var key = parsedPacketObject.packetId + "_" + parsedPacketObject.sequenceNo;

            if( !brokenPacketMap[key]){
                brokenPacketMap[key] = parsedPacketObject.bytes;

                //Found All Packets For this Packet Id
                if( __hasReceivedAllBrokenPacket(parsedPacketObject.packetId, parsedPacketObject.packetsLength )  ){

                    var brokenPacketParsedPacketObject = __mergeTagBrokenPacket(parsedPacketObject.packetId, parsedPacketObject.packetsLength);
                    brokenPacketParsedPacketObject.fromOffline = parsedPacketObject.fromOffline || false;
                    brokenPacketParsedPacketObject.fromHistory = parsedPacketObject.fromHistory || false;

                    var packetProcessorInfo = getPacketProcessorInfo(brokenPacketParsedPacketObject.packetType);
                    safeExecute(function() {
                        __logReceivedPacketInfo(brokenPacketParsedPacketObject.packetType, brokenPacketParsedPacketObject);
                        packetProcessorInfo.processor.call(this, brokenPacketParsedPacketObject);
                        __clearBrokenPacketsMap(parsedPacketObject.packetId, parsedPacketObject.packetsLength);

                    });

                }

                return true;

            }else{
                RingLogger.info('Ignoring Duplicate Packets');
                return false;
            }

        }


        function _doRequestForHistoryMessage(tagOrFriendId, direction, packetId, forFriendChat){

            if( forFriendChat ){

                var chatBox = __getChatBox(tagOrFriendId);

                tagOfflineChatManager.getFriendHistoryMessagesMultipleTimes(tagOrFriendId, direction, packetId).then(function(response){
                    if(!!response.sucs){
                        chatBox.historyLoading = false;
                    }
                }, function(){
                    chatBox.historyLoading = false;
                });

            }else{

                var chatBox = __getFriendChatBox(tagOrFriendId);

                tagOfflineChatManager.getHistoryMessagesMultipleTimes(tagOrFriendId, direction, packetId).then(function(response){
                    if(!!response.sucs){
                        chatBox.historyLoading = false;
                    }
                }, function(){
                    chatBox.historyLoading = false;
                });

            }
        }

        function _getMessageStatus(statusNo){

            var statusValue = TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_STATUS_VALUE[statusNo];

            if( !!statusValue){
                statusValue =  statusValue.charAt(0) + statusValue.substr(1).toLowerCase();
            }

            return statusValue
        }



        /***************** Privates ****************/

        function __getFriendChatBox(friendId){

            var chatBox = ChatFactory.getBoxByUId(friendId);
            if(!chatBox){
                chatBox = ChatFactory.creatNonDomBox(friendId, true);
                chatBox.loadHistoryMessages();
            }

            return chatBox;
        }

        function __getChatBox(tagId, tagObject){
            if(!tagObject){
                tagObject = tagChatFactory.getTag(tagId);
            }

            var chatBox = ChatFactory.getBoxByUId(tagId);

            if(!chatBox){

                chatBox = ChatFactory.creatNonDomBox(tagId, true);

                if(!chatBox.getIp() && !!tagObject && !!tagObject.getChatIp()){
                    chatBox.setIp(tagObject.getChatIp());
                    chatBox.setRPort(tagObject.getChatRegisterPort());
                    chatBox.setTitle(tagObject.getTagName());
                }

                chatBox.loadHistoryMessages();

            }

            return chatBox;
        }

        function __updateLastCommunicationTime(tagId, chatBox, tagObject){

            if( !chatBox ){
                chatBox = __getChatBox(tagId);
            }

            chatBox.updateLastCommunicationTime();


            if(!tagObject){
                tagObject = tagChatFactory.getTag(tagId);
            }

            tagChatFactory.updateTagRegisteredTime(tagId, chatBox.lastCommunicationTime);
        }

        function __addMembersToTagObject(aTag, members, addedByUserId){
            for(var tagMemberIndex = 0;tagMemberIndex < members.length; tagMemberIndex++ ){
                var memberObject = members[tagMemberIndex];
                if(!!addedByUserId){
                    memberObject.addedBy = addedByUserId;
                }

                var tagMemberObject = tagChatFactory.createNewTagMember( aTag.getTagId(), memberObject, true );
                if( !tagMemberObject.isRemoved()){
                    aTag.addMember( tagMemberObject );
                }

            }
        }

        function __removeMembersFromTagObject(aTag, tagMembers){
            var hasCurrentUser = false;
            for(var index = 0; index < tagMembers.length; index++){
                var tagMemberObject = aTag.getMember(tagMembers[index].userId);
                if(!!tagMemberObject){
                    hasCurrentUser = tagMemberObject.isCurrentUser();
                    aTag.removeMember(tagMemberObject);
                }
            }
            return hasCurrentUser;
        }

        function __updateMemberStatusInTagObject(aTag, tagMembers){
            for( var index = 0; index < tagMembers.length; index++ ){
                var aTagMember = tagMembers[index];

                if( !!aTag){
                    var tagMemberObject = aTag.getMember(aTagMember.userId);
                    if( !!tagMemberObject){
                        tagMemberObject.setStatus(aTagMember.status);
                    }
                }
            }
        }

        function __doAfterCurrentUserRemovedFromTag(tagId){
            var chatBox = ChatFactory.getBoxByUId(tagId);

            if(!!chatBox){
                ChatFactory.closeChatBox(chatBox.getKey()); //removes corresponding box from boxes stack using userId which is the key
                chatHistoryFactory.removeOpenBox(chatBox.getKey());
            }

            tagChatFactory.unRegisterTag(tagId);
        }

        function __hasReceivedAllBrokenPacket(packetId, totalLength){

            for(var index = 0; index < totalLength; index++){
                var keyIndex = packetId + "_" + index;

                if(!brokenPacketMap[keyIndex]){
                    return false;
                }
            }
            return true;

        }

        function __getCombinedParsedPacketFromTextBrokenPacket(packetId, length){

            var combinedParsedPacketObject = {};

            for(var index = 0; index < length; index++){

                var keyIndex = packetId + "_" + index;
                var aChunkPacket = brokenPacketMap[keyIndex];

                if( index === 0){

                    combinedParsedPacketObject = aChunkPacket;

                }else{

                    combinedParsedPacketObject.message += aChunkPacket.message;
                }
            }

            combinedParsedPacketObject.messageLength = combinedParsedPacketObject.message.length;

            return combinedParsedPacketObject;

        }

        function __clearBrokenPacketsMap(packetId, length){
            for(var index = 0; index < length; index++){
                var keyIndex = packetId + "_" + index;
                delete brokenPacketMap[keyIndex];
                RingLogger.debug('CLEARED KEY {0}'.format(keyIndex), RingLogger.tags.CHAT_BROKEN_CACHE);
            }
        }

        function __mergeTagBrokenPacket(packetId, packetsLength){

            var dataviewArray = [],
                index, totalPacketView, packetType, brokenPacketParser, brokenPacketParsedPacketObject;

            for(index = 0; index < packetsLength; index++){

                var keyIndex = packetId + "_" + index;
                //brokenPacketMap[keyIndex].print_r(true);
                dataviewArray.push(brokenPacketMap[keyIndex]);
            }


            totalPacketView = dataviewArray.joinAsDataView();

            //totalPacketView.print_r(true);
            packetType = totalPacketView.getIntByByte(0, 1);

            RingLogger.print('Inside Broken Packet: Packet Type ', packetType, RingLogger.tags.TAG_CHAT  );

            brokenPacketParsedPacketObject = tagChatPacketProcessor.parseRawPacket(totalPacketView.buffer);
            brokenPacketParsedPacketObject.fromBrokenPacket = true;

            return brokenPacketParsedPacketObject;

        }





    }
})();

(function() {
    'use strict';

    angular
        .module('ringid.tagchat')
        .factory('tagChatUI', tagChatUI);

    tagChatUI.$inject = [
            'ChatFactory',
            'utilsFactory',
            'chatHistoryFactory',
            'TAG_CHAT_GENERAL_CONSTANTS',
            'tagChatFactory',
            'Ringalert'
        ];

    function tagChatUI (

        ChatFactory,
        utilsFactory,
        chatHistoryFactory,
        TAG_CHAT_GENERAL_CONSTANTS,
        tagChatFactory,
        Ringalert

    ) {

        return {
            getTagInfoChangeStatusMessage : _getTagInfoChangeStatusMessage,
            showTagInfoChangeStatusMessage : _showTagInfoChangeStatusMessage,

            showMemberTypeChangeStatusMessage: _showMemberTypeChangeStatusMessage,

            showTagMembersAddStatusMessage : _showTagMembersAddStatusMessage,
            showTagMembersRemoveStatusMessage : _showTagMembersRemoveStatusMessage

        };

        ///////////////////

        function __getMemberStatusValue(memberStatusString){
            var memberStatusValue;

            if( memberStatusString=== 'admin'){
                memberStatusValue = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_ADMIN;
            }else if( memberStatusString === 'member'){
                memberStatusValue = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_MEMBER;
            }else{
                memberStatusValue = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_OWNER;
            }

            return memberStatusValue;
        }

        function __getTagMemberByStatusGroup( changedTagMembers ){

            var statusChangeGroup = {};

            for(var index = 0; index < changedTagMembers.length; index++){
                var aTagMember = changedTagMembers[ index ];

                var statusValue;
                if( angular.isString(aTagMember.status)){
                    statusValue = __getMemberStatusValue(aTagMember.status);
                }else{
                    statusValue = aTagMember.status;
                }

                if(!statusChangeGroup[statusValue]){
                    statusChangeGroup[statusValue] = [];
                }

                statusChangeGroup[statusValue].push(aTagMember);
            }

            return statusChangeGroup;
        }


        function _showMemberTypeChangeStatusMessage(tagId, userId, changedTagMembers, messageDate, packetId){


            //if( !tagObject){
            //    tagObject = tagChatFactory.getTag(tagId);
            //}

            var chatBox = ChatFactory.getBoxByUId(tagId);

            var statusChangeGroup = __getTagMemberByStatusGroup(changedTagMembers);

            var restInfo = {};
            if( !!messageDate ){
                packetId = tagChatFactory.getUUIDPacketId(messageDate, true);
                restInfo['messageDate'] = messageDate;
            }


            var packetIndex = 1;

            for( var statusType in statusChangeGroup){

                if( statusChangeGroup.hasOwnProperty(statusType) ){

                    if(!packetIndex){
                        packetId = packetId + '_'  + packetIndex;
                    }

                    var statusMessageType = "";

                    statusType = parseInt(statusType);

                    if( statusType === TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN){
                        statusMessageType = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_ADMIN;

                    }else if( statusType === TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER ){

                        statusMessageType = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_MEMBER;
                    }else{

                        statusMessageType = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_OWNER;
                    }

                    var tagStatusMessage = tagChatFactory.createTagStatusMessage(
                        packetId,
                        tagId,
                        userId,
                        statusMessageType,
                        statusChangeGroup[statusType],
                        restInfo
                    );

                    if( !tagStatusMessage){ continue; }

                    var serializedStatusMessageObject = tagStatusMessage.serialize();


                    if(!chatBox){

                        chatHistoryFactory.addMessage(serializedStatusMessageObject, tagId);

                    }else{

                        chatBox.pushMessage(serializedStatusMessageObject, userId);
                    }

                }
            }

        }


        function _getTagInfoChangeStatusMessage(tagId, changedTagInfo, tagObject){

            if( !tagObject){
                tagObject = tagChatFactory.getTag(tagId);
            }

            var tagStatusMessageType = 0;

            if( !!tagObject){

                if( ( !!changedTagInfo.tagName && !!changedTagInfo.tagPictureUrl )
                    &&
                    ( tagObject.getTagName() !== changedTagInfo.tagName
                        && tagObject.getPictureUrl() !== changedTagInfo.tagPictureUrl.trim()
                    )
                ){
                    tagStatusMessageType = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_INFO_UPDATED;

                }else{

                    if( !!changedTagInfo.tagName && tagObject.getTagName() !== changedTagInfo.tagName  ){
                        tagStatusMessageType = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_NAME_CHANGE;
                    }

                    if( !!changedTagInfo.tagPictureUrl && tagObject.getPictureUrl() !== changedTagInfo.tagPictureUrl.trim()  ){
                        tagStatusMessageType = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_PICTURE_CHANGE;
                    }
                }

            }

            return tagStatusMessageType;

        }

        function _showTagInfoChangeStatusMessage(tagId, userId, changedTagInfo, packetId, tagObject){

            if( !tagObject){
                tagObject = tagChatFactory.getTag(tagId);
            }

            if( !packetId ){
                packetId = tagChatFactory.getUUIDPacketId();
            }

            var tagStatusMessageType = changedTagInfo.statusMessageType;
            if(!tagStatusMessageType){
                tagStatusMessageType = _getTagInfoChangeStatusMessage(tagId, changedTagInfo, tagObject);
            }

            if(!!changedTagInfo.messageDate){
                packetId = tagChatFactory.getUUIDPacketId(changedTagInfo.messageDate, true);
            }

            if(tagStatusMessageType !== 0){

                var chatBox = ChatFactory.getBoxByUId(tagId);

                var tagStatusMessage = tagChatFactory.createTagStatusMessage(
                    packetId,
                    tagId,
                    userId,
                    tagStatusMessageType,
                    [],
                    changedTagInfo
                );

                if( !tagStatusMessage){ return; }

                var serializedStatusMessageObject = tagStatusMessage.serialize();

                if(!chatBox){

                    chatHistoryFactory.addMessage(serializedStatusMessageObject, tagId);

                }else{

                    chatBox.pushMessage(serializedStatusMessageObject, userId);
                }

            }

        }

        function _showTagMembersAddStatusMessage(tagId, userId, changedMembers, messageDate, packetId, tagObject){

            if( !tagObject){
                tagObject = tagChatFactory.getTag(tagId);
            }

            var chatBox = ChatFactory.getBoxByUId(tagId);

            var changedMembersByStatus = __getTagMemberByStatusGroup(changedMembers);

            var restInfo = {};
            if( !!messageDate ){
                restInfo['messageDate'] = messageDate;
            }

            for( var statusType in changedMembersByStatus) {

                if (changedMembersByStatus.hasOwnProperty(statusType)) {

                    var typePacketId = packetId + '_' + statusType;

                    var statusMessageType = "";

                    statusType = parseInt(statusType);

                    if( statusType === TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN){

                        statusMessageType = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_ADMIN_ADD;

                    }else if( statusType === TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER ){

                        statusMessageType = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_ADD;

                    }else if( statusType === TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.OWNER ){

                        statusMessageType = TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_OWNER;
                    }

                    var tagStatusMessage = tagChatFactory.createTagStatusMessage(
                        typePacketId,
                        tagId,
                        userId,
                        statusMessageType,
                        changedMembersByStatus[statusType],
                        restInfo
                    );

                    if( !tagStatusMessage){
                        continue;
                    }

                    var serializedStatusMessageObject = tagStatusMessage.serialize();

                    if(!chatBox){
                        chatHistoryFactory.addMessage(serializedStatusMessageObject, tagId);

                    }else{
                        chatBox.pushMessage(serializedStatusMessageObject, userId);
                    }

                }
            }

        }


        function _showTagMembersRemoveStatusMessage(tagId, userId, changedMembers, messageDate, packetId, tagObject) {

            if (!tagObject) {
                tagObject = tagChatFactory.getTag(tagId);
            }

            if (!packetId) {
                packetId = tagChatFactory.getUUIDPacketId(messageDate, true);
            }

            var chatBox = ChatFactory.getBoxByUId(tagId);

            for(var index = 0; index < changedMembers.length; index++){
                var tagMember = tagObject.getMember(changedMembers[index].userId);
                if(!!tagMember){
                    changedMembers[index].fullName = tagMember.getName();
                }

            }

            var restInfo = {};
            if( !!messageDate ){
                restInfo['messageDate'] = messageDate;
                packetId = tagChatFactory.getUUIDPacketId(messageDate, true);
            }

            var tagStatusMessage = tagChatFactory.createTagStatusMessage(
                packetId,
                tagId,
                userId,
                TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_DELETE,
                changedMembers,
                restInfo
            );

            if( !tagStatusMessage){ return; }


            var serializedStatusMessageObject = tagStatusMessage.serialize();

            if (!chatBox) {
                chatHistoryFactory.addMessage(serializedStatusMessageObject, tagId);

            } else {
                chatBox.pushMessage(serializedStatusMessageObject, userId);
            }
        }



        

    }
})();

(function() {
    'use strict';

    angular
        .module('ringid.tagchat')
        .factory('tagChatHelper', tagChatHelper);

    tagChatHelper.$inject = [
           'TAG_CHAT_GENERAL_CONSTANTS', 'TAG_CHAT_LANG',
            'Auth',
            'tagChatFactory', 'profileFactory', 'CHAT_GLOBAL_VALUES', 'Storage'

        ];

    function tagChatHelper (

            TAG_CHAT_GENERAL_CONSTANTS, TAG_CHAT_LANG,
            Auth,
            tagChatFactory, profileFactory, CHAT_GLOBAL_VALUES, Storage

    ) {

        return {
            getTagChatStatusMessage : _getTagChatStatusMessage,

            getTagEmptyMessageObject : _getTagEmptyMessageObject,

            getCurrentChatServerTime : _getCurrentChatServerTime,

            hasChatSession : _hasChatSession,

            executeAfterTagRegisterEvent : _executeAfterTagRegisterEvent

        };

        ///////////////////

        function _getLanguageTemplate(selfUser, messageUser, memberShipType){


        }

        function __getMemberType(statusType){
            var memberType;

            if( statusType === TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_ADD){

                memberType = 'member';

            }else if(  statusType === TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_ADMIN_ADD){

                memberType = 'admin';
            }
            return memberType;
        }

        function _getTagChatStatusMessage(chatMessageObject){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                statusMessage = "",
                firstName = chatMessageObject.usersToChange[0],
                allNameJoined = chatMessageObject.usersToChange.slice(1).join(', '),
                totalMinusOne = chatMessageObject.usersToChange.length - 1,
                senderFullName = chatMessageObject.fullName,
                groupNewName = chatMessageObject.tagName,
                tagId,  tagObject,  isSelf;


            tagId = chatMessageObject.tagId;
            tagObject =tagChatFactory.getOrCreateTag(tagId);
            isSelf = currentUser.getKey() === chatMessageObject.userId.toString();

            if(!tagObject){
                RingLogger.warning('No Tag Found to Show Status Message', chatMessageObject, RingLogger.tags.TAG_CHAT);
                return;
            }

            if( !senderFullName){
                var sendMemberObject = tagObject.getMember(chatMessageObject.userId);
                if(!!sendMemberObject){
                    senderFullName = sendMemberObject.getName()
                }else{
                    senderFullName = chatMessageObject.userId;
                }
            }

            var templateParams = {};
            var langTemplate = TAG_CHAT_LANG.STATUS_MESSAGES;
            var langTemplateString, memberType;

            switch (chatMessageObject.statusType){

                case TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_ADD:

                case TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_ADMIN_ADD:

                    memberType = __getMemberType(chatMessageObject.statusType);

                    templateParams.member_name = senderFullName;
                    templateParams.new_member_name = (firstName == currentUser.getName() ) ? 'you' : firstName;
                    templateParams.new_member_type = memberType;
                    templateParams.rest_count = "<a href='javascript:void(0);' title='{0}'>{1} others</a>".format(allNameJoined, totalMinusOne);

                    if( isSelf ){

                        if(!totalMinusOne){
                            langTemplateString = langTemplate.SELF_ADD_MEMBER;
                        }else{
                            langTemplateString = langTemplate.SELF_ADD_MULTIPLE_MEMBER;
                        }

                    }else{

                        if(!totalMinusOne){
                            langTemplateString = langTemplate.OTHER_ADD_MEMBER;
                        }else{
                            langTemplateString = langTemplate.OTHER_ADD_MULTIPLE_MEMBER;
                        }
                    }


                    break;

                case TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_DELETE:

                    templateParams.member_name = senderFullName;
                    templateParams.old_member_name = (firstName == currentUser.getName() ) ? 'you' : firstName;;
                    templateParams.rest_count = "<a href='javascript:void(0);' title='{0}'>{1} others</a>".format(allNameJoined, totalMinusOne);

                    if( isSelf ){

                        if(!totalMinusOne){

                            if( firstName === senderFullName ){
                                langTemplateString = langTemplate.SELF_LEAVE_GROUP;
                            }else{
                                langTemplateString = langTemplate.SELF_REMOVE_MEMBER;
                            }

                        }else{
                            langTemplateString = langTemplate.SELF_REMOVE_MULTIPLE_MEMBER;
                        }

                    }else{

                        if(!totalMinusOne){

                            if( firstName === senderFullName ){
                                langTemplateString = langTemplate.OTHER_LEAVE_GROUP;
                            }else{
                                langTemplateString = langTemplate.OTHER_REMOVE_MEMBER;
                            }

                        }else{
                            langTemplateString = langTemplate.OTHER_REMOVE_MULTIPLE_MEMBER;
                        }
                    }


                    break;

                case TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_LEAVE:

                    templateParams.member_name = senderFullName;

                    if( isSelf ){

                        langTemplateString = langTemplate.SELF_LEAVE_GROUP;

                    }else{

                       langTemplateString = langTemplate.OTHER_LEAVE_GROUP;
                    }



                    break;

                case TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_ADMIN:

                    templateParams.member_name = senderFullName;
                    templateParams.rest_count = "<a href='javascript:void(0);' title='{0}'>{1} others</a>".format(allNameJoined, totalMinusOne);

                    if( firstName !== currentUser.getName() ){
                        templateParams.old_member_name = firstName;
                    }else{
                        templateParams.old_member_name = 'you';
                    }

                    if( isSelf ){

                        if(!totalMinusOne){
                            langTemplateString = langTemplate.SELF_MEMBER_CHANGE_TO_ADMIN;
                        }else{
                            langTemplateString = langTemplate.SELF_MULTIPLE_MEMBER_CHANGE_TO_ADMIN;
                        }

                    }else{

                        if(!totalMinusOne){
                            langTemplateString = langTemplate.OTHER_MEMBER_CHANGE_TO_ADMIN;
                        }else{
                            langTemplateString = langTemplate.OTHER_MULTIPLE_MEMBER_CHANGE_TO_ADMIN;
                        }
                    }


                    break;

                case TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_MEMBER:

                    templateParams.admin_name = senderFullName;

                    if( firstName !== currentUser.getName() ){
                        templateParams.old_admin_name = firstName;
                    }else{
                        templateParams.old_admin_name = 'you';
                    }


                    templateParams.rest_count = "<a href='javascript:void(0);' title='{0}'>{1} others</a>".format(allNameJoined, totalMinusOne);


                    if( isSelf ){

                        if(!totalMinusOne){

                            if( firstName === senderFullName ){
                                langTemplateString = langTemplate.SELF_REMOVED_FROM_ADMIN_BY_SELF;
                            }else{
                                langTemplateString = langTemplate.SELF_ADMIN_CHANGE_TO_MEMBER;
                            }


                        }else{
                            langTemplateString = langTemplate.SELF_MULTIPLE_ADMIN_CHANGE_TO_MEMBER;
                        }

                    }else{

                        if(!totalMinusOne){

                            if( firstName === senderFullName ){
                                langTemplateString = langTemplate.OTHER_REMOVED_FROM_ADMIN_BY_SELF;
                            }else{
                                langTemplateString = langTemplate.OTHER_ADMIN_CHANGE_TO_MEMBER;
                            }

                        }else{
                            langTemplateString = langTemplate.OTHER_MULTIPLE_ADMIN_CHANGE_TO_MEMBER;
                        }
                    }

                    break;

                case TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_OWNER:

                    templateParams.member_name = senderFullName;
                    templateParams.admin_name = firstName;

                    if( firstName !== currentUser.getName() ){

                        langTemplateString = langTemplate.OTHER_USER_ADDED_AS_OWNER;
                    }else{

                        langTemplateString = langTemplate.SELF_USER_ADDED_AS_OWNER;
                    }


                    break;

                case TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_INFO_UPDATED:

                    templateParams.member_name = senderFullName;
                    templateParams.group_name = groupNewName;

                    if( isSelf ){

                        langTemplateString = langTemplate.SELF_UPDATE_GROUP_INFO;

                    }else{

                        langTemplateString = langTemplate.OTHER_UPDATE_GROUP_INFO;
                    }


                    break;

                case TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_NAME_CHANGE:

                    templateParams.member_name = senderFullName;
                    templateParams.group_name = groupNewName;

                    if( isSelf ){

                        langTemplateString = langTemplate.SELF_RENAME_GROUP;

                    }else{

                        langTemplateString = langTemplate.OTHER_RENAME_GROUP;
                    }

                    break;

                case TAG_CHAT_GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_PICTURE_CHANGE:

                    templateParams.member_name = senderFullName;
                    templateParams.group_name = groupNewName;

                    if( isSelf ){

                        langTemplateString = langTemplate.SELF_CHANGE_GROUP_PIC;

                    }else{

                        langTemplateString = langTemplate.OTHER_CHANGE_GROUP_PIC;
                    }

                    break;

            }

            if(!!langTemplateString){
                statusMessage = langTemplateString.supplant(templateParams);
            }

            return statusMessage;

        }

        function _getTagEmptyMessageObject(tagId){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey();

            var object = {
                tagId : tagId,
                userId : currentUser.getKey(),
                fullName : currentUser.getName(),
                message : ' ',
                messageDate : new Date().getTime(),
                messageType : TAG_CHAT_GENERAL_CONSTANTS.MESSAGE_TYPES.BLANK_MESSAGE,
                packetId : tagChatFactory.getUUIDPacketId()
            };

            var tagMessageObject = tagChatFactory.createNewTagMessage(tagId, object);
            return tagMessageObject;

        }

        function _getCurrentChatServerTime(){

            var chatServerTime = CHAT_GLOBAL_VALUES.serverTimeDiff;
            var lcoalTimeInServerTime = new Date().getTime() - chatServerTime;
            return lcoalTimeInServerTime;

        }

        function _hasChatSession(serverReceivedTime){

            var serverTime = _getCurrentChatServerTime();
            return ( serverTime - serverReceivedTime ) < TAG_CHAT_GENERAL_CONSTANTS.ACTUAL_TAG_REGISTER_TIMEOUT;


        }

        function _executeAfterTagRegisterEvent(tagId, func, args, immidiate){

            if(immidiate){
                func.call(null, args);

            }else{

                var eventHandler = function(event) {
                    if(event.data.tagId.toString() === tagId.toString()){
                        func.call(null, args);
                        document.removeEventListener('tagregistered', eventHandler);
                    }
                };

                document.addEventListener('tagregistered', eventHandler);
            }

        }


    }
})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

	angular
		.module('ringid.tagchat')
		.factory('tagChatPacketProcessor', tagChatPacketProcessor);

		tagChatPacketProcessor.$inject = [
			'TAG_CHAT_PACKET_ATTRIBUTE_INFO', 'TAG_CHAT_PACKET_INFO', 'CHAT_PACKET_FORMAT', 'TAG_CHAT_PACKET_TYPE', 'TAG_CHAT_PACKET_ATTRIBUTE',
			'TAG_CHAT_GENERAL_CONSTANTS', 'OFFLINE_PACKET_TYPE', 'FRIEND_CHAT_PACKET_TYPE' ];

		function tagChatPacketProcessor(
			TAG_CHAT_PACKET_ATTRIBUTE_INFO, TAG_CHAT_PACKET_INFO, CHAT_PACKET_FORMAT, TAG_CHAT_PACKET_TYPE, TAG_CHAT_PACKET_ATTRIBUTE,
			TAG_CHAT_GENERAL_CONSTANTS, OFFLINE_PACKET_TYPE, FRIEND_CHAT_PACKET_TYPE ) {


			return {
                isTagPacket : isTagPacket,
				constructPacket : _constructPacket,
				parsePacket : _parsePacket,
				parseRawPacket : _parseRawPacket,
				getPacketSizeByObject : _getPacketSizeByObject,
				splitAndGetMultipleObjects : splitAndGetMultipleObjects,
				splitAndGetBrokenPackets : _splitAndGetBrokenPackets,


				/** Debug **/
				getObjectFromDataView : getObjectFromDataView,
				getIpPortFromPacket : getIpPortFromPacket,
				getPacketType : getPacketType,
				getPacketName : getPacketName,
				getUserId : getUserId,
				getBrokenContainerByPacketType : getBrokenContainerByPacketType,
				getBrokenPacketSplitter : getBrokenPacketSplitter,
                isMultipleBrokenPacket : isMultipleBrokenPacket

			};


			//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

			function isTagPacket( packetType ){
				return !!TAG_CHAT_PACKET_INFO[packetType];
			}

			function getPacketFormat( packetType ){
				return TAG_CHAT_PACKET_INFO[packetType].FORMAT;
			}

			function getPacketName( packetType ){
				return TAG_CHAT_PACKET_INFO[packetType].PACKET_NAME;
			}

			function getAttributeSize( attributeNo ){
				return TAG_CHAT_PACKET_ATTRIBUTE_INFO[attributeNo].SIZE;
			}

			function getRawAttributeSize( packetLength, offset ){
				return packetLength - offset;
			}

			function getRawAttributeSizeFromObject(object, attributeNo){
				var rawAttributeName = getAttributeName(attributeNo);
				return object[rawAttributeName].byteLength;
			}

			function getAttributeName( attributeNo ){
				return TAG_CHAT_PACKET_ATTRIBUTE_INFO[attributeNo].VAR_NAME;
			}

			function getAttributeType( attributeNo ){
				return TAG_CHAT_PACKET_ATTRIBUTE_INFO[attributeNo].VAR_TYPE;
			}

			function isConditionalAttribute( attributeNo ){
				return TAG_CHAT_PACKET_ATTRIBUTE_INFO[attributeNo].CONDITIONAL;
			}

			function getSubObjectContainerName( attributeNo ){
				try{
					return TAG_CHAT_PACKET_ATTRIBUTE_INFO[attributeNo].VAR_CONTAINER_NAME;
				}catch(e){
					RingLogger.warning('invalid `attribute no` for `container name` or `container name` not defined for `attribute no` : ', attributeNo);
					return -1;
				}
			}

			function getAttributeValue(object, attributeNo){
				try{

                    var variableName = TAG_CHAT_PACKET_ATTRIBUTE_INFO[attributeNo].VAR_NAME;

                    if( ~variableName.indexOf('Length') ){
                        var VariableNameWithoutLength = variableName.replace('Length', '');
    					return object[variableName] || object[VariableNameWithoutLength].length;
                    }else{
                        return object[variableName];
                    }

				}catch(e){
					RingLogger.warning('object attribute no not defined : ', attributeNo);
					return '';
				}
			}

			function getDynamicAttributeSize(object, attributeName){
				try{
					return object[attributeName + 'Length'];
				}catch(e){
					RingLogger.warning('object[attribute_name + Length] not set', attributeName);
					return -1
				}
			}

			function isDynamicAttribute(attributeNo){
				return ( getAttributeSize(attributeNo) == TAG_CHAT_GENERAL_CONSTANTS.PACKET_DYNAMIC_ATTRIBUTE );
			}

			function isRawByteAttribute(attributeNo){
				return ( getAttributeSize(attributeNo) == TAG_CHAT_GENERAL_CONSTANTS.PACKET_RAW_BYTE_ATTRIBUTE );
			}

			function getIpPortSize(){

				return TAG_CHAT_GENERAL_CONSTANTS.PACKET_IP_SIZE + TAG_CHAT_GENERAL_CONSTANTS.PACKET_PORT_SIZE;
			}

			function patchObjectForUtf8Encoding(object){

				if(!!object.message ){
					object.message = object.message.utf8Encode();
				}

				if(!!object.fullName){
					object.fullName = object.fullName.utf8Encode().substring(0, 124) + '...';
				}

				return object;
			}

			function getDateViewPacket(packetSize){
				return new DataView(new ArrayBuffer(packetSize));

			}

			function getDataViewByPacket(packet){
				return new DataView(packet);

			}

			function getPacketSize(object, packetType, packetFormat){

				var packetSize = 0;

				var packetFormatLength = packetFormat.length;

				var lastAttributeValue = -1;

				for(var packetFormatIndex = 0; packetFormatIndex < packetFormatLength; packetFormatIndex++ ){

					var anAttributeNoOrSubFormat = packetFormat[packetFormatIndex];

					if( !angular.isArray(anAttributeNoOrSubFormat)){

						var attributeValue = getAttributeValue( object, anAttributeNoOrSubFormat );

						if( isDynamicAttribute(anAttributeNoOrSubFormat) ){

							packetSize += attributeValue.length;

						}else if( isRawByteAttribute(anAttributeNoOrSubFormat) ){

							var attributeNo = anAttributeNoOrSubFormat;
							packetSize += getRawAttributeSizeFromObject( object, attributeNo );

						}else{

							//Not Dynamic Length
							var attributeNo = anAttributeNoOrSubFormat;
							packetSize += getAttributeSize( attributeNo );

							if( isConditionalAttribute( attributeNo )){
								packetFormat = _updatePacketFormat(packetType, packetFormat, packetFormatIndex, attributeValue);
								packetFormatLength = packetFormat.length;
							}
						}

						lastAttributeValue = attributeValue;

					}else{

						//SubFormat Length is placed Just Before the Format. So Get the last attribute size
                        var noOfSubFormatPacket = lastAttributeValue;

                        if( noOfSubFormatPacket > 0 ){

                            var previousAttributeNo = packetFormat[packetFormatIndex - 1];

                            var subObjectContainerName = getSubObjectContainerName( previousAttributeNo );

                            var subObjects = object[subObjectContainerName];

                            for( var subFormatPacketIndex = 0; subFormatPacketIndex < noOfSubFormatPacket; subFormatPacketIndex++ ){

						        var subFormatSize = getPacketSize(subObjects[subFormatPacketIndex], packetType, anAttributeNoOrSubFormat );
						        packetSize += subFormatSize;

                            }

                        }
					}

				}

				return packetSize;

			}



			function setDataViewOffset(dataview, offset, size, value, valueType){

                if(valueType == TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER){

                    value = parseInt(value);

					if(size == TAG_CHAT_GENERAL_CONSTANTS.ONE_BYTE_SIZE){
                        dataview.setUint8(offset, value);

                    }else if(size == TAG_CHAT_GENERAL_CONSTANTS.TWO_BYTE_SIZE){
                        dataview.setUint16(offset, value);

                    }else if(size == TAG_CHAT_GENERAL_CONSTANTS.FOUR_BYTE_SIZE){
                        dataview.setUint32(offset, value);

                    }else if(size == TAG_CHAT_GENERAL_CONSTANTS.EIGHT_BYTE_SIZE){
                        dataview.setUint64(offset, value);
                    }

				}else if(valueType == TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.STRING){

                    for(var valueIndex = 0; valueIndex < value.length; valueIndex++){
						dataview.setUint8(offset, value.charCodeAt(valueIndex));

                        offset += 1;
					}
				}else if(valueType == TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.BYTE){

					for(var valueIndex = 0; valueIndex < size; valueIndex++){
						dataview.setUint8(offset + valueIndex, value.getUint8(valueIndex) );
					}
				}

			}

			function getValueFromDataView(dataview, offset, size, valueType){
				var value = '';

				if(valueType == TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER){

					value = dataview.getIntByByte(offset, size);

				}else if(valueType == TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.STRING){

                    if( size  > 0){
					    value = dataview.getString(offset, size);
                    }
				}else if(valueType == TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.BYTE){

					if( size  > 0){
						value = dataview.copy(offset, size);
					}
				}
				return value;
			}

			function getIpParts(ip){
				var ipArray = [];
				try{
					ipArray = ip.split(".");
				}catch(e){
					RingLogger.warning('Invalid ip provided in object', ip);
				}

				return ipArray;

			}

			function getIpPortFromPacket(packet){
				var ip, port, ipPart = [];
				for(var index = 0; index < 4;index++){
					ipPart.push(getValueFromDataView(packet, index, 1, TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER));
				}

				ip = ipPart.join('.');
				port = getValueFromDataView(packet, 4, 2, TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER);

				return { ip : ip, port : port};

			}

			function getPacketType(packet){
				return getValueFromDataView(packet, 0, 1, TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER);
			}

			function getUserId(packet){
				return getValueFromDataView(packet, 1, 8, TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER);
			}

			function setDataViewWithIpPort(dataview, offset, ip, port){

				var ipArray = getIpParts(ip);

				for(var ipArrayIndex = 0; ipArrayIndex < ipArray.length; ipArrayIndex++ ){

					setDataViewOffset(dataview, offset, TAG_CHAT_GENERAL_CONSTANTS.ONE_BYTE_SIZE, ipArray[ipArrayIndex], TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER );
					offset += TAG_CHAT_GENERAL_CONSTANTS.ONE_BYTE_SIZE;
				}

				setDataViewOffset(dataview, offset, TAG_CHAT_GENERAL_CONSTANTS.TWO_BYTE_SIZE, port, TAG_CHAT_GENERAL_CONSTANTS.ATTRIBUTE_TYPE.INTEGER )
				offset += TAG_CHAT_GENERAL_CONSTANTS.TWO_BYTE_SIZE;

				return offset;

			}

			function setDataViewWithObject(dataview, offset, object, packetType, packetFormat){

				//Each SubFormat Length is Placed Just Before the SubFormat, So we need to record the last value fetched from dataview.
				var lastAttributeValue = -1;

                var offsetStart = offset;

				for(var packetFormatIndex = 0; packetFormatIndex < packetFormat.length; packetFormatIndex++ ){

					var anAttributeNoOrSubFormat = packetFormat[packetFormatIndex];

					if( !angular.isArray(anAttributeNoOrSubFormat)){
						//AttributeNumber
						var attributeNo = anAttributeNoOrSubFormat;

						var attributeValue = getAttributeValue(object, attributeNo);

                        var attributeType = getAttributeType(attributeNo);

						var attributeSize;
						if( isDynamicAttribute(attributeNo)){

							attributeSize = attributeValue.length
						}else if( isRawByteAttribute(attributeNo) ){

							attributeSize = getRawAttributeSizeFromObject( object, attributeNo );
						}else{
							attributeSize = getAttributeSize( attributeNo );
						}

						setDataViewOffset(dataview, offset, attributeSize, attributeValue, attributeType );

						offset += attributeSize;

						lastAttributeValue = attributeValue;

						if( isConditionalAttribute( attributeNo )){
							packetFormat = _updatePacketFormat(packetType, packetFormat, packetFormatIndex, attributeValue);
						}

					}else{

						//Sub-format
						var subPacketFormat = anAttributeNoOrSubFormat;

                        var noOfSubFormatPacket = lastAttributeValue ;

                        if( noOfSubFormatPacket > 0 ){

                            var previousAttributeNo = packetFormat[packetFormatIndex - 1];

                            var subObjectContainerName = getSubObjectContainerName( previousAttributeNo );

                            var subObjects = object[subObjectContainerName];

                            for( var subFormatPacketIndex = 0; subFormatPacketIndex < noOfSubFormatPacket; subFormatPacketIndex++ ){

						        var subFormatSize = setDataViewWithObject(dataview, offset, subObjects[subFormatPacketIndex] , packetType, subPacketFormat );
						        offset += subFormatSize;

                            }

                        }

						//SubFormat Length is placed Just Before the Format. So Get the last attribute size

						//var previousAttributeNo = packetFormat[packetFormatIndex - 1];
                        //
						//var previousAttributeValue = getAttributeValue(object, previousAttributeNo);

					}
				}

				return offset - offsetStart;
			}

			function _constructPacket(object, packetType) {

				//If Object contains Unicode Field, Encode It with `utf8` encoding.
				//object = patchObjectForUtf8Encoding(object);

				var packetFormat = getPacketFormat(packetType);

				var packetSize = getPacketSize(object, packetType, packetFormat) + getIpPortSize();

				if(!packetSize){
					RingLogger.error('Unable to define Packet Size, Check Payload', object, 'packetType', packetType, RingLogger.tags.TAG_CHAT );
					return false;
				}

				if(packetSize > 512){
					RingLogger.warn('Packet Size > 512', object, 'packetType', packetType, 'packetSize', packetSize, RingLogger.tags.TAG_CHAT );
				}

				var dataViewPacket = getDateViewPacket( packetSize );

				var dataViewOffsetIndex = 0;

				dataViewOffsetIndex = setDataViewWithIpPort( dataViewPacket, dataViewOffsetIndex, object.ip, object.port);

				dataViewOffsetIndex = setDataViewWithObject( dataViewPacket, dataViewOffsetIndex, object, packetType, packetFormat);

				return dataViewPacket;
			}

			function _updatePacketFormat(packetType, packetFormat, packetFormatIndex, attributeValue ){
				if( packetType == TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION ){
					packetFormat = angular.copy(packetFormat);

					switch( attributeValue ) {

						case TAG_CHAT_GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_RENAME:
							packetFormat = packetFormat.slice(0, -2);
							break;
						case TAG_CHAT_GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_URL_RENAME:
							packetFormat.splice(packetFormatIndex + 1, 2);
							break;
					}
				}
				return packetFormat;
			}

			function getObjectFromDataView(dataview, dataViewOffsetIndex, object, packetType, packetFormat){

				//Each SubFormat Length is Placed Just Before the SubFormat, So we need to record the last value fetched from dataview.
				var lastAttributeValue = -1;
                var dataViewOffsetStartIndex = dataViewOffsetIndex;

				var anAttributeNoOrSubFormat, attributeNo,
					attributeName, attributeType,
					attributeSize, attributeValue,
					subPacketFormat, subFormatContainer,
					previousAttributeNo, subObjectContainerName,
					noOfSubFormatPacket, subFormatPacketIndex,
					subFormatSize, subFormatObject;

				for(var packetFormatIndex = 0; packetFormatIndex < packetFormat.length; packetFormatIndex++){

					anAttributeNoOrSubFormat = packetFormat[packetFormatIndex];

					if( !angular.isArray(anAttributeNoOrSubFormat)){

						//AttributeNumber
						attributeNo = anAttributeNoOrSubFormat;

						attributeName = getAttributeName(attributeNo);

						if( dataViewOffsetIndex >= dataview.byteLength ){
							object[attributeName] = '';

						}else{


							attributeType = getAttributeType(attributeNo);
							attributeSize =
								isDynamicAttribute(attributeNo) ?
									getDynamicAttributeSize(object, attributeName) :
									isRawByteAttribute(attributeNo) ?
										getRawAttributeSize(dataview.byteLength, dataViewOffsetIndex) :
										//dataview.byteLength - dataViewOffsetIndex  :
										getAttributeSize( attributeNo );


							attributeValue = getValueFromDataView(dataview, dataViewOffsetIndex, attributeSize, attributeType );

							dataViewOffsetIndex += attributeSize;

							object[attributeName] = attributeValue;


							lastAttributeValue = attributeValue;

						}

						if( isConditionalAttribute( attributeNo )){
							packetFormat = _updatePacketFormat(packetType, packetFormat, packetFormatIndex, attributeValue);
						}


					}else{

						//Sub-format


						subPacketFormat = anAttributeNoOrSubFormat;

						subFormatContainer = [];

                        previousAttributeNo = packetFormat[packetFormatIndex - 1];

						subObjectContainerName = getSubObjectContainerName( previousAttributeNo );

                        noOfSubFormatPacket = lastAttributeValue;

                        if( noOfSubFormatPacket > 0 ){

                            for( subFormatPacketIndex = 0; subFormatPacketIndex < noOfSubFormatPacket; subFormatPacketIndex++ ){

                                subFormatObject = {};

                                subFormatSize = getObjectFromDataView(dataview, dataViewOffsetIndex, subFormatObject, packetType, subPacketFormat );
                                dataViewOffsetIndex += subFormatSize;

                                subFormatContainer.push(subFormatObject);

                            }

                        }

						object[subObjectContainerName] = subFormatContainer;


					}


				}

				return dataViewOffsetIndex - dataViewOffsetStartIndex;
			}

			function _postParseProcess(object){
				if(object.packetType == TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT){
					object.originalPacketId = object.packetId;

					try{
						var packetIdSequenceNo = object.packetId.split('_');
						object.packetId = packetIdSequenceNo[0];
						object.sequenceNo = packetIdSequenceNo[1];

					}catch(e){
						object.sequenceNo = 0;
					}

				}
				return object;
			}

			function _parsePacket(packet, packetType, packetFormat){

				if(!packetFormat){
					packetFormat = getPacketFormat( packetType );
				}

				var dataView = getDataViewByPacket( packet );

				var dataViewOffsetIndex = 0;

				var parsedObject = {};

				var parsedObjectSize = getObjectFromDataView(dataView, dataViewOffsetIndex, parsedObject, packetType, packetFormat);

				parsedObject = _postParseProcess(parsedObject);

				return parsedObject;

			}

            function getChatPacketTypeObject(typeNumber){
                var packetTypeObj = {};

                angular.forEach(CHAT_PACKET_FORMAT, function(aPacketTypeObj, packetTypeName){
                    if( aPacketTypeObj.PACKET_TYPE == typeNumber ){
                        packetTypeObj = aPacketTypeObj;
                    }
                });

                return  packetTypeObj;
            }

			function _parseRawPacket( packetData ) {
				//todo need to optimize the double dataView Construction
				var dataView = new DataView(packetData);
				var packetType = dataView.getIntByByte(0, 1);

				if( isTagPacket(packetType) ){
                    //console.log(getChatPacketTypeObject(packetType));
                    // try{
						//var rabbiParsed = PacketDataParse.parsePacket(packetData, packetType, getChatPacketTypeObject(packetType).FORMAT )
						//console.log(rabbiParsed);
					 //}catch(e){
						// console.error(e);
					 //}
                     try{
                         return  _parsePacket(packetData, packetType);
                     }catch(e){
						 dataView.print_r(true);
                         console.error('TagChat Packet Parse Error', e, ' PacketType ', packetType);
                     }

				}else{
                    //return {};
                    //return PacketDataParse.parsePacket(packetData, packetType, getChatPacketTypeObject(packetType).FORMAT )
				}

			}

			function _getPacketSizeByObject( object, packetType ){
				var packetFormat = getPacketFormat(packetType);
				return getPacketSize(object, packetType, packetFormat);
			}

			function _getSplittedTagMemberObjects(requestObject, packetType){
				/** todo, generalize please **/

				var objects = [];

				var packetFormat = getPacketFormat(packetType);

				var leftRequestObject = angular.copy(requestObject);
				var rightRequestObject = angular.copy(requestObject);

				var length = requestObject.tagMembers.length;
				leftRequestObject.tagMembers = requestObject.tagMembers.slice(0, length/2);
				rightRequestObject.tagMembers = requestObject.tagMembers.slice(length/2);

				var leftRequestObjectSize = getPacketSize(leftRequestObject, packetType, packetFormat);
				var rightRequestObjectSize = getPacketSize(rightRequestObject, packetType, packetFormat);

				if(leftRequestObjectSize > TAG_CHAT_GENERAL_CONSTANTS.PACKET_MAX_SIZE ){
					objects.concat(_getSplittedTagMemberObjects(leftRequestObject, packetType));
				}else{
					objects.push(leftRequestObject);
				}

				if(rightRequestObjectSize > TAG_CHAT_GENERAL_CONSTANTS.PACKET_MAX_SIZE ){
					objects.concat(_getSplittedTagMemberObjects(rightRequestObjectSize, packetType));
				}else{
					objects.push(rightRequestObject);
				}

				return objects;

			}


			function _sliceObjectValue(objectValue, isArray, start, end){
				if( isArray){
					return objectValue.slice(start, end);
				}else{
					return objectValue.substring(start, end);
				}
			}

			function _getSplittedRequestObject(requestObject, packetType, keyToSplit, splittedObjects){

				var packetFormat = getPacketFormat(packetType);

                var requestObjectSize = getPacketSize(requestObject, packetType, packetFormat);

                var isKeyValueArray = angular.isArray(requestObject[keyToSplit]) ? true : false;

				if(requestObjectSize > TAG_CHAT_GENERAL_CONSTANTS.PACKET_MAX_SIZE  ){

                    var length = requestObject[keyToSplit].length;

                    var leftRequestObject = angular.copy(requestObject);
                    var rightRequestObject = angular.copy(requestObject);

					leftRequestObject[keyToSplit] = _sliceObjectValue(requestObject[keyToSplit], isKeyValueArray, 0, length/2);
					rightRequestObject[keyToSplit] = _sliceObjectValue(requestObject[keyToSplit], isKeyValueArray, length/2, length);

					var leftRequestObjectSize = getPacketSize(leftRequestObject, packetType, packetFormat);
					var rightRequestObjectSize = getPacketSize(rightRequestObject, packetType, packetFormat);

					if(leftRequestObjectSize > TAG_CHAT_GENERAL_CONSTANTS.PACKET_MAX_SIZE ){
						splittedObjects.concat(_getSplittedRequestObject(leftRequestObject, packetType, keyToSplit, splittedObjects));
					}else{
						splittedObjects.push(leftRequestObject);
					}

					if(rightRequestObjectSize > TAG_CHAT_GENERAL_CONSTANTS.PACKET_MAX_SIZE ){
						splittedObjects.concat(_getSplittedRequestObject(rightRequestObject, packetType, keyToSplit, splittedObjects));
					}else{
						splittedObjects.push(rightRequestObject);
					}

				}else{
					splittedObjects.push(requestObject);
				}

				return splittedObjects;

			}

			function splitAndGetMultipleObjects(requestObject, packetType){

				//var noOfObjects = packetSize / TAG_CHAT_GENERAL_CONSTANTS.PACKET_MAX_SIZE;
				var keyToSplit = getBrokenContainerByPacketType(packetType);
				return _getSplittedRequestObject(requestObject, packetType, keyToSplit, []);

			}

			function _splitAndGetBrokenPackets(packet ){

				var packetSize = packet.byteLength,
					packetMaxSize = TAG_CHAT_GENERAL_CONSTANTS.PACKET_MAX_SIZE,
					noOfPacket = Math.floor(packetSize/packetMaxSize),
					packets = [],
					index,
					startOffset = 0,
					lastPacketSize,
					aBrokenPacket;


				for(index = 0; index < noOfPacket; index++){

					aBrokenPacket = packet.copy(startOffset, packetMaxSize);
					packets.push( aBrokenPacket);

					startOffset += TAG_CHAT_GENERAL_CONSTANTS.PACKET_MAX_SIZE;

				}

				lastPacketSize = packetSize - startOffset;
				if( lastPacketSize > 0){

					aBrokenPacket = packet.copy(startOffset, lastPacketSize);
					packets.push( aBrokenPacket);
				}

				return packets;

			}

			function getBrokenContainerByPacketType(packetType){
				switch (packetType){
					case OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET:
					case TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET:

						return 'bytes';

					case FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG:
					case FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG_EDIT:
					case FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG:
					case FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG_EDIT:

					case TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG:
					case TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_EDIT:
					case TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG:
					case TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG_EDIT:

						return 'message';

                    case FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN:

                        return 'messages';


					case OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION:
					case OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION:

						return 'packets'


				}
			}

			function getBrokenPacketSplitter(brokenPacketType, packetType, object, packet){
				switch (brokenPacketType){
					case OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET:
					case TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET:

						return function(){
							return _splitAndGetBrokenPackets(packet);
						};

					case FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG:
					case FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG_EDIT:
					case FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG:
					case FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG_EDIT:

					case TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG:
					case TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG_EDIT:
                    case FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN:
					case OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION:
					case OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION:

						return function(){
							return splitAndGetMultipleObjects(object, packetType);
						}

				}
			}

            function isMultipleBrokenPacket(packetType){
                switch (packetType){

					case OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION:
					case OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION:
                    case FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN:
                        return true;

                }
                return false;
            }




		}

})();


(function(){
    'use strict';
    var tagChatApp;

    try {
        tagChatApp = angular.module('ringid.tagchat');
    } catch (e) {

    }

    tagChatApp.factory('chatPacketResender', chatPacketResender);

    chatPacketResender.$inject = [ 'utilsFactory',  'globalSocketFactory',
        'tagChatFactory', 'tagChatApiService',
        'TAG_CHAT_GENERAL_CONSTANTS',
        'tagChatExceptions'
    ];

    function chatPacketResender( utilsFactory,  globalSocketFactory,
                                 tagChatFactory, tagChatApiService,
                                 TAG_CHAT_GENERAL_CONSTANTS,
                                 tagChatExceptions){

        var callXTimeAfterYIntervalStopOnSuccess = utilsFactory.callXTimeAfterYIntervalStopOnSuccess;
        var hasReceivedConfirmation = tagChatFactory.hasReceivedConfirmation;
        var ChatPacketResenderException = tagChatExceptions.ChatPacketException;

        function BaseChatPacketResender(){

            this._config = this._config || {};
            this._requiredConfigs = this._requiredConfigs || ['packetType'];
            this._callbacks = this._callbacks || {};

            this.init = function() {

                this._config = angular.extend(this._config, {
                    packetType: 0,
                    packet: '',
                    packetId: 0,
                    sequenceNo : 0,
                    packetObject: {},
                    sendFailed: false,
                    sendSuccess: false,
                    isBroken: false,
                    isOffline: false,
                    terminated: false,
                    ignoreConfirmation : false
                });
            };

            this.initCallbacks = function(){
                this._callbacks = angular.extend(this._callbacks, {
                    _send : this.onSend,
                    _successCheck : this.onSuccessCheck,
                    _failure : this.onFailure,
                    _success : this.onSuccess
                });
            };

            this.init.call(this);
            this.initCallbacks.call(this);

        }

        BaseChatPacketResender.prototype = {

            preProcess : function(){
                if( !this.getPacket() && this.hasPacketObject()){
                    this.setPacketType(this.getPacketObject().packetType);
                }
            },

            on : function(event, callback){
                this._callbacks[event] = callback;
            },

            onSend : function(){},

            onSuccessCheck : function(currentExecutionCount){
                return hasReceivedConfirmation(this.getPacketId(), this.getPacketType(), this.getSequenceNo());
            },

            onFailure : function(){},

            onSuccess : function(){},

            setPacketType : function(packetType){
                this._config.packetType = packetType;
            },

            getPacketType : function(){
                return this._config.packetType;
            },

            hasPacketType : function(){
              return !!this._config.packetType;
            },

            setSequenceNo : function(sequenceNo){
                this._config.sequenceNo = sequenceNo;
            },

            getSequenceNo : function(){
                return this._config.sequenceNo;
            },

            hasSequenceNo : function(){
                return !!this._config.sequenceNo;
            },

            hasPacket : function(){
                return this._config.packet != '';
            },

            getPacket : function(){
                return this._config.packet;
            },

            setPacket : function(packet){
                this._config.packet = packet;
            },

            setPacketObject : function(object){
                this._config.packetObject = object;
            },

            getPacketObject : function(){
                return this._config.packetObject;
            },

            hasPacketObject : function(){
                return Object.keys(this._config.packetObject).length > 0;
            },

            setPacketId : function(packetId){
                this._config.packetId = packetId;
            },

            hasPacketId : function(){
                return this._config.packetId != 0;
            },

            getPacketId : function(){
                return this._config.packetId;
            },

            setIgnoreConfirmation : function(ignoreConfirmation){
                this._config.ignoreConfirmation = ignoreConfirmation;
            },

            getIgnoreConfirmation : function(){
                return this._config.ignoreConfirmation;
            },

            isBroken : function(isBroken){
                if(typeof(isBroken) != "undefined"){
                    this._config.isBroken = isBroken;
                }

                return this._config.isBroken;

            },

            isOffline : function(isOffline){
                if(typeof(isOffline) != "undefined"){
                    this._config.isOffline = isOffline;
                }

                return this._config.isOffline;

            },

            isTerminated : function(terminated){
                if(typeof(terminated) != "undefined"){
                    this._config.terminated = terminated;
                }

                return this._config.terminated;

            },

            stop : function(){
                this._config.terminated = true;
            },

            isSendSuccess : function(sendSuccess){
                if(typeof(sendSuccess) != "undefined"){
                    this._config.sendSuccess = sendSuccess;
                }
                return this._config.sendSuccess;

            },

            validateConfig : function(){

                if( !this._config.packet && !this._config.packetObject){
                    throw ChatPacketResenderException('packet or objectToSend needs to be defined');
                }

                if( this._config.packet && !this._config.packetType){
                    throw ChatPacketResenderException('sending raw packet needs packetType to be given');
                }

                var index;
                for(index = 0; index < this._requiredConfigs.length; index++ ){
                    var key = this._requiredConfigs[index];
                    if( !this._config[key]){
                        throw ChatPacketResenderException(key + ' Not Defined');
                    }
                }

            },

            isCallbackDefined : function(name){
                return !!this._callbacks[name];
            },

            getCallback : function( callbackName){
                return this._callbacks[callbackName];
            },

            getDefaultCallback : function(callbackName){
                return this._callbacks['_' + callbackName];
            },

            getResponseObject : function(success, tryCount, timeout, terminated){

                return {
                    sucs : success,
                    tryCount : tryCount,
                    timeout : !!timeout,
                    terminated : !!terminated
                }
            },

            callSuccessCallback : function(currentExecutionCount){

                if( !this.isCallbackDefined('success') ){
                    this.getDefaultCallback('success').call(this,
                        this.getResponseObject(true, currentExecutionCount)
                    );


                }else{
                    this.getCallback('success').call(this,
                        this.getResponseObject(true, currentExecutionCount)
                    );
                }

            },
            callFailureCallback : function(){
                if( !this.isCallbackDefined('failure') ){
                    this.getDefaultCallback('failure').call(this,
                        this.getResponseObject(false, TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT, false, this.isTerminated() )
                    );

                }else{
                    this.getCallback('failure').call(null,
                        this.getResponseObject(false, TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT, false, this.isTerminated() )
                    );
                }
            }

        };

        function ChatPacketResender(){

            var self = this;

            self.onSend = function(){
                var packet, packets;

                if(!self.hasPacket()){
                    if( self.hasPacketObject() ){
                        packet = tagChatApiService.getPacket(self.getPacketObject(), self.getPacketType());
                        self.setPacket(packet);

                        if( !self.hasPacketId() && !!self.getPacketObject().packetId ){
                            self.setPacketId(self.getPacketObject().packetId);
                        }
                    }
                }else{
                    if( !self.hasPacketId() ){
                        self.setPacketId( tagChatFactory.getUUIDPacketId() );
                    }
                }

                if( self.hasPacket() ){

                    if(self.getPacketObject()){
                        tagChatApiService.logRequestedPacketInfo(self.getPacketType(), self.getPacketObject());
                    }else{
                        RingLogger.infoblack('Raw Packet ', self.getPacket(), RingLogger.tags.TAG_CHAT_REQUEST);
                    }

                    globalSocketFactory.send(self.getPacket());
                }else{
                    RingLogger.error('Skipped empty packet send', self.getPacketObject(), RingLogger.tags.TAG_CHAT);
                }

            };

            self.start = function(){

                self.preProcess();

                self.validateConfig();

                var hasReceivedSuccess = false;

                callXTimeAfterYIntervalStopOnSuccess(
                    function(){

                        if(self.isCallbackDefined('beforeSend')){
                            self.getCallback('beforeSend').call();
                        }

                        if( !self.isCallbackDefined('send') ){
                            return self.getDefaultCallback('send').call(self);
                        }else{
                            return self.getCallback('send').call();
                        }
                    },
                    function (currentExecutionCount) {


                        if( self.getIgnoreConfirmation() ){
                            return false;

                        }else if( !self.isTerminated() ){

                            if(self.isCallbackDefined('beforeSuccessCheck')){
                                self.getCallback('beforeSuccessCheck').call(null, currentExecutionCount);
                            }

                            if( !self.isCallbackDefined('successCheck') ){
                                hasReceivedSuccess = self.getDefaultCallback('successCheck').call(self, currentExecutionCount);
                            }else{
                                hasReceivedSuccess = self.getCallback('successCheck').call(null, currentExecutionCount);
                            }

                            if(self.isCallbackDefined('afterSuccessCheck')){
                                self.getCallback('afterSuccessCheck').call(null, currentExecutionCount, hasReceivedSuccess);
                            }

                            self.isSendSuccess(hasReceivedSuccess);
                        }

                        if( !!self.isSendSuccess() ){
                            self.callSuccessCallback(currentExecutionCount);
                        }

                        return self.isTerminated() || self.isSendSuccess();

                    },
                    function(){

                        if( self.getIgnoreConfirmation() ){

                            self.isSendSuccess(true);
                            self.callSuccessCallback();

                        }else{
                            self.isSendSuccess(false);
                            self.callFailureCallback();
                        }

                    },
                    TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT,
                    TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY
                );

                //setTimeout(function(){
                //
                //    if( !self.isSendSuccess() ){
                //        if( !self.isCallbackDefined('failure') ){
                //            self.getDefaultCallback('failure').call(self,
                //                self.getResponseObject(false, TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT, true, self.isTerminated() )
                //            );
                //
                //        }else{
                //            self.getCallback('failure').call(null,
                //                self.getResponseObject(false, TAG_CHAT_GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT, true, self.isTerminated() )
                //            );
                //        }
                //    }
                //
                //}, TAG_CHAT_GENERAL_CONSTANTS.REQUEST_TIMEOUT);
            };

            BaseChatPacketResender.call(this);
        }

        ChatPacketResender.prototype = BaseChatPacketResender.prototype;

        function ChatPacketBrokenResender(){

            var self = this;

            this._config = {
                packetObjects : [],
                confirmations : {}
            };

            this.setPacketObjects = function(packetObjects){
                self._config.packetObjects = packetObjects;
            };

            this.getPacketObjects = function(){
                return self._config.packetObjects;
            };

            this.hasPacketObjects = function(){
                return self._config.packetObjects.length > 0;
            };

            this.onSuccessCheck = function(currentExecutionCount){
                return ( Object.keys(self._config.confirmations).length === self._config.packetObjects.length );
            };

            this._checkForSuccess = function(currentExecutionCount){
                var hasBrokenSuccess = self.getDefaultCallback('successCheck').call(self, currentExecutionCount);
                self.isSendSuccess(hasBrokenSuccess);
                return hasBrokenSuccess;
            };


            this.addBrokenConfirmation = function(packetId, sequenceNo){
                console.debug('BROKEN CONFIRMATIONS ', self._config.confirmations);
                self._config.confirmations[packetId + '_' + sequenceNo] = true;
            };

            this.onBrokenSuccess = function(response, packetObject){
                self.addBrokenConfirmation(packetObject.packetId, packetObject.sequenceNo);
                if( self._checkForSuccess(response.tryCount) ){
                    self.callSuccessCallback(response.tryCount);
                }

            };

            this.onBrokenFailure = function(response, packetObject){
                if( !self.isTerminated() && self._checkForSuccess(response.tryCount) ){
                    self.callSuccessCallback(response.tryCount);
                }else{
                    if( !self.isTerminated() ){
                        self.isTerminated(true);
                        self.callFailureCallback();
                    }
                }
            };

            BaseChatPacketResender.call(this);

            this.setPacketObjects = function(packetObjects){
                self._config.packetObjects = packetObjects;
            };


            function _sendABrokenPacket(packetObject){

                var requestObject, aChatResender, hasBrokenSuccess;

                try{

                    aChatResender = new ChatPacketResender();
                    aChatResender.setPacketType(packetObject['packetType']);
                    aChatResender.setSequenceNo(packetObject['sequenceNo']);
                    aChatResender.setPacketObject(packetObject);

                    aChatResender.on('afterSuccessCheck', function(currentExecutionCount, hasSuccess){

                        if(self.isTerminated()){
                            aChatResender.isTerminated(true);
                        }

                    });

                    aChatResender.on('success', function(response){
                        if(!packetObject.sequenceNo){
                            packetObject.sequenceNo = 0;
                        }
                        console.debug('BROKEN SUCCESS {0}/{1}'.format(packetObject.sequenceNo+1, packetObject.packetsLength), response, packetObject);
                        if(response.sucs){
                            self.onBrokenSuccess(response, packetObject);
                        }

                    });
                    aChatResender.on('failure', function(response){
                        if(!packetObject.sequenceNo){
                            packetObject.sequenceNo = 0;
                        }
                        console.debug('BROKEN FAILURE {0}/{1}'.format(packetObject.sequenceNo+1, packetObject.packetsLength), response, packetObject);
                        self.onBrokenFailure(response, packetObject);
                    });

                    aChatResender.start();



                }catch(e){
                    RingLogger.print('A single broken packet send exception ', e, RingLogger.tags.TAG_CHAT);

                }


            }


            this.start = function(){

                var packetObjects;
                if( !self.hasPacketObjects() ){

                    self.preProcess();
                    self.validateConfig();

                    packetObjects = tagChatApiService.getBrokenPacketObjects(self.getBrokenPacketType(), self.getPacket(), self.getPacketObject());
                    self.setPacketObjects(packetObjects);

                }else{

                    packetObjects = self.getPacketObjects();
                }

                var noOfPacketsToSend = packetObjects.length;

                for(var index = 0; index < noOfPacketsToSend; index++){
                    _sendABrokenPacket(packetObjects[index]);
                }

            };

        }

        ChatPacketBrokenResender.prototype = BaseChatPacketResender.prototype;



        function ChatPacketSender(){

            var self = this;

            this._config = {
                brokenPacketType : 0,
                packet: '',
                packetObject: {},
                packetObjects : [],
                ignoreConfirmation : false

            };

            this.setPacket = function(packet){
                self._config.packet = packet;
            };

            this.getPacket = function(){
                return self._config.packet;
            };

            this.hasPacket = function(){
                return !!self.getPacket();
            };

            this.setBrokenPacketType = function(brokenPacketType){
                self._config.brokenPacketType = brokenPacketType;
            };

            this.getBrokenPacketType = function(){
                return self._config.brokenPacketType;
            };

            this.hasBrokenPacketType = function(){
                return !!self.getBrokenPacketType();
            };


            this.setPacketObject = function(packetObject){
                self._config.packetObject = packetObject;
            };

            this.setIgnoreConfirmation = function(ignoreConfirmation){
                self._config.ignoreConfirmation = ignoreConfirmation;
            };

            this.getIgnoreConfirmation = function(){
                return self._config.ignoreConfirmation;
            };

            this.getPacketObject = function(){
               return self._config.packetObject;
            };

            this.hasPacketObject = function(){
                return Object.keys(self._config.packetObject).length > 0
            };

            this.setPacketObjects = function(packetObjects){
                self._config.packetObjects = packetObjects;
            };

            this.getPacketObjects = function(packetObjects){
                return self._config.packetObjects;
            };

            this.hasPacketObjects = function(){
                return self._config.packetObjects.length > 0;
            };

            function _getSenderInstance(isBroken){
                return isBroken ? new ChatPacketBrokenResender() : new ChatPacketResender();
            }

            this._validate = function(isBroken){
                if(isBroken && !self.getBrokenPacketType()){
                    throw ChatPacketResenderException('Broken PacketType needs to be set for When Broken Packet is Set.');
                }
            };

            this.getInstance = function(isBroken){
                var senderInstance, packetObjects;

                self._validate(isBroken);

                packetObjects = tagChatApiService.getBrokenPacketObjects(self.getBrokenPacketType(), self.getPacket(), self.getPacketObject());

                if( !packetObjects.length ){
                    throw ChatPacketResenderException('Broken Packet Build Error');
                }

                if( !!isBroken || packetObjects.length > 1){
                    self.setPacketObjects(packetObjects);
                    isBroken = true;
                }

                senderInstance = _getSenderInstance(isBroken);
                senderInstance.setIgnoreConfirmation(self.getIgnoreConfirmation());

                if( self.hasPacket() && !isBroken ){
                    senderInstance.setPacket(self.getPacket());

                }else{
                    if( self.hasPacketObjects() ){
                        senderInstance.setPacketObjects(self.getPacketObjects());
                    }else{
                        senderInstance.setPacketObject(self.getPacketObject());
                    }
                    senderInstance.setPacketType(self.getBrokenPacketType());

                }
                return senderInstance;
            }
        }

        return {
            ChatPacketResender : ChatPacketResender,
            ChatPacketBrokenResender : ChatPacketBrokenResender,
            ChatPacketSender : ChatPacketSender
        };

    }



})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.tagchat')
        .controller('TagChatController', TagChatController);

    TagChatController.$inject = [
        '$scope', '$templateCache', '$timeout', 'settings',
        '$$connector',
        'Auth', 'Ringalert',
        'CHAT_GLOBAL_VALUES',
        'rgDropdownService', 'ChatFactory', 'utilsFactory', 'tagChatStorage',
        'friendsFactory', 'tagChatFactory', 'tagChatManager', 'tagChatSubscriber',
        'tagOfflineChatManager', 'ChatHelper', 'SystemEvents'];

    function TagChatController($scope, $templateCache, $timeout, settings,
                               $$connector,
                               Auth, Ringalert,
                               CHAT_GLOBAL_VALUES,
                               rgDropdownService, ChatFactory, utilsFactory, tagChatStorage,
                               friendsFactory, tagChatFactory, tagChatManager, tagChatSubscriber,
                               tagOfflineChatManager, ChatHelper, SystemEvents) {

        var viewModel = this;

        viewModel.memberDDHtml = 'pages/partials/tag-chat/member-actions-dropdown.html';//$templateCache.get('tag-chat-dropdown.html');
        viewModel.memberDDActions = memberDDActions;
        viewModel.getTagDDControl = getTagDDControl;

        viewModel.ready = false;

        viewModel.groupFilter = "groups";

        try {
            viewModel.debug = RingLogger.conditions[RingLogger.tags.TAG_CHAT];
        } catch (e) {
            viewModel.debug = false;
        }


        var currentUser = Auth.currentUser();


        viewModel.isCurrentUserOwner = function (tagObj) {
            return tagObj.getOwnerUserId() == currentUser.getKey();
        };

        viewModel.isCurrentUserMember = function (tagObj) {
            return tagObj.isUserMember(currentUser.getKey());
        };

        tagChatManager.subscribeForAuthUpdate();

        //tagChatFactory.startProcessingRequest = true;


        viewModel.allTags = tagChatFactory.getTags();

        viewModel.changeGroupFilter = function (filterName) {
            viewModel.groupFilter = filterName || 'groups';
        };

        viewModel.showGroupLogs = function (filterName) {
            return viewModel.groupFilter === 'logs';
        };

        viewModel.showGroups = function (filterName) {
            return viewModel.groupFilter === 'groups';
        };

        viewModel.getTagPictureImageByMemberAvatars = getTagPictureImageByMemberAvatars;
        viewModel.getLastMessageOnATag = getLastMessageOnATag;

        viewModel.imageBase = settings.imBase;

        viewModel.getUserAvatar = function (user) {
            if (!user || !user.avatar()) {
                return 'images/prof.png';
            } else {
                return user.avatar();
            }
        };

        viewModel.getLastMessageText = function (boxMessageObject) {

            if (boxMessageObject.messageType === 2) {
                return boxMessageObject.text;
            } else if ([6, 7, 8, 9].indexOf(boxMessageObject.messageType) !== -1) {
                return 'Media';
            }

            return false;
        };


        var restoreLocalData = function () {

            var packets = tagChatStorage.getAllPackets();
            var keys = Object.keys(packets);
            for (var index = 0; index < keys.length; index++) {
                if (packets.hasOwnProperty(keys[index])) {
                    var aPacket = packets[keys[index]];
                    tagChatSubscriber.processPacketData(utilsFactory.string2ArrayBuffer(aPacket));
                }
            }
        };


        $scope.$on('chatDataReceived', function (event, dataObj) {
            tagChatSubscriber.processUpdates(event, dataObj);

            //if(!$scope.$$phase){
            //	$scope.$digest();
            //}

        });

        //$scope.$watch(function(){
        //    return tagChatFactory.getTags().length();
        //}, function(){
        //    viewModel.allTags = tagChatFactory.getTags();
        //
        //    utilsFactory.safeDigest($scope);
        //});

        $scope.shouldShow = function () {
            return viewModel.ready;
        };

        //utilsFactory.onCustomEvent('tagChatLogMessageUpdated', function(){
        //	tagChatStorage.init();
        //});


        //document.addEventListener('taglistupdated', function(){
        //	if(!$scope.$$phase){
        //		$scope.$digest();
        //	}
        //	//viewModel.allTags = tagChatFactory.getTags();
        //});

        utilsFactory.onCustomEvent('MY_TAG_LIST_RECEIVED', function(){
            viewModel.ready = true;
            viewModel.allTags = tagChatFactory.getTags();
            utilsFactory.safeDigest($scope);
        });



        $timeout(function () {
            viewModel.ready = true;
        }, 8000);

        // for listing

        function getTagDDControl(aTagObj) {
            return {

                tagId: aTagObj.getTagId(),
                isOwner: viewModel.isCurrentUserOwner(aTagObj)
            };

        }

        function getTagPictureImageByMemberAvatars(aTag) {
            var images = [];
            var allMembersObjects = aTag.getMembersObjectMap().all();
            var imageCount = 0;

            for (var index = 0; ( index < allMembersObjects.length && imageCount < 3); index++) {
                var aMemberObject = allMembersObjects[index].value;
                var pictureUrl = aMemberObject.getPictureUrl();
                if (pictureUrl !== '') {
                    images.push(pictureUrl);
                    imageCount++;
                }
            }

            return images;

        }

        function getLastMessageOnATag(aTag) {
            //var box = ChatFactory.getBoxByUId(aTag.getTagId());
            //if( !box || !box.messages.length){
            //	return false;
            //}

            var message = tagChatStorage.getLastMessageByTag(aTag.getTagId());
            if (!message) {
                return false;
            }

            //var message = box.messages[box.messages.length - 1];
            return message.value;
        }

        // edit, view or delete
        function memberDDActions(actionObj) {
            switch (actionObj.action) {
                case 'edit':
                case 'view':
                    rgDropdownService.close();

                    return function () {
                        return {tagId: actionObj.tagId};
                    };
                    break;
                case 'delete':

                    rgDropdownService.close();

                    var tagObject = tagChatFactory.getTag(actionObj.tagId);
                    tagObject.setObjectLock();
                    tagChatManager.leaveFromTag(actionObj.tagId, currentUser.getKey()).then(function (response) {

                        tagObject.removeObjectLock();
                        Ringalert.show(response, 'info');


                    }, function (response) {

                        tagObject.removeObjectLock();
                        Ringalert.show(response, 'error');

                    });

                    break;
                default:
                    console.log('Err. no matching action');
            }
        }




    }


})();




/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.tagchat')

        .directive('rgTagChatList',
            function () {
                return {
                    restrict: 'E',
                    templateUrl: 'pages/partials/tag-chat/tag-chat-list.html'
                };
            }
        )



})();

/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.tagchat')
		.controller('TagChatPopupController', TagChatPopupController);

		TagChatPopupController.$inject = [
			'$timeout', '$scope', '$boxInstance', '$$stackedMap',
			'Auth', 'fileUploadService',
			'tagChatFactory', 'tagChatManager', 'friendsFactory',
			'localData', 'Ringalert', 'utilsFactory', 'settings',
			'TAG_CHAT_GENERAL_CONSTANTS', 'TAG_CHAT_LANG',
			'profileFactory', 'rgScrollbarService'
		];

		function TagChatPopupController(
			$timeout, $scope, $boxInstance, $$stackedMap,
			Auth, fileUploadService,
			tagChatFactory, tagChatManager, friendsFactory,
			localData, Ringalert, utilsFactory, settings,
			TAG_CHAT_GENERAL_CONSTANTS, TAG_CHAT_LANG,
			profileFactory, rgScrollbarService
		) {

            $scope.state = {
                loading: false,
                noData: false,
            };
			var oldMemberList = {},
				apiParams = {},
				utId = '',
				memberUtIds = '';

			//$scope.friends = friendsFactory.friends.copy();
            $scope.friends = friendsFactory.getFriends('friends');
            $scope.friendName = '';
			$scope.editMode = false;

			$scope.addToTag = addToTag;
			$scope.removeMember= removeMember;
			$scope.createChatTag = createChatTag;
			$scope.updateChatTag = updateChatTag;
			$scope.loadMoreFriends = loadMoreFriends;
			$scope.cancel = cancel;
			$scope.validateTag = validateTag;

			$scope.newOwnerTagMember = false;

			$scope.models = {
				popupTitle: 'Create New Group Chat',
				tagName: '',
				pictureUrl : '',
				pictureFileName : '',
				tagId : tagChatFactory.generateNewTagId(),
			};

			$scope.uploading = false;

			$scope.selectNewOwner = selectNewOwner;

			$scope.setNewOwner = setNewOwner;

			$scope.isMemberSelected = isMemberSelected;

			$scope.canRemoveMember = canRemoveMember;

			$scope.canUpdateTagInfo = canUpdateTagInfo;

			$scope.getPicturePreviewUrl = function(){
				return settings.tagChatImBase + $scope.models.pictureUrl;
			};

			$scope.contactListAction = function(actionObj) {
                if (!actionObj.friend.isLoading()) {
                    friendsFactory.friendAction(actionObj,true).then(function() {
                        $scope.$rgDigest();
                    }, function() {
                        $scope.$rgDigest();
                    });
                    $scope.$rgDigest();
                }
            };


			$scope.uploadAction = function (actionObj) {
				console.log(actionObj);

				actionObj.uploadFile.fetchMeta(function(){

					$scope.models.pictureUrl = actionObj.uploadFile.getPreview();
					$scope.uploading = true;

					utilsFactory.safeDigest($scope);

					utilsFactory.safeDigest($scope);

					actionObj.uploadFile.initUpload().then(function(imgData){
						$scope.uploading = false;
						console.info("chat image uploaded:" + imgData);
						$scope.models.pictureFileName = imgData.iurl;
						$scope.models.pictureUrl = settings.imBase + imgData.url;

						utilsFactory.safeDigest($scope);

					}, function(response){
						console.log(response);
						$scope.uploading = false;
					});

				});
			};

			var currentUserUId = Auth.currentUser().getKey();

			function initAdminMemberOwnerList(){
				$scope.memberList = $$stackedMap.createNew();
				$scope.adminList = $$stackedMap.createNew();
				//$scope.ownerList = $$stackedMap.createNew();
			}

			if (localData && localData.tagId) {


				//get tag data
				$scope.tag = tagChatFactory.getTag(localData.tagId);

                //take backup
				oldMemberList = $scope.memberList;

				var memberObjectMap = $scope.tag.getMembersObjectMap();

				if( !!memberObjectMap ){
                	$scope.memberAdminList = memberObjectMap.copy();
					initAdminMemberOwnerList();

					$scope.tag.initMemberObjects();

					angular.forEach($scope.memberAdminList.all(), function(aMemberList){

						//if( aMemberList.value.isAdmin() ){
						//
						//}else
						if( aMemberList.value.isMember() ){
							$scope.memberList.add(aMemberList.key, aMemberList.value);
						}else{
							$scope.adminList.add(aMemberList.key, aMemberList.value);
							//$scope.ownerList.add(aMemberList.key, aMemberList.value);
						}

					});

				}else{
					initAdminMemberOwnerList();

				}

				$scope.models.tagName = $scope.tag.getTagName();
				$scope.models.popupTitle = 'Update Group chat';
				$scope.models.pictureUrl = $scope.tag.getPictureFullUrl();
				$scope.models.pictureFileName = $scope.tag.getPictureUrl();

				// show an existing tag for view/edit
				$scope.editMode = true;

			} else {
				// create new stack
				initAdminMemberOwnerList();
			}


            function reInitFriends() {
                $timeout(function() {
			        $scope.friends = friendsFactory.friends.copy();
					utilsFactory.safeDigest($scope);
				}, 2000);

            }


            // search for friend
            $scope.$watch('friendName', function(newVal, oldVal) {
                console.log('search contact: ' + newVal);
                if(newVal != '') {
                    friendsFactory.searchContact({schPm: newVal}, true);
                    reInitFriends();
                }
            });

			$scope.$watch(function(){
				return ($scope.friends.length() - $scope.adminList.length() - $scope.memberList.length());
			}, function(newVal, oldVal){
				if(newVal < 10){
					loadMoreFriends();
				}
			});



			function isCurrentUserOwner(tagObj){

				return !!tagObj && tagObj.getOwnerUserId() === Auth.currentUser().getKey();
			}

			function canAddMember(tagMemberObject){

				return true;
			}

			function canRemoveMember(tagMemberObject){

				if( tagMemberObject.getId() === currentUserUId ){
					return false;
				}

				if( !!$scope.tag && !isCurrentUserOwner($scope.tag)){

					var isAddedByCurrentUser = tagMemberObject.getAddedBy() !== Auth.currentUser().getKey();

					if( $scope.tag.isCurrentUserStatusAdmin(currentUserUId) ){
						if(tagMemberObject.isAdmin() && isAddedByCurrentUser ){

						}else if(!tagMemberObject.isMember()){
							return false;
						}

					}

					if( $scope.tag.isCurrentUserStatusMember(currentUserUId) && isAddedByCurrentUser ){
						return false;
					}
				}

				return true;

			}

			function canUpdateTagInfo(){

				if( !!$scope.editMode && $scope.tag.isCurrentUserStatusMember(currentUserUId) ){
					return false;
				}

				return true;
			}



            $scope.$watch('friendName', function(newVal) {
                if (newVal && newVal.length >1) {
                    toggleLoading(true);
                    friendsFactory.searchContact({schPm: newVal}, true).then(function() {
                        $scope.friends = friendsFactory.getFriends('friends');
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                    });
                }
            });

            function loadMoreFriends() {
                // no request in progress
                if (!$scope.state.loading && $scope.friends.length() !== friendsFactory.totalFriends('friends')) {
                    toggleLoading(true);
                    friendsFactory.getContactDetails().then(function() {
                        $scope.friends = friendsFactory.getFriends('friends');
                        RingLogger.information('FRIENDS LENGTH: ' + $scope.friends.length(), RingLogger.tags.FRIEND);
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                        RingLogger.alert('friend Details fetch fail', RingLogger.tags.FRIEND);
                    });

                    // in case the promise never resolves or rejects
                    setTimeout(function() {
                        $scope.state.loading = false;
                    }, 3000);
                }
            }

			function createChatTag() {
				if(!validateTag()) {
					utilsFactory.safeDigest($scope);
					return
				}


				var tagName = $scope.models.tagName;

				var memberUIds = $scope.memberList.keys();
				var adminUIds = $scope.adminList.keys();

				var tagId = $scope.models.tagId;
				var pictureFileName = $scope.models.pictureFileName;

				tagChatManager.createTag({ tagName :tagName, memberUIds : memberUIds, adminUIds : adminUIds, tagId : tagId, tagPictureUrl: pictureFileName })
					.then(function(data){
						if( !!data.sucs){
							Ringalert.show('Group Created.', 'success');
						}

					}, function(response){

						Ringalert.show(TAG_CHAT_LANG.DEFAULT_FAILURE_MESSAGE, 'error');

						RingLogger.alert(response, 'on-tag-chat-tag-create', RingLogger.tags.TAG_CHAT);

					}, function(response){

						RingLogger.information(response, 'on-tag-chat-tag-create-progress', RingLogger.tags.TAG_CHAT);

					});


				utilsFactory.triggerCustomEvent('MY_TAG_LIST_RECEIVED');

				$boxInstance.close();

			}

			function removeTagObjectLock(tagId){
				var oldTagObj = tagChatFactory.getTag($scope.tag.getTagId());
				oldTagObj.removeObjectLock();
			}


			function updateChatTag() {
				if(!validateTag()) {
					utilsFactory.safeDigest($scope);
					return;
				}

				var oldTagObj = tagChatFactory.getTag($scope.tag.getTagId());
				var newTagName = $scope.models.tagName;
				var pictureFileName = $scope.models.pictureFileName;

				var memberUIdsToSet = $scope.memberList.keys();
				var adminUIdsToSet = $scope.adminList.keys();

				$scope.tag.setObjectLock();


				tagChatManager.updateTag(oldTagObj,
					newTagName,
					pictureFileName,
					memberUIdsToSet,
					adminUIdsToSet
				).then(function(response){
						removeTagObjectLock($scope.tag.getTagId());

						if(!!response.sucs){
							Ringalert.show(response, 'success');
						}

				}, function(response){
						removeTagObjectLock($scope.tag.getTagId());

						Ringalert.show(TAG_CHAT_LANG.DEFAULT_FAILURE_MESSAGE, 'error');

						RingLogger.alert(response, 'on-tag-chat-tag-update', RingLogger.tags.TAG_CHAT);

				}, function(response){
						if(!!response.sucs){

							removeTagObjectLock($scope.tag.getTagId());
							Ringalert.show(response, 'success');
						}

				});


				$scope.editMode = false;
				utilsFactory.triggerCustomEvent('MY_TAG_LIST_RECEIVED');

				$boxInstance.close();


			}

            function toggleLoading(bool) {
                $timeout(function() {
                    $scope.state.loading = bool;
                    if (!bool) {
                        rgScrollbarService.recalculate($scope);
                    }
                });
                //$scope.$digest();
            }

			function addToTag( member, type) {
                if ( ($scope.memberList.length() + $scope.adminList.length()) > $scope.friends.length() - 10) {
                    loadMoreFriends();
                }

				var tagId = !$scope.tag ? $scope.models.tagId : $scope.tag.getTagId();

				var aTagMemberObject = tagChatFactory.createNewTagMember(
					tagId,
					{ status : type == 'member' ? TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER : TAG_CHAT_GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN, addedBy : currentUserUId },
					false
				);

				if( !canAddMember(aTagMemberObject) ){
					Ringalert.show('Permission Denied', 'error');
					return;
				}


				if( !!$scope.tag ){
					aTagMemberObject.setTagId( $scope.tag.getTagId() );
				}

				aTagMemberObject.initWithUserMapObject( member );

				if( type === 'admin'){
					$scope.adminList.add( aTagMemberObject.getId(), aTagMemberObject);
				}else{
					$scope.memberList.add( aTagMemberObject.getId(), aTagMemberObject);
				}
				utilsFactory.safeDigest($scope);


			}

			function removeMember(tagMemberObj) {

				if(  canRemoveMember(tagMemberObj) ){

					if( tagMemberObj.isAdmin() ){
						$scope.adminList.remove(tagMemberObj.getId());
					}else{
						$scope.memberList.remove(tagMemberObj.getId());
					}
					utilsFactory.safeDigest($scope);


				}else{
					Ringalert.show('Permission Denied', 'error');
				}
			}


			function isMemberSelected(tagMember){
				return ($scope.newOwnerTagMember && tagMember.getId() === $scope.newOwnerTagMember.getId());
			}

			function setNewOwner(tagMember){
				$scope.newOwnerTagMember = tagMember;

				utilsFactory.safeDigest($scope);

			}

			function selectNewOwner(){

				var tagMember = $scope.newOwnerTagMember;
				var tag = $scope.tag;

				$scope.newOwnerTagMember = false;

				RingLogger.print('Selected New Owner', tagMember.getName(), 'tag-chat');

				var oldTagMemberStatus = tagMember.getStatus();

				tagMember.makeOwner();

				var currentOwner = tag.getMember(Auth.currentUser().getKey());
				currentOwner.makeMember();

				var revertChanges = function(){
					tagMember.setStatus(oldTagMemberStatus);
					currentOwner.makeOwner();
					tag.removeObjectLock();
				};

				var tagMembersStatusToChange = [tagMember.serialize(), currentOwner.serialize()];

				var membersAdminToUpdateOnSuccess = [tagMember, currentOwner];

				tag.setObjectLock();

				tagChatManager.changeTagMemberStatus(tag.getTagId(), tagMembersStatusToChange, membersAdminToUpdateOnSuccess).then(function(){

					tagChatManager.leaveFromTag( tag.getTagId()).then(function(memberLeaveResponse){

						tag.removeObjectLock();
						Ringalert.show(memberLeaveResponse, 'info');


					}, function(){
						Ringalert.show(TAG_CHAT_LANG.DEFAULT_FAILURE_MESSAGE, 'error');
						revertChanges();
					});


				}, function(){
					Ringalert.show(TAG_CHAT_LANG.DEFAULT_FAILURE_MESSAGE, 'error');
					revertChanges();
				});

				utilsFactory.safeDigest($scope);
				$boxInstance.close();

			}



			function cancel() {
				$scope.newOwnerTagMember = false;
				$boxInstance.close();

				utilsFactory.safeDigest($scope);

			}


			function validateTag() {
                if ($scope.models.tagName.length > 100 ) {
                    $scope.models.errTagName = 'Maximum 100 alpha numeric characters';
                } else {
                    $scope.models.errTagName = '';
                }
				$scope.models.errMemberList = ( ( $scope.memberList.length() + $scope.adminList.length() ) < 2 ) ? true : false;

				if ( !!$scope.models.errMemberList  || !!$scope.models.errTagName) {
					return false;
				} else {
					return true;
				}


			}

		}

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.tagchat')
		.controller('TagChatDebugInfoController', TagChatDebugInfoController);

	TagChatDebugInfoController.$inject = [
			'$scope', '$boxInstance',
			'Auth', 'ChatFactory',
			'tagChatFactory', 'tagChatManager', 'friendsFactory', 'tagChatApiService',
			'localData', 'Ringalert', 'utilsFactory', 'settings',
			'TAG_CHAT_GENERAL_CONSTANTS', 'profileFactory'
		];

		function TagChatDebugInfoController(
			$scope, $boxInstance,
			Auth, ChatFactory,
			tagChatFactory, tagChatManager, friendsFactory, tagChatApiService,
			localData, Ringalert, utilsFactory, settings,
			TAG_CHAT_GENERAL_CONSTANTS, profileFactory
		) {

			$scope.currentUserUId = Auth.currentUser().getKey();

			$scope.registerTag = registerTag;
			$scope.unregisterTag = unregisterTag;


			if (localData && localData.tagId) {

				//get tag data
				$scope.tag = tagChatFactory.getTag(localData.tagId);


				//set Debug Infos Start

				$scope.tagDebugInfo = {};
				$scope.tagDebugInfo.isTagRegistered = tagChatFactory.isTagRegistered(localData.tagId);
				$scope.chatBox = ChatFactory.getBoxByUId(localData.tagId);

			}

			function cancel() {
				$boxInstance.close();
			}

			function registerTag(){
				tagChatManager.registerTag($scope.tag.getTagId());
			}

			function unregisterTag(){
				tagChatApiService.unRegisterFromChatServer($scope.tag);
			}



		}

})();

/*
 * Md. Ibrahim Rashid
 * © Ipvision
 */

(function() {
    'use strict';

    var tagChatApp = angular.module('ringid.tagchat');

    tagChatApp.factory('tagChatExceptions', tagChatExceptions);

    tagChatExceptions.$inject = [];

    function tagChatExceptions(){

        function ChatPacketException(msg, code){
            if(!code){
                RingLogger.alert('code : ' + code, ' msg ' + msg, RingLogger.tags.CHAT_EXCEPTIONS);
            }else{
                RingLogger.alert('msg ' + msg, RingLogger.tags.CHAT_EXCEPTIONS);
            }
        }

        return {
            ChatPacketException : ChatPacketException

        }

    }


})();

/* 
 * © Ipvision 
 */

(function() {
	'use strict';

	angular
		.module('ringid.circle', [
			'ringid.ringbox',
			'ringid.common.rgdropdown_directive',
			'ringid.friend.friends_factory',
			'ringid.common.user_factory',
			'ringid.common.stacked_map'
		]);
})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

	angular
		.module('ringid.circle')
		.service('circleHttpService', circleHttpService);

		circleHttpService.$inject = ['$$connector', 'OPERATION_TYPES'];
		function circleHttpService($$connector, OPERATION_TYPES) { //jshint ignore:line
			var self = this, // jshint ignore:line
                OTYPES = OPERATION_TYPES.SYSTEM.CIRCLE,
                REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;

			self.go = function(data, method){
				method = method || 'post';
                return $$connector.request(data);
			};

			self.getCircleMembers = function(circleId,pvtid,lim) {
				var payload = {
					actn: OTYPES.TYPE_GROUP_MEMBERS_LIST,
					grpId: circleId,
					scl:1,
					lmt: lim || 40,
					pvtid: pvtid || 0
				};

				return $$connector.send(payload,REQTYPE.REQUEST);
			};

			self.createCircle = function(obj){
				var payload = {
					actn: OTYPES.TYPE_CREATE_GROUP,
                    gNm: obj.tg.utf8Encode(),
					uId:obj.uId,
					groupMembers: obj.alluser
				};
				return $$connector.request(payload,REQTYPE.UPDATE);
			};

			self.getCircles = function(){
				var payload = {
					actn: OTYPES.TYPE_GROUP_LIST,
                    ut: -1,
                    gpmut: -1
				};
				return $$connector.send(payload, REQTYPE.REQUEST);
			};
			self.getCircle = function(key){
				return $$connector.request({
					actn : OTYPES.TYPE_GROUP_DETAILS,
					grpId : key
				},REQTYPE.REQUEST);
			}
			self.getCirclesInfo = function(){
				var payload = {
					actn: OTYPES.TYPE_GROUP_LIST,
					ut: -1,
					gpmut: -1
				};
				return $$connector.request(payload, REQTYPE.REQUEST);
			};

			self.addMembers = function(obj){ // payload are not checked
				var payload = {
					actn: OTYPES.TYPE_ADD_GROUP_MEMBER,
					grpId: obj.grpId,
					groupMembers : obj.members
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};


			self.removeMember = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_REMOVE_GROUP_MEMBER,
					grpId: obj.grpId,
					groupMembers:[
						{uId: obj.uId}
					]
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.removeMembers = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_REMOVE_GROUP_MEMBER,
					grpId: obj.grpId,
					groupMembers: obj.members
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.addRemoveAdmins = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_EDIT_GROUP_MEMBER,
					grpId: obj.grpId,
					groupMembers : obj.members

				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.addRemoveAdmin = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_EDIT_GROUP_MEMBER,
					grpId: obj.grpId,
					groupMembers : [
						{
							admin: obj.admin,//admin = "true",
							uId: obj.uId//uId = 2000006232
						}
					]

				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.leaveCircle = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_LEAVE_GROUP,
					grpId: obj.grpId
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.deleteCircle = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_DELETE_GROUP,
					grpId: obj.grpId
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.getMemberResult = function (param,cid,stval) {
				var payload = {
					actn: OTYPES.TYPE_GROUP_MEMBERS_SEARCH_RESULT,
					grpId: cid,
					schPm: param,
					st: stval || 0
				};
				return $$connector.send(payload, REQTYPE.REQUEST);
			};



		}

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.circle')
		.factory('circleMap', circleMap);

		circleMap.$inject = ['userFactory', 'friendsFactory', '$$stackedMap','settings','utilsFactory'];
		function circleMap(userFactory, friendsFactory, $$stackedMap,settings,utilsFactory) { // jshint ignore:line
			return {
				create: function(obj){
					//RingLogger.print('OBJ CREATION', obj, RingLogger.tags.CIRCLE);
					var circle = {
						gNm: '',
						grpId: 0,
						ists: 0, /*  circle delete status , 1: deleted, 0: not deleted */
                        sAd: '',
                        ut: 0,
						mc:'',
						mt:'',

                        groupMembers: '',
						memberList: [],
						members: {},
						allMembersMap: $$stackedMap.createNew(), /** Contains Both Members and Admins **/
						adminIds: [],
						memberIds: []
					};
					if ( angular.isObject(obj) ) {
						//RingLogger.print(obj, RingLogger.tags.CIRCLE);
						circle = angular.extend({}, circle, obj);

					}
					//RingLogger.print(obj, RingLogger.tags.CIRCLE);

					function _log(){
						RingLogger.print(circle.grpId, circle.adminIds, circle.memberIds, RingLogger.tags.CIRCLE);
					}

					function _removeAdminId(uId){
						var index = circle.memberIds.indexOf(uId);
						if( index !== -1) {
                            circle.memberIds.splice(index, 1);
                        }
					}

					function _removeMemberId(uId){
						var index = circle.adminIds.indexOf(uId);
						if( index !== -1) {
							circle.adminIds.splice(index, 1);
                        }
					}

					function _refreshLength(){
						circle.mc = circle.allMembersMap.length();
					}

					function _update(obj){
						angular.extend(circle, obj);
					}

					var ObjectToReturn = {
						sortBy: function() {
							return circle.gNm.toLowerCase();
						},

						update  : _update,

             			addMember: function(uId, isAdmin) {
							var user = userFactory.create(uId);

                            circle.allMembersMap.save(user.getKey(), user);

							if(!!isAdmin){
								ObjectToReturn.promoteToAdmin(user.getKey());
							}else{
								ObjectToReturn.removeFromAdmin(user.getKey());
							}

							_refreshLength();

                        },
						isAdmin: function() {
							//if (circle.adminIds.indexOf(key) > -1) {
							if ( circle.mt === 1 ) {
								return true;
							} else {
								return false;
							}
						},

						isMember: function() {
							//if (circle.adminIds.indexOf(key) > -1) {
							if ( circle.mt === 0 ) {
								return true;
							} else {
								return false;
							}
						},

                        isSuperAdmin: function(uId) {
                            if (circle.sAd === uId) {
                                return true;
                            } else {
                                return false;
                            }

                        },

						getSuperAdminUId : function(){
							return circle.sAd;
						},

						promoteToAdmin: function(uId) {
							_removeMemberId(uId);

							circle.adminIds.push(uId);

							circle.allMembersMap.get(uId).setGroupAdmin(circle.grpId);

							_log();
						},
						removeFromAdmin: function(key) {
							_removeAdminId(key);

							circle.memberIds.push(key);

							circle.allMembersMap.get(key).removeGroupAdmin(circle.grpId);

							_log();
						},
						getAdmins: function() {
							var adminsMap = circle.allMembersMap.copy();
							for(var i = 0; i < circle.memberIds.length; i++) {
								adminsMap.remove(circle.memberIds[i]);
							}

							return adminsMap;
						},
						getMember : function(uId){
							return circle.allMembersMap.get(uId);
						},
                        getMembers: function() {
							var membersMap = circle.allMembersMap.copy();
							for(var i = 0; i < circle.adminIds.length; i++) {
								membersMap.remove(circle.adminIds[i]);
							}

							return membersMap;
                        },
						setMembers: function(newMembers) {

							angular.forEach(newMembers, function(aNewMember){
								if(!aNewMember.ists){

									var member = userFactory.create(aNewMember);

									circle.allMembersMap.save(member.getKey(), member);

									if (aNewMember.admin) {
										if( circle.adminIds.indexOf(member.getKey()) !== -1){
											circle.adminIds.push(member.getKey());
										}else{
											ObjectToReturn.promoteToAdmin(member.getKey());
										}
									} else {
										if( circle.memberIds.indexOf(member.getKey()) !== -1){
											circle.memberIds.push(member.getKey());
										}else{
											ObjectToReturn.removeFromAdmin(member.getKey());
										}
									}
								}
							});

							//_refreshLength();

							_log();


						},
						resetMembers: function() {
							circle.allMembersMap.reset();
							circle.adminIds = [];
							circle.memberIds = [];
						},
						removeMember: function(memberKey) {
							var removedMember;
							removedMember = circle.allMembersMap.remove(memberKey);
							_removeAdminId(memberKey);
							_removeMemberId(memberKey);

							_refreshLength();

							RingLogger.print('REMOVED', removedMember, RingLogger.tags.CIRCLE);
						},
						getAllMembers: function() {
							return circle.allMembersMap;
						},
						getMemberIds : function(){
							return circle.memberIds.slice();
						},
						getAdminIds : function(){
							return circle.adminIds.slice();
						},

						getMembersObjectCount: function() {
							return circle.allMembersMap.length();
						},
						getMembersCount: function() {
							//return circle.allMembersMap.length();
							return circle.mc;
						},
						getMemberType: function(){
							return circle.mt;
						},
						setMemberCount : function(count){
							circle.mc = count;
						},
						getLink: function(subPage) {
							 subPage = (subPage||'');
							return settings.baseUrl + utilsFactory.getRingRoute('CIRCLE_HOME',{circleId:circle.grpId,subpage : subPage});
						},
						getLinkOnly: function(subPage) {
							subPage = (subPage||'');
							return  utilsFactory.getRingRoute('CIRCLE_HOME',{circleId:circle.grpId,subpage : subPage}).slice(1);
						},
						getKey: function() {
							return circle.grpId;
						},
						getName: function() {
							return circle.gNm;
						},
						getAnchor: function(){
							return '<a class="cir-title" href="/#/circle/' + circle.grpId +'" >'+circle.gNm+'</a>';
						}

					};

					return ObjectToReturn;
				}
			};
		}
})();



/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.circle')
		.factory('circlesManager', circlesManager);

	circlesManager.$inject = ['$routeParams', '$location', '$rootScope','$$connector', 'OPERATION_TYPES', 'Storage',
        '$$stackedMap', '$$q', 'circleMap', 'userFactory', 'circleHttpService', 'Notification', 'SystemEvents','Ringalert', 'Auth'];
	function circlesManager($routeParams, $location, $rootScope, $$connector, OPERATION_TYPES, StorageFactory, // jshint ignore:line
                            $$stackedMap, $q, circleMap, UserFactory, circleHttpService, Notification, SystemEvents, Ringalert, Auth) {

        var myCircles = $$stackedMap.createNew(true, 'asc'),
            circlesOfMe = $$stackedMap.createNew(true, 'asc'),
            OTYPES = OPERATION_TYPES.SYSTEM.CIRCLE;
        var maxUserId;
        var stVal;



        function _removeLocalCircle(circleId){
            circlesOfMe.remove(circleId);
            $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_REMOVED, { circleId : circleId});
        }

        function doCreateCircle(circleMapObject, aGroup){

            var circle = circleMapObject.get(aGroup.grpId);
            if( !circle ){
                circle = circleMap.create(aGroup);
            }else{
                circle.update(aGroup);
            }
            circleMapObject.save(circle.getKey(), circle);

            return circle;

        }

        function CreateAndSaveCircle(aGroup){

                var circle;
                if(!aGroup.ists){

                    if (aGroup.sAd == Auth.currentUser().getKey() ) {
                        circle = doCreateCircle(myCircles, aGroup);
                    } else {
                        circle = doCreateCircle(circlesOfMe, aGroup);
                    }
                }
                return circle;
        }

        function _processCircleList(circleList){
            angular.forEach(circleList, CreateAndSaveCircle);
        }

        function redirect(circleId) {
            RingLogger.information('route circleid: ' + $routeParams.circleId, +' json.grpId: ' + circleId, RingLogger.tags.CIRCLE);
            if ($routeParams.circleId && $routeParams.circleId == circleId) { //jshint ignore:line
                Ringalert.show('Circle Deleted', 'success');
                $location.path('/');
            }
        }

        function redirectHome(){
            Ringalert.show('Circle does not exist!', 'warning');
            $location.path('/');
        }

        function processCircleUpdates (json){
            RingLogger.information('CIRCLE UPDATE: ' + json.actn, RingLogger.tags.CIRCLE);
            RingLogger.print(json, RingLogger.tags.CIRCLE);
            var circleId,
                circleToUpdate;

            if( json.sucs){
                switch(json.actn){
                    case OTYPES.TYPE_UPDATE_EDIT_GROUP_MEMBER:
                    case OTYPES.TYPE_UPDATE_ADD_GROUP_MEMBER:
                        circleId = json.grpId;
                        circleToUpdate = getCircle(circleId);
                        if(!!circleToUpdate){
                            circleToUpdate.setMembers(json.groupMembers);
                        } else {
                            RingLogger.warning('circle not found: ' , RingLogger.tags.CIRCLE);
                        }
                        break;
                    case OTYPES.TYPE_UPDATE_DELETE_GROUP:
                        circleId = json.grpId;
                        circleToUpdate = getCircle(circleId);
                        if(!!circleToUpdate) {
                            _removeLocalCircle(circleToUpdate.getKey());
                            redirect(json.grpId);
                        } else {
                            RingLogger.warning('circle not found: ' , RingLogger.tags.CIRCLE);
                        }
                        break;
                    case OTYPES.TYPE_UPDATE_REMOVE_GROUP_MEMBER:
                        circleId = json.grpId;
                        circleToUpdate = getCircle(circleId);

                        if(!!json.removedMembers && !!circleToUpdate){
                            angular.forEach(json.removedMembers, function(aMemberUId){
                                circleToUpdate.removeMember(aMemberUId);
                            });
                        } else {
                            RingLogger.warning('circle not found: ' , RingLogger.tags.CIRCLE);
                        }
                        break;
                    case OTYPES.TYPE_UPDATE_ADD_TO_GROUP_BY_FRIEND:
                        json.groupList = [{
                            gNm: json.gNm,
                            grpId: json.grpId,
                            mc: json.mc,
                            sAd: json.sAd
                        }];
                        _processCircleList(json.groupList);
                        processCircleMembersData(json.groupMembers);

                        break;
                }
            }
        }

        function circleUpdateFilter(json){
            return json.actn === OTYPES.TYPE_UPDATE_EDIT_GROUP_MEMBER ||
                   json.actn === OTYPES.TYPE_UPDATE_ADD_GROUP_MEMBER ||
                   json.actn === OTYPES.TYPE_UPDATE_DELETE_GROUP ||
                   json.actn === OTYPES.TYPE_UPDATE_REMOVE_GROUP_MEMBER ||
                   json.actn === OTYPES.TYPE_UPDATE_ADD_TO_GROUP_BY_FRIEND;
        }

            function processCirclesData(json) {
                if (json.actn === OTYPES.TYPE_GROUP_LIST && json.sucs === true) {
                    _processCircleList(json.groupList);

                    $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_LIST_PROCESS_COMPLETE);
                }
            }

            function processCircleMembersData(json) {
                //RingLogger.log(json, RingLogger.tags.CIRCLE);
                if(json.sucs === true) {
                    if(angular.isArray(json.groupMembers) && json.groupMembers.length){
                        for( var j=0; j<json.groupMembers.length; j++ ){
                            maxUserId = json.groupMembers[j].id;
                        }
                        var circle = myCircles.get(json.groupMembers[0].grpId);

                        if (!circle) {
                            circle = circlesOfMe.get(json.groupMembers[0].grpId);
                        }

                        if(!circle){
                           return;
                        }

                        circle.setMembers(json.groupMembers);
                    }
                }
                $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_PROCESS_COMPLETE,{
                    success : true
                });
            }

        function processCircleSearchMembersData(json) {
            //RingLogger.log(json, RingLogger.tags.CIRCLE);
            stVal = json.tr;
            if(json.sucs === true) {
                if(angular.isArray(json.groupMembers) && json.groupMembers.length){

                    var circle = myCircles.get(json.groupMembers[0].grpId);

                    if (!circle) {
                        circle = circlesOfMe.get(json.groupMembers[0].grpId);
                    }

                    if(!circle){
                        return;
                    }

                    circle.setMembers(json.groupMembers);
                }
            }
            $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_PROCESS_COMPLETE,{
                success : json.sucs
            });
        }

            function getCircle(circleKey) {
                return myCircles.get(circleKey) || circlesOfMe.get(circleKey);
            }

            function getCirclePromise(key){
                var circle = getCircle(key),defer = $q.defer();

                if(circle){
                    setTimeout(function(){
                        defer.resolve(circle);
                    });
                }else{
                    circleHttpService.getCircle(key).then(function(json){
                         if(json.sucs){
                            json.grpId = key;
                            json.ists = 0;
                            circle = CreateAndSaveCircle(json);
                            defer.resolve(circle);
                         }else{
                            defer.reject(false);
                         }
                    },function(reason){

                    });
                }
                return defer.promise;
            }

            function getCircles (circleCreatedByMe) {
                if (circleCreatedByMe) {
                    return myCircles;
                } else {
                    return circlesOfMe;
                }
            }

            function createCircle(circleObj) {
                //circleHttpService.createCircle(circleObj);
                var deferred = $q.defer();
                circleHttpService.createCircle(circleObj).then(function(data) {
                    //var response = angular.fromJson(data);
                    if (data.sucs === true) {
                        circleHttpService.getCircles();
                        Notification.info('Your circle ' + circleObj.tg + ' created successfully.');
                    }
                    deferred.resolve(data);
                });

                return deferred.promise;

            }

            function getCircleMembers(circleid,pvtid,lim){
                if( pvtid === 0 ){
                    maxUserId = pvtid;
                }
                circleHttpService.getCircleMembers(circleid,maxUserId,lim);
            }

            function getMemberResult(param,cid) {
                circleHttpService.getMemberResult(param,cid,stVal);
            }

            function leaveGroup(circle) {
                var deferred = $q.defer();
                circleHttpService.leaveCircle({grpId: circle.getKey()}).then(function(data) {
                    var response = angular.fromJson(data);
                    if (response.sucs === true) {
                        // remove circle
                        myCircles.remove(circle.getKey());
                        circlesOfMe.remove(circle.getKey());
                        deferred.resolve(response);
                    } else {
                        deferred.reject('Failed');
                    }
                });
                return deferred.promise;
            }

            function deleteCircle(circle) {
                var deferred = $q.defer();
                circleHttpService.deleteCircle({grpId:circle.getKey()}).then(function(response) {
                   // var response = angular.fromJson(data);
                   // RingLogger.print(response, RingLogger.tags.CIRCLE);
                    if (response.sucs === true) {
                        // remove circle
                        myCircles.remove(circle.getKey());
                        circlesOfMe.remove(circle.getKey());
                        deferred.resolve(response);
                    } else {
                        deferred.reject('Failed');
                    }
                });
                return deferred.promise;
            }

            function addMembers(members, circle) {

                var obj = {
                    grpId : circle.getKey(),
                    members : members
                };

                angular.forEach(members, function(aMember){
                    circle.addMember(aMember.uId, aMember.admin);
                });

                circle.setMemberCount(circle.getMembersObjectCount());

                circleHttpService.addMembers(obj).then(function(data) {
                    RingLogger.print(data, RingLogger.tags.CIRCLE);

                    if (data.sucs !== true) {
                        angular.forEach(members, function(aMember){
                            circle.removeMember(aMember.uId);
                        });
                        circle.setMemberCount(circle.getMembersObjectCount());

                    }

                    $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE);

                },function(errData) {
                    RingLogger.print(errData, RingLogger.tags.CIRCLE);
                });
            }

            function removeMember(memberKey, circle) {
                var param = {
                    grpId: circle.getKey(),
                    uId: memberKey
                };

                var removedMember = circle.removeMember(memberKey);

                circleHttpService.removeMember(param).then(function(data) {
                    if (data.sucs !== true) {

                        circle.addMember(removedMember);
                        Ringalert.show(data, 'error');

                    }
                    $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE);

                },function(errData) {
                    RingLogger.print(errData, RingLogger.tags.CIRCLE);
                });
            }

            function removeMembers(membersUIds, circle) {
                var param = {
                    grpId: circle.getKey(),
                    members : []
                };

                angular.forEach(membersUIds, function(aMemberUId){
                    param.members.push({uId : aMemberUId } );
                    circle.removeMember(aMemberUId);
                });

                circle.setMemberCount(circle.getMembersObjectCount());

                circleHttpService.removeMembers(param).then(function(data) {
                    if (data.sucs !== true) {

                        angular.forEach(membersUIds, function(aMemberUId){
                            circle.addMember(aMemberUId);
                        });

                        circle.setMemberCount(circle.getMembersObjectCount());

                        Ringalert.show(data, 'error');

                    }

                    $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE);

                },function(errData) {
                    RingLogger.print(errData, RingLogger.tags.CIRCLE);
                });
            }

            function toggleMembership(obj, circle) {

                circleHttpService.addRemoveAdmin(obj).then(function(data) {
                    RingLogger.print(data, RingLogger.tags.CIRCLE);

                    if (data.sucs === true) {
                        var groupMember = data.groupMembers[0];

                        if( groupMember.uId === obj.uId && groupMember.admin === true){
                            RingLogger.print('became admin', RingLogger.tags.CIRCLE);
                            circle.promoteToAdmin(obj.uId);
                        }else if( groupMember.uId === obj.uId && groupMember.admin === false){
                            RingLogger.print('became member', RingLogger.tags.CIRCLE);
                            circle.removeFromAdmin(obj.uId);
                        }

                        $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE);
                    }
                },function(errData) {
                    RingLogger.print(errData, RingLogger.tags.CIRCLE);
                });
            }





        $$connector.subscribe(processCircleUpdates, {
            action: [
                    OTYPES.TYPE_UPDATE_DELETE_GROUP, //352,// "delete_group";
                    OTYPES.TYPE_UPDATE_REMOVE_GROUP_MEMBER, //354,  //"remove_group_member";
                    OTYPES.TYPE_UPDATE_ADD_GROUP_MEMBER, //356,// "add_group_member";
                    OTYPES.TYPE_UPDATE_EDIT_GROUP_MEMBER //358, //  "edit_group_member";
            ]
        });

        $$connector.subscribe(processCirclesData, {
            action: [
                OTYPES.TYPE_GROUP_LIST
            ]
        });
        
        if (Auth.isLoggedIn()) {
            setTimeout(circleHttpService.getCircles, 5000);
        } else {
            $rootScope.$on(SystemEvents.AUTH.LOGIN, function() {
                setTimeout(circleHttpService.getCircles, 5000);
            });
        }



        return {
            processCircleUpdates : processCircleUpdates,
            circleUpdateFilter : circleUpdateFilter,
            processCirclesData: processCirclesData,
            processCircleMembersData: processCircleMembersData,
            processCircleSearchMembersData:processCircleSearchMembersData,

            getCircle: getCircle,
            getCirclePromise: getCirclePromise,
            getCircles : getCircles,
            createCircle: createCircle,
            getCircleMembers: getCircleMembers,
            leaveGroup: leaveGroup,
            deleteCircle:deleteCircle,
            addMembers: addMembers,
            removeMember: removeMember,
            removeMembers: removeMembers,
            toggleMembership: toggleMembership,
            redirectHome:redirectHome,
            getMemberResult:getMemberResult
		};


	}

})();





/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.circle')
		.controller('CirclePopupController', CirclePopupController);

		CirclePopupController.$inject = ['$scope','$$connector' ,'circlesManager', '$boxInstance', 'friendsFactory', '$$stackedMap', 'localData', 'Ringalert', 'Auth', 'rgScrollbarService'];
		function CirclePopupController($scope, $$connector,circlesManager, $boxInstance, friendsFactory, $$stackedMap, localData, Ringalert, Auth, rgScrollbarService) { // jshint ignore:line
			//load friends
			$scope.friends = friendsFactory.getFriends('friends');
			$scope.circleAddMode = false;

            $scope.state = {
                loading: false,
                noData: false
            };


			$scope.models = {
				errCircleName: false,
				errMemberList: false,
				errAdminList: false
			};

			if( !localData.circleId ) {
				$scope.circleAddMode = true;
			}

			$scope.editMode = false;

			if (localData && localData.circleId) {

				//get circle data
				$scope.circle = circlesManager.getCircle(localData.circleId);

				$scope.memberList = $scope.circle.getMembers();
				$scope.adminList = $scope.circle.getAdmins();

				$scope.isCurrentUserSuperAdmin = $scope.circle.isSuperAdmin(Auth.currentUser().getKey());

				$scope.models.popupTitle = 'Edit Group';
				$scope.models.circleName = $scope.circle.getName();

				$scope.editMode = true;

			}else{

				$scope.models.popupTitle = 'Create New Circle';
				$scope.models.circleName = '';

				// create new stack
				$scope.memberList = $$stackedMap.createNew(true, 'asc');
				$scope.adminList = $$stackedMap.createNew(true, 'asc');

			}


			$scope.addToCircle = addToCircle;
			$scope.addToAdmin = addToAdmin;
			$scope.removeMember= removeMember;
			$scope.removeAdmin = removeAdmin;
			$scope.createCircle = createCircle;
			$scope.updateCircle = updateCircle;

			$scope.close = $boxInstance.close;
			$scope.validateCircle = validateCircle;
			$scope.loadMoreFriends = loadMoreFriends;



			function createCircle() {
				if (!validateCircle()) {
                    return;
                }

				var frndIds = $scope.memberList.keys();
				var adminIds = $scope.adminList.keys();

				var frnds = [];
				for(var i=0; i<frndIds.length;i++){
					frnds[i] = {admin:'false',uId:frndIds[i]};
				}

				var admins = [];
				for(var j=0; j<adminIds.length;j++){
					admins[j] = {admin:'true',uId:adminIds[j]};
				}
				var allUser = admins.concat(frnds);

                var circleObj = {
					tg: $scope.models.circleName,
					alluser:allUser
                };
               	circlesManager.createCircle(circleObj);
                $scope.close();
			}

			function updateCircle() {
				if (!validateCircle()) {
                    return;
                }

				var newMemberIds = $scope.memberList.keys();
				var newAdminIds = $scope.adminList.keys();

				var previousMemberIds = $scope.circle.getMemberIds();
				var previousAdminIds = $scope.circle.getAdminIds();

				var newMembersToAdd = newMemberIds.difference(previousMemberIds);
				var previousMembersToRemove  = previousMemberIds.difference(newMemberIds);

				var newAdminsToAdd = newAdminIds.difference(previousAdminIds);
				var previousAdminsToRemove = previousAdminIds.difference(newAdminIds);

				/* Add New Admin and Member */

				var newMemberAndAdminToAdd = [];
				angular.forEach(newMembersToAdd, function(aNewMemberUId){
					newMemberAndAdminToAdd.push({ admin: false, uId : aNewMemberUId });
				});

				angular.forEach(newAdminsToAdd, function(aNewAdminUId){
					newMemberAndAdminToAdd.push({ admin: true, uId : aNewAdminUId });
				});

				RingLogger.print(newMemberAndAdminToAdd, RingLogger.tags.CIRCLE);

				if(newMemberAndAdminToAdd.length > 0){
					circlesManager.addMembers(newMemberAndAdminToAdd, $scope.circle);
				}

				/* Remove Old Admin and Member */

				var memberKeysToRemove = previousMembersToRemove;
				memberKeysToRemove = memberKeysToRemove.concat(previousAdminsToRemove);

				RingLogger.print(memberKeysToRemove, RingLogger.tags.CIRLCE);

				if(memberKeysToRemove.length > 0){
					circlesManager.removeMembers(memberKeysToRemove, $scope.circle);
				}

				Ringalert.show('Circle Updated', 'success');

				$scope.close();
			}

            function needMoreFriends() {
                if ( ($scope.memberList.length() + $scope.adminList.length()) > $scope.friends.length() - 10) {
                    loadMoreFriends();
                }
            }

			function addToCircle(member) {
                needMoreFriends();
				$scope.memberList.add(member.getKey(), member);
				$scope.$rgDigest();
			}

			function removeMember( member) {
				$scope.memberList.remove(member.getKey());
				$scope.$rgDigest();
			}

			function addToAdmin( admin) {
                needMoreFriends();
				$scope.adminList.add(admin.getKey(), admin);
				$scope.$rgDigest();
			}

			function removeAdmin( admin) {
				$scope.adminList.remove(admin.getKey());
				$scope.$rgDigest();
			}


            function toggleLoading(bool) {
                $scope.state.loading = bool;
                if (!bool) {
                    rgScrollbarService.recalculate($scope);
                }
                if (!$scope.$$phase && !$scope.$root.$$phase) {
                    $scope.$digest();
                }
            }

            $scope.$watch('friendName', function(newVal) {
                if (newVal && newVal.length >1) {
                    toggleLoading(true);
                    friendsFactory.searchContact({schPm: newVal}, true).then(function() {
                        $scope.friends = friendsFactory.getFriends('friends');
                        toggleLoading(false);
						$scope.$rgDigest();
                    }, function() {
                        toggleLoading(false);
						$scope.$rgDigest();
                    });
                }
            });

            function loadMoreFriends() {
                // no request in progress
                if (!$scope.state.loading && $scope.friends.length() !== friendsFactory.totalFriends('friends')) {
                    toggleLoading(true);
                    friendsFactory.getContactDetails().then(function() {
                        $scope.friends = friendsFactory.getFriends('friends');
                        RingLogger.information('FRIENDS LENGTH: ' + $scope.friends.length(), RingLogger.tags.FRIEND);
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                        RingLogger.alert('friend Details fetch fail', RingLogger.tags.FRIEND);
                    });

                    // in case the promise never resolves or rejects
                    setTimeout(function() {
                        $scope.state.loading = false;
                    }, 3000);
					$scope.$rgDigest();
                }
            }

			function validateCircle() {
                if ($scope.models.circleName.length > 60) {
                    $scope.models.errCircleName = 'Maximum 60 characters';
                } else if ($scope.models.circleName.length === 0) {
                    $scope.models.errCircleName = 'Name required';
                } else {
                    $scope.models.errCircleName = '';
                }
                $scope.models.errMemberList = ($scope.memberList.length() < 1) ? true : false;

				// no need to check adminLIst. Creator of Circle is Admin automatically
                //$scope.models.errAdminList = ($scope.adminList.length() < 1) ? true : false;

				if($scope.models.errCircleName.length === 0 && !$scope.models.errMemberList) {
					return true;
				} else {
					return false;
				}
                return valid;
			}
		}

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.circle')
		.controller('CirclePageController', CirclePageController);

		CirclePageController.$inject = ['$scope', '$routeParams', '$location', 'circlesManager', 'friendsFactory', 'Auth', '$ringbox',
			'SystemEvents',  '$$connector','OPERATION_TYPES','circleHttpService', '$timeout', 'APP_CONSTANTS', 'Ringalert', 'rgDropdownService', '$rootScope'];
		function CirclePageController($scope, $routeParams, $location, circlesManager, friendsFactory, Auth,  $ringbox, // jshint ignore:line
                                      SystemEvents, $$connector,OPERATION_TYPES,circleHttpService, $timeout, APP_CONSTANTS, Ringalert, rgDropdownService, $rootScope) {
			var vm = this;

			var circleId = $routeParams.circleId;
			var subpage = $routeParams.subpage;
			$scope.loadMoreCircleMember = false;
			$scope.showSearchLoader = false;
			$scope.hideLoadButton = false;
			$scope.currentUserUId = Auth.currentUser().getUId();
			circlesManager.getCirclePromise(circleId).then(function(circle){
				if(circle){
					vm.circle = circle;
					$scope.isCurrentUserAdmin = vm.circle.isAdmin();
					$scope.isCurrentUserSuperAdmin = vm.circle.isSuperAdmin($scope.currentUserUId);
					//requestForCircleMembers();
					if(subpage==='members'){
						requestForCircleMembers();
					}
					pageInit();
				}else{
					circlesManager.redirectHome();
				}

			},function (reason){
				   circlesManager.redirectHome();
			});



			/* Fixed Data to Init */
			vm.ddHtml = 'pages/dropdowns/circle-edit-dropdown.html';//$templateCache.get('circle-edit-dropdown.html');
			vm.ddAction = openConfirmation;
			vm.ddControl = {
				isAdmin : $scope.isCurrentUserAdmin,
				isSuperAdmin : $scope.isCurrentUserSuperAdmin,
				getCircleData : function(){
                    rgDropdownService.close();
					return { circleId : circleId };
				}
			};


			vm.ddMemberHtml = 'pages/dropdowns/circle-member-dropdown.html';//$templateCache.get('circle-member-dropdown.html');
			vm.ddMemberAction = circleMemberAction;

			vm.removeMember = removeMember;

			if (angular.isUndefined($routeParams.subpage)) {
				vm.subPage = 'post';
			} else {
				vm.subPage = $routeParams.subpage;
			}

			vm.subPageLink = 'pages/home/circle.' + vm.subPage + '.html';

			/* Dynamic Data */

          //  vm.circle = circlesManager.getCircle(circleId);

			vm.isCurrentUserAdmin = false;
			vm.isCurrentUserSuperAdmin = false;

			vm.getFriendType = function(memberObj){
				return memberObj.friendshipStatus();
			};

			if(!!vm.circle){
				$scope.isPageReady = false;
				if(!$scope.circleMembers.length){
					requestForCircleMembers();
				}

			}else{
				$scope.isPageReady = false;

			}

			var friendStatuses = [APP_CONSTANTS.NOT_FRIEND , APP_CONSTANTS.OUTGOING_FRIEND];

			vm.shouldShowMemberEditMenu = function(memberObj){

				//console.log( vm.isCurrentUserAdmin ,  vm.isCurrentUserSuperAdmin, !vm.circle.isSuperAdmin(memberObj.getKey()) )

				return  !memberObj.isCurrentUser()
					&&
					(( vm.isCurrentUserSuperAdmin ||  (vm.isCurrentUserAdmin && !memberObj.isAdmin(circleId))) || ( friendStatuses.indexOf(memberObj.friendshipStatus()) !== -1 ))
					&&
					( !vm.circle.isSuperAdmin(memberObj.getKey()) );

			};

			//vm.getMemberEditMenuControl = function (memberObj) {
			//	return {
			//		isAdmin: memberObj.isAdmin(vm.circle.getKey()),
			//		isSuperAdmin: vm.isCurrentUserSuperAdmin,
			//		member: memberObj,
			//		friendShipType: vm.getFriendshipType(memberObj)
			//	}
			//};

			vm.memberListSubscriptionKey = $$connector.subscribe(circlesManager.processCircleMembersData,
				{action:OPERATION_TYPES.SYSTEM.CIRCLE.TYPE_GROUP_MEMBERS_LIST}
			);
			vm.searchListSubscriptionKey = $$connector.subscribe(circlesManager.processCircleSearchMembersData,
				{action:OPERATION_TYPES.SYSTEM.CIRCLE.TYPE_GROUP_MEMBERS_SEARCH_RESULT}
			);

			$scope.$on(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_PROCESS_COMPLETE, function(event,data){
				RingLogger.print(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_PROCESS_COMPLETE, RingLogger.tags.CIRCLE);
				$scope.loadMoreCircleMember = false;
				$scope.showSearchLoader = false;
				if(!data.success){
					$scope.hideLoadButton = true;
				}else{
					$scope.hideLoadButton = false;
				}
				pageInit();
                $scope.$rgDigest();
			});

   //     $scope.$on(SystemEvents.CIRCLE.MY_CIRCLE_LIST_PROCESS_COMPLETE, function(){
			// 	RingLogger.print(SystemEvents.CIRCLE.MY_CIRCLE_LIST_PROCESS_COMPLETE, RingLogger.tags.CIRCLE);
			// 			if(!vm.circle){
			// 				vm.circle = circlesManager.getCircle(circleId);
			// 				if(vm.circle){
			// 					requestForCircleMembers();
			// 				}

			// 			}

   //       });

      		$scope.$on(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE, function(){
				RingLogger.print(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE, RingLogger.tags.CIRCLE);
				setMembers();
		  		$scope.$rgDigest();
			});


			$scope.$on(SystemEvents.CIRCLE.MY_CIRCLE_REMOVED, function($event, data){
				RingLogger.print(data, RingLogger.tags.CIRCLE);
				if(data.circleId === $routeParams.circleId){

					Ringalert.show('Circle has been Removed OR You have been removed from the circle.', 'info');

					$timeout(function(){
						$location.path('/');
					});
				}
			});


			$scope.cMemberSearch = function () {
				if( vm.searchParam ) {
					$scope.showSearchLoader = true;
					//$scope.hideLoadButton = true;
					circlesManager.getMemberResult(vm.searchParam,circleId);
				}else{
					$scope.hideLoadButton = false;
				}
				$scope.$rgDigest();
			};


			$scope.loadMoreMembers = function () {
				if( vm.searchParam ){
					$scope.showSearchLoader = true;
					circlesManager.getMemberResult(vm.searchParam,circleId);
					console.log('load more search');
				}else{
					var lim = 20;
					$scope.loadMoreCircleMember = true;
					circlesManager.getCircleMembers(circleId,null,lim);
					console.log('load more member');
				}
				$scope.$rgDigest();

			};


			$scope.$on('$destroy', function() {
				if (vm.circle) {
					vm.circle.resetMembers(); //.reset();
				}
				$$connector.unsubscribe(vm.memberListSubscriptionKey);
				$$connector.unsubscribe(vm.searchListSubscriptionKey);
			});



			function pageInit(){
				if( vm.circle ){
					$scope.isPageReady = true;
					setMembers();
					//if($scope.circleMembers.length > 0){
						//setPageSettings();
					//}
					setPageSettings();
				}

			}

			function setPageSettings(){

				vm.isCurrentUserAdmin = $scope.currentUser.isAdmin(vm.circle.getKey());

				vm.isCurrentUserSuperAdmin = vm.circle.isSuperAdmin(Auth.currentUser().getKey());

				/** For Circle Edit DropDown **/
				vm.ddControl.isAdmin = vm.isCurrentUserAdmin;
				vm.ddControl.isSuperAdmin = vm.isCurrentUserSuperAdmin;

			}

			function setMembers(){
				$scope.circleMembers = vm.circle.getAllMembers();
                $scope.$rgDigest();
			}

			function requestForCircleMembers(){
				circlesManager.getCircleMembers(circleId,0);
			}


			function removeMember(memberKey) {
				circlesManager.removeMember(memberKey, vm.circle);
			}

			function circleMemberAction(actionObj) {
				RingLogger.print(actionObj, RingLogger.tags.CIRCLE);
				switch(actionObj.action) {
					case 'remove':
						circlesManager.removeMember(actionObj.member.getKey(), vm.circle);
						break;

					case 'changemember':

						circlesManager.toggleMembership(
                            {
                                grpId: vm.circle.getKey(), uId: actionObj.member.getKey(), admin: Boolean(actionObj.admin)
                            },
                            vm.circle
                        );

						break;

					case 'addFriend' :

						friendsFactory.addFriend( {
							friend: actionObj.member, ct: 2
						});

						break;
					case 'cancel' :
						friendsFactory.rejectFriendRequest({friend: actionObj.member});
						break;

					default:
						RingLogger.warning('ERR! No matching action', RingLogger.tags.CIRCLE);
				}
                $scope.$rgDigest();

			}


            function openConfirmation(actionObj) {
                var message = 'Are you sure you want to ' + actionObj.action + ' ' + vm.circle.getName() +'?';

                var boxInstance = $ringbox.open({
                        type : 'remote',
                        scope:false,
                        controller: 'RingBoxConfirmController',
                        resolve : {
                            localData : {
                                message : message
                            }
                        },
                        templateUrl : 'pages/partials/ringbox-confirm.html'
                });

                boxInstance.result.then(function(confirmed){
                    if(confirmed){
                        circleAction(actionObj);
                    }
                });
            }

			function circleAction (actionObj) {
				RingLogger.print(actionObj.action, RingLogger.tags.CIRCLE);
				switch(actionObj.action) {
					case 'delete':
						circlesManager.deleteCircle(vm.circle).then(function(response) {
							RingLogger.print(response, RingLogger.tags.CIRCLE);
							if (response.sucs === true) {
								$location.path('/');
                                $rootScope.$rgDigest();
                            } else {
                                $scope.$rgDigest();
                            }
						}, function(errData) {
							RingLogger.warning(errData, RingLogger.tags.CIRCLE);
                            $scope.$rgDigest();
						});
						break;
					case 'leave':
						circlesManager.leaveGroup(vm.circle).then(function(response) {
							RingLogger.print(response, RingLogger.tags.CIRCLE);
							if (response.sucs === true) {
								$location.path('/');
							}
                            $scope.$rgDigest();
						},function(errData) {
							RingLogger.warning(errData, RingLogger.tags.CIRCLE);
                            $scope.$rgDigest();
						});
						break;
					default:
                        RingLogger.warning('ERR! No matching action', RingLogger.tags.CIRCLE);
				}

			}



		}

})();



(function() {
    'use strict';
    var feedApp;
      feedApp = angular
            .module('ringid.feed', [
              'ngWebSocket','ringid.utils','ringid.config','ringid.connector'
            ]);
            
            
})();
(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
                .module('ringid.feed', [
                    'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config', 'ringid.media'
                ]);
    }


    feedApp.factory("$$feedMap",$$feedMap);

    $$feedMap.$inject =  ['Auth', 'settings',

        '$$stackedMap', '$$imageMap', 'Media', '$$mediaAlbumMap', '$$mediaMap',
        'userFactory', 'utilsFactory', 'circlesManager', '$sce',
        'EmotionFactory',
        'MESSAGES','OPERATION_TYPES'];

    function $$feedMap(Auth, settings,

        $$stackMap, $$imageMap, Media, $$mediaAlbumMap, $$mediaMap,
        User, utilsFactory, circlesManager, $sce,
        EmotionFactory,
        MESSAGES,OPERATION_TYPES) {


            var keyPrefix = "nf_",
                sortBy = 'tm',
                self = this,
                messages = MESSAGES.FEED,
                OTYPES = OPERATION_TYPES.SYSTEM;

                /**
                 * [feedConditionalReplacer : replace || macthes with condition]
                 * @param  {String} str     [description]
                 * @param  {array} conditions [arrays of condition to be replaced]
                 * @return {[string]}            [replaced string will be return]
                 * @example : for string i have||has posted in||at
                 * it will look for too condition in condiotions array, in 0 condtion. if first matched is true
                 * left portion of the pipe(||) will remain otherwise the right part
                 */
                function feedConditionalReplacer(str,conditions){
                        var i=0; conditions = conditions || [];
                        str = str.replace(/(\w+)?\|\|(\w+)?/g,function(match,p1,p2){
                            if(conditions[i] !== undefined){
                                return !!conditions[i]?p1:p2;
                            }else{
                                return "";
                            }
                        });
                        return str.replace(/(\s){2,}/g," ");// replacing two or more spaces into one
                }

                /** Feed Create Private Functions Start **/

                function __getRawFeedObject(_d){

                    var key = keyPrefix + _d.nfId;

                    return {
                        key: key,
                        nfId: _d.nfId || 0, /* News Feed Id */
                        utId : _d.utId || 0,
                        isNew: _d.isNew || 0, // when is new one the its needed to add on the first cell top by default it will be on top for tm sorting
                        location: _d.lctn || '',
                        lat : _d.lat || 9999, //default 9999
                        lng : _d.lng || 9999, //default 9999
                        groupName: _d.gNm || "",
                        grpId: _d.grpId || 0,
                        text: _d.sts || "", // emoticon replace needed here
                        stsTags: _d.stsTags || [], // emoticon replace needed here
                        imageTotal: _d.tim || 0,
                        imageType: _d.imT || 0,
                        medias:[],
                        audios : [],
                        album: {},
                        friend: !!_d.fndId ? User.getUser(_d.fndId) : false,
                        whoShare: _d.whoShare || {},
                        type: _d.type || 0,
                        mdLst : _d.mdLst || [],
                        tm: _d.tm ? _d.tm : Date.now(), // tm need to keep raw for sorting
                        //time : $filter('date')(new Date(_d.tm),DATE_FORMAT),
                        at: _d.at ? _d.at : Date.now(),
                        ic: _d.ic || 0, //current user comment 0/1
                        il: _d.il || 0, //current user like 0/1
                        is: _d.is || 0, //current user share
                        nc: _d.nc || 0, //number of comment
                        nl: _d.nl || 0, //number if like
                        ns: _d.ns || 0, //number of share
                        sc: _d.sc, // feed text more than 1000 word/char
                        tfc : _d.tfc || 0, //total tag friend count
                        stp : _d.stp || 0, //feed sub type SINGLE_AUDIO_FEED_SHARED = 1; SINGLE_VIDEO_FEED_SHARED = 2; required building feed message
                        fc : _d.fc || 0,//feed category GENERAL_FEED = 0;SPECIAL_FEED = 1;
                        orginal: {}, // orginal feed if its a shared feed
                        message : '' ,//tile message assigned in bottom
                        subMessage : '',//submessage shows last activty message assgined in bottom
                        activity : _d.actvt || 0, //
                        afn : _d.afn || "", //activity first name
                        auId : _d.auId || 0,//activity utId
                        pending : _d.pending || false,
                        lnkDmn: _d.lnkDmn || '',
                        lnkDsc: _d.lnkDsc || '',
                        lnkTtl: _d.lnkTtl || '',
                        lnkURL: _d.lnkURL || '',
                        lnlImgURL: _d.lnlImgURL || '',
                        /** Client Side Property  */
                        viewColumn : _d.viewColumn || '',
                        fTgLst : _d.fTgLst || [],

                        oldMessage : '',
                        ogData : {}
                    }; //initalize feed basic object on response

                }

                function __updateRawFeedObject(feed, json, doNotupdateTm){

                    if(!!json.lat){
                        feed.lat = json.lat;
                        feed.lng = json.lng;
                    }

                    if(!!json.lctn){
                        feed.lctn = json.lctn;
                        feed.location = json.lctn;

                    }else{

                        if( json.lat === 9999){
                            feed.location = '';
                            feed.lctn = '';
                        }
                    }


                    if(!!json.gNm){
                        feed.gNm = json.gNm;
                        feed.groupName = json.gNm;
                    }

                    if(!!json.grpId){
                        feed.grpId = grpId;
                    }

                    if(!!json.sts){
                        feed.text = json.sts;
                    }

                    if(!!json.tim){
                        feed.imageTotal = json.tim;
                    }

                    if(!!json.imT){
                        feed.imageType = json.imT;
                    }

                    if(!!json.mdLst){
                        feed.mdLst = json.mdLst;
                    }


                    if(!!json.ic){
                        feed.ic = json.ic;
                    }

                    if(!!json.il){
                        feed.il = json.il;
                    }

                    if(!!json.is){
                        feed.is = json.is;
                    }

                    if(!!json.nc){
                        feed.nc = json.nc;
                    }

                    if(!!json.nl){
                        feed.nl = json.nl;
                    }

                    if(!!json.ns){
                        feed.ns = json.ns;
                    }

                    if(!!json.sc){
                        feed.sc = json.sc;
                    }

                    if(!!json.tfc){
                        feed.tfc = json.tfc;
                    }

                    if(!!json.actvt){
                        feed.activity = json.actvt;
                    }

                    if(!!json.afn){
                        feed.afn = json.afn;
                    }

                    if(!!json.auId){
                        feed.auId = json.auId;
                    }

                    if(!!json.lnkDmn){
                        feed.lnkDmn = json.lnkDmn;
                    }

                    if(!!json.lnkDsc){
                        feed.lnkDsc = json.lnkDsc;
                    }

                    if(!!json.lnkTtl){
                        feed.lnkTtl = json.lnkTtl;
                    }

                    if(!!json.lnkURL){
                        feed.lnkURL = json.lnkURL;
                    }

                    if(!!json.lnlImgURL){
                        feed.lnlImgURL = json.lnlImgURL;
                    }

                    if(!!json.fTgLst){
                        feed.fTgLst = json.fTgLst;
                    }

                    if(!doNotupdateTm){
                        feed.tm = json.tm || Date.now();
                    }

                }

                function __getUtf8Fields(){
                    return [

                        'location', 'lctn', 'lnkDmn',  'lnkDsc', 'lnkTtl', 'lnkURL', 'lnlImgURL'

                    ];
                }

                function __getUserCardString(){
                    return '<user-card user="feed.user()"></user-card>';
                }

                function __setFeedUser(feed, _d, user){

                    if (angular.isDefined(user)) {
                        feed.user = user;
                    } else {
                        if(_d.utId){
                            feed.user = User.getByUtId(_d.utId);
                        }else if(_d.uId){
                            feed.user =  User.getUser(_d.uId);
                        }else{
                            feed.user = false;
                        }
                        if(!feed.user){
                            var uOb = {};
                                if(_d.uId){
                                    uOb.uId = _d.uId;
                                }
                                if(_d.utId){
                                    uOb.utId = _d.utId;
                                }
                                if(_d.fn){
                                    uOb.fn = _d.fn;
                                }
                                if(_d.prIm){
                                    uOb.prIm = _d.prIm;
                                }
                            feed.user = User.create(uOb);
                        }
                    }//updating feed user

                }

                function __initImageMap(imageList, $images,feed){
                    var temp;

                    if (!!imageList) {
//                        setImages(_d.imageList)
                        var loopIndex = 0;
                        if (angular.isArray(imageList) && imageList[loopIndex].getMapKey) {
                            for (loopIndex = 0; loopIndex < imageList.length; loopIndex++) {
                                $images.add(imageList[loopIndex].getMapKey(), imageList[loopIndex]);
                            }
                        } else {
                            try {
                                temp = angular.isString(imageList) ? angular.fromJson(imageList): imageList;
                            } catch (e) {
                            }
                            var imlength = temp.length > 3 ? 3 : temp.length;
                            for (loopIndex = 0; loopIndex < imlength; loopIndex++) {
                                // temp[i].link = settings.imBase + temp[i].iurl;
                                temp[loopIndex].nfId = feed.nfId;
                                temp[loopIndex] = $$imageMap.create(temp[loopIndex],feed.user);
                                $images.add(temp[loopIndex].getMapKey(), temp[loopIndex]);
                            }
                            // console.log($images.all());
                        }
                        //$images.sort('desc', 'sortByTime');//sort is not needed using default sort by id as image layout requires

                    }//if response have images then pushing into image map
                  feed.images = $images;
                  switch($images.length()){
                      case 1:
                          feed.imlayout = 5;
                          break;

                      case 2:
                          feed.imlayout = 4;
                          break;
                      default:
                          feed.imlayout = feed.nfId % 4;
                          break;
                  }

                }

                function __initFeedMedias(feed, mdaCntntLst, $medias, $audios){
                    if(!!mdaCntntLst) {
                        var albumMap,user = feed.stp > 0?null:feed.user;

                        if (mdaCntntLst.length > 0) {
                            albumMap = Media.getAlbum(mdaCntntLst[0].albId);
                            if (!albumMap) {
                                albumMap = $$mediaAlbumMap.createAlbum({
                                    albId: mdaCntntLst[0].albId,
                                    albn: mdaCntntLst[0].albn,
                                    mdaT: mdaCntntLst[0].mdaT
                                });
                            }
                        }

                        if (albumMap.isAudio()){

                            $audios =  albumMap.pushContent(mdaCntntLst, user,feed.nfId,$audios);
                        } else if (albumMap.isVideo()){
                            $medias = albumMap.pushContent(mdaCntntLst, user,feed.nfId,$medias);
                        }
                        feed.album = albumMap;

                        //feed.medias = $medias.length() ? $medias.sliceBy(3,0):[];
                        //feed.audios = $audios.length() ? $audios.sliceBy(3,0):[];
                        feed.medias = $medias;
                        feed.audios = $audios;
                    }

                }

                function __checkForFriendFeed(feed, friendId, friendFirstName, friendLastName){
                    // check if feed is posted on a friend wall
                    if (!!friendId && !feed.friend) {
                        feed.friend = User.create({
                            uId: friendId,
                            fn: friendFirstName,
                            ln: friendLastName
                        });
                    }
                }

                function __initFeedFeelings(feed){

                    // mdIds  : process(feelings)
                    feed.feelings = {};
                    if(feed.mdLst.length){
                        feed.feelings = EmotionFactory.getEmotion(feed.mdLst[0],true);
                    }

                }

                function _setTagUsers(feed, feedTagList, feedTagFriendCount){

                    if(!feedTagList){
                        feedTagList = feed.fTgLst;
                    }else{
                        feed.fTgLst = feedTagList;
                    }

                    feed.tagUsers.length = 0;
                    if(feedTagList && feedTagList.length){

                        for(var i = 0;i < feedTagList.length;i++){

                            feedTagList[i].fn = feedTagList[i].nm;

                            feed.tagUsers.push(User.createByUtId(feedTagList[i]));
                        }
                    }


                    if(angular.isDefined(feedTagFriendCount)){
                        feed.tfc = feedTagFriendCount;
                    }
                }

                function __initFeedTags(feed, feedTagList){

                    feed.tagUsers = [];
                    _setTagUsers(feed, feedTagList);

                }

                function __setFeedTopMessage(feed, ob){
                    if(feed.activity > 0){

                        // todo : when this is a share feed check if afn comes in orginal or whoshare
                        if(!!ob){
                            feed.afn = ob.fn;
                            feed.activity = 2;
                        }
                        feed.subMessage = "";

                        if(feed.activity && !!MESSAGES.FEED['ACT_'+feed.activity]){
                            var activity_user = User.getByUtId(feed.auId), acmessage = '<b>You</b>';

                            if(activity_user){
                                if(!activity_user.isCurrentUser()){
                                    acmessage = '<user-card user="feed.getActivityUser()"></user-card>';
                                }
                            }else{

                                if(Auth.currentUser().getUtId() !== feed.auId){
                                    activity_user = User.createByUtId({fn:feed.afn,utId:feed.auId},true);

                                    acmessage = '<user-card user="feed.getActivityUser()"></user-card>';
                                }
                            }

                            feed.activityUser = activity_user;

                            acmessage = MESSAGES.FEED['ACT_'+feed.activity].format(acmessage);

                            feed.subMessage =(acmessage);
                        }

                        feed.subMessage =  $sce.trustAsHtml ( feed.subMessage );

                    }
                }

                function __initFeedTime(feed) {
                    /**
                     * @note : if order changes of comments stackmap,then in feed factory there is firstComment and lastCommnet Api to be changed
                     */
                    if (feed.at) {
                        feed.time = utilsFactory.verbalDate(feed.at);
                    } else {
                        feed.time = "";// preventing from throwing error
                    }
                }//setting and updating time

                function __parseStatus(feed) {
                         var usr,text_spilit = [];
                    if (feed.text || feed.stsTags) {
                        if(feed.stsTags && feed.stsTags.length){
                            var start=0,end;
                            feed.stsTags.sort(function(a,b){
                                return b.pstn > a.pstn ? -1:1;
                            });
                            for(var i=0;i<feed.stsTags.length;i++){
                                // for security make this glue dynamic
                                //end = feed.stsTags[i].pstn - start+1;
                                end = feed.stsTags[i].pstn - start;
                                usr = User.create(feed.stsTags[i]);
                                if(end > 0){
                                    text_spilit.push(utilsFactory.parseForLE(feed.text.substr(start,end)));    
                                }                                
                                text_spilit.push(usr.getLink({'class' : 'sts-tag','contenteditable':"false",'data-link':usr.getUtId()}));
                                start = feed.stsTags[i].pstn;
                            }
                             end = feed.text.length - start;
                             if(end > 0){
                                text_spilit.push(utilsFactory.parseForLE(feed.text.substr(start,end)));
                             }
                             RingLogger.print(text_spilit,"STSTAG");
                             feed.feedHtml = text_spilit.join("");
                        }else{
                            feed.feedHtml = utilsFactory.parseForLE(feed.text);
                        }
                        feed.feedHtml = $sce.trustAsHtml(feed.feedHtml);
                    }else{
                        feed.feedHtml = "";
                    }
                }

                function __addPostfixMessage(feed){

                    feed.message = feed.oldMessage;

                    if(!!feed.mdLst.length){
                        feed.message += '<span class="feelings-text">&nbsp;feeling</span> <img class="feed_emo" src="'+feed.feelings.url+'" />&nbsp;'+feed.feelings.nm;
                    }

                    if(!!feed.tagUsers.length){
                        feed.message += '&nbsp;<feed-tag-more-user tag-feed="feed"></feed-tag-more-user>';
                    }

                    if(feed.location){
                        feed.message += '<location-card feed="feed"></location-card>';
                    }

                }

                function __processFeedMessage(feed, userCardString){

                    var circleGroupPrefix = '',subtype;

                    if(!!feed.friend){
                        circleGroupPrefix='F';

                    }else if(feed.grpId){

                        feed.circle = circlesManager.getCircle(feed.grpId);
                        circleGroupPrefix = 'C';

                    }

                    var replacer = [userCardString];

                    switch(feed.type){
                        case OTYPES.NEWS_FEED_TYPE_IMAGE://1

                            if(feed.images.length() > 0){

                                feed.message = messages['TYPE_1' + feed.images.top().getImageType() + circleGroupPrefix] || messages['TYPE_D'];
                                feed.message = feedConditionalReplacer(feed.message,[feed.user.isCurrentUser()]);

                            }else{

                                feed.message = messages['TYPE_D']; //default
                            }
                            break;

                        case OTYPES.NEWS_FEED_TYPE_STATUS://2

                            feed.message = messages['TYPE_2'+circleGroupPrefix];
                            break;

                        case OTYPES.NEWS_FEED_TYPE_MULTIPLE_IMAGE://3

                            feed.message = messages['TYPE_'+feed.type];
                            feed.message = feedConditionalReplacer(feed.message,[feed.user.isCurrentUser()]);
                            replacer.push(feed.imageTotal);
                            break;

                        case OTYPES.NEWS_FEED_TYPE_ALBUM://4
                        case OTYPES.NEWS_FEED_TYPE_AUDIO://5
                        case OTYPES.NEWS_FEED_TYPE_VIDEO://6
                            subtype = feed.stp || 0;
                            feed.message = messages['TYPE_'+feed.type+subtype];
                            replacer.push('<user-card class="share-user" user="feed.getSingleContent().user()"></user-card>')
                            break;
                        default:

                            feed.message = messages['TYPE_D'];
                            break;
                    }

                    if(!!feed.friend){
                        feed.message += " " + messages['F_POSTFIX'].format('<user-card class="wall-user" user="feed.getTargetWall()"></user-card>');
                    }else if(feed.grpId){
                        feed.message += " " + messages['C_POSTFIX'].format(!angular.equals({},feed.circle) ? feed.groupName:feed.circle.getAnchor());
                    }

                    feed.message = feed.message.format(replacer);

                    feed.oldMessage = feed.message;

                }

                function __setStatusMessageForShareFeed(feed, userCardString) {

                    var temstr = userCardString;

                    if(feed.orginal.getTotalShare() > 1){
                        temstr += "and "+(feed.orginal.getTotalShare() - 1)+" other people";
                    }

                    var repl = [userCardString];

                    feed.message = messages['TYPE_SHARE'];

                    repl.push('<user-card class="share-user" user="feed.getOrginalFeed().user()"></user-card>');

                    feed.message = feed.message.format(repl);

                    feed.oldMessage = feed.message;

                    __addPostfixMessage(feed);
                }

                function __initOgData(feed){
                    feed.ogData['image'] = feed.lnlImgURL;
                    feed.ogData['description'] = feed.lnkDsc;
                    feed.ogData['title'] = feed.lnkTtl;
                    feed.ogData['url'] = feed.lnkURL;
                    feed.ogData['lnkDmn'] = feed.lnkDmn;
                }

                function __initLocationData(feed){
                    if(feed.lat !== 9999){
                        feed.locationData = { description: feed.location, lat : feed.lat, lng: feed.lng };
                    }else{
                        feed.locationData = { description: feed.location };
                    }

                }

                function __feedInit(feed, _d, user, $images, $medias, $audios, userCardString, utf8fields){

                    //General Props
                   // feed.whoLikes = $$stackMap.createNew();//who likes initialization
                    feed.circle = {}; // circle initialization for circle fee
                   // feed.images = $images;


                    // assigning user
                    //updating feed.user
                    __setFeedUser(feed, _d, user);

                    //if response have images then pushing into image map
                    __initImageMap(_d.imageList, $images,feed);

                    //set medias
                    __initFeedMedias(feed, _d.mdaCntntLst, $medias, $audios);

                    //check for friend feed
                    __checkForFriendFeed(feed, _d.fndId, _d.ffn, _d.fln);

                    //Init Feed Feelings
                    __initFeedFeelings(feed);

                    //Init Feed Tags
                    __initFeedTags(feed, _d.fTgLst);

                    //Update Feed Time
                    __initFeedTime(feed); // update time while creating

                    //set feed top message
                    __setFeedTopMessage(feed);

                    __processFeedMessage(feed, userCardString);

                    __addPostfixMessage(feed);

                    __initOgData(feed);

                    __initLocationData(feed);

                    //__setStatusMessageForShareFeed(feed, userCardString);

                    // linkify or emotify
                    __parseStatus(feed);//initial parsing



                }

                /** Feed Create Private Functions End **/


            return {
                getPrefix: function () {
                    return keyPrefix;
                },
                setSortKey : function(key){
                    sortBy = key;
                },
                setPrefix: function (prefix) {
                    keyPrefix = prefix;
                },
                getSortIndex: function () {
                    return sortBy;
                },
                makeKey: function (key) {
                    return keyPrefix + key;
                },

                create: function (_d, user) {

                    var feed, key, $images, $medias, $audios, userCardString, utf8fields, shareUsers,identicalFeed;

                    utf8fields = __getUtf8Fields();
                    userCardString = __getUserCardString();
                    shareUsers = [];

                    if(!$images){

                        $images = $$stackMap.createNew(true,'asc');//creating empty omage stacked map
                        $medias = $$stackMap.createNew();//creating empty video stacked map
                        $audios = $$stackMap.createNew();//creating empty video stacked map
                    }

                    

                    key = keyPrefix + _d.nfId;

                    feed = __getRawFeedObject(_d);
                    feed.images = $images;
                    feed.medias = $medias;
                    feed.audios = $audios;
                    //General Feed Init
                    __feedInit(feed, _d, user, $images, $medias, $audios, userCardString, utf8fields);


                    function isSingleContentFeed(){

                            return (feed.images.length() === 1 || feed.medias.length() === 1 || feed.audios.length() === 1);
                    }

                    function getSingleContent(){
                            return (feed.images.length() && feed.images.bottom()) || (feed.medias.length() && feed.medias.bottom()) || (feed.audios.length() && feed.audios.bottom()) || feedMapObjectToReturn;
                    }

                    if(isSingleContentFeed()){
                        var content = getSingleContent();
                        if(!feed.images.length()){
                            feed.is = content.share();   
                            feed.ns = content.getTotalShare(); 
                        }
                        
                        
                        feed.ic = content.selfComment();
                        feed.nc = content.getTotalComment()
                    }

                    var feedMapObjectToReturn =  {
                        getFeedRaw : function(){
                            /* for debug  */
                            return feed;
                        },
                        ddControl: {
                            feedKey: feed.nfId,
                            showEdit: function () {
                                return (feed.user.isCurrentUser() && feed.nl < 1) ? true : false;
                            },
                            feedUser: function () {
                                return feed.user;
                            },
                            tagButtonText : function(){
                                return feed.tagUsers.length ? 'Edit Tag' : 'Add Tag';
                            },
                            showDelete : function(){
                               return feed.user.isCurrentUser() || feed.friend && feed.friend.isCurrentUser();
                            },
                            showTagButton : function(){
                                return feed.user.isCurrentUser() && !feed.grpId;
                            }
                        },
                        isEmpty : function(ignore){ //ignore is object it should contain the property to ignore check
                            ignore = ignore || {};

                            return !feed.text || (ignore.tagUsers && feed.tagUsers.length);
                        },
                        isSpecial : function(){
                            return feed.fc > 0;
                        },
                        isFeed : true,
                        setIdenticalFeed : function(f){
                            identicalFeed = f;
                        },
                        getByProperty: function (property_name, return_default) {
                            return_default = return_default || false;
                            return feed.hasOwnProperty(property_name) ? feed[property_name] : return_default;
                        },
                        showMore : function(){
                            return !!feed.sc;
                        },
                        getKey: function () {
                            return feed.nfId;
                        },
                        sortBy: function () {
                            return feed[sortBy] || feed['tm'];
                        },
                        getMapKey: function () {
                            return feed.key;
                        },
                        setFeedKey: function (key) {
                            feed.nfId = key;
                        },
                        getFeedKey: function (key) { // used by rg like. cause all media image have feed key so for keeping same api name this has been added
                            return feed.nfId;
                        },
                        user: function () {
                            return feed.user;
                        },
                        isTimelinePost : function(){
                            return feed.friend && feed.friend.isCurrentUser();
                        },
                        checkMessageUpdated : function(){
                            return feed.message + feed.location + feed.tagUsers.reduce(function(prev,curr){
                                return prev.toString() + curr.toString();
                            },"") + feed.tfc;
                        },
                        getMessageText: function () {
                            return feed.message;
                        },
                        isWallPost : function(){
                            return !!feed.friend;
                        },
                        isCirclePost : function(){
                            return feed.grpId > 0;
                        },
                        getTargetWall : function(){
                            return feed.friend;
                        },
                        getTargetCircle : function(){
                            return angular.equals({},feed.circle) ? feed.groupName:feed.circle;
                        },
                        text: function () {
                            return feed.text;
                        },
                        getDynamicText: function () {
                            return feed.feedHtml;
                        },
                        getDynamicTextMore: function (words, uid) {
                            words = parseInt(words)>0 ? parseInt(words): 20;
                            var ptrn = '(', text,
                                fhtml = utilsFactory.parseForLE(feed.text);
                            for (var i = words; i > 0; i--) {
                              ptrn += '[\\S]+\\s';
                            }
                            ptrn +=')(.*)';
                            text = fhtml.replace(new RegExp(ptrn),'<span class="with-more"><input id="read'+uid+'" type="checkbox" /><span class="less">$1</span><span class="more">$2</span><label for="read'+uid+'" class="trigger"></label></span>');
                            return $sce.trustAsHtml(text);
                        },
                        hasActivityMessage : function(){
                            //console.info(feed.subMessage,!!feed.subMessage,"feedMessage");
                          return feed.activity > 0;
                        },
                        setActivity : function(json){
                            feed.activity = json.actvt || 0;
                            feed.afn = json.afn;
                            feed.auId = json.auId;
                            __setFeedTopMessage(feed);
                        },
                        setFeedTopMessage: function(){
                            __setFeedTopMessage(feed);
                        },
                        getActivityMessage : function(i, k, fe){
                           // console.log("scope Id : "+ i +"  parent index : " + k ,"  feed : "+fe.getKey());
                           // console.dir(fe);
                          return feed.subMessage;
                        },
                        getActivityUser : function(){
                            return feed.activityUser;
                        },
                        getLocationText : function(){
                           return feed.location;
                        },
                        getLocationShortText : function(){
                           if( !!feed.location ){
                              var location = feed.location;
                              var parts = feed.location.split(',');

                              if( parts.length > 2){
                                   location = parts[0].replace("(", "");
                              }

                              if( location.length > 30){
                                   location = location.substr(0, 30) + '...';
                              }
                              return location;
                           }                                                      
                        },
                        setLocationText : function(location){
                           feed.location = location;
                            __addPostfixMessage(feed);
                            return location;
                        },
                        resetLocationText : function(){
                            feed.location = '';
                        },
                        isMediaShared : function(){
                            return feed.stp > 0;
                        },
                        isSingleContentFeed : isSingleContentFeed,
                        getContentType : function(){
                            var a;
                            if(feed.images.length()){
                                a = 'image';
                            }else if(feed.medias.length()){
                                a = 'media';
                            }else if(feed.audios.length()){
                                a = 'media';
                            }else {
                                a = 'feed';
                            }
                            return a;
                        },
                        getSingleContent : getSingleContent,
                        hasLocationInfo: function(){
                            return feed.location !== '' && !feed.lnkURL && !feed.text && !feed.images.length() && !feed.medias.length() && !feed.audios.length();
                        },
                        validateForUpdateTag : function(){

                            return feed.location !== '' || feed.lnkURL || feed.text ||  feed.images.length()  || feed.medias.length() ||  feed.audios.length();

                        },
                        getLocationInfo : function(){
                            return feed.locationData;
                        },

                        getLocationUrl : function(){
                            return $sce.trustAsResourceUrl( utilsFactory.getGoogleMapJSUrl(feed.lat, feed.lng, feed.location, false) );
                        },

                        getLocationEmbedUrl : function(){
                            return $sce.trustAsResourceUrl( utilsFactory.getGoogleMapJSUrl(feed.lat, feed.lng, feed.location, true) );
                        },
                        getLocationStaticEmbedUrl : function(){
                            return $sce.trustAsResourceUrl( utilsFactory.getGoogleMapStaticUrl(feed.lat, feed.lng) );
                        },

                        setLocationInfo : function(location){
                            feed.location = location.description;
                            feed.lat = location.lat;
                            feed.lng = location.lng;
                            __initLocationData(feed);
                            __addPostfixMessage(feed);
                        },

                        setText: function (sts,stsTags) {
                            feed.text = sts;
                            if(stsTags){
                                feed.stsTags = stsTags;
                            }
                            __parseStatus(feed);
                        },
                        time: function () {
                            return feed.time;
                        },
                        setTime: function (tm) {
                            feed.tm = tm;
                            //updateTime();
                        },
                        updateTime: function () {
                            feed.time = utilsFactory.verbalDate(feed.at);
                        },
                        getTimestamp: function(){
                            return feed.tm;
                        },
                        getAtTime: function(){
                            return feed.at;
                        },
                        incomingLike: function (type) {
                            return (type && ++feed.nl) || --feed.nl;
                        },
                        // incomingWhoLikes: function (userJson) {
                        //         var user = User.create(userJson);
                        //         feed.whoLikes.save(user.getKey(), user);
                        // },
                        // getWhoLikes: function () {
                        //     return feed.whoLikes.all();
                        // },
                        like: function (dolike,totalLike) {
                            if (!dolike) {
                                return feed.il;
                            }
                            feed.il = feed.il ^ 1;
                            if(totalLike){
                               feed.nl = totalLike;
                            }else{
                               feed.nl = feed.il ? feed.nl+1 : feed.nl-1;
                            }
                            if(identicalFeed){
                                identicalFeed.like(dolike);
                            }
                            return feed.il;
                        },
                        setTotalLikes: function (nl,il){
                            feed.nl = nl;
                            if(angular.isDefined(il)){
                                feed.il = il;
                            }
                            if(identicalFeed){
                                identicalFeed.setTotalLikes(nl);
                            }
                        },
                        getTotalLikes: function () {
                            return feed.nl;
                        },
                        setTotalComment :function(loc,ic){
                            feed.nc = loc;
                            if(angular.isDefined(ic)){
                                feed.ic = ic;
                            }
                            if(identicalFeed){
                                identicalFeed.setTotalComment(loc);
                            }
                        },
                        getTotalComment: function () {
                            return feed.nc;
                        },
                        selfComment: function () {
                            return feed.ic;
                        },
                        getTotalImages : function(){
                            return feed.imageTotal;
                        },
                        getTotalShare: function () {
                            return feed.ns;
                        },
                        getShareUsers : function(){
                            return feed.orginal.getShareUsers();
                        },
                        addShareUser : function(usr){
                            if(typeof usr == 'array'){
                                shareUsers = shareUsers.concat(usr);
                            }else{
                                shareUsers.push(usr);
                            }
                            return shareUsers;
                        },
                        updateShareMessage : function(){
                            __setStatusMessageForShareFeed(feed, userCardString);
                        },
                        share: function (doShare,totalShare) {

                            if (!doShare) {
                                return feed.is;
                            }
                            feed.is = feed.is ^ 1;
                            if(totalShare){
                               feed.ns = totalShare;
                            }else{
                               feed.ns = feed.is ? feed.ns+1 : feed.ns-1;
                            }                                                        
                            return feed.is;
                        },
                        shares: function (mainFeed) { // mainFeed Is The Feed that Shared Current Feed
                            feed.orginal = mainFeed;
                            feed.orginal.addShareUser(feed.user);
                            __setStatusMessageForShareFeed(feed, userCardString);
                        },
                        getWhoShares: function () {
                            return feed.whoShare;
                        },
                        getOrginalFeed: function () {
                            return feed.orginal;
                        },
                        hasSharedFeed: function () {
                            return !angular.equals({}, feed.orginal);
                        },
                        setImages: function (imageList) {
                            _
                            // var loopIndex = 0, temp;
                            // if (angular.isArray(imageList) && imageList[loopIndex].getMapKey) {
                            //     for (loopIndex = 0; loopIndex < imageList.length; loopIndex++) {
                            //         $images.add(imageList[loopIndex].getMapKey(), imageList[loopIndex]);
                            //     }
                            // } else {
                            //     try {
                            //         temp = angular.fromJson(imageList);
                            //     } catch (e) {
                            //     }
                            //     var imlength = temp.length > 3 ? imlength : temp.length;
                            //     for (loopIndex = 0; loopIndex < imlength; loopIndex++) {
                            //         // temp[i].link = settings.imBase + temp[i].iurl;
                            //         temp[loopIndex] = $$imageMap.create(temp[loopIndex]);
                            //         $images.add(temp[loopIndex].getMapKey(), temp[loopIndex]);
                            //     }
                            // }
                            // //$images.sort('desc', 'sortByTime');
                             __initImageMap(imageList,$images,feed);
                           // feed.images = $images;

                        },
                        hasMedia: function() {
                            return feed.images.length() > 0 || feed.medias.length() > 0 || feed.audios.length() > 0;
                        },
                        getImages: function (map) {
                            // console.dir(feed.images.all());
                            return map ? feed.images : feed.images.all();
                        },
                        getTotalImage : function(){
                            return feed.imageTotal;
                        },
                        //setVideos: function (mdaCntntLst) {
                        //
                        //    var loopIndex = 0;
                        //    //if (angular.isArray(mdaCntntLst) && mdaCntntLst[loopIndex].getMapKey) {
                        //    //    for (loopIndex = 0; loopIndex < mdaCntntLst.length; loopIndex++) {
                        //    //        $videos.add(mdaCntntLst[loopIndex].getMapKey(), mdaCntntLst[loopIndex]);
                        //    //    }
                        //    //}
                        //    //else {
                        //        try {
                        //            temp = angular.fromJson(imageList);
                        //        } catch (e) {
                        //        }
                        //        var imlength = temp.length > 3 ? imlength : temp.length;
                        //        for (loopIndex = 0; loopIndex < imlength; loopIndex++) {
                        //            // temp[i].link = settings.imBase + temp[i].iurl;
                        //            temp[loopIndex] = $$imageMap.create(temp[loopIndex]);
                        //            $images.add(temp[loopIndex].getMapKey(), temp[loopIndex]);
                        //        }
                        //    //}
                        //    //$videos.sort('desc', 'sortByTime');
                        //    feed.videos = $videos;
                        //
                        //},
                        getAlbum: function() {
                            return feed.album;
                        },
                        getMedias: function () {
                            return feed.medias;
                        },
                        getAudios : function(){
                            return feed.audios;
                        },
                        getStrmURL: function() {
                          return feed.strmURL;
                        },
                        getLinkDomain: function(){
                            return feed.lnkDmn;
                        },
                        getLinkUrl : function(){
                            return feed.lnkURL;
                        },
                        getLinkTitle : function(){
                            return feed.lnkTtl;
                        },
                        getLinkDescription : function(){
                            return feed.lnkDsc;
                        },
                        getLinkImageUrl : function(){
                            return feed.lnlImgURL;
                        },
                        hasOgData : function(){
                            return !!(feed.lnlImgURL || feed.lnkTtl || feed.lnkDsc)
                        },
                        getOgData : function(){

                            // if(!feed.ogData){
                            //     feed.ogData = {
                            //     image : feedMapObjectToReturn.getLinkImageUrl(),
                            //     description : feedMapObjectToReturn.getLinkDescription(),
                            //     title : feedMapObjectToReturn.getLinkTitle(),
                            //     url : feedMapObjectToReturn.getLinkUrl(),
                            //     lnkDmn: feedMapObjectToReturn.getLinkDomain()
                            // };
                            // }

                            return feed.ogData;
                        },
                        setOgData : function(ogData){
                            feed.lnkDsc = ogData.lnkDsc || ogData.description ||'' ;
                            feed.lnkTtl = ogData.lnkTtl || ogData.title || '' ;
                            feed.lnkURL = ogData.lnkURL || ogData.url || '' ;
                            feed.lnlImgURL = ogData.lnlImgURL || ogData.image || '' ;
                            feed.lnkDmn = ogData.lnkDmn || ogData.domain || '' ;

                            __initOgData(feed);

                        },
                        parseMoreText: function (feedObj) {
                            feed = angular.extend({}, feed, feedObj);
                            feed.text = feedObj.sts;
                            __parseStatus(feed);
                        },
                        isPending : function(val){
                            if(val !== undefined){
                                feed.pending = !!val;
                            }
                            return feed.pending;
                        },
                        setViewColumn : function(column){
                            feed.viewColumn = column;
                        },
                        getViewColumn : function(){
                            return feed.viewColumn;
                        },
                        getUrl : function(){
                            /** Not an ideal place, will be refactored */
                            // var feedId, isShared=false;
                            // if (feedMapObjectToReturn.hasSharedFeed()) {
                            //     feedId = feedMapObjectToReturn.getOrginalFeed().getKey();
                            //     isShared = true;
                            // } else {
                            //     feedId = feedMapObjectToReturn.getKey();
                            // }
                            return utilsFactory.getRingRoute('SINGLE_FEED', {feedId : feed.nfId, shared: feedMapObjectToReturn.hasSharedFeed()});
                        },
                        getWhoShareUrl : function() {
                            var feedId;
                            if (feedMapObjectToReturn.hasSharedFeed()) {
                                feedId = feedMapObjectToReturn.getOrginalFeed().getKey();
                            } else {
                                feedId = feedMapObjectToReturn.getKey();
                            }
                            return utilsFactory.getRingRoute('WHO_SHARED_FEED', {feedId : feedId});
                        },
                        /** todo : need improvement
                         * @description : updates this feed raw data
                         * @param json : target json object
                         * @param doNotupdateTm : when set true it will not update tm .. useful when we need to update but don't want to change the order in feed
                         */
                        update : function(json, doNotupdateTm){

                            __updateRawFeedObject(feed, json, doNotupdateTm);

                            //Init Feed Feelings
                            __initFeedFeelings(feed);

                            //Init Feed Tags
                            __initFeedTags(feed);

                            //Update Feed Time
                            __initFeedTime(feed); // update time while creating

                            //set feed top message
                            __setFeedTopMessage(feed);

                            __processFeedMessage(feed, userCardString);

                            __addPostfixMessage(feed);

                            // linkify or emotify
                            __parseStatus(feed);//initial parsing

                        },

                        hasFeelings : function(){
                            return !!feed.mdLst.length;
                        },
                        getFeelings : function(){
                            return feed.feelings;
                        },

                        setFeelings : function(feelings){
                            if(!!feelings && !!feelings.id){
                                feed.feelings = feelings;
                                feed.mdLst[0] = feelings.id;
                            }else{
                                feed.feelings = {};
                                feed.mdLst = [];
                            }
                            __addPostfixMessage(feed);
                        },

                        isShareAble : function(returnWithMessage){
                            var sucs = true,rc;
                            var content = feedMapObjectToReturn.isSingleContentFeed() && !feed.images.length();
                                var f = feedMapObjectToReturn.getSingleContent();
                            if(feed.user.isCurrentUser() || (content && f.user().isCurrentUser())){
                                rc = 'RC15';//reason code 15 from setting
                                sucs = false;
                            }else if(!!feed.friend){
                                rc = 'CRCFS1';//custom reason code feed share
                                sucs = false;
                            }else if(!!feed.grpId){
                                rc = 'CRCFS2';
                                sucs = false;
                            }else if(feed.is && !content){
                                rc = 'CRCFS3';
                                sucs = false;
                            }
                            return !returnWithMessage?sucs:{sucs:sucs,rc:rc};
                        },
                        //starts tag user part
                        hasTagUsers :function(){
                            return !!feed.tagUsers.length;
                        },
                        getTagUsers : function(){
                            return feed.tagUsers;
                        },
                        hasMoreTagUsers : function(){
                            return feed.tfc > feed.tagUsers.length;
                        },
                        getMoreTagUsers : function(){
                            return feed.tfc - feed.tagUsers.length;
                        },
                        getTotalTag : function(){
                            return feed.tfc;
                        },
                        updateTagUser : function(obTag){

                            _setTagUsers(feed, obTag.fTgLst, obTag.tfc);

                            __addPostfixMessage(feed);
                        },
                        encodeUtf8Fields : function(){
                            for(var utf8fieldsIndex = 0; utf8fieldsIndex < utf8fields.length; utf8fieldsIndex++){
                                var feedUtf8AttributeName = utf8fields[utf8fieldsIndex];
                                if(!feed[ feedUtf8AttributeName ]){
                                    feed[ feedUtf8AttributeName ] = '';
                                }else{
                                    feed[ feedUtf8AttributeName ] = feed[ feedUtf8AttributeName ].utf8Encode();
                                }
                            }
                        },
                        getImageLayout : function(withCLass){

                            return feed.imlayout;
                        }
                    };
                    return feedMapObjectToReturn;
                }
            };
        }
})();

(function(undefined) {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket','ringid.puller','ringid.utils','ringid.config', 'ringid.notification'
            ]);
    }


    feedApp.factory('feedFactory', feedFactory);

    feedFactory.$inject = [ 'fileUploadService', '$$connector', '$$q','$$stackedMap','$$feedMap','utilsFactory','OPERATION_TYPES', 'APP_CONSTANTS', 'Ringalert','Auth','MIN_TIMESTAMP', '$rootScope', 'SystemEvents'];
    function feedFactory( fileUploadService, $$connector, $q,$$stackedMap,$$feedMap,helper,OPERATION_TYPES, APP_CONSTANTS, Ringalert,Auth,MIN_TIMESTAMP, $rootScope, SystemEvents) {
        var NO_MORE_FEED = false, OTYPES = OPERATION_TYPES.SYSTEM, AC = APP_CONSTANTS;
        //$feed = $$stackedMap.createNew($$feedMap.getSortIndex());

        var feed_index = OTYPES.TYPE_NEWS_FEED + '.all';
        // note : do not need anymore
        //var possibleActions = [OTYPES.TYPE_NEWS_FEED,
        //    OTYPES.TYPE_GROUP_NEWS_FEED,
        //    OTYPES.TYPE_MY_NEWS_FEED,
        //    OTYPES.TYPE_FRIEND_NEWSFEED,
        //    OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS
        //];
        var latestFeeds = [];
        var feedList = {},
            incomingFeedData = [],
            pushInIncomingFeed = false,//to keep incoming feed data in json format for later process
            ignoreActions = []; // its have key,action,callback. callback should return true or false
                               // if it returns true it will not go further execution with that action for feed

        var processorFunctions = {};
        var FEED_SCOPES = {};

        processorFunctions[OTYPES.TYPE_NEWS_FEED] = pushFeed;
        processorFunctions[OTYPES.TYPE_MY_NEWS_FEED] = pushFeed;
        processorFunctions[OTYPES.TYPE_FRIEND_NEWSFEED] = pushFeed;
        processorFunctions[OTYPES.TYPE_GROUP_NEWS_FEED] = pushFeed;
        //processorFunctions[OTYPES.TYPE_COMMENTS_FOR_STATUS] = pushComments;
        //processorFunctions[OTYPES.TYPE_LIKES_FOR_STATUS] = updateWhoLike;
        //processorFunctions[OTYPES.TYPE_LIST_LIKES_OF_COMMENT] = updateWhoLike;

        // updates todo : complete the list of updates
        processorFunctions[OTYPES.TYPE_UPDATE_ADD_STATUS] = updateAddStatus;
        processorFunctions[OTYPES.ACTION_UPDATE_SHARE_STATUS] = updateShareStatus;
        processorFunctions[OTYPES.TYPE_UPDATE_DELETE_STATUS] = updateDeleteStatus;
        processorFunctions[OTYPES.TYPE_UPDATE_EDIT_STATUS] = processUpdates;
        processorFunctions[OTYPES.TYPE_UPDATE_LIKE_STATUS] = processUpdates;
        processorFunctions[OTYPES.TYPE_UPDATE_UNLIKE_STATUS] = processUpdates;
        processorFunctions[OTYPES.TYPE_UPDATE_ADD_STATUS_COMMENT] = processUpdates;
        //processorFunctions[OTYPES.TYPE_UPDATE_LIKE_COMMENT] = processUpdates;
      //  processorFunctions[OTYPES.TYPE_UPDATE_UNLIKE_COMMENT] = processUpdates;
        processorFunctions[OTYPES.TYPE_UPDATE_DELETE_STATUS_COMMENT] = processUpdates;
       // processorFunctions[OTYPES.TYPE_UPDATE_EDIT_STATUS_COMMENT] = processUpdates;



        return {
            init: init,
            addScope : function(nfId,$scope){
                FEED_SCOPES[nfId] = $scope;
            },
            removeScope : function(nfId){
                if(FEED_SCOPES[nfId]){
                    delete FEED_SCOPES[nfId];
                }
            },
            getFeed: getFeed,

            updateTime: updateTime,

            pushFeed : pushFeed,
            processIncomingFeed : processIncomingFeed,
            setpushInIncomingFeed :function(val){
                pushInIncomingFeed = !!val;
            },
            getPushIncomingFeed : function(){
                return pushInIncomingFeed;
            },
            hasUnprocessedFeed : function(){
                return incomingFeedData.length;
            },
            addIgnoreFilter: addIgnoreFilter,

            removeIgnoreFilter: removeIgnoreFilter,

            setFactoryKey: setFactoryKey,

            createFeed : createFeed,

            process: process,

            getFeedFilter: getFeedFilter,

            noMoreFeed: noMoreFeed,

            requestForFeed: requestForFeed,
            initFeedRequest : initFeedRequest,

            getSingleFeed: getSingleFeed,

            requestForMoreFeed: requestForMoreFeed,
            getRawFeeds: getRawFeeds,

            getFeeds: getFeeds,

            addFeed: addFeed,

            shareFeed: shareFeed,

           // likeUnlikeFeed: likeUnlikeFeed,

          //  fetchComments: fetchComments,

          //  fetchCommentsByOffset: fetchCommentsByOffset,

         //   fetchCommentById: fetchCommentById,

         //   addComment: addComment,

         //   likeUnlikeComment: likeUnlikeComment,

            deleteFeed: deleteFeedService,

            updateFeed: updateFeed,

          //  deleteComment: deleteComment,

           // updateComment: updateComment,

           // fetchWhoLikesFeed: fetchWhoLikesFeed,

            reset: reset,

            moreFeedText: moreFeedText,

            getSingleFeedPageKey: getSingleFeedPageKey,

            getWhoShareFeedId : getWhoShareFeedId,
            getTagUsers : getTagUsers,
            setSortBy : setSortBy,
            getCurrentPageValue : getCurrentPageValue,
            hasSpecialFeed : function(){
                var pageValue = getCurrentPageValue();
                return (OTYPES.TYPE_NEWS_FEED === pageValue.action) && (feedList.special && feedList.special.length() > 0);
            },
            getSpecialFeedList : function(){
                return feedList.special && feedList.special.all();
            },
            synchLike : synchLike,
            synchComment : synchComment
            /**
             * @description : this function is for fake feed generation for testing purpose
             * @params : startingOffset,length
             *
             */
            //fakeFeed : fakeFeedGenerator

        };


        /////////////////////////////

        // ------------------------- Private -----------------------------------
        function setSortBy(key){
            $$feedMap.setSortKey(key);
        }
        function getIndexedFeed() {

            return feedList.hasOwnProperty(feed_index) ? feedList[feed_index].data : $$stackedMap.createNew();
        }

        function getIndexedRemovedFeed(){
            return feedList.hasOwnProperty(feed_index) ? feedList[feed_index].removed : $$stackedMap.createNew();
        }
        function getCurrentPageValue(){ // returns current Feed Page Action
            var keyParts = [];
            try {
                keyParts = feed_index.split('.', 2);
            } catch (e) {
                return false;
            }

            if (keyParts.length != 2) {
                return false;
            }

            return {
                    action : parseInt(keyParts[0]),
                    page : keyParts[1]
                   };
        }


        function updateTime() {
            var feeds = getIndexedFeed();
            for(var i=0; i<feeds.length();i++){
                var timediff = Date.now()-feeds.all()[i].value.getTimestamp();
                if(timediff < 3600000) {
                    feeds.all()[i].value.updateTime();
                }
            }
        }
        //setInterval(feedFactory.updateTime, 180000);
        function init(ob) {

            var $feed = getIndexedFeed();

            if ($feed.length() < 10) {
                requestForFeed(ob);

                return true;// return for scope set busy //
            } else {

                return false; //return for scope set busy false cause no ajax call initiated
            }
            // initiating stack for holding feeds
        }
        function reset() {
            getIndexedFeed().reset();
            getIndexedRemovedFeed().reset();
            incomingFeedData.length = 0;
        }
        function getMinTm(){
            var sortIndex = $$feedMap.getSortIndex(),$feed = getIndexedFeed();
            if(sortIndex === 'tm'){
                return $feed.length() ? $feed.top().getTimestamp() : MIN_TIMESTAMP;
            }
            var mintimestamp = $feed.length() ? $feed.top().getAtTime() : MIN_TIMESTAMP;

            // $feed.doForAll(function(f){
            //     if(f.getTimestamp() < mintimestamp){
            //         mintimestamp = f.getTimestamp();
            //     }
            // });
            return mintimestamp;
        }
        function createFeed(json,user){
            return $$feedMap.create(json,user);
        }
        function DashboardFeedFilter(){
            return true;//all Kinda of filter will be shown
        }
        function singlePageFilter(message,pageValue){
            return message.nfId == pageValue.page || ( message.whShrLst && message.whShrLst[0].nfId == pageValue.page);
        }
        function GroupNewsFeedFilter(message,pageValue){
            return !!message.grpId && message.grpId == pageValue.page;
        }
        function CurrentUserPageFilter(tempData,pageValue){

            if(!pageValue){
                pageValue = getCurrentPageValue();
            }
            if((pageValue.page === tempData.uId) || (!!tempData.fndId && pageValue.page === tempData.fndId)){
                return true;
            }
            if(!!tempData.orgFd && ( pageValue.page === tempData.orgFd.uId)){
                return true;
            }
            return false;
        }
        function processCurrentUserFriendFeed(feedData){
            processCurrentUserFeed(feedData);
        }

        function processCurrentUserFeed(feedData){
            processAllFeed(feedData,CurrentUserPageFilter,{
                processWhoShare : function(tempData,$feed,pageValue){
                    var _d1,_d;
                    if(tempData.uId === pageValue.page && tempData.orgFd){ // someone shares it but main owner is the current user

                        _d = createFeed(tempData.orgFd);
                        _d1 = createFeed(tempData);
                        _d1.shares(_d);
                        $feed.save(_d1.getMapKey(), _d1);
                        //saveOrginalFeedIntoRemoved(_d1,tempData.nfId); profile pages doesn't need to process the update share
                    }
                }
            });
        }


        function processGroupNewsFeed(feedData){
            processAllFeed(feedData,GroupNewsFeedFilter);
        }
        function processDashboardFeed(feedData){
            processAllFeed(feedData,DashboardFeedFilter);
        }
        function processSpecialFeed(json) {
            var _d;
            if(!feedList.special){
                feedList.special = $$stackedMap.createNew($$feedMap.getSortIndex(), 'desc');
            }
            _d = createFeed(json);
            feedList.special.save(_d.getMapKey(), _d);
        };

        function processAllFeed(feedData,filterFunc,options){
            options = options || {};
            if(!angular.isFunction(filterFunc))filterFunc = function(){return true;};
            var message = angular.isArray(feedData) ? feedData : feedData.newsFeedList;
            if(!angular.isArray(message))return;
            var pageValue = getCurrentPageValue();
            var $feed = getIndexedFeed(),_d,tempKey,_d1,tempData;
            for (var i = 0; i < message.length; i++) {
                tempData = message[i];
                if(tempData.fc > 0){processSpecialFeed(message[i]);continue;}
                if(!filterFunc(tempData,pageValue))continue;
                if (tempData.deleted) {
                    deleteFromIndexedFeed(tempData.nfId);
                //} else if (tempData.sharedFeed) { //todo : may be no use now ! please check calls when user share from share controller
                //    _d1 = createFeed(tempData.sharedFeed);
                //    tempData.sharedFeed = {};//no need
                //    _d = createFeed(tempData);
                //    _d.shares(_d1);
                //    // TODO may be original feed d1 should remove from here !
                //    $feed.save(_d.getMapKey(), _d);
                } else if (tempData.whShrLst || tempData.orgFd) { // when share feed comes from server
                    if(!!options.processWhoShare && angular.isFunction(options.processWhoShare)){
                        options.processWhoShare.call(null,tempData,$feed,pageValue);
                    }else{
                        if(tempData.orgFd){
                            _d = createFeed(tempData);
                            if (!(_d1 = _getFeed(tempData.orgFd.nfId))) {
                            _d1 = createFeed(tempData.orgFd);
                            }
                        }else{
                            _d = createFeed(tempData.whShrLst[0]);
                            if (!(_d1 = _getFeed(tempData.nfId))) {
                            _d1 = createFeed(tempData);
                            }
                        }
                        _d.shares(_d1);
                        $feed.save(_d.getMapKey(), _d);
                        saveOrginalFeedIntoRemoved(_d1,_d.getKey());
                    }

                } else {
                    _d = createFeed(tempData);
                    $feed.save(_d.getMapKey(), _d);
                }

            }

        }

        function processSingleFeed(feedData){
            processAllFeed(feedData,singlePageFilter);
        }

        function getCurrentPageFilter(pageValue){
            if(!pageValue){
                pageValue = getCurrentPageValue();
            }
            switch (pageValue.action) {
                case OTYPES.TYPE_MY_NEWS_FEED:
                case OTYPES.TYPE_FRIEND_NEWSFEED:
                    return CurrentUserPageFilter;
                case OTYPES.TYPE_GROUP_NEWS_FEED:
                    return GroupNewsFeedFilter;
                case OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS:
                    return singlePageFilter;
                case OTYPES.TYPE_NEWS_FEED:
                default :
                    return DashboardFeedFilter;

            }
        }

        function pushFeed(feedData) {
            var pageValue = getCurrentPageValue();
            switch (pageValue.action) {
                case OTYPES.TYPE_MY_NEWS_FEED:
                    processCurrentUserFeed(feedData);
                    break;
                case OTYPES.TYPE_FRIEND_NEWSFEED:
                    processCurrentUserFriendFeed(feedData)
                    break;
                case OTYPES.TYPE_GROUP_NEWS_FEED:
                    processGroupNewsFeed(feedData);
                    break;
                case OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS:
                    processSingleFeed(feedData);
                    break;
                case OTYPES.TYPE_NEWS_FEED:
                default :
                    processDashboardFeed(feedData);
                    break;
            }

        }
        function processIncomingFeed(){
            var tempData;
            while(incomingFeedData.length && pushInIncomingFeed){
                tempData = incomingFeedData.shift();
                if(!!tempData.callback){
                    tempData.callback.call(null,tempData,true);
                }else{
                    pushFeed([tempData]);
                }

            }
        }
        function saveOrginalFeedIntoRemoved(feed,reference,removedMap){
            if(!removedMap){
                removedMap = getIndexedRemovedFeed();
            }
            feed.reference = reference;
            removedMap.save(feed.getMapKey(),feed);
        }
        function _getRemovedFeed(nfId,removedMap){
            if(!removedMap){
                removedMap = getIndexedRemovedFeed();
            }
            nfId = $$feedMap.getPrefix() + nfId;
            return removedMap.get(nfId);
        }
        function _getFeed(nfId) {
            var $feed;
            $feed = getIndexedFeed();
            nfId = $$feedMap.getPrefix() + nfId;
            return $feed.get(nfId);

        }

        function _addFeed(feed) {
            var $feed = getIndexedFeed();
            $feed.add(feed.getMapKey(), feed);

        }

        function deleteFeed(key,$feed) {
            if(!$feed){
                $feed = getIndexedFeed();
            }
           return $feed.remove($$feedMap.makeKey(key));

        }

        function synchLike(nfId,il,loc){
            if(!nfId)return;
            var f = getFeed(nfId);
            if(f && f.isSingleContentFeed()){
                f.setTotalLikes(loc,il);
                return FEED_SCOPES[nfId];
            }
        }

        function synchComment(nfId,total,is){
            if(!nfId)return;
            var f = FEED_SCOPES[nfId];
            if(f && f.feed.isSingleContentFeed()){
                f.feed.setTotalComment(total,is);
                return f;
            }
        }



        // function updateWhoLike(message, feed) {
        //     var commentOrFeed;
        //     if (!feed || (!!feed && feed.getKey() !== message.nfId)) {
        //         feed = _getFeed(message.nfId);
        //     }
        //     if (!feed)return;
        //     if (!!message.cmnId) {
        //         commentOrFeed = feed.getCommentByKey(message.cmnId) || feed;
        //     } else {
        //         commentOrFeed = feed;
        //     }
        //     var likes = message.likes || [];
        //     for (var i = 0; i < likes.length; i++) {
        //         commentOrFeed.incomingWhoLikes(likes[i]);
        //     }

        // }

        function processUpdates(json) {

            var f = _getFeed(json.nfId);
            var scope = FEED_SCOPES[json.nfId];
            if (!f || !scope){
                return;
            }

            switch (json.actn) {

                case OTYPES.TYPE_UPDATE_EDIT_STATUS:
                    f.update(json);

                    break;

                case OTYPES.TYPE_UPDATE_LIKE_STATUS:
                case OTYPES.TYPE_UPDATE_UNLIKE_STATUS:

                    f.setTotalLikes(json.loc);
                    f.setFeedTopMessage();
                    break;

                case OTYPES.TYPE_UPDATE_ADD_STATUS_COMMENT:
                case OTYPES.TYPE_UPDATE_DELETE_STATUS_COMMENT :

                    f.setTotalComment(json.loc);
                    f.setFeedTopMessage();
                    break;

            }
            return scope;
        }

        function updateDeleteStatus(json) {
            deleteFeed(json.nfId);
        }

       function updateShareStatus(json,forceProcess,selfShared,currentUser) {
            if(pushInIncomingFeed && !forceProcess){
                json.callback = updateShareStatus;
                var filterFunc = getCurrentPageFilter();
                if(filterFunc.call(null,json.newsFeed)){ //validating if this feed should processed via current page
                    incomingFeedData.push(json);
                }
                return;
            }

            var key = json.newsFeed.orgFd && json.newsFeed.orgFd.nfId;
            if(!key)return;
            var f = _getFeed(key);
            var $removed = getIndexedRemovedFeed();
            if(f){ // searched in main feed list
                // note : its found in main list so nobody shares it so we just deletes it
                //and update with latest with common function
                if(selfShared){
                    f.setActivity(json.newsFeed.orgFd);
                    return FEED_SCOPES[f.getKey()];
                }else{
                    saveOrginalFeedIntoRemoved(f,json.newsFeed.nfId,$removed);
                    deleteFeed(f.getKey());
                }
            }else{ // searched for previously added to removed feed
                f = _getRemovedFeed(key,$removed);
                if(f){ // found in removed feed
                    //todo : synch current three feed
                    var filterFunc = getCurrentPageFilter();
                    processAllFeed([json.newsFeed],filterFunc,{processWhoShare:
                        function(message,$feed,pageValue){
                            var _d,_d1,orginal = _getFeed(f.reference);//getting orginal feed
                                if(!orginal){
                                    pushFeed([message]); // normally update
                                    return;
                                }
                            if(pageValue.page == OTYPES.TYPE_FRIEND_NEWSFEED || pageValue.page == OTYPES.TYPE_MY_NEWS_FEED){
                                return;// todo : check if there needed to update
                            }
                            f.update(message,true);// updating the old feed without the tm to keep the order
                            if(selfShared){
                                f.addShareUser(currentUser);
                                orginal.updateShareMessage();
                                orginal.setActivity(message);
                                return FEED_SCOPES[orginal.getKey()];
                            }
                            // todo : when current user share status the whoShare doesn't contain the current user data. instead previous share user data.need to be checked with auth
                                // deleting the feed from orginal feed list
                            _d = createFeed(message); //creating new feed
                            _d.setActivity(message.orgFd);//set orginal feed activity
                            //_d1 = createFeed(tempData);
                            //_d1.addShareUser(orginal.getOrginalFeed().getShareUsers());//pushing orginal user
                                deleteFeed(f.reference);
                                _d.shares(f);
                                $feed.save(_d.getMapKey(), _d);


                        }
                    });
                    return;
                // todo here you should return after calling processAllFeed with whoShare processor
                }else{ //also not found in removed feed . means the orginal feed does not exist in removed feed list
                    // so saving the orginal feed into removed feed list.
                    //note : processAllFeed and processUsersFeed saves orginal feed
                }

            }
            pushFeed([json.newsFeed]);
        }



        function updateAddStatus(json) {
            if (!json.imageList && json.type === 1) { // when updates comes then it brings image imformation directly to feed data
                json.imageList = [json];            // but feedmap processes image in imagesList
            }
            if(pushInIncomingFeed){
                var filterFunc = getCurrentPageFilter();
                if(filterFunc.call(null,json,getCurrentPageValue())){
                    incomingFeedData.push(json);
                }
            }else{
                pushFeed([json]);
            }

        }

        function _process(json) {
            //console.dir(json);
            var i, ignore = false, feedData = angular.isArray(json) ? json[0] : json;
            if (ignoreActions.length) {
                for (i = 0; i < ignoreActions.length; i++) {
                    if (ignoreActions[i].action === feedData.actn) {
                        ignore = ignoreActions[i].callback.call(null, feedData);
                    }
                }
            }
            if (!!processorFunctions[feedData.actn] && !ignore) {
               return processorFunctions[feedData.actn].call(null, feedData);
            }

        }

        //------------------------- Public -------------------------

        function getFeed(key) {
            // key = $$feedMap.getPrefix() + key;
            return _getFeed(key);
        }

        function addIgnoreFilter(action, callback) {
            var key = helper.getUniqueID();

            ignoreActions.push({
                key: key,
                action: action,
                callback: callback
            });

            return key;
        }

        function removeIgnoreFilter(key) {
            var idx = -1;

            for (var i = 0; i < ignoreActions.length; i++) {
                if (ignoreActions[i].key === key) {
                    idx = i;
                }
            }

            return idx != -1 ? ignoreActions.splice(idx, 1) : [];
        }

        function setFactoryKey(key) {
            feed_index = key;
            if (!feedList.hasOwnProperty(feed_index)){
                feedList[feed_index] = {
                    data: $$stackedMap.createNew($$feedMap.getSortIndex(), 'desc'),
                    removed : $$stackedMap.createNew(),//removed feed
                    no_more_feed: false
                };
            }

            //feedList.special = feed.special || $$stackedMap.createNew($$feedMap.getSortIndex(), 'desc');

        }

        function process(json) {
          return _process(json);
        }

        function getFeedFilter() {
            return function (m) {
                return !!processorFunctions[m.actn];
            };

        }
        function getRawFeeds() {
            return getIndexedFeed().all();

        }

        function getFeeds() {
           // var t0 = performance.now();

            //console.dir($feed.all());
            var $feed = getIndexedFeed();
            return $feed.all();
/** @type {
Now cols are divided in rg repeat directive so no need to separte in to three array
}  */
            // var arrayToReturn = [];
            // if ($feed.length() > 0) {
            //     var i = 0, j=0,arr = $feed.all(),
            //         lengthofsublist = helper.feedColumn();
            //     while(j < lengthofsublist){
            //         arrayToReturn[j] = [];j++;
            //     }
            //     while (i < arr.length) {
            //         j = (i%lengthofsublist);
            //         arr[i].serial = i + 1;
            //         arr[i].viewColumn = j + 1;
            //         arrayToReturn[j].push(arr[i]);
            //         i++;// move on to next feed
            //     }
            // }


            // var t1 = performance.now();
            // console.warn("Dividing feed("+$feed.length()+") into three array took " + (t1 - t0) + " milliseconds.");
            // //console.log('getFeeds returned', arrayToReturn);
            // return arrayToReturn;

        }
        function noMoreFeed() {
            return feedList.hasOwnProperty(feed_index) ? feedList[feed_index].no_more_feed : false;

        }
        function requestForFeed(ob) {
            ob = angular.copy(ob || {});
            ob.lmt = ob.lmt || AC.FEED_LIMIT;

            return $$connector.send(ob, OTYPES.REQUEST_TYPE.REQUEST);
        }
        function initFeedRequest(ob){
            ob = angular.copy(ob || {});
            ob.lmt = 10;
            ob.scl = 2;
            requestForFeed(ob);
        }

        function requestForMoreFeed(ob, scl) {
            var timestamp = getMinTm();
            //todo : if scl == 1 we need to send max tm instead of min tm
            ob = angular.copy(ob || {});
            ob.scl = scl || 2;
            ob.tm = timestamp ? timestamp : MIN_TIMESTAMP;
            return requestForFeed(ob);

        }
        function getSingleFeed(feedId, whoShare) {

            var payload = {
                actn: OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS,
                nfId: feedId
            };

            var deffer = $q.defer();

            var feedObj = getFeed(feedId);

            if(!feedObj){

                $$connector.request(payload, OTYPES.REQUEST_TYPE.REQUEST)
                    .then(function(feedData){
                        if(feedData.sucs === true){

                            // pushFeed(feedData);
                            //
                            // if( !!whoShare){
                            //     pushFeed(feedData);
                            //     var whoShareFeedId = getWhoShareFeedId(feedData);
                            //     feedObj = getFeed(whoShareFeedId);
                            // }else{
                            //     deleteWhoShareFromSingleFeedData(feedData);
                            //     pushFeed(feedData);
                            //     feedObj = getFeed(feedId);
                            // }
                            var message = angular.isArray(feedData) ? feedData : feedData.newsFeedList[0];
                            if( !!whoShare && message.orgFd){
                                if( message.orgFd ){
                                    feedObj = createFeed(message);
                                    var orginalFeed = createFeed(message.orgFd);
                                    feedObj.shares(orginalFeed);
                                }
                            }else{
                                feedObj = createFeed(message);
                            }

                            if(feedObj){
                                var $feed = getIndexedFeed();
                                $feed.save(feedObj.getMapKey(), feedObj);
                            }

                            deffer.resolve(feedObj);
                        }else{
                            deffer.resolve(false);
                        }

                    }, function(errData){
                        deffer.reject(errData);
                    });

            }else{

                deffer.resolve(feedObj);
            }

            return deffer.promise;

        }


        function addFeed(ob, user,content_shared) {
            var defer = $q.defer(),lengthPadding = 0,
                _d, /* _d means json data */
                $feed = getIndexedFeed(),
                nfId = helper.getUniqueID();
                ob.stsTags = [];
                var tempText = '';
                //processing for sts tag
                var tempText = '';
                //processing for sts tag
                if(ob.text){
                   tempText =  ob.text.replace(/##([\d]+)##/g,function(match,$1,index){
                         var offset;
                         offset = index - lengthPadding;
                         ob.stsTags.push({
                            pstn : offset,
                            utId : $1
                         });
                         lengthPadding += match.length;
                        return "";
                    });
                   ob.text = tempText;
                }

            if(!content_shared){
                _d = createFeed({
                    nfId: nfId,
                    fpvc: ob.fpvc,
                    sts: ob.text,
                    lat : ob.lat || 9999,//default 9999
                    lng : ob.lng || 9999,//default 9999
                    //imgIds: ob.images,
                    grpId: ob.group || "",
                    friendId: ob.friend || "",
                    fndId : ob.friend || "",
                    mdLst : ob.mdIds,
                    // captionList: ob.captionList,
                    isNew: 1,
                    pending: true,
                    lctn: ob.lctn || '',
                    lnkDmn: ob.lnkDmn || '',
                    lnkDsc: ob.lnkDsc || '',
                    lnkTtl: ob.lnkTtl || '',
                    lnkURL: ob.lnkURL || '',
                    lnlImgURL: ob.lnlImgURL || ''
                }, user);
             $feed.save(_d.getMapKey(), _d);
           }else if(ob.feed){
                _d = ob.feed;
           }else{
                _d = getFeed(ob.nfId);
           }




            var newFeedData = {};
            if(ob.cntntIDLst){
                newFeedData.cntntIDLst = ob.cntntIDLst;
            }
            if (ob.group) {
                newFeedData.grpId = ob.group;
            }

            if (ob.friend) {
                newFeedData.fndId = ob.friend;
            }

            if (ob.lctn) {
                newFeedData.lctn = ob.lctn.utf8Encode();
            }

            if( ob.lnkDmn){
                newFeedData.lnkDmn = ob.lnkDmn.utf8Encode();
            }

            if( ob.lnkDsc){
                newFeedData.lnkDsc = ob.lnkDsc.utf8Encode();
            }

            if( ob.lnkTtl){
                newFeedData.lnkTtl = ob.lnkTtl.utf8Encode();
            }

            if( ob.lnkURL){
                newFeedData.lnkURL = ob.lnkURL.utf8Encode();
            }

            if( ob.lnlImgURL){
                newFeedData.lnlImgURL = ob.lnlImgURL.utf8Encode();
            }
            if(ob.stsTags.length){
                newFeedData.stsTags = ob.stsTags;
            }

            newFeedData.actn = OTYPES.TYPE_ADD_STATUS;

            if (!!ob.images && ob.images.length > 0) {
                if (ob.images.length === 1) {//  type for single image
                    newFeedData.type = OTYPES.NEWS_FEED_TYPE_IMAGE;
                    newFeedData = angular.extend({}, newFeedData, ob.images[0].getAuthData());
                } else {// type for multiple images
                    newFeedData.actn = OTYPES.TYPE_ADD_MULTI_IMAGE;
                    newFeedData.type = OTYPES.NEWS_FEED_TYPE_MULTIPLE_IMAGE;
                    // imageList: [{ih, iw, cptn, iurl}]
                    newFeedData.imageList = [];
                    for (var i = 0, lt = ob.images.length; i < lt; i++) {
                        newFeedData.imageList.push(ob.images[i].getAuthData());
                    }
                }
            } else if (!!ob.videos && ob.videos.length > 0) {
                newFeedData.mdaCntntDTO  = {
                    albId: fileUploadService.getUploadAlbum(),
                    htgLst: [],
                    mdaLst: [],
                    mdaT: AC.NEWS_FEED_MEDIA_TYPE_VIDEO,
                    lnkT: AC.NEWS_FEED_MEDIA_TYPE_VIDEO
                };
                newFeedData.type = OTYPES.NEWS_FEED_TYPE_VIDEO;

                for (var i = 0, lt = ob.videos.length; i < lt; i++) {
                    newFeedData.mdaCntntDTO.mdaLst.push((ob.videos[i].getAuthData(true)));
                    if (i === 0) {
                        newFeedData.mdaCntntDTO.htgLst = newFeedData.mdaCntntDTO.mdaLst[0].htgLst;
                    }
                }
            } else if (!!ob.audios && ob.audios.length > 0) {
                newFeedData.mdaCntntDTO  = {
                    albId: fileUploadService.getUploadAlbum(),
                    htgLst: [],
                    mdaLst: [],
                    mdaT: AC.NEWS_FEED_MEDIA_TYPE_AUDIO,
                    lnkT: AC.NEWS_FEED_MEDIA_TYPE_AUDIO
                };
                newFeedData.type = OTYPES.NEWS_FEED_TYPE_AUDIO;

                for (var i = 0, lt = ob.audios.length; i < lt; i++) {
                    newFeedData.mdaCntntDTO.mdaLst.push((ob.audios[i].getAuthData(true)));
                    if (i === 0) {
                        newFeedData.mdaCntntDTO.htgLst = newFeedData.mdaCntntDTO.mdaLst[0].htgLst;
                    }
                }
            } else {// setting action and type for only text post
                newFeedData.actn = OTYPES.TYPE_ADD_STATUS;
                if(content_shared){
                    newFeedData.type = ob.audio ? OTYPES.NEWS_FEED_TYPE_AUDIO:OTYPES.NEWS_FEED_TYPE_VIDEO;
                }else{
                    newFeedData.type = OTYPES.NEWS_FEED_TYPE_STATUS;
                }

            }

            if(ob.mdIds){
                newFeedData.mdIds = ob.mdIds;
            }
            if(ob.tFrndIds){
                newFeedData.tFrndIds = ob.tFrndIds;
            }

            newFeedData.vldt = ob.vldt || "-1";// set validity for timout status // implement it while implementing timout status
            newFeedData.lng = ob.lng || 9999;
            newFeedData.lat = ob.lat || 9999;
            newFeedData.sts = ob.text.utf8Encode(); // setting the feed text
            newFeedData.fpvc = ob.fpvc;

            RingLogger.print(newFeedData, RingLogger.tags.FEED);
            $$connector.request(newFeedData, OTYPES.REQUEST_TYPE.UPDATE).then(function (json) {
                $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.UPLOADS_POSTED);
                RingLogger.debug(json);
                if (json.sucs) {
                    //console.dir(json);
                    if(!content_shared){
                        $feed.remove(_d.getMapKey());
                        if (json.type === OTYPES.TYPE_SINGLE_IMAGE_STATUS) {
                            json.imageList = [json];
                        }
                        pushFeed([json]);
                        Ringalert.show(json, 'success');
                    }else{
                        _d && _d.share(json.mdaCntntLst[0].is,json.mdaCntntLst[0].ns);
                    }
                    defer.resolve(json);
                } else {
                    if(!content_shared){
                        $feed.remove(_d.getMapKey());
                        Ringalert.show(json, 'error');
                    }
                    defer.reject(json);
                }

            }, function (reason) {
                if(!content_shared){
                    $feed.remove(_d.getMapKey());
                    Ringalert.show(json, 'error');
                }
                defer.reject(json);
            });

            return defer.promise;
        }

        function shareFeed(ob) {
            if(ob.addShare){
                return addFeed(ob,ob.user,true);
            }
            var defer = $q.defer();

            var data = {
                actn: OTYPES.ACTION_SHARE_STATUS,
                sfId: ob.feed.getKey(),
                type: 2,
                sts: ob.text.utf8Encode(),
            };

            if(ob.mdIds){
                data.mdIds = ob.mdIds;
            }

            if(ob.tFrndIds){
                data.tFrndIds = ob.tFrndIds;
            }

            if(!!ob.location){

                if(!!ob.location.description){
                    data['lctn'] = ob.location.description.utf8Encode();
                }

                if(!!ob.location.lat){
                    data['lat'] = ob.location.lat;
                    data['lng'] = ob.location.lng;
                }
            }

            $$connector.request(data, OTYPES.REQUEST_TYPE.UPDATE).then(function (json) {
                // todo remove orginal feed from feedlist and made a function to prevent duplicacy on share feed
                if (!!json.sucs) {
                    // console.dir(json);
                    //$feed.remove(_d.getMapKey());
                    updateShareStatus(json,true,true,Auth.currentUser());
                    ////console.log("after");
                    ////console.dir($feed.all());
                    ob.feed.share(true);

                    defer.resolve(json);
                } else {

                    defer.reject(json);

                    //$feed.remove(_d.getMapKey());
                }


            }, function (reason) {
                defer.reject(reason);
            });
            //console.log("before");
            //console.dir($feed.all());
            return defer.promise;
        }

        // function likeUnlikeFeed(key, feed) {
        //     var il, defer = $q.defer();
        //     if (!feed) {
        //         feed = _getFeed(key);
        //     }
        //     if (!!feed) {
        //         il = feed.like(true);// updating map before sending request
        //         $$connector.request({
        //             actn: il === 1 ? OTYPES.TYPE_LIKE_STATUS : OTYPES.TYPE_UNLIKE_STATUS,
        //             nfId: key
        //         }, OTYPES.REQUEST_TYPE.UPDATE).then(function (json) {
        //             if (json.sucs !== true) {
        //                 feed.like(true);// toggling back if success is not true
        //                 defer.reject(json);
        //             } else {
        //                 feed.setTotalLikes(json.loc);
        //                 defer.resolve(json);
        //             }
        //         }, function (reason) {
        //             feed.like(true);//toggling back on error
        //             defer.reject(reason);
        //         });
        //     } else {
        //         defer.reject("Invalid Request");
        //     }

        //     return defer.promise;

        // }

        // function fetchComments(key, feedMap) {

        //     var startingIndex;
        //     if (!feedMap) {
        //         feedMap = !!key && _getFeed(key);
        //         if (!feedMap)return;
        //     }
        //     startingIndex = feedMap.getCommentStartingIndex();

        //     $$connector.send({
        //         actn: OTYPES.TYPE_COMMENTS_FOR_STATUS,
        //         nfId: key,
        //         st: startingIndex
        //     }, OTYPES.REQUEST_TYPE.REQUEST);
        // }

        // function fetchCommentById(nfId, commentId) {

        //    return $$connector.request({
        //         actn: OTYPES.ACTION_GET_FULL_COMMENT,
        //         cmnId: commentId,
        //         nfId: nfId,
        //         cmntT: 1 // 1=feed comment, 2= image comment
        //     },OTYPES.REQUEST_TYPE.REQUEST);
        // }

        // function fetchCommentsByOffset(feed, currentTm, before) {

        //     // 1 for before currentTm Comments, 2 for bellow currentTm Comments
        //     var scl = !!before ? 2 : 1;
        //     if(!currentTm){
        //         var comment=false,comments = feed.getComments(true);
        //         if(comments.length()) {
        //             comment = comments.getByIndex((scl===1 ? 0 : comments.length() -1));
        //         }
        //         currentTm = comment ? comment.getTimestamp():feed.getTimestamp();
        //     }

        //     $$connector.send({
        //         actn: OTYPES.TYPE_COMMENTS_FOR_STATUS,
        //         nfId: feed.getKey(),
        //         st: 0,
        //         tm: currentTm,
        //         scl: scl
        //     }, OTYPES.REQUEST_TYPE.REQUEST);
        // }

        // function addComment(feed, comment, user) {
        //     var /*feed = _getFeed(key),*/cmnId, defer = $q.defer(), commData;
        //     var key = feed.getKey();
        //     if (feed !== false) {
        //         cmnId = helper.getUniqueID();//generating unique key for further identification
        //         commData = {
        //             cmnId: cmnId,
        //             cmn: comment,
        //             deleted: false,
        //             isNew: true,
        //             edited: false,
        //             nfId: key,
        //             pending: true// setting status pending to showing 50% opacity
        //         };
        //         feed.addComment(commData, user);// added comment to the feed as pending
        //         $$connector.request(
        //             {
        //                 actn: OTYPES.TYPE_ADD_STATUS_COMMENT,
        //                 nfId: key,
        //                 cmn: comment.utf8Encode()
        //             }, OTYPES.REQUEST_TYPE.UPDATE
        //         ).then(function (json) { // http service start
        //                 feed.deleteComment(cmnId);
        //                 if (json.sucs === true) {
        //                     json.pending = false;
        //                     angular.extend(commData, json);
        //                     //json.cmn = json.cmn || comment;//response not sending back the text
        //                     //commentMap = $$commentMap.create(json,user);
        //                     feed.addComment(commData, user);
        //                     //commentMap.isPending(false); // updating the status
        //                     defer.resolve(json);
        //                 } else {
        //                     defer.reject(json);
        //                 }
        //             }, function (json) {
        //                 feed.deleteComment(cmnId);
        //                 defer.reject(json);
        //             });
        //     }
        //     return defer.promise;
        // }

        // function likeUnlikeComment(key, commentId, feed) {
        //     var il;
        //     if (!feed) {
        //         feed = _getFeed(key);
        //     }
        //     if (!!feed) {
        //         il = feed.likeUnlikeComment(commentId);//updating map before sending request
        //         $$connector.request({
        //             actn: il ? OTYPES.TYPE_LIKE_COMMENT : OTYPES.TYPE_UNLIKE_COMMENT,
        //             nfId: key,
        //             cmnId: commentId
        //         }, OTYPES.REQUEST_TYPE.UPDATE).then(function (json) {
        //             if (json.sucs !== true) {
        //                 feed.likeUnlikeComment(commentId);// toggling back if success is not true
        //                 Ringalert.show(json, 'error');
        //             }
        //         }, function (json) {
        //             feed.likeUnlikeComment(commentId);// toggling back on error
        //             Ringalert.show(json, 'error');
        //         });
        //     }

        // }

        function deleteFeedService(user, key) {
            var defer = $q.defer();
            var feed = _getFeed(key);
            var $feed = getIndexedFeed();
            if(!feed){
                setTimeout(function(){
                    defer.reject("Can't Delete Invalid Feed");
                });
                return defer.promise;
            }


            if (!feed.user().isCurrentUser(user.getKey())) {
                setTimeout(function () {
                    defer.reject("You are not authorized to delete this feed.");
                }, 100);
            }

            if (feed !== false) {
                // console.log($feed);

                deleteFeed(feed.getKey(),$feed);
                /** TODO : We Should Not Replace Here instead make the feed in gray/pending mode **/

                $$connector.request({
                    actn: OTYPES.TYPE_DELETE_STATUS,
                    nfId: key
                }, OTYPES.REQUEST_TYPE.UPDATE).then(function (json) {
                    if (!json.sucs) {
                        _addFeed(feed);
                        defer.reject(json);
                    } else {
                        defer.resolve(json);
                    }

                }, function (json) {
                    _addFeed(feed);
                    defer.reject(json);

                });

            } else {
                setTimeout(function () {
                    defer.reject("Feed Not Found!");
                }, 100);
            }

            return defer.promise;
        }

        function updateFeed(user, key, status, location, ogData, feedEmotions, taggedFriends) {
            var defer = $q.defer();
            var feed = _getFeed(key);
            var mapkey = feed.getMapKey();
            if (!feed.user().isCurrentUser(user.getKey())) {
                return;
            }
            var oldText = feed.text();
            var oldLocation = feed.getLocationInfo();
            var oldOgData = feed.getOgData();
            var oldEmotions = feed.getFeelings();
            var stsTags = [],lengthPadding=0,tempText;


                if(status){
                   tempText =  status.replace(/##([\d]+)##/g,function(match,$1,index){
                         var offset;
                         offset = index - lengthPadding
                         ob.stsTags.push({
                            pstn : offset,
                            utId : $1
                         });
                         lengthPadding += match.length;
                        return "";
                    });
                   status = tempText;
                }


            var dataToUpdate = {
                actn: OTYPES.TYPE_EDIT_STATUS,
                nfId: key,
                sts: status.utf8Encode()
            };

            if(stsTags.length){
                dataToUpdate['stsTags'] = stsTags;
            }

            location = location || {};
            dataToUpdate['lctn'] = !!location.description ? location.description.utf8Encode() : '';
            dataToUpdate['lat'] = location.lat || 9999;
            dataToUpdate['lng'] = location.lng || 9999;


            //http://192.168.1.117/ringID/ringIDWeb/issues/689
            var shouldUpdateLinkShareInfo = !feed.hasOgData() || feed.getLinkUrl() != ogData.url;

            if( shouldUpdateLinkShareInfo ){

                dataToUpdate['lnkDmn'] = ogData.domain || '';
                dataToUpdate['lnkDsc'] = ogData.description ? ogData.description.utf8Encode() : '';
                dataToUpdate['lnkTtl'] = ogData.title ? ogData.title.utf8Encode() : '';
                dataToUpdate['lnkURL'] = ogData.url ? ogData.url.utf8Encode() : '';
                dataToUpdate['lnlImgURL'] = ogData.image || '';
            }

            var shouldUpdateFeedEmotion = false;
            if(!!feedEmotions && !!feedEmotions.id){
                dataToUpdate.mdIds = [feedEmotions.id]; // we will support one emotion at a time for now
                shouldUpdateFeedEmotion = true;
            }else{
                dataToUpdate.mdIds = [];
                shouldUpdateFeedEmotion = true;
            }


            if( !!taggedFriends){
                if(!!taggedFriends.removed){
                    dataToUpdate['rTFrndIds'] = taggedFriends.removed;
                }
                if(!!taggedFriends.new){
                    dataToUpdate['tFrndIds'] = taggedFriends.new;
                }

            }

            if (feed !== false) {
                feed.setText(status,stsTags);
                feed.setLocationInfo(location);

                if(shouldUpdateFeedEmotion){
                    feed.setFeelings(feedEmotions);
                }

                if( shouldUpdateLinkShareInfo ){
                    feed.setOgData(ogData);
                }

                $$connector.request(dataToUpdate, OTYPES.REQUEST_TYPE.UPDATE).then(function (json) {
                    if (json.sucs === false) {
                        feed.setText(oldText);
                        feed.setLocationInfo(oldLocation);

                        if(shouldUpdateFeedEmotion){
                            feed.setFeelings(oldEmotions);
                        }


                        if( shouldUpdateLinkShareInfo ) {
                            feed.setOgData(oldOgData);
                        }


                        defer.reject(json);
                    } else {
                        defer.resolve(json);
                    }
                }, function (json) {
                    feed.setText(oldText);
                    feed.setLocationInfo(oldLocation);

                    if(shouldUpdateFeedEmotion){
                        feed.setFeelings(oldEmotions);
                    }


                    if( shouldUpdateLinkShareInfo ) {
                        feed.setOgData(oldOgData);
                    }

                    defer.reject(json);
                });

                //$feed.remove(feed.getMapKey());
            }
            return defer.promise;
        }

        // function deleteComment(comment, feed) {
        //     if (!feed) {
        //         feed = _getFeed(comment.getFeedKey());
        //     }
        //     var defer = $q.defer();
        //     if (comment && feed) {
        //         comment.isPending(true);
        //         $$connector.request(
        //             {
        //                 actn: OTYPES.TYPE_DELETE_STATUS_COMMENT,
        //                 nfId: comment.getFeedKey(),
        //                 cmnId: comment.getKey()
        //             }, OTYPES.REQUEST_TYPE.UPDATE
        //         ).then(function (json) {
        //                 if (json.sucs === true) {
        //                     feed.deleteComment(comment.getKey());
        //                     defer.resolve(json);
        //                 } else {
        //                     comment.isPending(false);
        //                     defer.reject(json);
        //                 }

        //             }, function (json) {
        //                 comment.isPending(false);
        //                 defer.reject(json);
        //             });

        //     }
        //     return defer.promise;
        // }

        // function updateComment(comment, text) {
        //     var defer = $q.defer(),
        //         oldText = comment.text();
        //     comment.setComment(text);
        //     comment.isPending(true);
        //     $$connector.request(
        //         {
        //             actn: OTYPES.TYPE_EDIT_STATUS_COMMENT,
        //             nfId: comment.getFeedKey(),
        //             cmnId: comment.getKey(),
        //             cmn: text.utf8Encode()
        //         }, OTYPES.REQUEST_TYPE.UPDATE
        //     ).then(function (json) {
        //             if (json.sucs === false) {
        //                 comment.setComment(oldText); // reset comment
        //                 defer.reject(json);
        //             } else {
        //                 defer.resolve(json);
        //             }
        //             comment.isPending(false);
        //         }, function (e) {
        //             comment.setComment(oldText);
        //             comment.isPending(false);
        //             defer.reject(json);
        //         });
        //     return defer.promise;
        // }

        // function fetchWhoLikesFeed(feed, commentId) { // keyId is either feedKey or imageKey // comment Id while fetch Like for comment
        //     var defer = $q.defer(), dorequest = !0; // type : n for feed , i for image

        //     if (feed === false) {
        //         defer.reject("feed Not Found");
        //         dorequest = !1;
        //     } else if (feed.getTotalLikes() === feed.getWhoLikes().length) {
        //         defer.resolve({sucs: true});
        //         dorequest = !1;
        //     }

        //     if (dorequest) {
        //         var requestData = {
        //             actn: OTYPES.TYPE_LIKES_FOR_STATUS,
        //             nfId: feed.getKey(),
        //             st : feed.getWhoLikes().length
        //         };
        //         var utids = [],notified=0;

        //         $$connector.pull(requestData, OTYPES.REQUEST_TYPE.REQUEST).then(function (json) {

        //             if (json.sucs === true) {
        //                 for(var i = 0; i< json.likes.length ; i++) {
        //                     utids[i] = json.likes[i].utId;
        //                 }
        //                 var payload = {
        //                     actn: OTYPES.FRIENDS.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS,
        //                     idList: utids
        //                 };
        //                 $$connector.send(payload, OTYPES.REQUEST_TYPE.REQUEST);
        //                 updateWhoLike(json, feed);
        //                 defer.resolve(json);
        //             } else {
        //                 defer.reject(json);
        //             }

        //         }, function (reason) {
        //         },function notify(json){
        //             if(json.sucs){
        //                 updateWhoLike(json, feed);
        //                 notified++;
        //             }

        //         });
        //         setTimeout(function(){
        //             if(!defer.promise.$$state.status && !notified){
        //                 defer.reject("No Data Found");
        //             }
        //         },3000);
        //     }

        //     return defer.promise;
        // }



        function moreFeedText(feed) {
            //console.log(obj);
            var defer = $q.defer(),
                payload = {
                    actn: OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS,
                    nfId: feed.getKey()
                };
            $$connector.request(payload, OTYPES.REQUEST_TYPE.REQUEST).then(function (json) {
                if (json.sucs) {
                    if (!!json.newsFeedList) {
                        feed.parseMoreText(json.newsFeedList[0]);
                    } else {
                        feed.parseMoreText(json);
                    }
                    defer.resolve(json);
                } else {
                    Ringalert.show(json, 'error');
                    defer.reject();
                }
            }, function (reason) {

                Ringalert.show(reason, 'error');
                defer.reject();
            });

            return defer.promise;
        }

        function getTagUsers(feed){
            //todo : remember to implement limit and starting offset
            return $$connector.pull({
                actn : OTYPES.TYPE_TAG_USER_LIST,
                nfId : feed.getKey()
            },OTYPES.REQUEST_TYPE.REQUEST);
        }


        function getSingleFeedPageKey(feedId){
            return OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS + "." + feedId ;
        }

        function getWhoShareFeedId(rawFeedData){
            var message = angular.isArray(rawFeedData) ? rawFeedData : rawFeedData.newsFeedList;
            if( message.length > 0 && message[0].whShrLst[0] ){
                return message[0].whShrLst[0].nfId;
            }
            return false;

        }

        function deleteWhoShareFromSingleFeedData(rawFeedData){
            var message = angular.isArray(rawFeedData) ? rawFeedData : rawFeedData.newsFeedList;
            if( message.length > 0 && message[0].whShrLst[0] ){
                delete message[0].whShrLst[0];
            }
        }



        /**
         * This function is a fake feed generator
         * were created for who share details fetch from feedWhoShareController
         *
         */
        //function fakeFeedGenerator(starting,length){
        //    var defer = $q.defer();
        //    starting = starting || 0;
        //    length = length || 5;
        //    var DataHouse = [{"nfId":4841,"uId":"2110010010","fndId":"2110063704","utId":5,"sts":"","tm":1442465461657,"at":1442465461657,"type":3,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","ffn":"Tom","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"fprIm":"","fprImPr":1,"imageList":[{"imgId":478,"iurl":"2110010010/1442465443047.jpg","cptn":"","ih":1280,"iw":720,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442465461657,"nl":0,"il":0,"ic":0,"nc":0},{"imgId":479,"iurl":"2110010010/1442465454105.jpg","cptn":"","ih":1280,"iw":720,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442465461657,"nl":0,"il":0,"ic":0,"nc":0}],"sfId":0,"tim":2,"grpId":0,"actvt":0,"auId":0,"imc":2,"sc":false},
        //
        //        {"nfId":4832,"uId":"2110010010","utId":5,"sts":"","tm":1442465426137,"at":1442465426137,"type":1,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"imageList":[{"imgId":477,"iurl":"2110010010/1442465417178.jpg","ih":1280,"iw":720,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442465426137,"nl":0,"il":0,"ic":0,"nc":0}],"sfId":0,"tim":1,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4843,"uId":"2110010010","fndId":"2110063704","utId":5,"sts":"","tm":1442465461657,"at":1442465461657,"type":3,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","ffn":"Tom","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"fprIm":"","fprImPr":1,"imageList":[{},{}],"sfId":0,"tim":2,"grpId":0,"actvt":0,"auId":0,"imc":2,"sc":false},
        //
        //        {"nfId":4834,"uId":"2110010010","utId":5,"sts":"","tm":1442465426137,"at":1442465426137,"type":1,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"imageList":[{}],"sfId":0,"tim":1,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4825,"uId":"2110010010","utId":5,"sts":"","tm":1442465404677,"at":1442465404677,"type":1,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"imageList":[{"imgId":476,"iurl":"2110010010/1442465396383.jpg","ih":1280,"iw":720,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442465404677,"nl":0,"il":0,"ic":0,"nc":0}],"sfId":0,"tim":1,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //        {"nfId":4646,"uId":"2110010130","utId":107,"sts":"fdsfsdfsdf","tm":1442407330406,"at":1442407330406,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4827,"uId":"2110010010","utId":5,"sts":"","tm":1442465404677,"at":1442465404677,"type":1,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"imageList":[{}],"sfId":0,"tim":1,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4648,"uId":"2110010130","utId":107,"sts":"fdsfsdfsdf","tm":1442407330406,"at":1442407330406,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4639,"uId":"2110010130","utId":107,"sts":"sadasdasdasd","tm":1442407276553,"at":1442407276553,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4621,"uId":"2110010130","utId":107,"sts":"sadasdasd","tm":1442407247081,"at":1442407247081,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //        {"nfId":4632,"uId":"2110010130","utId":107,"sts":"sadasdasdasd","tm":1442407276553,"at":1442407276553,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4623,"uId":"2110010130","utId":107,"sts":"sadasdasd","tm":1442407247081,"at":1442407247081,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4614,"uId":"2110010130","utId":107,"sts":"asdasdasd","tm":1442407135324,"at":1442407135324,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4605,"uId":"2110010130","utId":107,"sts":"asdasdasd","tm":1442407104103,"at":1442407104103,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4616,"uId":"2110010130","utId":107,"sts":"asdasdasd","tm":1442407135324,"at":1442407135324,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4607,"uId":"2110010130","utId":107,"sts":"asdasdasd","tm":1442407104103,"at":1442407104103,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4588,"uId":"2110010130","utId":107,"sts":"The awesome post","tm":1442405763121,"at":1442405763121,"type":3,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"imageList":[{"imgId":460,"iurl":"2110010130/1442405663379.jpg","cptn":"The awesome guitter","ih":768,"iw":1024,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442405763121,"nl":0,"il":0,"ic":0,"nc":0},{"imgId":461,"iurl":"2110010130/1442405663380.jpg","cptn":"The awesome sunflower","ih":768,"iw":1024,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442405763121,"nl":0,"il":0,"ic":0,"nc":0},{"imgId":459,"iurl":"2110010130/1442405663376.jpg","cptn":"The awesome Flower","ih":768,"iw":1024,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442405763121,"nl":0,"il":0,"ic":1,"nc":2}],"sfId":0,"tim":4,"grpId":0,"actvt":0,"auId":0,"imc":4,"sc":false},
        //
        //        {"nfId":4579,"uId":"2110010130","utId":107,"sts":"asdasdasd ads ad asda dsasd","tm":1442405625514,"at":1442405625514,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4581,"uId":"2110010130","utId":107,"sts":"The awesome post","tm":1442405763121,"at":1442405763121,"type":3,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"imageList":[{},{},{}],"sfId":0,"tim":4,"grpId":0,"actvt":0,"auId":0,"imc":4,"sc":false},
        //
        //        {"nfId":4572,"uId":"2110010130","utId":107,"sts":"asdasdasd ads ad asda dsasd","tm":1442405625514,"at":1442405625514,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false}];
        //
        //    setTimeout(function(){
        //        var r_object=[];
        //        for(var i = starting; i < starting + length;i++){
        //            if(i>DataHouse.length)break;
        //            try{
        //                r_object.push($$feedMap.create(DataHouse[i]));
        //            }catch(e){
        //                console.dir(e);
        //            }
        //        }
        //        if(r_object.length){
        //            defer.resolve(r_object);
        //        }else{
        //            defer.reject("no more Feed");
        //        }
        //    },2000);
        //
        //    return defer.promise;
        //}

    }

})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }
    feedApp.directive('rgFeedSubscriber',rgFeedSubscriber);

    rgFeedSubscriber.$inject = ['$$connector','feedFactory','$window','$$rgsyncher','OPERATION_TYPES','REASON_CODES', '$rootScope'];
        function rgFeedSubscriber($$connector, feedFactory,$window,$$rgsyncher,OPERATION_TYPES,REASON_CODES, $rootScope) {
            return function (cscope, element, attrs) {
                var scope = cscope.$parent,
                    initial_req = true,
                    counter_previous =0,
                    counter_current = 0,
                    OTYPES = OPERATION_TYPES.SYSTEM,
                    timeout_set = false;

                var updateScope = function RecursePro() {
                     //counter_previous = counter_current;
                    // console.log("called UpdateScope");
                    timeout_set = true;
                    var scrollTop = 0;
                    counter_previous = counter_current;
                    window.setTimeout(function () {
                      //  console.log("called timeouts");
                        if (counter_previous !== counter_current){
                             RingLogger.print("counter greater 10",counter_current,"RGSUBSCRIBER");
                             RecursePro(); return;
                        }else{
                            timeout_set = false;
                          //  counter_current = 0;
                            scope.feeds = feedFactory.getFeeds();
                            //scrollTop = element[0].scrollTop;
                            scope.clearRequestTimer && scope.clearRequestTimer();
                            scope.busy = false;
                            scope.$rgDigest();
                            RingLogger.print(counter_current,"RGSUBSCRIBER");
                            //element[0].scrollTop = (scrollTop+element[0].clientHeight-150);
                        }
                    },30);
                };
                var ignored = false;
                function processFeed(message){
                    var targetScope;
                    if(!ignored){
                        ignored = true;
                        scope.addIgnore();

                        setTimeout(function(){
                            $rootScope.$broadcast('FIRST_FEED_RECEIVED');
                        }, 1000);

                    }
                    if(!message.sucs && message.rc > 0 && message.rc == REASON_CODES.NO_MORE_FEED){
                        scope.setNoMoreFeed(true);
                    }else{
                       targetScope = feedFactory.process(message);
                    }


                    //  console.dir(message);
                    //$timeout(function () {
                    //    feeds = feedFactory.getFeeds();
                    //    $scope.busy = false;
                    //});



                    if(targetScope){
                        targetScope.$rgDigest();
                    }else /*if (counter_current > 5 || (initial_req && counter_current>2))*/ {
                       counter_current++;
                       scope.feeds = feedFactory.getFeeds();
                       if(scope.busy){
                        scope.busy = false;
                        scope.clearRequestTimer() ;
                       }

                       //
                       //counter_current = 0;
                       //initial_req = false;
                      // if(counter_current > 10 && timeout_set === false){
                        //updateScope();
                      // }else{
                       // if(!timeout_set){

                        if(timeout_set === false) {
                            timeout_set = true;
                            requestAnimationFrame(function(){
                                scope.$rgDigest();
                                timeout_set = false;
                            });

                        }


                       // }

                      // }
                    }

                };

                var subKey = $$connector.subscribe(processFeed,{
                    filter : feedFactory.getFeedFilter(),
                    callWithUnresolved : true
                });

                // scope.$on('feedShared',function($ev){
                //     // scope.$digest();
                // });

                //$$connector.request({
                //    "actn" : OTYPES.TYPE_NEWS_FEED,
                //    "request_type" : OTYPES.REQUEST_TYPE.REQUEST,
                //    "lmt" : 10
                //}).then(function(json){
                //    console.dir(json);
                //});


               // feedFactory.requestForFeed(scope.params);


                var syncher_key = $$rgsyncher.add(function(){
                    feedFactory.requestForFeed(scope.params,1);
                });

                scope.$on('$destroy', function (){
                    $$connector.unsubscribe(subKey);
                    feedFactory.reset();
                    $$rgsyncher.remove(syncher_key);
                    if(ignored){
                        scope.removeIgnore();
                    }
                });
            };
        };
})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }
    feedApp.directive('feedImage',feedImage);
    // feedApp.directive("feedImageStyle",function(){
    //     return function (scope,element,attr){
    //         var image = scope.feedimages[attr.feedImageStyle].value;
    //         var styles = {backgroundImage: 'url(' + image.src(600) + ')'};
    //          element.css(styles);
    //          RingLogger.print(element[0].clientHeight,"feedImage");
    //     }
    // });
    feedImage.$inject = ['utilsFactory','SystemEvents','$compile'];
    function feedImage(utilsFactory,SystemEvents,$compile) {
            function getHeightByWidth(ob,width){ //ob is image image map offset() api return value
                return (width * ob.height)/ob.width;
            }
// <div ng-repeat="image in feed.getImages()" ng-init="image = image.value;" class="floader" feed-image
//              rg-ringbox="true" ringbox-controller="RingBoxImagePopupController" ringbox-type="remote"
//              ringbox-target="pages/partials/notification/image-popup.html"
//              ringbox-data="getImageData(image, feed)"></div>
            function getImageTemplate(index,template){
                return '<div class="img'+(index+1)+'" style="background-image:url(\'{{::feedimages['+index+'].value.src(600)}}\')" rg-ringbox="true"'
                        +'ringbox-controller="RingBoxImagePopupController" ringbox-type="remote" ringbox-animation="true" '
                        +'ringbox-target="pages/partials/notification/'+(template || 'image-popup.html')+'"'
                        +' ringbox-data="getImageData(feedimages['+index+'].value, feed)"></div>';
            }
            var layoutHtmls = {
                        layout_0 : '<div class="grid">'+getImageTemplate(0)+'</div>'
                                          +'<div class="grid">'+getImageTemplate(1) + getImageTemplate(2)+'</div>',
                        layout_2 : '<div class="grid">'+getImageTemplate(0) + getImageTemplate(1)+'</div>'
                                          +'<div class="grid">'+getImageTemplate(2)+'</div>',
                        layout_4 : '<div class="grid">'+getImageTemplate(0) + getImageTemplate(1)+'</div>',
                        layout_5 : getImageTemplate(0)
                    };
                    layoutHtmls.layout_1 = layoutHtmls.layout_0;
                    layoutHtmls.layout_3 = layoutHtmls.layout_2;
                    layoutHtmls.layout_6 = layoutHtmls.layout_5;
                var layoutHtmls2 = {
                    layout_0 : '<div class="grid">'+getImageTemplate(0,"image-popup-special.html")+'</div>'
                                          +'<div class="grid">'+getImageTemplate(1,"image-popup-special.html") + getImageTemplate(2,"image-popup-special.html")+'</div>',
                        layout_2 : '<div class="grid">'+getImageTemplate(0,"image-popup-special.html") + getImageTemplate(1,'image-popup-special.html')+'</div>'
                                          +'<div class="grid">'+getImageTemplate(2,"image-popup-special.html")+'</div>',
                        layout_4 : '<div class="grid">'+getImageTemplate(0,"image-popup-special.html") + getImageTemplate(1,"image-popup-special.html")+'</div>',
                        layout_5 : getImageTemplate(0,"image-popup-special.html")
                    };
                    layoutHtmls2.layout_1 = layoutHtmls2.layout_0;
                    layoutHtmls2.layout_3 = layoutHtmls2.layout_2;
                    layoutHtmls2.layout_6 = layoutHtmls2.layout_5;
                

            return {
                restrict: 'A',
                scope : true,
                link: function (scope, element, attr) {
                        var layouts;
                        if(attr.feedImage === 'shared'){
                            scope.feed = scope.feed.getOrginalFeed();
                        }
                        //scope.divHeight = element[0].offsetHeight;
                        //scope.divWidth = element[0].offsetWidth;
                        scope.layout_id = scope.feed.getImageLayout();

                        scope.feedimages = scope.feed.getImages();
                       // scope.layout_styles = layoutHtmls['layout_'+scope.layout_id].styles;
                        if(scope.layout_id === 5){
                            if(scope.feedimages[0].value.offset().width < 600 && scope.feedimages[0].value.offset().height < 400){
                                scope.layout_id = 6;
                            }else{
                                if(getHeightByWidth(scope.feedimages[0].value.offset(),600) < 400){
                                    scope.layout_id = 6;
                                }
                            }
                            // element.css({
                            //     height : scope.feedimages[0].value.offset().height +'px'
                            // });
                        }

                        element.addClass('img-layout-'+scope.layout_id);
                        if(scope.feedimages.length){
                            if(attr.popupTemplate){
                                layouts = layoutHtmls2;
                            }else{
                                layouts = layoutHtmls;
                            }
                            var html = $compile(layouts['layout_'+scope.layout_id])(scope);
                            if(scope.feed.getTotalImage() > 3){
                                html[1].lastChild.innerHTML = '<div class="img-bg-opa"></div>\
    <div class="img-bg-counter">+'+(scope.feed.getTotalImage() - 3)+'</div>';
                            }
                            element.html("");
                            element.append(html);

                        }




                        // if(!angular.isDefined(scope.imageslength)){
                        //     scope.imageslength = 1;
                        // }

                        // element.removeClass('floader');

                        // var imageOffset = scope.image.offset();

                        // function setWidthHeight(withClass){
                        //     var classname;
                        //     if(((scope.imageslength >= 3 && scope.$index === 0 )) || scope.imageslength == 1){
                        //         classname = 'full';
                        //         if(utilsFactory.feedCellWidth > imageOffset.width){
                        //             element.css({
                        //                 width : imageOffset.width +'px',
                        //                 height : imageOffset.height +'px'
                        //             });
                        //         }else{
                        //             element.css({
                        //                 width : utilsFactory.feedCellWidth +'px',
                        //                 height : getHeightByWidth(imageOffset,utilsFactory.feedCellWidth) + 'px'
                        //             });

                        //         }
                        //         if(scope.imageslength == 1){
                        //             classname = 'single';
                        //         }
                        //     }else if ((scope.imageslength == 2 || scope.$index > 0 )) {
                        //         classname = 'half';
                        //     }

                        //     if(withClass){
                        //         element.addClass(classname);
                        //     }

                        // }
                        // scope.$on(SystemEvents.COMMON.WINDOW_RESIZED,function ($event) {
                        //     if(!attr['feedImageResponsive']) {
                        //         setWidthHeight()
                        //     }
                        // });

                        // scope.$on(SystemEvents.COMMON.COLUMN_CHANGED,function ($event) {
                        //      RingLogger.print(SystemEvents.COMMON.COLUMN_CHANGED + " fired","EVENTS");
                        //     if(!attr['feedImageResponsive']) {
                        //         setWidthHeight()
                        //     }
                        // });

                        // if(!attr['feedImageResponsive']){
                        //     setWidthHeight(true);
                        // }

                       // element.css({backgroundImage: 'url(' + scope.image.src(600) + ')'});
                        //  console.dir(scope.image.offset());
                        //if (img.complete) { // sometimes when browser load the image from cache // onload not fired
                        //    loadHandler();
                        //}

                    }
            };
    }

    /** 
     * directive not in use
     */
    // feedApp.directive('feedVideo',feedVideoDirective);

    // feedVideoDirective.$inject = ['utilsFactory','SystemEvents'];
    //  function feedVideoDirective(utilsFactory,SystemEvents) {
    //         function getHeightByWidth(ob,width){ //ob is image image map offset() api return value
    //             return (width * ob.height)/ob.width;
    //         }

    //     return {
    //         restrict: 'A',
    //         link:  function (scope, element, attr) {

    //                 if(!angular.isDefined(scope.medialength)){
    //                     scope.medialength = 1;
    //                 }

    //                // element.removeClass('floader');

    //                 var imageOffset = scope.media.thumbOffset();

    //                 function setWidthHeight(withClass){
    //                     var classname;
    //                     if(((scope.medialength >= 3 && scope.$index === 0 )) || scope.medialength == 1){
    //                         classname = 'full';
    //                             if(scope.media.isVideo()){
    //                                if(utilsFactory.feedCellWidth > imageOffset.width){
    //                                     element.css({
    //                                         width : imageOffset.width +'px',
    //                                         height : imageOffset.height +'px'
    //                                     });
    //                                 }else{
    //                                     element.css({
    //                                         width : utilsFactory.feedCellWidth +'px',
    //                                         height : getHeightByWidth(imageOffset,utilsFactory.feedCellWidth) + 'px'
    //                                     });
    //                                }
    //                             }

    //                         if(scope.medialength == 1){
    //                             classname = 'single';
    //                         }
    //                     }else if ((scope.medialength == 2 || scope.$index > 0 )) {
    //                         classname = 'half';
    //                     }

    //                     if(withClass){
    //                         element.addClass(classname);
    //                     }

    //                 }
    //                 scope.$on(SystemEvents.COMMON.WINDOW_RESIZED,function ($event) {
    //                     if(!attr['feedImageResponsive']) {
    //                         setWidthHeight()
    //                     }
    //                 });

    //                 if(!attr['feedImageResponsive']){
    //                     setWidthHeight(true);
    //                 }

    //                 element.css({backgroundImage: 'url(' + scope.media.feedThumb() + ')'});
    //                 //  console.dir(scope.image.offset());
    //                 //if (img.complete) { // sometimes when browser load the image from cache // onload not fired
    //                 //    loadHandler();
    //                 //}

    //             }


    //     }
        
    // }
})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
        .directive('rgMoreFeed', rgMoreFeed);


    rgMoreFeed.$inject = ['feedFactory', 'SystemEvents'];
    function rgMoreFeed(feedFactory, SystemEvents) {
        return {
            restrict: 'A',
            link: function(scope, element, attr) {
                var feed = scope.$eval(attr.rgMoreFeed),updatedText = false,count=0;

                function setFeedText(){
                    var content = feed.getDynamicText();
                    if(content.toString()){
                        element.html(content.toString());    
                        if(!scope.editorEnabled){
                            element.removeClass('ng-hide');    
                        }else{
                            element.addClass("ng-hide");
                        }
                        
                    }else{
                        element.addClass("ng-hide");
                    }
                    SetShowMoreButton();
                }

                

                function SetShowMoreButton(){
                    if(feed.showMore() && !updatedText) {
                      var moreel = angular.element('<span class="showpointer showmore"> Show More</span>');
                        element.append(moreel);
                        moreel.bind('click', moreFeedText);
                        scope.$on('$destroy',function(){
                           if(!!moreel) { 
                              moreel.unbind('click');
                              moreel = null;
                           }  
                        });
                    }
                }
                setFeedText();

                scope.$on(SystemEvents.FEED.UPDATED, function(event, data){
                    if( data.id === feed.getKey() ){
                        setFeedText();
                    }
                });

                scope.$on(SystemEvents.FEED.RESET, function(event, f){
                    if( f.getKey() === feed.getKey() ){
                        feed = f;
                        setFeedText();
                    }
                });

                scope.$watch('feed.text()', function(oldVal, newVal){
                   if(count > 0){
                    setFeedText();//skipping for first time
                   } 
                   count++;
                });

                scope.$watch('editorEnabled', function(oldVal, newVal){
                    setFeedText();//skipping for first time
                });


                function moreFeedText() {
                    feedFactory.moreFeedText(feed).then(function(json) {
                            scope[attr.rgMoreFeed] = feed;
                            element.html(feed.getDynamicText().toString());
                            moreel.unbind('click');
                            moreel=null;
                            scope.$rgDigest();
                            updatedText = true;
                        //scope.$digest();
                    });
                }



            }
        };
    }

})();


/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
        .directive('rgIncomingFeed', rgIncomingFeed);


    rgIncomingFeed.$inject = ['feedFactory', '$window','utilsFactory','OPERATION_TYPES'];
    function rgIncomingFeed(feedFactory, $window,utilsFactory,OPERATION_TYPES) {
        return {
            restrict: 'A',
            link: function(scope, element, attr) {
                var windowEl = angular.element($window)
                    ,pageValue = feedFactory.getCurrentPageValue()
                    ,extraHeight = 0
                    ,previousScrollTop
                    ,OTYPES = OPERATION_TYPES.SYSTEM;
                
                switch (pageValue.action) {
                    case OTYPES.TYPE_MY_NEWS_FEED:
                    case OTYPES.TYPE_FRIEND_NEWSFEED:
                         extraHeight = 492;break;
                    case OTYPES.TYPE_GROUP_NEWS_FEED:
                        extraHeight = 250;break;
                    case OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS:
                    case OTYPES.TYPE_NEWS_FEED:
                    default :
                        extraHeight = 0;
                }
                function position(){
                    var scrollP = utilsFactory.viewport.yo,diff,top;

                    if(extraHeight > 0){
                        top = extraHeight + 75;
                        diff = top - scrollP;
                        if(diff > 0){
                            if(diff < 75){
                                element.css('top',75+'px');
                            }else{
                                element.css('top',diff+'px');
                            }
                            
                        }
                    }
                }
                function updateClass(){
                    if(feedFactory.hasUnprocessedFeed()){
                        if(!element.hasClass('active')){
                            element.addClass('active');
                        }
                       
                    }else{
                        element.removeClass('active');
                    }

                }

                function update(){

                     if(utilsFactory.viewport.yo >  500){
                            feedFactory.setpushInIncomingFeed(true);
                     }else{
                        if(feedFactory.hasUnprocessedFeed() && previousScrollTop > utilsFactory.viewport.yo){
                           feedFactory.processIncomingFeed();
                           feedFactory.setpushInIncomingFeed(false);
                           updateClass(); 
                        }else{
                            feedFactory.setpushInIncomingFeed(false);    
                        }
                        
                    }
                    if(element.hasClass('active')){
                        position();
                    }
                    previousScrollTop = utilsFactory.viewport.yo;
                }

                scope.$watch(feedFactory.hasUnprocessedFeed,function(newV,oldV){
                    if(newV > oldV){
                        updateClass();
                    }
                });

                

                

                element.on("click",function(){
                    feedFactory.processIncomingFeed();
                    feedFactory.setpushInIncomingFeed(false);
                    updateClass();
                   
                    utilsFactory.resetScroll();
                    utilsFactory.animateScroll();
                    
                    scope.setFeed();
                    scope.$rgDigest();
                });


                windowEl.bind("scroll", update);
                var cleanupEvents = function () {
                    windowEl.unbind('scroll', update);
                    element.off("click");
                };
                // console.log(elem.scrollTop);

                updateClass();
                scope.$on('$destroy', cleanupEvents);

            }
        };
    }

})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        console.warn("Feed Module Not Found");
        return;
    }
    feedApp.directive('feedTimeoutSelect', feedTimeoutSelect);
    feedApp.directive('feedTimoutOption', feedTimoutOption);
    feedApp.directive('feedTimeoutMenu', feedTimeoutMenu);


    function feedTimoutOption(){

        return {
            restrict: 'E',
            replace : true,
            templateUrl : 'pages/partials/feed-timeout-option.html',
            link : function(scope){
                    scope.$rgDigest();
            },
            controller : ['$scope',function($scope){

                $scope.rows = [1,9,17];
                $scope.cols = [0,1,2,3,4,5,6,7];
                $scope.lastCols = [25,26,27,28,29,30];

                $scope.select = function(v){
                    if(angular.isFunction($scope.onSelect)){
                        $scope.onSelect({item:v});
                        
                    }
                    $scope.close();
                    $scope.$parent.$rgDigest();
                }

            }]
        };

    };

    function feedTimeoutSelect(){

        return function(scope,element,attr){

            element.on("click",function(e){
                e.stopPropagation();
                scope.select(attr['feedTimeoutSelect']);
            });

            scope.$on('$destroy',function(){
                element.off("click");
            });
        };


    };

    feedTimeoutMenu.$inject = ['$document','$compile'];
    function feedTimeoutMenu($document,$compile) {
        return {
            restrict : 'A',
            scope : {
                onSelect : '&ringOnOptionSelect',
                value : '=selectedValue'
            },
            link : function(scope,element,attr){
            
                var menuDom, isOpen = false;
                
                scope.close = function(){
                    if(menuDom) menuDom.remove();
                    menuDom = null;
                    isOpen = false;
                    $document.off("click", checkClickedOnElement);
                };
                scope.$watch('value',function(newval,oldval){
                            if(parseInt(newval) > -1){
                                element.addClass('active');
                            }else{
                                element.removeClass('active');
                            }
                });

                function checkClickedOnElement(e){

                    if(e.target != element[0] && e.target.parentNode != element[0] && e.target.parentNode.parentNode != element[0] && e.target.className !='pt-top') {
                        scope.close();
                    }
                }

                element.on("click",function(event){
                        if(isOpen) {
                          scope.close();
                          return '';
                        }
                    	if(!menuDom){
                        	menuDom = $compile(angular.element('<feed-timout-option></feed-timout-option>'))(scope);
                    	}
                    	element.after(menuDom);
                    	isOpen = true;
                    	

                        $document.on("click", checkClickedOnElement);



                });

                scope.$on('$destroy', function(){
                    element.off('click');
                    $document.off("click", checkClickedOnElement);

                });
            }
        };
    };

})();

/**
 * © Ipvision
 */

(function () {
    'use strict';

    angular.module('ringid.feed')
    .directive('feedRepeat', feedRepeat);

    feedRepeat.$inject = ['$parse', '$compile', '$templateCache', '$http', 'utilsFactory','$rootScope', 'SystemEvents','$sniffer', 'feedFactory'];

    function feedRepeat($parse, $compile, $templateCache, $http, helper, $rootScope, SystemEvents, $sniffer, feedFactory) {

        function compile(element, attr) {


            return function ($scope, $element, $attr, ctrl, $transclude) {

                var expression = $attr.feedRepeat;
                var match = expression.match(/^\s*(.+)\s+in\s+(.*?)\s*$/),
                    index, lhs, rhs, trackByExp, valueIdentifier, cell, cells = [],
                    maxColumn = 3,
                    column = helper.feedColumn(),
                    lastBlockMap = Object.create(null),
                    lastCollection = [],
                    onFeedProcesing = false,
                    wrapper = document.querySelector('div.middle'),
                    feedContainer = document.getElementById('feeds-container'),
                    wh = helper.viewport.y,
                    hwh = wh/2,
                    wst = 0,
                    scrollHeight=0,
                    prefix = $sniffer.vendorPrefix.toLowerCase(),
                    doAnimation = (prefix == 'moz' || prefix == 'ms')? false: true,
                    busy = false,
                    first = true,
                    totalFeeds =0,
                    specialTpl = '',
                    specials = [],
                    readyToFeed = false,
                    lastLoader = false,
                    lastLoaderFrame = false,
                    specialBlockMap = Object.create(null),
                    elm;
                
                /*
                if (!match) {
                    throw "Expected expression in form of '_item_ in _collection track by _key_'";
                } */

                var t0 = window.performance.now();

                lhs = match[1];
                rhs = match[2];
               
                /* find getter function by parsing track by*/
                var getTrackID = (match[3])? $parse(match[3]) : '';

                valueIdentifier = match[1];

                // Creating Feed Cell
                for (index = 0; index < maxColumn; index++) {
                    cell = {};
                    elm = document.createElement('div');
                    elm.className = "cell cell-id" + index;
                    elm.appendChild(document.createComment('cell: ' + index));
                    cell.element = elm;
                
                    /*loader*/
                    var loader = document.createElement('div');

                    loader.innerHTML = '<div class="rf-box">'
                                            + '<div class="rf-top">'
                                                + '<div class="rf-cir">'
                                                     + '<span class="icon-logo-circle"></span>'
                                                + '</div>'
                                                + '<div class="rf-line"></div>'
                                                + '</div>'
                                                + '<div class="rc-feed"> </div>'
                                                + '<div class="rc-feed rc2"> </div>'
                                                + '<div class="rc-feed rc3"> </div>'
                                                + '<div class="rf-ics"></div>'
                                            + '</div>';
                                        
                    loader.style.display = 'none';
                    elm.appendChild(loader);
                    
                    cell.loader = loader;
                    cells[index] = cell;

                    /*post box*/
                    if ($attr.postbox && index == 0) {
                        (function (elm) {
                            $http.get($attr.postbox, {cache: $templateCache}).then(function (result) {
                                var template = $compile(result.data)($scope);
                                //elm.firstChild appendChild(template[0]);
                                elm.insertBefore(template[0], elm.firstChild.nextSibling);
                                readyToFeed = true;
                                
                                requestAnimationFrame(function(){
                                  update($scope[rhs]);
                               }); 

                               /*digest after loading postbox*/ 
                               $scope.$rgDigest();

                            });
                        })(elm);
                    }
                  loader = null;
                }
                
                $http.get("pages/partials/special-feed.html", {cache: $templateCache}).then(function (result) {
                    specialTpl = result.data;
                 });

                

                /* append in main div*/
                for (index = 0; index < maxColumn; index++) {
                    $element[0].appendChild(cells[index].element);
                }
                

                var showLoader = function(display) { 
                   
                   if(lastLoader == display || lastLoaderFrame) return;

                   requestAnimationFrame(function(){
                      for (var index = 0; index < column; index++) {
                       if(cells && cells[index].loader) cells[index].loader.style.display = (display)?'block':'none';
                      }
                      lastLoaderFrame = false;
                      console.log('display ='+display+' time '+ window.performance.now());
                   });
                   
                   lastLoaderFrame = true;
                   lastLoader = display; 
                    
                }
                
                var setCellVisibility = function() {

                    for (var index = 0; index < maxColumn; index++) {
                        if (index < column) {
                            cells[index].element.style.display = 'block';
                        }
                        else {
                            cells[index].element.style.display = 'none';
                        }
                    }
                }

                var doColumnChange = function(){
                    update($scope[rhs]);
                    onScrollEvent(false);
                    busy = false;
                    showLoader(busy);
                    setCellVisibility();
                }

                
                /*set view window*/
                wrapper.style.height = wh+'px';
                element[0].className='cols-'+column;
                setCellVisibility();
                busy = true;
                showLoader(busy);
                
                /* calculate height*/ 
                var offsetTop = (-1)*wh*4;
                var offsetBottom = wh*4;
                var lastHeight =0;

                /* scorilling hack for refreshing issue */

                document.documentElement.scrollTop = 0;
                document.body.parentNode.scrollTop = 0;
                document.body.scrollTop = 0;

                
                var onScrollEvent = function(loadFeed) {
                        
                        /*request new feed*/
                        if(!readyToFeed) return;
                        if(!cells) return;

                        requestAnimationFrame(function() {
                            
                            var loadThreshold;
                            scrollHeight = $element[0].scrollHeight; 
                            loadThreshold = scrollHeight - helper.viewport.y - helper.viewport.y;
                            

                            if (helper.viewport.yo > loadThreshold && !!loadFeed) {

                                $scope.LoadMoreData();

                                if($scope.noMoreFeed) return;

                                if($scope.busy != busy) {
                                   busy = $scope.busy;  
                                   showLoader(busy);   
                                }
                            }
                        
                    
                            /*hide feed dom if it is out of the viewport*/ 
                            if(onFeedProcesing) return; 
                            if(Math.abs(helper.viewport.yo - wst) < hwh) return;
                            
                            var cols = [139,0,0], col, trackID, value, block, height, show = [], hide = [], pt=[0,0,0], pb=[0,0,0];  //column1 contain postbox which height is 139
                            wst = helper.viewport.yo;
                            
                            /*special feeds*/
                            
                            for (index = 0; index < specials.length; index++) {
                                value = specials[index];
                                trackID = value.key;
                                if(!specialBlockMap[trackID]) continue;

                                block = specialBlockMap[trackID];
                                height = block.height;
                                col = block.cell;
                                cols[col] += height;

                                if( cols[col] >= (offsetTop + wst) &&  cols[col] <= (wst+wh+offsetBottom)) {
                                    if(!!block.clone.RG_HIDDEN) {
                                       show.push(block.clone);
                                    }  
                                } 
                                else {
                                
                                    if(cols[col] < (offsetTop + wst)) {
                                        pt[col] += height;
                                    }
                                        
                                    if(cols[col] >= (offsetTop + wst) && cols[col] > (wst+wh+offsetBottom)) {
                                        pb[col] += height; 
                                    }
                                    
                                    if(!block.clone.RG_HIDDEN) {
                                        
                                       hide.push(block.clone);
                                    }
                                }
                            }    

                            /*regular feed*/
                            for (index = 0; index < lastCollection.length; index++) {
            
                                value = lastCollection[index];
                                trackID = value.key;
                                if(!lastBlockMap[trackID]) continue;
                                block = lastBlockMap[trackID];
                                height = block.height;
                                col = block.cell;
                                cols[col] += height;
                                
                                if( cols[col] >= (offsetTop + wst) &&  cols[col] <= (wst+wh+offsetBottom)) {
                                    if(!!block.clone.RG_HIDDEN) {
                                       show.push(block.clone);
                                    }  
                                } 
                                else {
                                
                                    if(cols[col] < (offsetTop + wst)) {
                                        pt[col] += height;
                                    }
                                        
                                    if(cols[col] >= (offsetTop + wst) && cols[col] > (wst+wh+offsetBottom)) {
                                        pb[col] += height; 
                                    }
                                    
                                    if(!block.clone.RG_HIDDEN) {
                                        
                                       hide.push(block.clone);
                                    }
                                }
                            }
                            
                           value = null;
                           block = null;
                           
                           var max = Math.max(Math.max.apply(null, cols),wh);
                            
                          // requestAnimationFrame(function() {
                           
                                wrapper.style.height = (max+hwh)+'px';
                                for (var i = 0; i < cells.length; i++) {
                                   cells[i].element.style.paddingTop = pt[i]+'px';
                                }
                                
                                for (var i = 0; i < show.length; i++) {
                                    show[i].style.display = 'block';
                                    show[i].RG_HIDDEN = false;
                                 }
                                  
                                for (var i = 0; i < hide.length; i++) {
                                    hide[i].style.display = 'none';
                                    hide[i].RG_HIDDEN = true;  
                                } 
                      });     
                           
                  }
                    
                window.addEventListener("scroll", onScrollEvent);
                
                $scope.$on(SystemEvents.COMMON.COLUMN_CHANGED, function(event, newVal){
                    column = newVal;
                    element[0].className='cols-'+column;
                    doColumnChange();  
                });

                $scope.$on(SystemEvents.COMMON.WINDOW_RESIZED, function(event, newVal){
                    column = helper.feedColumn();
                    element[0].className='cols-'+column;
                    doColumnChange();  
                });
               

                $scope.$watchCollection(rhs, update);
                
                
                $scope.$on('$destroy', function(){
                   lastBlockMap = lastCollection = elm = cells = cell = specialBlockMap = specials = specialTpl =null;
                   window.removeEventListener("scroll", onScrollEvent);
                });
                
                $scope.$on(SystemEvents.FEED.HEIGHT, function($event, key){
                
                    $event.stopPropagation();
                    
                    if(!lastBlockMap[key]) return;
                      
                    deferFeedHeight(key);
                });

                $scope.$on(SystemEvents.FEED.BUSY, function($event, isBusy){ 
                     busy = isBusy;
                     showLoader(busy);
                });


                function deferFeedHeight(key){


                    fastdom.defer(3,function() {
                        if(lastBlockMap && lastBlockMap[key]) {
                           lastBlockMap[key].height = lastBlockMap[key].clone.offsetHeight + 12;  
                        }
                     });
                }
                
                function eventTranstionEnd() {
                
                  this.removeEventListener(prefix+'TransitionEnd', eventTranstionEnd);
                  this.removeEventListener('transitionend', eventTranstionEnd); 
                  this.parentNode.removeChild(this);

                }
 
               

                function eventTranstionEnd2() {
                
                  this.removeEventListener(prefix+'TransitionEnd', eventTranstionEnd2);
                  this.removeEventListener('transitionend', eventTranstionEnd2); 
                  
                  RingLogger.info("animation complete:"+ (window.performance.now()-t0), RingLogger.tags.DIGEST);


                }

                

                function update(collection) {
                     
                    RingLogger.print("update called", "RGREPEAT");

                    var index, i, length = collection.length,
                        value, childScope, cellIndex, trackID, block, prevNode = [],
                        nextNode, nextBlockMap = Object.create(null), parent, clone, 
                        special = 0, initialDigest = false; //speciaSerial = false

                     onFeedProcesing = true;

                     if(!readyToFeed) return;
                     if(!cells) return;

                     if(collection.length == 0 && first) {
                        
                        if($scope.noMoreFeed) {

                            requestAnimationFrame(function(){
                                $scope.$rgDigest();
                                //initialDigest = false;
                            });
                        }
                        return;  
                     }
                     
                     RingLogger.info("first called: ("+collection.length+")"+ (window.performance.now()-t0), RingLogger.tags.DIGEST);
                     
                      $rootScope.$$postDigest(function() {
                         var index, value, block;
                         for (index = 0; index < collection.length; index++) {
                            value = collection[index];
                            trackID = value.key;
                            if(!lastBlockMap[trackID]) continue;
                            block = lastBlockMap[trackID];
                            if(block.childHead) block.scope.$$childHead = block.childHead;
                          }
                      }); 
                    

                    if(feedFactory.hasSpecialFeed()) {
                       specials = feedFactory.getSpecialFeedList();  
                       special = specials.length;
                    }
                    
                    

                    /* Find next Blocks that are going to be added*/
                  
                    for (index = 0; index < length; index++) {

                        cellIndex = (index+special) % column;
                        value = collection[index];    
                        trackID = value.key; // huh, considering a constant track ID

                        if (lastBlockMap[trackID]) {

                            block = lastBlockMap[trackID];
                            block.cell = cellIndex;
                            delete lastBlockMap[trackID]; // found it and it is going to be processed in next blockmap and deleted it

                        } else {

                            childScope = $scope.$new();
                            childScope[valueIdentifier] = value;
                            block = {};
                            block.clone = null;
                            block.cell = cellIndex;
                            block.scope = childScope;
                            block.height = 110;
                            block.key = trackID; 
                            block.serial = -1;
                            
                        }

                        //collection[index]['$TrackID'] = trackID;
                        nextBlockMap[trackID] = block;
                    }


                    /* initialise a prev node */
                    for (index = 0; index < column; index++) {
                        if (!prevNode[index]) prevNode[index] = (index == 0 && cells[index].element.firstElementChild) ? cells[index].element.firstElementChild : cells[index].element.firstChild;
                    }

                    /* Remove blocks from existing which are not going to process*/
                    for (trackID in lastBlockMap) {
                        if (lastBlockMap[trackID]) {
                            block = lastBlockMap[trackID];
                            block.clone.style.opacity =0;
                            block.clone.RG_DELETE = true;
                            
                            
                            block.clone.addEventListener(prefix+'TransitionEnd', eventTranstionEnd);
                            block.clone.addEventListener('transitionend', eventTranstionEnd);
                            
                            block.scope.$destroy();
                        }
                    }
                    
                    /* Build DOM now*/
                    var defer = 2;
                    var nodesToBeAppeard =[];


                      /* Special feeds*/
                    if(specialTpl && special > 0) {

                       for (index = 0; index < special; index++) {

                           value = specials[index];
                           trackID = value.key;
                           cellIndex = index % column;

                           nextNode = prevNode[cellIndex];
                           parent = nextNode.parentNode;  

                           if(specialBlockMap[trackID]) {
                             
                                 block = specialBlockMap[trackID];
                                 clone = block.clone;
                                 block.cell = cellIndex;

                                 if (clone != nextNode.nextSibling) {
                                   parent.insertBefore(clone, nextNode.nextSibling);  
                                 }

                                /*
                                 if(!block.serialElm) {
                                   block.serialElm = block.clone.querySelector('[feed-serial]');  
                                 } */
                                 
                                 prevNode[block.cell] = clone;
                           } 
                           else {

                               //specials[index]['$TrackID'] = trackID;
                               childScope = $scope.$new();
                               childScope[valueIdentifier] = value.value; 
                               clone = $compile(specialTpl)(childScope);
                               
                               parent.insertBefore(clone[0], nextNode.nextSibling);
                               nextNode = clone[0]; 

                               nextNode.style.opacity =1;

                               block = {};
                               block.clone = clone[0];
                               block.cell = cellIndex;
                               block.scope = childScope;
                               block.height = 110;
                               block.key = trackID; 
                               block.serial = index;
                               block.serialElm = block.clone.querySelector('[feed-serial]');
                               
                               prevNode[cellIndex] = nextNode;
                               specialBlockMap[trackID] = block;

                               (function(nextNode, block){
                                        fastdom.defer(1,function() {
                                           if(!block) return; 
                                           block.height = nextNode.offsetHeight + 12;
                                        });
                                })(nextNode, block); 
                          }

                          if(block.serialElm) {
                            block.serialElm.innerHTML = index+1;
                           // speciaSerial = true;
                          }    
                       } 
                      
                    }

                    /*regular feeds*/

                    for (index = 0; index < length; index++) {

                        value = collection[index];
                        trackID = value.key;
                        block = nextBlockMap[trackID];
                        block.scope.$index = index;
                        nextNode = prevNode[block.cell];
                        parent = nextNode.parentNode;
                        clone = block.clone;
                        
                        //if(clone && clone.RG_HIDDEN) continue;

                        if (clone) {
                        
                             // skip nodes that are already pending removal via leave animation
                            do {
                                nextNode = nextNode.nextSibling;
                            } while (nextNode && nextNode.RG_DELETE);
              
                            if (clone != nextNode) {
                               parent.insertBefore(clone, nextNode);  
                            }
                            
                            prevNode[block.cell] = clone;
                            
                            block.childHead = block.scope.$$childHead;
                            block.scope.$$childHead = null;
                            
                         }  
                        else {

                             $transclude(block.scope, function (clone) {

                                parent.insertBefore(clone[0], nextNode.nextSibling);
                                nextNode = clone[0];
                                
                                (function(nextNode, block){
                                    fastdom.defer(++defer,function() {
                                       if(!block) return; 
                                       block.height = nextNode.offsetHeight + 12; // bottom margin of each 12 
                                    });
                                })(nextNode, block); 

                                if(!doAnimation || first || totalFeeds < 10) {
                                    nextNode.style.opacity =1;  
                                } 
                                else { 
                                    nodesToBeAppeard.push(nextNode);
                                }    

                                //nextNode.addEventListener(prefix+'TransitionEnd', eventTranstionEnd2); // temp
                                //nextNode.addEventListener('transitionend', eventTranstionEnd2); // temp
                                block.clone = nextNode;
                                prevNode[block.cell] = nextNode;
                                block.serialElm = block.clone.querySelector('[feed-serial]'); 
                                totalFeeds++; 
                            });
                        }
                        
                        
                        if(block.serial != (index+special) && block.serialElm) {
                           block.serialElm.innerHTML = special+index+1;
                           block.serial = index+special;
                        } 
                    }
                    
                    RingLogger.info("first called end "+ (window.performance.now()-t0), RingLogger.tags.DIGEST);
                    
                    if(nodesToBeAppeard.length> 0 ) {

                            fastdom.defer(2, function() {

                                if(!nodesToBeAppeard) return false;

                                for (index = 0; index < nodesToBeAppeard.length; index++) {
                                    nodesToBeAppeard[index].style.opacity =1;
                                }  
                                nodesToBeAppeard = null;
                            });
                     }


                    if($scope.busy != busy) {
                       busy = $scope.busy;  
                       showLoader(busy);   
                    }
                    

                    /* Updating last blockmap from current block map*/
                    lastBlockMap = nextBlockMap;
                    lastCollection = collection; 
                    onFeedProcesing = false;
                    
                    /* release ref*/
                    nextBlockMap =  null;
                    first = false;
                    block = null;
                    clone = null;
                    parent = null;
                    nextNode = null;
                    prevNode = null;
                    childScope = null;

                    if(collection.length <= 10) {
                       //initialDigest = true; 
                       requestAnimationFrame(function(){
                          $scope.$rgDigest();
                          //initialDigest = false;
                       }); 
                    }

                }
            }
        }

        return {
            restrict: 'A',
            transclude: true,
            priority: 1000,
            terminal: true,
            compile: compile
        };

    }

})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        console.warn("Feed Module Not Found");
        return;
    }

    feedApp.directive('feedLocationViewItem', feedLocationViewItem);
    function feedLocationViewItem(){
        return {
            restrict: 'E',
            scope: {
                onHover: '&',
                onSelect : '&',
                location : '='
            },
            templateUrl : 'pages/partials/feed_location/item.html',
            link : function(scope, element, attr){

                element.on("click",function(e){
                    e.stopPropagation();

                    if(!!scope.onSelect){
                        scope.onSelect({location: scope.location});
                    }
                });

                if(!!scope.onHover){
                    element.on('mouseover', function(event){
                        scope.onHover({location: scope.location})
                    });
                }

                scope.$on('$destroy',function(){
                    element.off("click");
                    element.off('mouseover');
                });

            }
        }
    }

    feedApp.directive('feedLocationView', feedLocationView);
    feedLocationView.$inject = ['utilsFactory'];
    function feedLocationView(utilsFactory){
        function eventStopPropogate(e){
            e.stopPropagation();
        }
        return {
            restrict: 'E',
            replace : true,
            templateUrl : 'pages/partials/feed_location/view.html',
            compile: function(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink(scope, iElement, iAttrs, controller) {
                        scope.initLocation(iElement);
                    },
                    post: function postLink(scope, iElement, iAttrs, controller) {
                        scope.$rgDigest();
                        iElement.on("click",eventStopPropogate);
                        scope.$on("$destroy",function(){
                            iElement.off("click",eventStopPropogate);
                        })
                    }
                }

            },

            controller : ['$scope',function($scope){

                $scope.keyword = '';

                $scope.showLocationMap = true;

                $scope.suggestedLocations = {};

                $scope.loadingData = false;

                //function getLocationText(placeId){
                //    var place = $scope.suggestedLocations[placeId];
                //
                //    var placeText = place.description || place.name;
                //    return placeText;
                //}

                $scope.onLocationItemSelect = function(selectedItem){
                    if(angular.isFunction($scope.onItemSelect)){
                        try{                            
                            var data = { description: selectedItem.terms[0].value };    
                        }catch(e){
                            var data = { description: selectedItem.description };    
                        }                        

                        data['lat'] = 9999;
                        data['lng'] = 9999;

                        if(!!selectedItem.geometry && !!selectedItem.geometry.location){
                            data['lat'] = selectedItem.geometry.location.lat();
                            data['lng'] = selectedItem.geometry.location.lng();
                        }

                        $scope.onItemSelect({location: data});
                        $scope.$parent.$rgDigest();
                        //mouseInside();
                    }
                    $scope.close();
                };

                $scope.shareUserLocation = function(){

                     utilsFactory.getUserLocation().then(function(location){
                        if( location.sucs ){
                            
                            $scope.onItemSelect({location: location});
                            $scope.$rgDigest();        
                            $scope.close();
                            

                        }else{

                            Ringalert.show({mg: 'Unable to detect user location'}, 'error');
                            RingLogger.aert(error, RingLogger.tags.FEED);
                        }
                        
                     })
                
                };

                $scope.onLocationItemHover = onLocationItemHover;

                var marker, map, placesService, AutoCompleteService, searchInput;
                var placeInfos = {};

                $scope.initLocation = function(iElement){
                    searchInput = iElement.find('input')[0];

                    placesService = new google.maps.places.PlacesService(searchInput);
                    AutoCompleteService = new google.maps.places.AutocompleteService();

                  //  $scope.mouseInside = false;

                 //   iElement.on('mouseover', onLocationViewHover);

                    //iElement.on('mouseleave', onLocationOptionMouseLeave);

                    //$scope.$watch("keyword", watchKeyword);

                    searchInput.focus();

                    utilsFactory.getUserLocation().then(function(location){

                        if( location.sucs ){
                            initMap(location);
                        }else{
                            initMap({lat: 23.70, lng: 90.40});
                        }
                    })
                
                    $scope.keyword = !!$scope.value ? $scope.value.description : '';

                };

                ////////////////////////

                // function onLocationViewHover(){
                //     //$scope.mouseInside = true;
                // }

                function onLocationItemHover(location){
                    //$scope.mouseInside = true;

                    try{
                        //var placeId = obj.target.attributes['data-place-id'].nodeValue;
                        updateMapPreviewByPlaceId(location.place_id);
                        showMapPreview();

                    }catch(e){

                    }
                }

                //// Private Functions

                function getPlaceInfo(placeId){
                    placesService.getDetails({ placeId: placeId }, function (place, status) {
                        if (status == google.maps.places.PlacesServiceStatus.OK) {

                            placeInfos[placeId] = place;
                            $scope.suggestedLocations[placeId] = angular.extend({}, $scope.suggestedLocations[placeId], place);

                        }
                        updateSocpe();
                    });
                }

                var processPredictions = function(predictions, status) {
                    if (status != google.maps.places.PlacesServiceStatus.OK) {
                        console.warn(status);
                        hideLoader();
                        return;
                    }

                    var locations = {};
                    angular.forEach(predictions, function(prediction){
                        var placeId = prediction.place_id;

                        if(!placeInfos[placeId]){
                            getPlaceInfo(placeId);
                        }

                        locations[placeId] = prediction;
                    });

                    if(!!locations){
                        setPredictions(locations);
                        hideLoader();
                        updateSocpe();
                    }
                    updateSocpe();

                };

                function showLoader(){ $scope.loadingData = true; }
                function hideLoader(){ $scope.loadingData = false; }
                function showMapPreview() { $scope.showLocationMap = true; }
                function hideMapPreview() { $scope.showLocationMap = false; }
                function resetPredictions(){ $scope.suggestedLocations = []; updateSocpe(); }
                function setPredictions(newPredictions){ $scope.suggestedLocations = newPredictions;updateSocpe(); }
                function updateSocpe(){ $scope.$rgDigest(); }
                function initMap(location){                
                    map = new google.maps.Map(document.getElementById('feed-location-map'), {
                        center: location,
                        zoom: 13
                    });

                    if( location.description ){
                        AutoCompleteService.getPlacePredictions({ input: location.description }, processPredictions);
                    }else{

                    }
                    

                }

                //// Scope Functions




                // function onLocationOptionMouseLeave(obj){
                //     $scope.mouseInside = false;
                // }

                function updateMapPreviewByPlaceId(placeId){
                    var place = placeInfos[placeId];
                    if(place){
                        if(marker)
                            marker.setMap(null);

                        map.setCenter(place.geometry.location);

                        marker = new google.maps.Marker({
                            map: map,
                            place: {
                                placeId: placeId,
                                location: place.geometry.location
                            }
                        });

                    }
                }

                function search(searchKey){
                    resetPredictions();
                    showLoader();

                    AutoCompleteService.getPlacePredictions({ input: searchKey }, processPredictions);

                }


                function watchKeyword(e){
                    var newValue = e.target.value;
                    if(!!newValue && newValue.length > 3){
                        search(newValue);
                    }else{
                        resetPredictions();
                    }
                    $scope.keyword = e.target.value;

                }


                $scope.processKeyup = utilsFactory.debounce(watchKeyword,500);


            }]
        };

    }


    function feedLocationPreview(){
        return {
            replace : true,            
            template : '<span ng-if="!!feed.getLocationInfo().lat" ><a ng-href="{{ feed.getLocationUrl() }}"  rg-ringbox="true" ringbox-type="remote" ringbox-target="pages/partials/google-map-preview.html" scope-data="{url : feed.getLocationEmbedUrl() }">  <img height="170px" width="100%" ng-src="{{ feed.getLocationStaticEmbedUrl()}}" alt="location-hover" /> </a>'
        }
    }
    feedApp.directive('feedLocationPreview', feedLocationPreview);


})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        console.warn("Feed Module Not Found");
        return;
    }

    feedApp.directive('feedLocationMenu', feedLocationMenu);

    feedLocationMenu.$inject = ['$document','$compile', 'utilsFactory'];
    function feedLocationMenu($document,$compile, utilsFactory ) {
        return {
            restrict : 'A',
            scope : {
                onItemSelect : '&feedLocationMenuOnSelect',
                value : '=selectedValue',
                viewWidth : '@',
                viewHeight : '@',
                autoAdjust : '@'
            },
            link : function(scope,element,attr){

                var menuDom, isOpen = false, slackSpaceWidth = 20, directionProvided;

                //scope.mouseInside = true;

                scope.viewDirection = 'right';
                if(!!attr.feedLocationMenuDirection){
                    scope.viewDirection = attr.feedLocationMenuDirection;
                    directionProvided = true;
                }

                scope.viewWidth = scope.viewWidth || 600;
                scope.viewHeight = scope.viewHeight || 466;

                scope.close = function(){
                    if(menuDom) menuDom.remove();
                    menuDom = null;
                    isOpen = false;
                    //scope.mouseInside = true;
                    $document.off("click", checkClickedOnElement);

                };
                scope.$watch('value',function(newval,oldval){
                        if(!!newval.description){
                            element.addClass('active');
                        }else{
                            element.removeClass('active');
                        }
                });


                function checkClickedOnElement(e){

                     if(e.target != element[0] && e.target.parentNode != element[0] && e.target.parentNode.parentNode != element[0] && e.target.className !='pt-top') {
                        //scope.mouseInside = true;
                        scope.close();
                        if(scope.autoAdjust !== "false"){
                            adjustView(event);    
                        }
                    }
                        
                   

                }

                function adjustView(event){

                    window.eventFix(event); /** Add Polyfill for `pageX`, `pageY` **/

                    var viewportSize = utilsFactory.viewportsize();

                    if( !directionProvided && (event.pageY + scope.viewHeight + slackSpaceWidth > viewportSize.y) ){
                        window.scrollToYOffset(event.pageY - viewportSize.y/2, 500);
                    }

                    if( event.pageX + scope.viewWidth + slackSpaceWidth > viewportSize.x - 200 ){
                        scope.viewDirection += ' left';
                    }

                }

                element.on("click",function(event){

                        if(isOpen) {
                          scope.close();
                          return '';
                        }
                        if(scope.autoAdjust !== "false"){
                            adjustView(event);    
                        }
                        


                    	if(!menuDom){
                        	menuDom = $compile(angular.element('<feed-location-view></feed-location-view>'))(scope);
                    	}
                    	element.after(menuDom);
                    	isOpen = true;

                        $document.on("click", checkClickedOnElement);

                });



                scope.$on('$destroy', function(){
                    if(menuDom) menuDom.remove();
                    element.off('click');
                    $document.off("click", checkClickedOnElement);

                });
                scope.$rgDigest();
            }
        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
        .factory('LikeHttpService',LikeHttpService)
        .controller('LikeController',LikeController)
        .controller('WhoLikeController',WhoLikeController)
        //.directive('rgImageLike', rgImageLike)
        .directive('rgLikes', rgLikes)
        .directive('rgLikerAnchor', rgLikerAnchor)
        .directive('rgWhoLike', rgWhoLike)
        .directive('rgLikerButton', rgLikerButton);



        LikeHttpService.$inject = ['$$connector','OPERATION_TYPES'];
        function LikeHttpService($$connector,OPERATION_TYPES){
                  var OTYPES = OPERATION_TYPES.SYSTEM,ob;

                    ob = {
                        likeUnlike : likeUnlike,
                        likeUnlikeComment : likeUnlikeComment,
                        fetchWhoLikes : fetchWhoLikes,
                        fetchWhoLikesComment : fetchWhoLikesComment
                      //  getPeopleDetails : getPeopleDetails
                    };

                function likeUnlike(ob){
                    var payload = {};
                        switch(ob.type){
                            case 'feed':
                                payload.actn = ob.il === 1 ? OTYPES.TYPE_LIKE_STATUS : OTYPES.TYPE_UNLIKE_STATUS
                                break;
                            case 'image':
                                payload.actn = OTYPES.IMAGE.TYPE_LIKE_IMAGE;
                                payload.imgId = ob.target.getKey();
                                payload.lkd = ob.il;
                                break;
                            case 'media':
                                payload.actn = OTYPES.MEDIA.ACTION_LIKE_UNLIKE_MEDIA;
                                payload.cntntId= ob.target.getKey();
                                payload.lkd = ob.il;
                                break;
                            default:
                               throw new Error("comment type not familiar");
                         };
                         if(ob.target.getFeedKey()){
                           payload.nfId = ob.target.getFeedKey();
                         }
                    return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
                 }
                 function likeUnlikeComment(ob){
                     var payload = {};
                        switch(ob.type){
                            case 'feed':
                                  payload.actn = ob.il ? OTYPES.TYPE_LIKE_COMMENT : OTYPES.TYPE_UNLIKE_COMMENT;
                                  payload.nfId = ob.key;
                                break;
                            case 'image':
                                  payload.actn = OTYPES.IMAGE.TYPE_LIKE_UNLIKE_IMAGE_COMMENT;
                                  payload.imgId = ob.key;
                                  payload.lkd = ob.il;
                                break;
                            case 'media':
                                  payload.actn = OTYPES.MEDIA.ACTION_LIKE_UNLIKE_MEDIA_COMMENT;
                                  payload.cntntId= ob.key;
                                  payload.lkd = ob.il;
                                break;
                            default:
                               throw new Error("comment type not familiar");
                         }
                         if(ob.parentKey){
                          payload.nfId = ob.parentKey;
                         }

                      payload.cmnId = ob.target.getKey();
                    return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
                 }
                 function fetchWhoLikesComment(ob){
                    var payload = {};
                        switch(ob.type){
                            case 'feed':
                                  payload.actn = OTYPES.TYPE_LIST_LIKES_OF_COMMENT;
                                  payload.nfId = ob.key;
                                break;
                            case 'image':
                                  payload.actn = OTYPES.IMAGE.TYPE_IMAGE_COMMENT_LIKES;
                                  payload.imgId = ob.key;
                                break;
                            case 'media':
                                  payload.actn = OTYPES.MEDIA.ACTION_MEDIACOMMENT_LIKE_LIST;
                                  payload.cntntId= ob.key;
                                break;
                            default:
                               throw new Error("comment type not familiar");
                         }
                         if(ob.parentKey){
                          payload.nfId = ob.parentKey;
                         }

                           payload.st = ob.st || 0;

                      payload.cmnId = ob.target.getKey();
                    return $$connector.pull(payload,OTYPES.REQUEST_TYPE.REQUEST);
                 }
                function fetchWhoLikes(ob){
                    var payload = {};
                    switch(ob.type){
                        case 'feed':
                            payload.actn = OTYPES.TYPE_LIKES_FOR_STATUS;
                            payload.nfId = ob.target.getKey();
                            break;
                        case 'image':
                            payload.actn = OTYPES.IMAGE.TYPE_LIKES_FOR_IMAGE;
                            payload.imgId = ob.target.getKey();
                            break;
                        case 'media':
                            payload.actn = OTYPES.MEDIA.ACTION_MEDIA_LIKE_LIST;
                            payload.cntntId = ob.target.getKey();
                            break;
                        //case 'media':break; // check for media fetch comment
                        default:
                           throw new Error("comment type not familiar");
                     }
                      if(ob.target.getFeedKey()){
                           payload.nfId = ob.target.getFeedKey();
                         }
                         payload.st = ob.st || 0;


                    return $$connector.pull(payload,OTYPES.REQUEST_TYPE.REQUEST);
                 }
                 // function getPeopleDetails(utids){
                 //    return $$connector.pull({
                 //      actn : OTYPES.FRIENDS.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS,
                 //      idList : utids
                 //    },OTYPES.REQUEST_TYPE.REQUEST);
                 // }

          return ob;
        }

        WhoLikeController.$inject = ['$scope','LikeHttpService','rgScrollbarService','userFactory','friendsFactory','InviteFactory','Auth'];
        function WhoLikeController($scope,LikeHttpService,rgScrollbarService,userFactory,friendsFactory,InviteFactory,Auth){
             $scope.loading = true;
             $scope.users = [];
             $scope.contactListAction = function(actionObj) {
                 if (!actionObj.friend.isLoading()) {
                     friendsFactory.friendAction(actionObj, true).then(function() {
                         $scope.$rgDigest();
                     }, function() {
                         $scope.$rgDigest();
                     });
                    $scope.$rgDigest();
                 }
             };
             $scope.isCurrentUser = function(user){
                return user.equals(Auth._currentUser);
             };

            $scope.loadmore = function () {
                if(!$scope.loading){
                    loadMoreUser();
                }
            };

             function loadMoreUser(){
              var reqData,reqFn = 'fetchWhoLikes';
                if($scope.users.length < $scope.target.getTotalLikes()){
                  reqData = {
                            target : $scope.target,
                            type : $scope.likeType,
                            st : $scope.users.length
                       };
                    if($scope.likeComment == 'true'){
                      reqFn = 'fetchWhoLikesComment';
                      reqData.parentKey = $scope.targetOwner();
                      reqData.key = $scope.targetParent();
                       // promise = LikeHttpService.fetchWhoLikesComment({
                       //    target : $scope.target,
                       //     type : $scope.likeType,
                       //     key : $scope.targetParent(),
                       //     parentKey : $scope.targetOwner(),
                       //     st : $scope.users.length
                       //   });
                    }
                    $scope.loading = true;
                    // if($scope.likeType === 'feed' && $scope.target.isSingleContentFeed()){
                    //    reqData.target = $scope.target.getSingleContent();
                    //    reqData.type = $scope.target.getContentType();
                    // }
                    LikeHttpService[reqFn](reqData).then(function(json){
                        //console.log(json);
                                  $scope.loading = false;
                                  if(!json.sucs){
                                    // RingLogger.print("failed to load who likes",'rgLikes');
                                     $scope.$close();return;
                                  }
                                  var i,usr;
                                  //var utids = [];
                                  for( i=0;i < json.likes.length;i++){
                                     //utids[i] = json.likes[i].utId;
                                     usr = userFactory.createByUtId(json.likes[i],true,true);
                                    $scope.users.push(usr);
                                    usr.commonFriends(true,true).then(function(){
                                       $scope.$rgDigest();
                                     });
                                  }
                                    rgScrollbarService.recalculate($scope);
                                  $scope.$rgDigest();
                                  // LikeHttpService.getPeopleDetails(utids).then(function(json){
                                  //      RingLogger.print(json,'rgLikes');
                                  // });
                                },function(reason){
                                 // RingLogger.print(reason,'error','RgLike');
                                  $scope.$close();
                                },function(json){
                                 // RingLogger.print(json,'notify','RgLike');
                                  //$scope.$close();
                                });
                }
             }
             loadMoreUser();

            $scope.getMutualFriend = function(user) {

                return{
                    data: function() {
                        return {
                            target: user
                        };
                    },
                    promise: InviteFactory.getMutualFriend(user)
                };
            };

        }

LikeController.$inject = ['$scope','LikeHttpService','Ringalert','$ringbox','feedFactory'];
function LikeController($scope,LikeHttpService,Ringalert,$ringbox,feedFactory){
   //RingLogger.print("scope id : from LikeController",+$scope.$id,'RgLike');

    $scope.anchorCallback = angular.noop;
    $scope.buttonCallback = angular.noop;

            // ##DIGEST_DEBUG_START##
            if(RingLogger.tags.DIGEST){
            $scope.$watch(function(){
                 RingLogger.info("from rgLikeDirective",RingLogger.tags.DIGEST);
            });
            }
            // ##DIGEST_DEBUG_END##
    function failedLike(reason){
              $scope.target.like(true,reason.loc ? reason.loc : false);
              Ringalert.show(reason, 'error');
              $scope.anchorCallback.call(null,$scope.target.like());
              $scope.buttonCallback.call(null,$scope.target.like());
              $scope.$rgDigest();
          }
    $scope.LikeUnlike = function(){
          var reqData,reqFn = 'likeUnlike';
             reqData = {
              target : $scope.target,
              type : $scope.likeType
            };
          if($scope.likeComment == 'true'){
              reqFn = 'likeUnlikeComment';
              reqData.parentKey = $scope.targetOwner();
              reqData.key = $scope.targetParent();
             //  promise = LikeHttpService.likeUnlikeComment({
             //       target : $scope.target,
             //       type : $scope.likeType,
             //       key : $scope.targetParent(),
             //       parentKey : $scope.targetOwner()
             // });
          }
          reqData.il = $scope.target.like(true);
          $scope.anchorCallback.call(null,reqData.il);
          $scope.buttonCallback.call(null,reqData.il);
          LikeHttpService[reqFn](reqData).then(function(json){
              if(!json.sucs){
                failedLike(json);
              }else{
                if($scope.likeType !== 'feed' && $scope.likeComment !== 'true'){
                  if(json.nfId){
                   var sc = feedFactory.synchLike(json.nfId,reqData.il,json.loc);
                     if(sc){sc.$rgDigest();}
                  }

                }
              }

          },failedLike);
        $scope.$rgDigest();
    };
    $scope.$watch('target', function(newValue) {
          $scope.anchorCallback.call(null,newValue.like());
          $scope.buttonCallback.call(null,newValue.like(),true);
    });
    $scope.showWhoLike = function(){
      if(!$scope.target.getTotalLikes())return;
        var boxInstance = $ringbox.open({
                              type : 'remote',
                              scope:$scope,
                              controller: 'WhoLikeController',
                              templateUrl : 'pages/home/wholikes.html'
                          });

               // boxInstance.result.then(function(updatedFeed){
               //   if(!!updatedFeed){
               //      $scope.feed = updatedFeed;
               //   }
               // });
    }


}






    rgLikerButton.$inject = [];
    function rgLikerButton(){
        return {
          restrict: 'E',
          require: '^rgLikes',
          replace : true,
          template : '<a><i class="lc-ico"></i><b>Like</b></a>',
          link: function(scope, elem, attrs, parentCtrl) {

           //  RingLogger.print("scope id : from rgLikerButton"+scope.$id,"RgLike");

             function iLikeChange(v,stopAnimation){
                if(v){
                   // elem.addClass('active');
                    //var el = angular.element('');
                    // if(!stopAnimation){
                      elem[0].firstChild.className = elem[0].firstChild.className.replace
      ( "icon-like" , '' ).trim();
      elem[0].firstChild.className = elem[0].firstChild.className.replace
      ( "icon-like-h", '' ).trim();
                       elem[0].firstChild.className += ' icon-like-h';
                       
                       if(!stopAnimation){
                         elem[0].firstChild.innerHTML = '<span class="like-ani"></span>';
                         window.setTimeout(function(){
                            if(elem){
                              elem[0].firstChild.innerHTML = '';
                            }
                         },2000);
                       }

                   //  }

                }else{
                  elem[0].firstChild.className = elem[0].firstChild.className.replace
      ( "icon-like-h", '' ).trim();
      elem[0].firstChild.className = elem[0].firstChild.className.replace
      ( "icon-like", '' ).trim();
      elem[0].firstChild.className += ' icon-like';
                  //elem.removeClass('active');
                }
             }
             scope.buttonCallback = iLikeChange;
             iLikeChange(scope.target.like(),true);
             elem.bind('click',scope.LikeUnlike);
             scope.$on('$destroy',function(){
                elem.unbind("click",scope.likeUnlike);
             });
          }
        }
    }
    rgLikerAnchor.$inject = [];
    function rgLikerAnchor(){
        return {
          restrict: 'E',
          require: '^rgLikes',
          replace : true,
          template : '<a class="lcs_button ">Like</a>',
          link: function(scope, elem, attrs, parentCtrl) {
             //RingLogger.print("scope id : from rgLikerAnchor"+scope.$id,"RgLike");
             elem.bind('click',scope.LikeUnlike);
             scope.$on('$destroy',function(){
                elem.unbind("click",scope.likeUnlike);
             });
          }
        }
    }

    rgWhoLike.$inject = ['$ringbox'];
    function rgWhoLike($ringbox){
        return {
          restrict: 'E',
          require: '^rgLikes',
          replace : true,
          template : '<a class="lcs_button ">{{target.getTotalLikes()}}</a>',
          link: function(scope, elem, attrs, parentCtrl) {
            // RingLogger.print("scope id : from rgWhoLike"+scope.$id,"RgLike");
             elem.bind('click',scope.showWhoLike);
             scope.$on('$destroy',function(){
                elem.unbind("click",scope.showWhoLike);
             });
          }
        }
    }



        rgLikes.$inject = [];
        function rgLikes() {
            return {
                restrict: 'EA',
                scope : {
                    target : '=',
                    likeType : '@', // string feed,image,media
                    targetParent : '&',
                    targetOwner : '&',
                    likeComment : '@'
                },
                controller : 'LikeController',
                template : '<rg-liker-button></rg-liker-button><rg-who-like></rg-who-like>',
                link : function(scope,element,attr){
                      // RingLogger.print(scope,'rgLike');
                       function iLikeChange(iLikeValue){ //
                          if(iLikeValue){
                            element.addClass('active');
                          }else{
                            element.removeClass('active');
                          }
                       }
                       scope.anchorCallback = iLikeChange;
                       iLikeChange(scope.target.like());
                       scope.$watch('target.like()',function(){
                          iLikeChange(scope.target.like());
                          scope.buttonCallback.call(null,scope.target.like(),true);
                       });
                }
            };
        }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
    .factory('CommentHttpService',CommentHttpService)
    .controller('CommentsController',CommentsController)
    .directive('rgComments', rgComments)
    .directive('rgImageComments', rgImageComments);
    CommentHttpService.$inject = ['$$connector','OPERATION_TYPES']
    function CommentHttpService($$connector,OPERATION_TYPES){
        var OTYPES = OPERATION_TYPES.SYSTEM,ob;
        ob = {
            getComment : getComment,
            getComments : getComments,
           // likeUnlike : likeUnlike,
            addComment : addComment,
            updateComment : updateComment,
            deleteComment : deleteComment,
          //  fetchWhoLikes : fetchWhoLikes,
            getUpdateFilter : getUpdateFilter
          };
        /**
         * @descripion : for failure test this code can be blocked after testing
         * @return {[type]} [description]
         */
        // function fakePromise(){
        //     var defer = $q.defer();
        //     setTimeout(function(){
        //         defer.reject({
        //             sucs : false,
        //             mg : "not processed successfully"
        //         });
        //     });
        //     return defer.promise;
        //  }



        function getComment(ob) {
            var payload = {};
            switch(ob.type){
                case 'feed':
                    payload.cmntT = 1;
                    payload.nfId = ob.key;
                    break;
                case 'image':
                    payload.cmntT = 2;
                    payload.imgId = ob.key;
                    break;
                case 'media':
                    payload.cmntT = 3;// note : make sure for media its three
                    payload.cntntId = ob.key;
                    break;
                default:
                   throw new Error("comment type not familiar");
             }
            payload.actn = OTYPES.ACTION_GET_FULL_COMMENT;
            payload.cmnId = ob.commentId;
            return $$connector.request(payload,OTYPES.REQUEST_TYPE.REQUEST);
         }
        function getComments(ob,timeOffset,before){
            var scl,
            payload = {};
            if(!ob.key || !ob.type){
                throw new Error("key and type must needed for fetcing comment");
            }
            switch(ob.type){
                case 'feed':
                    payload.actn = OTYPES.TYPE_COMMENTS_FOR_STATUS;
                    payload.nfId = ob.key;
                    break;
                case 'image':
                    payload.actn = OTYPES.IMAGE.TYPE_COMMENTS_FOR_IMAGE;
                    payload.imgId = ob.key;
                    if(ob.target.getFeedKey()){
                        payload.nfId = ob.target.getFeedKey();
                    }
                    break;
                case 'media':
                    payload.actn = OTYPES.MEDIA.ACTION_MEDIA_COMMENT_LIST;
                    payload.cntntId = ob.key;
                    if(ob.target.getFeedKey()){
                          payload.nfId = ob.target.getFeedKey();
                    }
                    break; // check for media fetch comment
                default:
                   throw new Error("comment type not familiar");
             }

             if(timeOffset){
                // 1 for b efore currentTm Comments, 2 for bellow currentTm Comments note : but in this case somehow its inverse lol
                payload.scl = !!before ? before : 1;
                payload.tm = timeOffset;
             }else{
                payload.st = ob.st || 0;
             }
             return $$connector.pull(payload, OTYPES.REQUEST_TYPE.REQUEST);
         }
        // function likeUnlike(ob){
        //     var payload = {};
        //         switch(ob.type){
        //             case 'feed':
        //                 payload.actn = ob.il ? OTYPES.TYPE_LIKE_COMMENT : OTYPES.TYPE_UNLIKE_COMMENT;
        //                 payload.nfId = ob.key;
        //                 break;
        //             case 'image':
        //                 payload.actn = OTYPES.IMAGE.TYPE_LIKE_UNLIKE_IMAGE_COMMENT;
        //                 payload.imgId = ob.key;
        //                 payload.lkd = ob.il;
        //                 if(ob.target.getFeedKey()){
        //                   payload.nfId = ob.target.getFeedKey();
        //                 }
        //                 break;
        //             case 'media':
        //                 payload.actn = OTYPES.MEDIA.ACTION_LIKE_UNLIKE_MEDIA_COMMENT;
        //                 payload.cntntId= ob.key;
        //                 payload.lkd = ob.il;
        //                 if(ob.target.getFeedKey()){
        //                   payload.nfId = ob.target.getFeedKey();
        //                 }
        //                 break;
        //             default:
        //                throw new Error("comment type not familiar");
        //          };
        //     payload.cmnId = ob.commentId;
        //     return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
        //  }
        function addComment(ob){
            var payload = {};
            switch(ob.type){
                case 'feed':
                    payload.actn = OTYPES.TYPE_ADD_STATUS_COMMENT;
                    payload.nfId = ob.key;
                    break;
                case 'image':
                    payload.actn = OTYPES.IMAGE.TYPE_ADD_IMAGE_COMMENT;
                    payload.imgId = ob.key;
                    if(ob.target.getFeedKey()){
                       payload.nfId = ob.target.getFeedKey();
                    }
                    break;
                case 'media':
                    payload.actn = OTYPES.MEDIA.ACTION_ADD_COMMENT_ON_MEDIA;
                    payload.cntntId = ob.key;
                    if(ob.target.getFeedKey()){
                      payload.nfId = ob.target.getFeedKey();
                    }
                    break;
                default:
                   throw new Error("comment type not familiar");
             }
             payload.cmn = ob.text.utf8Encode();
             return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
         }
        function updateComment(ob){
            var payload = {};
            switch(ob.type){
                case 'feed':
                    payload.actn = OTYPES.TYPE_EDIT_STATUS_COMMENT;
                    payload.nfId = ob.key;
                    break;
                case 'image':
                    payload.actn = OTYPES.IMAGE.TYPE_EDIT_IMAGE_COMMENT;
                    payload.imgId = ob.key;
                    break;
                case 'media':
                    payload.actn = OTYPES.MEDIA.ACTION_EDIT_COMMENT_ON_MEDIA;
                    payload.cntntId = ob.key;
                    break;
                //case 'media':break; // check for media fetch comment
                default:
                   throw new Error("comment type not familiar");
             }
            payload.cmnId = ob.commentId;
            payload.cmn = ob.text.utf8Encode();;
            return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
         }
        function deleteComment(ob){
            var payload = {};
            switch(ob.type){
                case 'feed':
                    payload.actn = OTYPES.TYPE_DELETE_STATUS_COMMENT;
                    payload.nfId = ob.key;
                    break;
                case 'image':
                    payload.actn = OTYPES.IMAGE.TYPE_DELETE_IMAGE_COMMENT;
                    payload.imgId = ob.key;
                    break;
                case 'media':
                    payload.actn = OTYPES.MEDIA.ACTION_DELETE_COMMENT_ON_MEDIA;
                    payload.cntntId = ob.key;
                    break;
                //case 'media':break; // check for media fetch comment
                default:
                   throw new Error("comment type not familiar");
             }
            payload.cmnId = ob.commentId;
            return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
         }
        // function fetchWhoLikes(ob){
        //     var payload = {};
        //     switch(ob.type){
        //         case 'feed':
        //             payload.actn = OTYPES.TYPE_LIST_LIKES_OF_COMMENT;
        //             payload.nfId = ob.key;
        //             break;
        //         case 'image':
        //             payload.actn = OTYPES.IMAGE.TYPE_IMAGE_COMMENT_LIKES;
        //             payload.imgId = ob.key;
        //             if(ob.target.getFeedKey()){
        //                payload.nfId = ob.target.getFeedKey();
        //             }
        //             break;
        //         case 'media':
        //             payload.actn = OTYPES.MEDIA.ACTION_MEDIACOMMENT_LIKE_LIST;
        //             payload.cntntId = ob.key;
        //             if(ob.target.getFeedKey()){
        //                   payload.nfId = ob.target.getFeedKey();
        //             }
        //             break;
        //         //case 'media':break; // check for media fetch comment
        //         default:
        //            throw new Error("comment type not familiar");
        //      }
        //     payload.cmnId = ob.commentId;
        //     return $$connector.pull(payload,OTYPES.REQUEST_TYPE.REQUEST);
        //  }



         function getUpdateFilter(type,value){
            var mainActionsSet,key,
                actionUpdateFeedSet = [OTYPES.TYPE_UPDATE_ADD_STATUS_COMMENT,OTYPES.TYPE_UPDATE_LIKE_COMMENT,OTYPES.TYPE_UPDATE_UNLIKE_COMMENT,OTYPES.TYPE_UPDATE_DELETE_STATUS_COMMENT,OTYPES.TYPE_UPDATE_EDIT_STATUS_COMMENT],
                actionUpdateImageSet = [OTYPES.IMAGE.TYPE_UPDATE_ADD_IMAGE_COMMENT,OTYPES.IMAGE.TYPE_UPDATE_LIKE_UNLIKE_IMAGE_COMMENT,OTYPES.IMAGE.TYPE_UPDATE_EDIT_IMAGE_COMMENT,OTYPES.IMAGE.TYPE_UPDATE_DELETE_IMAGE_COMMENT],
                actionUpdateMediaSet = [OTYPES.MEDIA.ACTION_UPDATE_ADD_MEDIA_COMMENT,OTYPES.MEDIA.ACTION_UPDATE_LIKE_UNLIKE_MEDIA_COMMENT,OTYPES.MEDIA.ACTION_UPDATE_EDIT_MEDIA_COMMENT,OTYPES.MEDIA.ACTION_UPDATE_DELETE_MEDIA_COMMENT];
                switch(type){
                    case 'feed' : mainActionsSet =  actionUpdateFeedSet;key = 'nfId'; break;
                    case 'image' : mainActionsSet = actionUpdateImageSet;key = 'imgId';break;
                    case 'media' : mainActionsSet = actionUpdateMediaSet;key = 'cntntId'; break;
                    default :
                        return [1111111];// a never matching action
                };
                return function(message){
                       return mainActionsSet.indexOf(message.actn) !== -1 && message[key] === value;
                }
         }



        return ob;
    }

    CommentsController.$inject = ['$scope','$$connector','Ringalert','utilsFactory','CommentHttpService','Auth',
                          '$$stackedMap','$$commentMap','rgDropdownService','OPERATION_TYPES','rgScrollbarService','feedFactory']

    function CommentsController($scope,$$connector,Ringalert,utilsFactory,CommentHttpService,Auth,
                        $$stackMap,$$commentMap,rgDropdownService,OPERATION_TYPES,rgScrollbarService,feedFactory){

        var commentSubsriberKey,OTYPES = OPERATION_TYPES.SYSTEM,loadingTimeout,firstTimeChangedTarget = false;
        $scope.comments = $$stackMap.createNew(true, 'desc');//comment map for feed initialization//$scope.target.getComments();// every
        $scope.loadingComment = false;
        $scope.canComment = true;
        $scope.commentEditorEnabled = false;
        $scope.commentKey = '';
        $scope.commenttext = '';
        $scope.ddCommentHtml = 'pages/dropdowns/comment-edit-dropdown.html';//$templateCache.get('comment-edit-dropdown.html');
        $scope.previousComment = false;
        $scope.afterComment = !!$scope.target.getTotalComment();
        $scope.models = {
                commentedittext: ""
            };
        $scope.currentUser = Auth.currentUser();
        $scope.openRingboxLike = function(comment){
            return comment.getTotalLikes() > 0;
        }
        $scope.loadMoreComment = loadMoreComment;
        $scope.loadPreviousComment = loadPreviousComment;
        $scope.addComment =addComment;
        $scope.updateComment = updateComment;

         if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
             if($scope.target.getMedias().length() || $scope.target.getAudios().length()){
                $scope.likeType = 'media';
             }else if($scope.target.getImages(true).length()){
                $scope.likeType = 'image';
             }
             $scope.parentKey = $scope.target.getSingleContent().getKey();
         }else{
             $scope.likeType = $scope.commentType;
             $scope.parentKey = $scope.target.getKey();
         }

      //  $scope.like = likeUnlikeComment;
    //    $scope.fetchWhoLikes = fetchWhoLikes;
        $scope.hideScroll = !!$scope.hideScroll && $scope.hideScroll !== 'false';
        $scope.showPreviousButton = function(){
             return ($scope.target.getTotalComment() > $scope.comments.length() && $scope.previousComment) && !$scope.loadingComment;
        };
        $scope.showMoreButton = function(){
             return ($scope.target.getTotalComment() > $scope.comments.length() && $scope.afterComment) && !$scope.loadingComment;
        };
        $scope.cancelEdit = function(){
            $scope.commentEditorEnabled = false;
            safeDigest()
        };
        $scope.actionCommentDropdown = function (actionObj) {
            rgDropdownService.close();
            actionObj.event.preventDefault();
            switch (actionObj.action) {
                case 'edit':
                    //console.log('edit');
                    enableCommentEditor(actionObj.commentMap.getKey(), actionObj.commentMap.text());
                    break;
                case 'delete':
                    //console.log(actionObj.commentInfo);
                    deleteComment(actionObj.commentMap);
                    break;
                default:
            }
           // $scope.$parent.$rgDigest();
        };

        // ##DIGEST_DEBUG_START##
                    if(RingLogger.tags.DIGEST){
                        $scope.$watch(function(){
                             RingLogger.info("from rgComments directive",RingLogger.tags.DIGEST);
                        });
                    }
        // ##DIGEST_DEBUG_END##
        function safeDigest(){
            if($scope.$parent && $scope.$parent.$id !== 1){
                $scope.$parent.$rgDigest();
            }else{
                $scope.$rgDigest();
            }
        }
        function enableCommentEditor(commentKey, commentText) {
            if (commentKey) {
                $scope.commentEditorEnabled = true;
                $scope.commentKey = commentKey;
                $scope.models.commentedittext = commentText;
                safeDigest();
            }
        };

        function setLoading(val){
            $scope.loadingComment = val;
             RingLogger.print("Loading... comment "+val,'rgComments');
            if(loadingTimeout){
                window.clearTimeout(loadingTimeout);
                loadingTimeout = undefined;
            }
         }



        function setupInitials(){
               commentSubsriberKey = $$connector.subscribe(function(json){
                        switch(json.actn){
                            case OTYPES.TYPE_UPDATE_ADD_STATUS_COMMENT :
                            case OTYPES.IMAGE.TYPE_UPDATE_ADD_IMAGE_COMMENT :
                            case OTYPES.MEDIA.ACTION_UPDATE_ADD_MEDIA_COMMENT :
                                pushComments({comments:[json]});
                                  break;
                            case OTYPES.TYPE_UPDATE_EDIT_STATUS_COMMENT:
                            case OTYPES.IMAGE.TYPE_UPDATE_EDIT_IMAGE_COMMENT:
                            case OTYPES.MEDIA.ACTION_UPDATE_EDIT_MEDIA_COMMENT:
                                 var com = $scope.comments.get(json.cmnId);
                                    if(com){
                                        com.setComment(json.cmn);
                                    }
                                    break;
                            case OTYPES.TYPE_UPDATE_LIKE_COMMENT:
                            case OTYPES.TYPE_UPDATE_UNLIKE_COMMENT:
                            case OTYPES.IMAGE.TYPE_UPDATE_LIKE_UNLIKE_IMAGE_COMMENT:
                            case OTYPES.MEDIA.ACTION_UPDATE_LIKE_UNLIKE_MEDIA_COMMENT:
                                var com = $scope.comments.get(json.cmnId);
                                    if(com){
                                        com.incomingLike(json.loc);
                                    }
                                    break;
                            case OTYPES.TYPE_UPDATE_DELETE_STATUS_COMMENT:
                            case OTYPES.IMAGE.TYPE_UPDATE_DELETE_IMAGE_COMMENT:
                            case OTYPES.MEDIA.ACTION_UPDATE_DELETE_MEDIA_COMMENT:
                                $scope.comments.remove(json.cmnId);

                        };
                        safeDigest();
                },{
                    filter : CommentHttpService.getUpdateFilter($scope.commentType,$scope.target.getKey())
                });
               $scope.$on("$destroy",function(){
                        if(commentSubsriberKey){
                            $$connector.unsubscribe(commentSubsriberKey);
                        }
                        commentSubsriberKey = false;
                });
         }


        function loadPreviousComment(force){
            var comment,timeOffset = false;
            if($scope.comments.length()) {
                comment = $scope.comments.getByIndex(0);
                timeOffset = comment.getTimestamp();
            }
            fetchComments(timeOffset,1,force);
         }
         function processPreviousComment(json){
            var arr = [],lowestComment;
            if(!json.comments){return; }
            if(json.comments.length > 5 && $scope.target.getTotalComment() > ($scope.comments.length() + json.comments.length)){
                 json.comments.sort(function(a,b){
                    return a.tm > b.tm ? 1 : -1;
                });
                pushComments({comments : json.comments.splice(0)});
                $scope.previousComment = true;
            }else{
                $scope.previousComment = false;
                pushComments(json);
            }
         }

         function loadMoreComment(){
            var timeOffset = false;
            if(parseInt($scope.activeCommentId) > 0){
                var comment;
                if($scope.comments.length()) {
                    comment = $scope.comments.getByIndex(($scope.comments.length() -1));
                    timeOffset = comment.getTimestamp();
                }
            }
            fetchComments(timeOffset,2);
         }

         function processAfterComment(json){
            var arr = [],lowestComment;
            if(!json.comments){return; }
            if(json.comments.length > 5 && $scope.target.getTotalComment() > ($scope.comments.length() + json.comments.length)){
                json.comments.sort(function(a,b){
                    return a.tm < b.tm ? 1 : -1;
                });
                pushComments({comments : json.comments.splice(0)});
                $scope.afterComment = true;
            }else{
                $scope.afterComment = false;
                pushComments(json);
            }
         }
         function initialCommentRequest(){
            if(parseInt($scope.activeCommentId) > 0){
                var type = $scope.commentType,target = $scope.target;
            
                if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                        target = $scope.target.getSingleContent();
                        type = $scope.target.getContentType();
                }
                CommentHttpService.getComment({
                    key : target.getKey(),
                    type : type,
                    commentId : parseInt($scope.activeCommentId)
                    
                }).then(function(json){
                    if(json.sucs){
                          pushComments({comments:[json.cmntDTO]});
                          loadMoreComment();
                          setTimeout(function(){
                            loadPreviousComment(true);
                        },500);

                       }else{
                        $scope.activeCommentId = 0;
                        fetchComments();
                       }
                       safeDigest();
                },function(reason){
                    fetchComments();
                });
            }else{
                fetchComments();
            }
         }
        function fetchComments(timeOffset,before,force){
            if(!$scope.target.getTotalComment() || ((before ===1 && !$scope.showPreviousButton()) || (before ===2 && !$scope.showMoreButton())) && !force){
                 RingLogger.print("fetched all comments or already loading or no comments",'rgcomments');
                 return;
            }
            setLoading(true);
            var type = $scope.commentType,target = $scope.target;
            
            if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                    target = $scope.target.getSingleContent();
                    type = $scope.target.getContentType();
            }
            
            loadingTimeout = setTimeout(setLoading.bind($scope,false),
                 3000);
            CommentHttpService.getComments({
                key : target.getKey(),
                type : type,
                st : $scope.comments.length(),
                target : target
            },timeOffset,before).then(function(json){
                RingLogger.print(json,"rgComments");
             if(json.sucs){
                if(parseInt($scope.activeCommentId)){
                    if(before === 1){ // previous comment
                        processPreviousComment(json);
                    }else{ // after comment
                        processAfterComment(json);
                    }
                 }else{
                    pushComments(json);
                 }
             }
                 setLoading(false);
                 safeDigest();
            },function(json){
                RingLogger.print(json,"rgCommentsError");
            },function(json){
                 RingLogger.print(json,"rgCommentsNotified");
            });
            safeDigest();
         }
        function pushComments(message){
             var commentMap,i;
             for (i = 0; i < message.comments.length; i++) {
                commentMap = $$commentMap.create(message.comments[i]);
                $scope.comments.save(commentMap.getKey(), commentMap);
             }
         }

         // function faildAddComment(){
         //        $scope.comments.remove(cmnId);
         //        $scope.canComment = true;
         //        Ringalert.show(json,'error');
         //        $scope.commenttext = text;
         //        safeDigest();
         // }

        function addComment(){
            var text = $scope.commenttext,cmnId,commData,target = $scope.target,type=$scope.commentType;
                $scope.canComment = false;
                if (validateComment()) {
                    cmnId = utilsFactory.getUniqueID();//generating unique key for further identification
                    commData = {
                        cmnId: cmnId,
                        cmn: text,
                        deleted: false,
                        isNew: true,
                        edited: false,
                        //nfId: key,
                        pending: true// setting status pending to showing 50% opacity
                    };
                    if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                        target = $scope.target.getSingleContent();
                        type = $scope.target.getContentType();
                    }
                    $scope.comments.add(cmnId,$$commentMap.create(commData,$scope.currentUser));
                    CommentHttpService.addComment({
                        key : target.getKey(),
                        type : type,
                        text : text,
                        target : target
                    }).then(function (json) {
                        if (json.sucs === true) {
                            $scope.comments.remove(cmnId);
                            commData.cmnId = json.cmnId;
                            commData.pending = false;
                            angular.extend(json, commData);
                            var comment = $$commentMap.create(json,$scope.currentUser);
                            $scope.comments.add(comment.getKey(),comment);
                            $scope.target.setTotalComment(json.loc,1);
                            if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                                target.setTotalComment(json.loc,1);
                            }else if($scope.commentType !== 'feed'){
                                var sc = feedFactory.synchComment($scope.target.getFeedKey(),json.loc,1);
                                sc && sc.$rgDigest();
                            }
                            $scope.canComment = true;
                            $scope.commenttext = "";
                            safeDigest();
                        } else {
                            $scope.comments.remove(cmnId);
                            $scope.canComment = true;
                            Ringalert.show(json,'error');
                            $scope.commenttext = text;
                            safeDigest();
                        };
                    },function(reason){
                        $scope.comments.remove(cmnId);
                        $scope.canComment = true;
                        Ringalert.show(reason,'error');
                        $scope.commenttext = text;
                        safeDigest();
                    });
                    rgScrollbarService.scrollTop($scope);
                }
        };
        function updateComment(comment) {
                if (!comment.user().isCurrentUser()) {
                    $scope.commentEditorEnabled = false;
                    return;
                }
               var text = $scope.models.commentedittext.trim(),
                    type = $scope.commentType,
                    target = $scope.target,
                   oldText = comment.text();
                   comment.setComment(text);
                   comment.isPending(true);
                   if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                        target = $scope.target.getSingleContent();
                        type = $scope.target.getContentType();
                    }
                if (text !== '') {
                    CommentHttpService.updateComment({
                        key : target.getKey(),
                        type : type,
                        commentId : comment.getKey(),
                        text : $scope.models.commentedittext
                    }).then(function(json){
                        if(!json.sucs){
                            comment.setComment(oldText);
                            Ringalert.show(json,'error');
                        }
                        comment.isPending(false);
                        $scope.models.commentedittext = "";
                        $scope.commentEditorEnabled = false;
                        safeDigest();
                    },function(reason){
                        comment.setComment(oldText);
                        Ringalert.show(json,'error');
                        safeDigest();
                    });
                }else{
                    Ringalert.show("Please write something",'error');
                    // show the error message
                }
                safeDigest();
        };

        // function likeUnlikeComment(comm){
        //     var il = comm.like(true);

        //     CommentHttpService.likeUnlike({
        //         key : $scope.target.getKey(),
        //         type : $scope.commentType,
        //         commentId : comm.getKey(),
        //         il : il,
        //         target : $scope.target
        //     }).then(function(json){
        //         if(!json.sucs){
        //             comm.like(true);
        //             Ringalert.show(json, 'error');
        //         }

        //     },function(reason){
        //         comm.like(true);
        //         Ringalert.show(reason, 'error');
        //     });
        // }
        function deleteComment(comm){
            var type = $scope.commentType,target = $scope.target;
            comm.isPending(true);
            if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                target = $scope.target.getSingleContent();
                type = $scope.target.getContentType();
            }
            CommentHttpService.deleteComment({
                key : target.getKey(),
                type : type,
                commentId : comm.getKey()
            }).then(function(json){
               if(json.sucs){
                    $scope.comments.remove(json.cmnId);
                    $scope.target.setTotalComment(json.loc,json.ic);
                    if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                        target.setTotalComment(json.loc,json.ic);
                    }else if($scope.commentType !== 'feed'){
                         var sc = feedFactory.synchComment($scope.target.getFeedKey(),json.loc,json.ic);
                               sc && sc.$rgDigest();
                    }
                    //todo : decrease the target nc by one
               }else{
                    comm.isPending(false);
                    Ringalert.show(json,'error');
               }
               safeDigest();
            },function(json){
                    comm.isPending(false);
                    Ringalert.show(json,'error');
                    safeDigest();
            });
            safeDigest();
         }
        // function fetchWhoLikes(comment) {
        //     var defer = $q.defer(),dorequest = true;
        //     if (comment.getTotalLikes() === comment.getWhoLikes().length) {
        //             $timeout(function(){
        //                 defer.resolve({sucs: true});
        //             });
        //             dorequest = false;
        //     }
        //     if(dorequest){
        //         CommentHttpService.fetchWhoLikes({
        //             key : $scope.target.getKey(),
        //             type : $scope.commentType,
        //             commentId : comment.getKey(),
        //             target : $scope.target
        //         }).then(function(json){
        //             if (json.sucs === true) {
        //                 var likes = json.likes || [];
        //                 for (var i = 0; i < likes.length; i++) {
        //                     comment.incomingWhoLikes(likes[i]);
        //                 }
        //                 defer.resolve(json);
        //             } else {
        //                 defer.reject(json);
        //             }
        //         },function(reason){
        //             defer.reject(reason);
        //         });
        //     }
        //         return {
        //             data: function () {
        //                 return {
        //                     target: comment
        //                 };
        //             },
        //             promise: defer.promise
        //         };
        //  }

        function validateComment(){
                if ($scope.commenttext.length < 1) {
                    $scope.commentErrorClass = "inputerror";
                    $scope.canComment = true;
                    return false;
                } else {
                    $scope.commentErrorClass = "";
                    return true;
                }
         }

         $scope.$watch('showCommentBox',function(newVal){
                if(newVal){
                    if(!commentSubsriberKey){
                        setupInitials();
                    }
                    if(!$scope.comments.length()){
                        initialCommentRequest();
                    }
                }
         });

          $scope.$watch('target.getKey()',function(newVal){ // for popup image changes
                    if(firstTimeChangedTarget){
                        if(commentSubsriberKey){
                          $$connector.unsubscribe(commentSubsriberKey);
                          setupInitials();
                          $scope.comments.reset();
                        }
                        if(!$scope.comments.length()){
                            initialCommentRequest();
                        }
                    }
                    firstTimeChangedTarget = true;

         });

    }
    function rgComments() {
        return {
            restrict: 'E',
            controller : CommentsController,
            scope : {
                target : '=',
                showCommentBox : '=',
                commentType : '@', // string feed,image,media
                commentOrder : '@', // comment order asc|desc
                activeCommentId : '@', // specific comment id
                hideScroll : '@' // show the scrollbar or not
            },
            //templateUrl: 'pages/partials/comments.html'
			template :  '<div class="feed_comment"><div rg-scrollbar="scrollbar()" disabled="{{::hideScroll}}" ng-class="!hideScroll ? \'comm-scroll-height\':\'\'"><ul class="media-list"><li class="item b-none bd" style="border:none" ng-show="showPreviousButton()"><div class="float-right gray font-12 margin-10"><a class="view_more" rg-click="loadPreviousComment()">load previous comments</a></div><div class="clear"></div></li><li class="item" rg-repeat="comm in comments.all() track by comm.key" ng-init="comment = comm.value" ng-class="{ half_opacity:comment.isPending(),comment_blink: (comment.getKey() == activeCommentId)}"><div class="comment-area"><div class="pro_img_bg_30 mar-right-10" style="flex:none"><img ng-src="{{ comment.user().avatar(\'thumb\')}}" alt=""></div><div class="comm-p"><p class="unm"><a ng-href="{{comment.user().link()}}">{{comment.user().getName()}}</a></p><p class="comment_text" onmousedown="return false" ng-hide="(commentEditorEnabled && commentKey == comment.getKey())" ng-bind-html="comment.getDynamicText()"></p><p ng-show="(commentEditorEnabled && commentKey == comment.getKey())"><span class="comment"><rg-editor class="editor" editor-content="models.commentedittext" new-line="ctrl" on-enter="updateComment" on-enter-arg="comment" on-escape="cancelEdit" edit-mode="comment.getDynamicText" show-emoji="true" focus="$parent.commentEditorEnabled" placeholder="Write your comment..."></rg-editor><span class="esc-to-cancel">Press Esc to <a rg-click="cancelEdit()">cancel</a></span></span></p></div><div class="comm-sett"><div ng-show="target.user().isCurrentUser() || comment.user().isCurrentUser()" class="" style="position: relative"><div rg-dropdown="dropdown()" dd-html="ddCommentHtml" dd-control="comment" dd-action="actionCommentDropdown" ng-class="comment.user().isCurrentUser() ? \'icon-ds-arrow\' : \'\'" class="ico-f arrow-b"></div></div></div><div class="clear"></div></div><div class="comm-l"><ul class="comment_like_menu 1000" ng-hide="comment.isPending() || (commentEditorEnabled && commentKey == comment.getKey())"><li rg-likes="" like-type="{{::likeType}}" target="comment" target-parent="parentKey" target-owner="target.getFeedKey()" like-comment="true"><!-- <a ng-class="{active:comment.like()}" rg-click="like(comment)"><i class="icon-like lc-ico" rg-like="comment.like()" ng-class="{\'icon-like-h\':comment.like()}"></i></a> <a ng-class="{active:comment.like()}" rg-click="like(comment)">&nbsp;Like</a> <a ng-class="{active:comment.like()}" class="counter" href="javascript:void(0)" rg-ringbox="{{::comment.getTotalLikes() > 0}}" ringbox-open="openRingboxLike(comment)" ringbox-controller="fetchLikeController" ringbox-target="pages/home/wholikes.html" ringbox-type="remote" ringbox-data="fetchWhoLikes(comment)">{{comment.getTotalLikes()}}</a> --></li><li class="mar-top-7 feed-m"><span class="time"><i class="icon-dt"></i> {{comment.time()}}</span></li></ul></div></li></ul></div><div ng-show="loadingComment" style="text-align:center;margin-top:10px"><div class="loader-s"><div class="lr1"></div><div class="lr2"></div><div class="lr3"></div></div></div><div class="item b-none" style="border:none" ng-show="showMoreButton()"><div class="float-right gray font-12 margin-10"><a class="view_more" rg-click="loadMoreComment()">More comments</a></div><div class="clear"></div></div><div ng-if="target.getTotalComment() > comments.length()" class="divider"></div><div class="mar-top-10"><div class="comment-w" ng-class="commentErrorClass"><div class="comment-editor"><rg-editor class="editor" editor-content="commenttext" new-line="ctrl" on-enter="addComment" show-emoji="true" is-disabled="!canComment" focus="showCommentBox" placeholder="Write something...."></rg-editor></div></div></div></div>'
			        };
    }
     function rgImageComments() {
        return {
            restrict: 'E',
            controller : CommentsController,
            scope : {
                target : '=',
                showCommentBox : '=',
                commentType : '@', // string feed,image,media
                commentOrder : '@', // comment order asc|desc
                activeCommentId : '@' // specific comment id
            },
            //templateUrl: 'pages/partials/image-comments.html'
            template :  '<div class="feed-comment-wrapper" style="height:calc(100% - 165px)"><div class="feed_comment" rg-scrollbar="scrollbar()"><ul class="feed-img-l"><li class="item b-none" style="border:none" ng-show="showPreviousButton()"><div class="float-right gray font-12 margin-10"><a class="view_more" rg-click="loadPreviousComment()">load previous comments</a></div><div class="clear"></div></li><li class="item pv-item" ng-repeat="comm in comments.all()" ng-init="comment = comm.value" ng-class="{ half_opacity:comment.isPending(),active: (comment.getKey() == activeCommentId) }"><div class="comment-area"><div class="pro_img_bg_30 mar-right-10" style="flex:none"><img ng-src="{{::comment.user().avatar(\'thumb\')}}" alt=""></div><div class="comm-p"><p class="unm"><a ng-href="{{::comment.user().link()}}">{{::comment.user().getName()}}</a></p><p onmousedown="return false" class="txt_justify" ng-hide="(commentEditorEnabled && commentKey == comment.getKey())" ng-bind-html="comment.getDynamicText()"></p><p ng-show="(commentEditorEnabled && commentKey == comment.getKey())"><span class="comment"><rg-editor class="editor" editor-content="models.commentedittext" new-line="ctrl" on-enter="updateComment" on-enter-arg="comment" on-escape="cancelEdit" edit-mode="comment.getDynamicText" show-emoji="true" focus="$parent.commentEditorEnabled" placeholder="Write something...." style="width: 94%"></rg-editor><span class="esc-to-cancel">Press Esc to <a rg-click="cancelEdit()">cancel</a></span></span></p></div><div class="comm-sett"><div ng-show="target.user().isCurrentUser() || comment.user().isCurrentUser()" class=""><div rg-dropdown="dropdown()" dd-html="ddCommentHtml" dd-control="comment" dd-action="actionCommentDropdown" ng-class="comment.user().isCurrentUser() ? \'icon-ds-arrow\' : \'\'" class="ico-f arrow-b"></div></div></div><div class="clear"></div></div><div class="comm-l"><ul class="comment_like_menu" ng-hide="comment.isPending() || (commentEditorEnabled && commentKey == comment.getKey())"><li rg-likes="" like-type="{{::likeType}}" target="comment" target-parent="parentKey" target-owner="target.getFeedKey()" like-comment="true"><!-- <a ng-class="{active:comment.like()}" rg-click="like(comment)"><i ng-class="{\'icon-like-h\':comment.like() > 0}" class="icon-like lc-ico" rg-like="comment.like()"></i></a> <a ng-class="{active:comment.like()}" rg-click="like(comment)">&nbsp;Like</a> <a ng-class="{active:comment.like()}" class="counter" href="javascript:void(0)" rg-ringbox="{{::comment.getTotalLikes() > 0}}" ringbox-open="openRingboxLike(comment)" ringbox-controller="fetchLikeController" ringbox-target="pages/home/wholikes.html" ringbox-type="remote" ringbox-data="fetchWhoLikes(comment)">{{comment.getTotalLikes()}}</a> --></li><li class="mar-left-60"><span class="time"><i class="icon-dt"></i> {{comment.time()}}</span></li></ul></div></li><li ng-show="loadingComment" class="loader-s"><div class="lr1"></div><div class="lr2"></div><div class="lr3"></div></li><li class="item b-none" style="border:none" ng-show="showMoreButton()"><div class="float-right gray font-12 margin-10"><a class="view_more" rg-click="loadMoreComment()">More comments</a></div><div class="clear"></div></li></ul></div><div class="pv-c-top"><div class="width-100-percent"><div class="pv-pro float-left"><img ng-src="{{::currentUser.avatar(\'thumb\')}}" alt=""></div><div class="comment-w" style="width:85%" ng-class="commentErrorClass"><div class="comment-editor popimgcmnt-box"><rg-editor class="editor" editor-content="commenttext" new-line="ctrl" on-enter="addComment" show-emoji="true" is-disabled="!canComment" focus="showCommentBox" placeholder="Write something...."></rg-editor></div></div></div></div></div>'
				
    						
			
			        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

        .directive('rgNewsFeedTop', rgNewsFeedTop);
    
    rgNewsFeedTop.$inject = ['$templateCache'];

    function rgNewsFeedTop($templateCache) {
        
        return {
                scope : {
                    feed : '=',
                    serial : '=',
                    ddTemplate : '=',
                    actionFeedDropdown : '=',
                    dropdown: '&',
                    singleFeed : '@',
                    showdroparrow: '='

                },
               restrict: 'E',
               template: $templateCache.get('top.html')  
            }
     }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
        .directive('rgNewsFeedBottom',rgNewsFeedBottom); 

        rgNewsFeedBottom.$inject = ['$templateCache'];

        function rgNewsFeedBottom($templateCache) {
            
            return {
                restrict: 'E',
                template: $templateCache.get('bottom.html')
            };
        }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

        .directive('rgNewsFeedDetails', rgNewsFeedDetails);

    function rgNewsFeedDetails() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/news_feed/details.html'

            //scope : {
            //    feed : '=',
            //    editorEnabled : '=',
            //    inputDisabled : '=',
            //    updateFeed : '&',
            //    cancelEdit : '&',
            //    getImageData: '&',
            //    setFeedText : '=',
            //    feedText : '='
            //
            //}


        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

        .directive('rgNewsFeedSharedFeed', rgNewsFeedSharedFeed);

    function rgNewsFeedSharedFeed() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/news_feed/shared_feed.html'
        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

        .directive('rgNewsFeedMenu', rgNewsFeedMenu);

    rgNewsFeedMenu.$inject = ['$compile','SystemEvents','$templateCache','MESSAGES',"Ringalert"];
    
    function rgNewsFeedMenu($compile,SystemEvents, $templateCache,MESSAGES,Ringalert) {
      
        return {
            restrict: 'E',
            template: $templateCache.get('menu.html'),  
            link: function(scope, element, attrs) {
            
                 var comment = null, share = null, 
                     eventListner = element[0].querySelector('[data-events]'),
                     wrapper = element[0].closest('[data-feed-bottom]');
              function clickHandler(e) {
                      
                    if(e.target.hasAttribute('data-event-share') || (e.target.parentNode && e.target.parentNode.hasAttribute('data-event-share'))) {
                          e.stopPropagation();
                          var f = scope.feed.hasSharedFeed() ? scope.feed.getOrginalFeed():scope.feed;
                          var shareablle = f.isShareAble(true);
                          if(!shareablle.sucs) {
                              Ringalert.show(MESSAGES[shareablle.rc],'warning');
                              return;
                          }else{
                            shareHandler();
                          }
                          
                       }
                 
                      if(e.target.hasAttribute('data-event-comment') || (e.target.parentNode && e.target.parentNode.hasAttribute('data-event-comment'))) {
                          e.stopPropagation();
                          commentHandler(); 
                      }
                   
                    scope.$rgDigest();
               }
              eventListner.addEventListener('click', clickHandler);  
               
             function shareHandler() {
                  if(scope.showCommentBox) {
                       wrapper.removeChild(comment); 
                       scope.showCommentBox = false; 
                  } 
                      
                 if(!scope.showShareBox) {                          
                      share = (share)? share : $compile('<feed-inline-share-view></feed-inline-share-view>')(scope)[0];
                      wrapper.appendChild(share); 
                      scope.showShareBox = true;
                      scope.$emit(SystemEvents.FEED.HEIGHT, scope.feed.getMapKey());
                      return;
                   } 
                      
                   if(scope.showShareBox) {
                        wrapper.removeChild(share); 
                        scope.showShareBox = false;
                        scope.$emit(SystemEvents.FEED.HEIGHT, scope.feed.getMapKey());
                        return;
                    }
                    
                    scope.$emit('$feedHeight', scope.feed.getMapKey()); 
               }
               
               function commentHandler() {
                  var templateComment;
                  // if(scope.feed.isSingleContentFeed()){
                  //     templateComment = '<rg-comments target = "feed.getSingleContent()" show-comment-box="showCommentBox" comment-type = "'+scope.feed.getContentType()+'" comment-order = "desc"></rg-comments>';
                  // }else{
                      templateComment = '<rg-comments target = "feed" show-comment-box="showCommentBox" comment-type = "feed" comment-order = "desc"></rg-comments>'
                  //}
               
                    if(scope.showShareBox) {
                       wrapper.removeChild(share); 
                       scope.showShareBox = false;
                    } 
                          
                     if(!scope.showCommentBox) {
                           
                        comment = (comment)? comment : $compile(templateComment)(scope)[0];
                        wrapper.appendChild(comment); 
                        scope.showCommentBox = true;
                         scope.$emit(SystemEvents.FEED.HEIGHT, scope.feed.getMapKey());
                        return;
                    } 
                      
                    if(scope.showCommentBox) {
                         wrapper.removeChild(comment); 
                         scope.showCommentBox = false;
                         scope.$emit(SystemEvents.FEED.HEIGHT, scope.feed.getMapKey());
                         return;
                     } 
               }
               
               /*External scope api*/
                scope.closeShareBox = function() {
                   scope.showShareBox = true;
                   shareHandler();
                   scope.$rgDigest();
                }
                
                scope.closeCommentBox = function() {
                   scope.showCommentBox = true;
                   commentHandler();
                   scope.$rgDigest();
                }
               
               scope.$on("$destroy", function(){
                 /*clear DOM reference*/
                 eventListner.removeEventListener("click",clickHandler);
                   eventListner = null;
                   wrapper = null;
                   comment = null;
                   share = null;
               });  
            

            }

        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

        .directive('rgNewsFeedComment', rgNewsFeedComment);

    function rgNewsFeedComment() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/news_feed/comment.html'

        };
    }

})();

 /**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
        .directive('locationCard',function(){

         return {
            restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
            replace : true,
            scope : {
              feed : '='
            },
            template : '<span class="location">&nbsp;at&nbsp;<a ng-href="{{ feed.getLocationEmbedUrl() }}" target="_blank" title="{{ ::feed.getLocationText() }}" rg-hovercard hover-template-url="pages/partials/hovercards/location-hover.html">{{::feed.getLocationShortText()}}</a></span>'
          };
        })
        .directive('userCard',function(){

         return {
            restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
            replace : true,
            controller : ['$scope','profileHttpService','InviteFactory','friendsFactory',function($scope,profileHttpService,InviteFactory,friendsFactory){

                $scope.getUserDetail = function(){
                    $scope.showMfc = false;
                    profileHttpService.getUserDetails({utId : $scope.user.getUtId()},true).then(function(json){
                        if(json.sucs){
                            $scope.mfc = json.userDetails.mfc;
                            $scope.showMfc = true;
                            $scope.user.setUid(json.userDetails.uId);
                            $scope.$rgDigest();
                        }
                    });
                };
                $scope.getMutualFriend = function(user) {

                    return{
                        data: function() {
                            return {
                                target: user
                            };
                        },
                        promise: InviteFactory.getMutualFriend(user)

                    };
                };
                $scope.contactListAction = function(actionObj) {
                    if (!actionObj.friend.isLoading()) {
                        friendsFactory.friendAction(actionObj,true).then(function() {
                            $scope.$rgDigest();
                        }, function() {
                            $scope.$rgDigest();
                        });
                        $scope.$rgDigest();
                    }
                };

            }],
            scope : {
              user : '='
            },
            template : '<span class="user"><a ng-href="{{user.link()}}" rg-hovercard="{{::!user.isCurrentUser()}}" on-hover-start="getUserDetail" hover-template-url="pages/partials/hovercards/profile-hover.html">{{::user.getName()}}</a></span>'
          };
        })
        .directive('feedMessage',feedMessage)
        .directive('feedTagMoreUser',feedTagMoreUser);

        feedMessage.$inject = ['$compile'];
         function feedMessage($compile) {
            return {
                restrict: 'A',
                //transclude: true,

                scope : {
                      feed : '=feedMessage'
                    },
                link : function(scope, element, attrs) {

                      scope.$watch('feed.checkMessageUpdated()',
                        function(value) {
                           element.html(scope.feed.getMessageText());
                          $compile(element.contents())(scope);
                        }
                      );
                 }
                // link : function(scope,iElement,attrs){
                //     var html = '<div>'+scope.feed.getMessageText()+'</div>';
                //     html = $compile(html)(scope);
                //     iElement.append(html);
                // },

                   // template : '<ng-transclude></ng-transclude>'
            };


    }

  feedTagMoreUser.$inject = [];
  function feedTagMoreUser(){
          // Runs during compile
          return {
             restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
             scope : {
                  feed : '=tagFeed'
                  },
              controller : ['$scope','feedFactory',function(scope,feedFactory){
                //console.log("dreictive controller");


                          scope.getTagUsers = function(feed) {

                              return{
                                  data: function() {
                                      return {
                                          target: feed
                                      };
                                  },
                                  promise: feedFactory.getTagUsers(feed)

                              };
                          };

                  scope.tooltip = '';
                      if(scope.feed.getTotalTag() > 2){
                        var users = scope.feed.getTagUsers();
                        if(users.length > 1){
                          scope.tooltip += users[1].getName();
                          if(!!users[2]){
                            scope.tooltip += "\n"+ users[2].getName();
                            if(scope.feed.getTotalTag() > 3){
                              scope.tooltip += "\nand "+(scope.feed.getTotalTag()- 3) +" others";
                            }
                          // for (var i = 1; i < users.length; i++) {
                          //    scope.tooltip += users[i].getName()+(i<users.length -1 ?"\n":'');
                          // };
                          // if(scope.feed.getTotalTag() > users.length){
                          //     scope.tooltip += "\nand "+(scope.feed.getTotalTag()- users.length) +" others";
                          // }
                        }
                      }
                   }
              }],
             template: '<span class="">with&nbsp;</span>'
                  +'<span class="tag-people"><user-card user="feed.getTagUsers()[0]"></user-card></span>'
                  +'<span ng-if="::feed.getTotalTag() > 1">'
                  +'&nbsp;and&nbsp;<span class="tag-people" ng-if="::feed.getTotalTag() == 2"><user-card user="feed.getTagUsers()[1]"></user-card></span>'
                  +'<span class="" ng-if="::feed.getTotalTag() > 2"><a rg-ringbox="true" ringbox-controller="feedTagUserListController" ringbox-type="remote"'
                  +'ringbox-target="pages/home/tag-user-list.html"'
                  +'ringbox-data="getTagUsers(feed)" class="tag-f-msg" data-tooltip="{{::tooltip}}"'
                  +'>{{::feed.getTotalTag() -1}} others peoples</a></span></span>'


          };
        }
})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

    .directive('rgSingleFeedHeader', rgSingleFeedHeader)
    .directive('rgSingleFeedBody', rgSingleFeedBody)
    .directive('rgSingleFeedMenu', rgSingleFeedMenu)

    function rgSingleFeedBody() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/single_feed/body.html'
        };
    }

    function rgSingleFeedHeader() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/single_feed/header.html'
        };
    }

    function rgSingleFeedMenu() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/single_feed/menu.html'
        };
    }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

        .directive('rgSingleFeedDetails', rgSingleFeedDetails);

    function rgSingleFeedDetails() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/single_feed/details.html'

            //scope : {
            //    feed : '=',
            //    editorEnabled : '=',
            //    inputDisabled : '=',
            //    updateFeed : '&',
            //    cancelEdit : '&',
            //    getImageData: '&',
            //    setFeedText : '=',
            //    feedText : '='
            //
            //}


        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

    .directive('rgSingleFeedComments', rgSingleFeedComments);

    function rgSingleFeedComments() {
        return {
            restrict: 'E',
            scope : {
                feed : '=',
                commentType : '@',
                user : '&',
                addComment : '&',
                updateComment : '&',
                cancelEdit : '&',
                likeComment : '&',
                fetchWhoLikes : '&',
                canComment : '=',
                commentErrorClass : '=',
                commentText : '=',
                allComments : '=',
                commentKey : '=',
                commentEditorEnabled : '=',
                commentEditText : '=',
                ddCommentHtml : '=',
                actionCommentDropdown : '&',
                showCommentBox: '=',
                loadMoreComments : '&',
                loadPreviousComments : '&',
                activeCommentId : '='

            },
            templateUrl: 'pages/partials/single_feed/comments.html',
            link : function(scope, elem, attr){
                scope.updateCommentAdaptor = function(comment){
                    return  scope.updateComment({comment:comment})
                };

                scope.actionCommentDropdownAdaptor = function(actionObj){
                    scope.actionCommentDropdown({actionObj:actionObj});
                };

                scope.addCommentAdaptor = function($event){
                    switch (scope.commentType) {
                        case 'feed':
                            scope.addComment({ feed: scope.feed });
                            break;
                        case 'image':
                            scope.addComment({ 'event': $event });
                            break;
                        default:
                    }

                };

                scope.likeCommentAdaptor = function(comment){
                    switch (scope.commentType) {
                        case 'feed':
                            scope.likeComment({ feedKey : scope.feed.getKey(), commentKey: comment.getKey()});
                            break;
                        case 'image':
                            scope.likeComment({comment: comment});
                            break;
                        default:
                    }
                };
            }
        };
    }

})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        console.warn('Feed Module Not Found');
        return;
    }

    feedApp.directive('feedInlineShareView', feedInlineShareView);

    feedInlineShareView.$inject = ['GlobalEvents', '$compile','$ringhttp'];
    function feedInlineShareView(GlobalEvents, $compile,$ringhttp){ //jshint ignore:line
        return {
          restrict : 'E',
          //templateUrl : 'pages/partials/news_feed/inline-share.html',

			template :  '<div class="status-box noselect inline-share"><form enctype="multipart/form-data"><div style="padding:10px"><div class="float-left"><div class="thumbnail"><div class="icon-logo-circle pss-logo"><a><img class="responsive-all" rg-src="currentUser.avatar(\'thumb\')"></a></div></div></div><div class="post-t float-right"><div class="inline-share-box"><rg-editor class="editor" editor-content="feedText" new-line="on" on-escape="closeShareBox" focus="showShareBox" placeholder="Write something...."></rg-editor><span class="esc-cancel" rg-click="closeShareBox()">Press Esc to <a>Cancel</a></span><p ng-if="emotions.length" class="pst-loc-txt"><span class="feelings-text">feeling</span> <img class="feed_emo" rg-src="emotions[0].url"> {{emotions[0].nm}} &nbsp;<span class="icon-close f-8" rg-click="emotions.length = 0"></span></p><div ng-if="tagList.length"><ul class="tag-fnd-lst"><span class="tag-with">With :</span><li ng-repeat="usr in tagList"><span class="tag-title">{{::usr.getName()}}</span>&nbsp;<span class="icon-close f-11" rg-click="removeTag(usr)"></span></li></ul></div><p ng-if="feedLocation.description" class="pst-loc-txt">{{ feedLocation.description}} <span class="showpointer icon-close f-8" rg-click="resetFeedLocation()"></span></p><p ng-show="!boxIsLoading && errorMessage" class="s-error">{{errorMessage}}</p><!--<p ng-show="!boxIsLoading && !errorMessage" class="s-info"><b>Enter</b> to SHARE, <b>ESC</b> to Cancel</p>--><rg-loader-view2 is-loading="boxIsLoading"></rg-loader-view2></div></div><div class="clear"></div></div><div class="status-photo-box" style="margin:0;padding:0;border-top:1px solid #ebebeb;width:100%"><div class="pad-7-0"><div class="post-b-ico m-l-5"><a data-tooltip-post="Add Feeling" rg-emotion on-select="chooseEmotion(item)" class="p-ab"><span class="feeling-ico"></span></a></div><div class="post-b-ico m-l-5"><a data-tooltip-post="Tag Friends" rg-tag-friend="" show-if="showAddTag" tag-items="tagList" on-select="addTag(item)" class="p-ab"><span class="tag-f-ico"></span></a></div><div class="post-b-ico m-l-5"><a data-tooltip-post="Add Location" feed-location-menu="" feed-location-menu-on-select="updateFeedLocation(location)" autoAdjust="{{::autoAdjustScroll}}" selected-value="feedLocation" class="p-ab"><span class="location-ico"></span></a></div><div class="float-right"><input type="button" ng-disabled="inputDisabled" rg-click="shareFeed()" class="share_btn float-right" value="Share"></div><!--<p>Press escape to cancel</p>--></div></div></form><div class="clear"></div></div>',
			controller : 'feedInlineShareController',
          link : function(scope,elemnet,attr){

          } /*,
          link : function(scope) {

            var hideShareBox = function(e) {
                var code = e.keyCode || e.which;
                if(code === 27) {
                    scope.closeShareBox();
                }
            };

        
            scope.closeShareBox = function() {
                $timeout(function() { // ghapla. needs improvement
                    if(scope.hasOwnProperty('showShareBox')) {
                        scope.showShareBox = false;
                    } else {
                        scope.$parent.showShareBox = false;
                    }
                });
            };
            

          
            scope.$watch('showShareBox', function(newval) {
                if(newval) {
                    document.addEventListener('keydown', hideShareBox);
                } else {
                    document.removeEventListener('keydown', hideShareBox);
                }
            }); 

            //element.on('mouseenter', function() {
                //GlobalEvents.unbindHandler('keydown', 'document', hideShareBox);
            //});

            //element.on('mouseleave', function() {
                //GlobalEvents.bindHandler('keydown', 'document', hideShareBox);
            //});
          } */
      };

    }


})();

(function () {
    'use strict';
    var feedApp;
        feedApp = angular.module('ringid.feed');
 feedApp.controller('FeedMainController', ['$scope', '$timeout','feedFactory', 'utilsFactory','$rootScope','SystemEvents',
        function ($scope, $timeout,feedFactory, helper,$rootScope,SystemEvents) {
            // initiate feed binding for scope
            feedFactory.reset();
            $scope.noMoreFeed  = false;


            $scope.feeds = feedFactory.getFeeds();

            feedFactory.setFactoryKey($scope.pagekey);
            feedFactory.setSortBy($scope.sortBy || 'tm');
            $scope.busy = true;
            // setTimeout(function(){ // first time we are requesting from rg-feed subscriber directive when directive is ready
            //                        // so after 3 second we need to change the busy filter to normal so that we can request for data again
            //     $scope.busy = false;
            //     $scope.$broadcast(SystemEvents.FEED.BUSY, $scope.busy);
            // },3000);

            var feedUpdateTimer = setInterval(function(){
                feedFactory.updateTime();
                $scope.$rgDigest();
            }, 300000);

            $scope.setFeed = function (forceDigest) {
                $scope.feeds = [];
                $scope.feeds = feedFactory.getFeeds();
                if(forceDigest){
                    $scope.$rgDigest();
                }
            };

           // $scope.scopeData = scopeData;
            $scope.forAdd = $scope.forAdd || 'my';
            $scope.getFeeds = function () {
                if (!$scope.feeds || $scope.feeds.length === 0) {
                    $scope.setFeed();
                }
                return $scope.feeds;
            };

            var busyTimer,previousFeedLength;
            $scope.LoadMoreData = function (syncher) {
                previousFeedLength = $scope.feeds.length;
                if ($scope.busy === false && !$scope.noMoreFeed) {
                    $scope.busy = true;
                    feedFactory.requestForMoreFeed($scope.params);

                    $scope.clearRequestTimer();

                    busyTimer = setTimeout(function(){
                        if($scope.busy ){
                            if(previousFeedLength === $scope.feeds.length){
                                $scope.busy = false;
                                $scope.$broadcast(SystemEvents.FEED.BUSY, $scope.busy);
                                
                            }
                            

                        }
                    },6000);
                }

                /*
                else{
                    $scope.busy = false;
                    $scope.$broadcast(SystemEvents.FEED.BUSY, $scope.busy);
                } */

                // request for loading more data
            };
            $scope.clearRequestTimer = function(a){ // a for getting native undefined
                if(!!busyTimer)clearTimeout(busyTimer);
                busyTimer = a;
            };

            $rootScope.$on("FeedListChanged",function(){
                $scope.setFeed();
            });



            $scope.setNoMoreFeed = function(state){
                $scope.noMoreFeed = state;
                feedFactory.noMoreFeed(state);
                $scope.busy = false;
                $scope.$broadcast(SystemEvents.FEED.BUSY, $scope.busy);
            }
            $scope.noDataYet = function(){
                return $scope.noMoreFeed && $scope.feeds.length == 0;
            }
            //$scope.incomingFeed = true;
            //$scope.setIncomingFeed = function(val){
            //        $scope.incomingFeed = !!val;
            //};
            //$scope.loadIncomingFeed = function(){
            //    feedFactory.processIncomingFeed();
            //    $scope.setFeed();
            //    $scope.incomingFeed = false;
            //};

            // ##DIGEST_DEBUG_START##
            if(RingLogger.tags.DIGEST){
                $scope.$watch(function(){
                     RingLogger.info("from FeedMainController",RingLogger.tags.DIGEST);
                });
            }
            // ##DIGEST_DEBUG_END##
            //feedFactory.requestForFeed($scope.params);
            var initFeedInterval;
            function initTialFeedRequest(){
                if(!$scope.feeds.length){
                    feedFactory.initFeedRequest($scope.params);
                    if(!initFeedInterval){
                        initFeedInterval = setInterval(initTialFeedRequest,6000);
                    }
                }else{
                    if(initFeedInterval){
                        clearInterval(initFeedInterval);
                        initFeedInterval = null;
                    }
                }
            }
            initTialFeedRequest();
            //for faster load dashboard feed
            $scope.$on("$destroy",function(){
                if(initFeedInterval){
                    clearInterval(initFeedInterval);
                    initFeedInterval = null;
                }
                if(feedUpdateTimer){
                    clearInterval(feedUpdateTimer);
                    feedUpdateTimer = null;
                }
                });
             
            $scope.$on(SystemEvents.COMMON.COLUMN_CHANGED,function(){
                $scope.$rgDigest();
            });
        }])
       ;

})();


(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }
    feedApp.controller('SingleFeedSubController', ['$$feedMap', '$scope','$controller', '$routeParams', 'feedFactory', 'Auth','SystemEvents','utilsFactory','$location',
        function ($$feedMap, $scope,$controller, $routeParams, feedFactory, Auth,SystemEvents,utilsFactory,$location){
            var page= 'singleFeed';

            $scope.feedId = parseInt($routeParams.feedId || 0);

            $scope.shared = !!$routeParams.shared ? true : false;

            $scope.activeCommentId = parseInt($routeParams.commentId || 0);

            //console.log($routeParams);

            $scope.isReady = false;
            $scope.noData = false;

            $scope.pagekey  = feedFactory.getSingleFeedPageKey($scope.feedId);

            feedFactory.setFactoryKey($scope.pagekey);

            //$scope.feed = $$feedMap.create({'nfId' : $scope.feedId });

            $scope.singleFeed = true;

            $scope.ogData = {};


            $scope.currentUser = Auth.currentUser();

            getSingleFeed();

            $scope.setFeed = function (deleted) {
                
                if(deleted){
                    $location.path("/");
                }else{
                    getSingleFeed();
                }
            };
            $scope.skipSaveScope = true;
            

            ////////////////////////////////////////////////////////////
            $controller('FeedSubController', {$scope: $scope});
            function getSingleFeed(){

                feedFactory.getSingleFeed($scope.feedId, $scope.shared).then(function(feed){
                    if(!!feed){
                        $scope.feed = feed;
                        $scope.isReady = true;
                        initFeedView();
                    }else{
                        $scope.feed = false;
                        $scope.isReady = true;
                        $scope.noData = true;

                    }
                    $scope.$rgDigest();
                });

            }



            function initFeedView(){
                if($scope.feed){
                    $scope.serial = $scope.feed.serial;
                    $scope.feedstatus = $scope.feed.text();
                    $scope.keyid = $scope.feed.getKey();
                    $scope.imageslength = $scope.feed.getImages().length;
                    $scope.shareMenuDisabled = $scope.feed.isCirclePost();
                    $scope.ogData = $scope.feed.getOgData();
                    $scope.ogShowPreview = $scope.feed.hasOgData();
                    $scope.showCommentBox = true;
                    $controller('FeedSubController', {$scope: $scope});
                    utilsFactory.safeDigest($scope);
                    $scope.$broadcast(SystemEvents.FEED.RESET,$scope.feed);
                }
            }
        }]);

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller("FeedSubController",FeedSubController);
        FeedSubController.$inject = ['rgDropdownService', '$rootScope','$scope', '$location', 'feedFactory', 'Ringalert','MESSAGES', 'SystemEvents','$ringbox','Media', 'utilsFactory'];
     function FeedSubController(rgDropdownService, $rootScope,$scope, $location, feedFactory, Ringalert,MESSAGES, SystemEvents,$ringbox,Media, utilsFactory) {

            $scope.showdroparrow = 0;
            $scope.showCommentBox = false; // use
            $scope.showShareBox = false; // use
            $scope.showCommentView = true; // do not use
            $scope.showShareForm = false; // do not use
            $scope.editorEnabled = false;
            $scope.errorImageEdit = false;

            $scope.feedLocation = {};
            $scope.ogData = $scope.ogData || {};
            $scope.filterOnProgress = false;

            $scope.ogDataLoading = false;
            $scope.ogShowPreview = false;

            $scope.previousFeedLocation = '';

            $scope.emotions = {};
            var f = $scope.feed && $scope.feed.value ? $scope.feed.value : $scope.feed;
            if(f && f.isSingleContentFeed()){
             if(f.getMedias().length() || f.getAudios().length()){
                $scope.likeType = 'media';
             }else if(f.getImages(true).length()){
                $scope.likeType = 'image';
             }
                $scope.likeTarget =  f.getSingleContent();
             }else{
                 $scope.likeType = 'feed';
                 $scope.likeTarget = f;
             }

            $scope.shareMenuDisabled = $scope.shareMenuDisabled ? $scope.shareMenuDisabled : false;
            $scope.toggleCommentBox = function (event) {
                event.stopPropagation();
                $scope.showCommentBox = !$scope.showCommentBox;
                if($scope.showCommentBox) {
                    $scope.showShareBox = false;
                }
                //$scope.showShareForm = !$scope.showCommentBox;
            };


            /**
             *  For update feed verbal time
             */
            //setInterval(feedFactory.updateTime, 180000 );

             $scope.feedEditChooseEmotion = function(subCat){
                 $scope.emotions.length = 0;
                 $scope.emotions.push(subCat);
                 $scope.$rgDigest();
             };

            // $scope.toggleShareBox = function(event) {
            //     event.stopPropagation();
            //     var f = $scope.feed.hasSharedFeed() ? $scope.feed.getOrginalFeed():$scope.feed;
            //     var shareablle = f.isShareAble(true);
            //     if(shareablle.sucs) {
            //         $scope.showShareBox = !$scope.showShareBox;
            //         if($scope.showShareBox) {
            //             $scope.showCommentBox = false;
            //         }
            //         $scope.$rgDigest();
            //     } else {
            //         Ringalert.show(MESSAGES[shareablle.rc],'warning');
            //     }
            // };



            //$scope.hideTheCommentBox = function () {
                //$scope.showCommentBox = false;
                //$scope.showShareForm = !$scope.showCommentBox
            //};

            //$scope.showTheCommentBox = function () {
                //$scope.showCommentBox = true;
                //$scope.showShareForm = !$scope.showCommentBox
            //};

            // feed dropdown data
            //$scope.ddHtml = 'pages/dropdowns/feed-edit-dropdown.html';//$templateCache.get('feed-edit-dropdown.html');
            $scope.ddTemplate =
				'<div class="ng-cloak action feed-ac float-right">' +
					'<div class="feed-line" ng-if="ddControl.showEdit()">' +
						'<span class="icon-edit-p feed-font"></span>' +
						'<a rg-click="ddAction()({event: $event, action:\'edit\', feedKey: ddControl.feedKey})" href="#">Edit</a>' +
					'</div>' +
					'<div class="feed-line" ng-if="ddControl.showTagButton()">' +
						'<span class="icon-add-tag feed-font"></span>' +
						'<a rg-click="ddAction()({event: $event, action:\'edittag\', feedKey: ddControl.feedKey})" href="#" class="border-0">{{ddControl.tagButtonText()}}</a>' +
					'</div>' +
					'<div class="feed-line">' +
						'<span class="icon-delete-p feed-font"></span>' +
						'<a rg-click="ddAction()({event: $event, action:\'delete\', feedKey: ddControl.feedKey})" href="#" class="border-0">Delete</a>' +
					'</div>' +
				'</div>';


            $scope.actionFeedDropdown = function (actionObj) {
                rgDropdownService.close();
                // console.log(actionObj);
                actionObj.event.preventDefault();
                switch (actionObj.action) {
                    case 'edit':
                        $scope.enableEditor(actionObj.feedKey);
                        break;
                    case 'edittag':
                        openRingBoxToEditTag();
                        break;
                    case 'delete':
                        $scope.deleteFeed(actionObj.feedKey);
                        break;
                    default:
                    //   console.log("no action matched");
                };
            };



            // $scope.like = function (f) {
            //    // Ringalert.alert();return;
            //     feedFactory.likeUnlikeFeed($scope.keyid,f).then(function(json){ //success so show notification
            //        // Ringalert.show('','success');// passing empty in message to show default message
            //     },function(json){// failed so show notification
            //         Ringalert.show(json,'error');
            //     });
            //     if(f.like()){
            //         $scope.$broadcast('LikeChange',true);
            //     }

            // };


            $scope.enableEditor = function (feedKey) {
                //$scope.showDropdown = false;

                $scope.showdroparrow = feedKey;
                $scope.editorEnabled = true;
                console.log($scope.showdroparrow);

                var feedObj = feedFactory.getFeed(feedKey);

                $scope.feedText = feedObj.text();
                $scope.feedLocation =  angular.copy(feedObj.getLocationInfo());
                $scope.ogData =  angular.copy(feedObj.getOgData());
                $scope.ogShowPreview = feedObj.hasOgData();

                $scope.emotions = [feedObj.getFeelings()];


                var obj = {
                  feedText:  $scope.feedText,
                  feedLocation: $scope.feedLocation,
                  feedKey: feedKey,
                  ogData: $scope.ogData
                };

                $rootScope.$broadcast('enableeditor',obj);
                $scope.$rgDigest();
            };



            $scope.cancelEdit = function () {
                $scope.editorEnabled = false;
                $scope.errorImageEdit = false;
                $scope.$rgDigest();
            };
            function validateUpdate(){
                    return !$scope.feedText
                        && !$scope.feedLocation.description
                        && !$scope.ogData.url
                        && !($scope.feelings && $scope.feelings.id)
                        && !$scope.feed.hasMedia()
                        && !$scope.feed.hasTagUsers();
            }
            $scope.updateFeed = function () {
                $scope.feedText = $scope.feedText.trim();

                if($scope.emotions.length){
                    $scope.feelings = $scope.emotions[0];// we will support one emotion at a time for now
                    $scope.emotions.length = 0;//emptying emotion
                }else{
                    $scope.feelings = false;
                }

                //$scope.showdroparrow = 0;



                if(validateUpdate()){
                    $scope.errorImageEdit = true;
                    $scope.editorEnabled = true;
                }else{
                    feedFactory.updateFeed($scope.currentUser, $scope.keyid, $scope.feedText, $scope.feedLocation, $scope.ogData, $scope.feelings  ).then(function (json) {
                        /* Isolated Directives will update based on this event */
                        $scope.editorEnabled = false;
                        $scope.errorImageEdit = false;

                        $scope.$rgDigest();

                        $scope.$broadcast(SystemEvents.FEED.UPDATED, { id: $scope.keyid });

                    },function(json){
                        Ringalert.show(json,'error');
                        $scope.$rgDigest();
                    });
                }
             $scope.$rgDigest();


            };

            $scope.deleteFeed = function (key) {
                //console.log('key: '+key);
                //console.log('scope Key: '+$scope.keyid);
                feedFactory.deleteFeed($scope.currentUser, key).then(function (json) {
                    $scope.setFeed(true);
                    Ringalert.show(json,'success');
                }, function(errJson){
                    $scope.setFeed(true);
                    Ringalert.show(errJson,'error');
                });
            };

            $scope.getShareData = function () {
                return function () {
                    return {keyid: $scope.keyid, feed: $scope.feed.hasSharedFeed() ? $scope.feed.getOrginalFeed():$scope.feed};
                };
            };
            $scope.getImageData = function (image, feed) {

                return function () {
                            return {
                               image: image,
                               feed: feed
                           };
                        };
            };

         $scope.getMediaData = function (media, feed) {

            return {
                    data: function () {
                        return {
                            media: media,
                            album: feed.getAlbum(),
                            feedTime: feed.time()
                        };
                    },
                    promise: Media.fetchContentDetails(media.getKey(), true, media.user())
                };

         };

            // $scope.fetchWhoLikes = function () {
            //     return {
            //         data: function () {
            //             return {
            //                 target: $scope.feed,
            //                 type:'feed'
            //             };
            //         },
            //         promise: feedFactory.fetchWhoLikesFeed($scope.feed)
            //     };
            // };


             $scope.selectedFeedLocation = function(location){
                 $scope.feedLocation = location;

                 utilsFactory.safeDigest($scope);
             };

             $scope.resetFeedLocation = function(){
                 $scope.feedLocation = {};
             };

         //setInterval(feedFactory.updateTime, 180000);
         //setInterval(function(){
         //    feedFactory.updateTime();
         //    $scope.$rgDigest();
         //}, 180000);

            $scope.goToFeed = goToFeed;

            $scope.isShareAble= function(f){
                f = f.hasSharedFeed() ? f.getOrginalFeed():f;
                return f.isShareAble();
             // return  f.hasSharedFeed() ?(!f.getOrginalFeed().user().isCurrentUser() && !f.user().isCurrentUser()):!f.user().isCurrentUser();
            };
            
            
            
             ///////////////////////////////


             //------------------ Public -------------------

             function goToFeed(feedUrl){
                 if(!!feedUrl){
                     $location.path(feedUrl);
                 }
             }

            function goToImage($event, imageUrl){
                if(!!imageUrl){
                    $location.path(imageUrl);
                }
            }
            function openRingBoxToEditTag () {

               var boxInstance = $ringbox.open({

                        type : 'remote',
                        scope:false,
                        controller: 'feedEditTagController',
                        resolve : {
                            localData : {
                                feed : $scope.feed
                            },
                            remoteData : function(){
                                if($scope.feed.hasTagUsers()){
                                    return feedFactory.getTagUsers($scope.feed);
                                }else{
                                    return {};
                                }
                            }
                        },
                        templateUrl : 'pages/home/feed-tag-user-edit.html'
                });

               

               boxInstance.result.then(function(updatedFeed){
                 if(!!updatedFeed){
                    $scope.feed = updatedFeed;
                 }
                 $scope.cancelEdit();
               });
            }

        $scope.openRingBoxLike = function(){
            return $scope.feed.getTotalLikes() > 0;
        };
        $scope.openRingboxShare = function(){

            return (($scope.feed.hasSharedFeed() ? $scope.feed.getOrginalFeed().getTotalShare() > 0 : $scope.feed.getTotalShare()) > 0) && !$scope.feed.isMediaShared() && !$scope.feed.isSingleContentFeed();
        };
        $scope.whoShareFalsyFunc = function(){
            if($scope.feed.isSingleContentFeed()){
                Ringalert.show("Oops! This feature is coming soon",'info');
            }
             RingLogger.print("print from who share falsy func",RingLogger.tags.TEST);
        };

        // RingLogger.print("Skip Save Scope From WhoShare"+$scope.skipSaveScope,"scopetest");
         if(!$scope.skipSaveScope){
             var key = ($scope.feed.value)? $scope.feed.value.getKey(): $scope.feed.getKey();
             feedFactory.addScope(key,$scope);
             $scope.$on('$destroy',function(){
                 feedFactory.removeScope($scope.feed.getKey());
             });
         }

                // ##DIGEST_DEBUG_START##
                if(RingLogger.tags.DIGEST){
                $scope.$watch(function(){
                     RingLogger.info("from FeedSubController : " + ($scope.$index +1),RingLogger.tags.DIGEST);
                });
                }
                // ##DIGEST_DEBUG_END##

     }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('FeedWhoShareController',FeedWhoShareController);
    FeedWhoShareController.$inject = ['$$connector','$scope','$$feedMap','feedFactory','OPERATION_TYPES','$rootScope','Ringalert'];

    function FeedWhoShareController($$connector,$scope,$$feedMap,feedFactory,OPERATION_TYPES,$rootScope,Ringalert){
        /**
         *
         * This contrller Has been made abstract and couldn't be used alone, use it by extending
         *
         * See, feed.ringbox.whoshare.controller.js , feed.single.whoshare.controller.js
         *
         * $scope.params will contain the parameters to init the controller
         *
         *
         */


        var subKey,ignoreCommKey,ignoreLikeKey,i,OTYPES=OPERATION_TYPES.SYSTEM;

        $scope.feeds = [];
        $scope.message = "";

        $scope.boxIsLoading = !$scope.params.boxIsLoading ?  true : $scope.params.boxIsLoading;

        var dashboardFeed;
        if(!!$scope.params){
            dashboardFeed = feedFactory.getFeed($scope.params.keyid);
        }


        $scope.showMessage = false  ;
        $scope.shareMenuDisabled = true;
        $scope.singleFeed = true;
        $scope.busy = false;


        $scope.boxHeight = $rootScope.windowHeight - 20;


        /**
         * Prohibiting Main feed subscriber from feedFactory not to process data if this controller scope exist for certain action        *
         *
         */



        subKey = $$connector.subscribe(function(json){
            $scope.boxIsLoading = false;
            $scope.isReady = true;
            $scope.busy = false;

            if(!json.sucs){
                $scope.$close();
                //todo : reason code implementation
                Ringalert.show(json.mg || "Opps ! Looks Like Something Went Wrong ! Please Try Later.",'error');
                return;
            }

            if(json.newsFeedList.length){
                for(i=0;i<json.newsFeedList.length;i++){
                    var aFeedMapObject = $$feedMap.create(json.newsFeedList[i]);

                     if( aFeedMapObject.getKey() === dashboardFeed.getKey()){                        
                         aFeedMapObject.setIdenticalFeed(dashboardFeed);
                     }
                    // }else{
                    $scope.feeds.push(aFeedMapObject);
                    // }

                }
            }
            $scope.$rgDigest();
        },{
            action : OTYPES.TYPE_WHO_SHARES_LIST
        });



        function startRequest(){
            $scope.boxIsLoading = true;
            if($scope.feeds.length < $scope.params.feed.getTotalShare() && !$scope.busy){
                $$connector.send({
                    actn : OTYPES.TYPE_WHO_SHARES_LIST,
                    nfId : $scope.params.feed.getKey(),
                    st : $scope.feeds.length
                },OTYPES.REQUEST_TYPE.REQUEST);
                $scope.busy = true;
                setTimeout(function(){ // blocking next three second not to send the request
                    $scope.busy = $scope.busy && false;
                    $scope.$rgDigest();
                },3000);
                $scope.$rgDigest();
                /**
                 * for Testing purpose ther service were created in feedFactory
                 * Now its blocked but if you need to retest block the socket sending option
                 * and unblock this one
                 */
                //feedFactory.fakeFeed($scope.feeds.length,4).then(function(json){
                //    for(var i=0;i<json.length;i++){
                //        if(findFromFeeds(json[i].getKey())){
                //            console.log("duplicate Feed :" + json[i].getKey());
                //        }else{
                //            $scope.feeds.push(json[i]);
                //        }
                //
                //    }
                // busy = false;
                //},function(message){
                //    console.log("Limit Reached");
                // busy = false;
                //});
            }


        }
        $scope.loadMore = startRequest;
        $scope.loadMore();//starting first Request

        $scope.$on('$destroy',function(){
            feedFactory.removeIgnoreFilter(ignoreCommKey);
            feedFactory.removeIgnoreFilter(ignoreLikeKey);
            $$connector.unsubscribe(subKey);
        });
        $scope.skipSaveScope = true;

        // ##DIGEST_DEBUG_START##
              if(RingLogger.tags.DIGEST){
                  $scope.$watch(function(){
                       RingLogger.info("from FeedWhoShareController",RingLogger.tags.DIGEST);
                   });
              }
        // ##DIGEST_DEBUG_END##
    }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('FeedRingboxWhoShareController',FeedRingboxWhoShareController);
    FeedRingboxWhoShareController.$inject = ['$controller','$scope','localData'];

    function FeedRingboxWhoShareController($controller, $scope, localData){

        $scope.viewType = 'ringbox';

        $scope.params = localData;
        

        $controller('FeedWhoShareController', {$scope: $scope} )

    }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('FeedSingleWhoShareController',FeedSingleWhoShareController);
    FeedSingleWhoShareController.$inject = ['$controller', '$scope', '$routeParams', 'feedFactory'];

    function FeedSingleWhoShareController($controller, $scope, $routeParams, feedFactory) {

        $scope.viewType = 'singleWhoShareFeed';

        $scope.isReady = false;

        $scope.$close = angular.noop;

        $scope.feedId = $routeParams.feedId;

        $scope.pagekey  = feedFactory.getSingleFeedPageKey($scope.feedId);

        $scope.params = {};

        feedFactory.getSingleFeed($scope.feedId).then(function (feed) {
            if (!!feed) {
                $scope.params.feed = feed;
                $scope.params.boxIsLoading = false;
                initFeedView();
                $controller('FeedWhoShareController', {$scope: $scope});
            }else{
                $scope.params.boxIsLoading = false;
                $scope.noData = true;
            }
        });


        ////////////////////////////////////////////////////////////


        function initFeedView(){
            if($scope.feed){
                $scope.serial = false;

                $scope.feedstatus = $scope.feed.text();

                $scope.keyid = $scope.feed.getKey();

                $scope.imageslength = $scope.feed.getImages().length;

            }
        }




    }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }


    feedApp.controller("feedShareController",feedShareController);
    feedShareController.$inject = ['$scope', 'Auth', 'feedFactory','$rootScope','Ringalert', 'utilsFactory'];
    function feedShareController($scope,AuthFactory, feedFactory,$rootScope,Ringalert, utilsFactory) {
            /**
                This will act as a abstract base controller,
                Usage Example :
                  `feed.inline.share.controller`
                  `feed.ringbox.share.controller`

                params:
                    $scope.params = {
                      `feed` : FEED_MAP_OBJECT
                      `afterShareCallback` : `Callback FUNCTION AFTER SHARE`
                  }
            */

            $scope.feed = $scope.params.feed;
            $scope.afterShareCallback = $scope.params.afterShareCallback;
            $scope.updateFeedLocation = updateFeedLocation;
            $scope.resetFeedLocation = resetFeedLocation;
            $scope.currentUser = AuthFactory.currentUser();

            resetFeedLocation();
            resetFeedText();
            resetErrorMessage();
            enablePostInput();
            hideLoader();
            
            $scope.shareFeed = shareFeed;

            ///////////////// SCOPE FUNCTIONS ////////////////////

            function shareFeed(ob) {
                var data = getFeedShareData();

                disablePostInput();
                showLoader();
                resetErrorMessage();

                feedFactory.shareFeed(data).then(function (json) {
                    hideLoader();
                    resetFeedText();
                    enablePostInput();
                    resetErrorMessage();
                    resetFeedLocation();

                    emitFeedListChangedEvent();

                    afterShareCallback();
                    showSuccessMsg(json);
                    if($scope.media){
                        $scope.media.share(true);
                        $scope.$close();
                    }else{
                        $scope.$parent.$rgDigest();
                    }
                    
                },function(responseObj){
                    hideLoader();
                    enablePostInput();
                    processErorr(responseObj);
                    $scope.$parent.$rgDigest();
                });
                $scope.$rgDigest();
            }

            ///////////////////////////////////////////////////////////////

            function disablePostInput(){ $scope.inputDisabled = true; }
            function enablePostInput(){ $scope.inputDisabled = false; }

            function showLoader(){ $scope.boxIsLoading = true; }
            function hideLoader(){ $scope.boxIsLoading = false; }

            function setErrorMessage(msg){ $scope.errorMessage = msg; }
            function resetErrorMessage(){ $scope.errorMessage = ""; }

            function resetFeedText(){ $scope.feedText = ""; }
            function setFeedText(text){ $scope.feedText = text;  }

            function setFeedLocation(location){ $scope.feedLocation = location; }
            function resetFeedLocation(location){ $scope.feedLocation = ""; }

            function updateFeedLocation(location){
                //$scope.$apply(function(){
                    setFeedLocation(location);
                    $scope.$rgDigest();
                //})
                // $scope.$digest();
            }

            function emitFeedListChangedEvent(){
              $rootScope.$broadcast("FeedListChanged");
              $scope.$broadcast('cleareditor');
            }

            function showSuccessMsg(json){ Ringalert.show(json,'success'); }

            function showErrorMsg(msg){ Ringalert.show(msg,'error'); }

            function getFeedShareData(){
                var feed = $scope.media ? null:$scope.feed;
              var data =  { text: $scope.feedText,
                  feed: feed && feed.hasSharedFeed()? feed.getOrginalFeed() : feed,
                  location : $scope.feedLocation
              },content = $scope.media,i;

              if($scope.emotions.length){
                  data.mdIds = [$scope.emotions[0].id];// we will support one emotion at a time for now
                  $scope.emotions.length = 0;//emptying emotion
              }

              if($scope.tagList.length){
                  data.tFrndIds = [];
                  for(i=0;i<$scope.tagList.length;i++){
                      data.tFrndIds.push($scope.tagList[i].getUtId());
                  }
                  $scope.tagList.length = 0;
              }
            if(content || (feed  && feed.isSingleContentFeed() && (feed.getMedias().length() || feed.getAudios().length())) ){
                 content = content || feed.getSingleContent();
                 data.audio = content.isAudio();
                 data.cntntIDLst = [content.getKey()];
                 data.addShare = true;
                 data.user = $scope.currentUser;
            }

              return data;

            }


            function afterShareCallback(){
                if(!!$scope.afterShareCallback){
                  $scope.afterShareCallback();
                }
            }

            function processErorr(responseObj){

                var msg = utilsFactory.getReasonMessageFromResponse(responseObj);
                if(msg == ""){
                    msg = "Unable To Share Status. Please Try Again Later";
                }

                $scope.errorMessage = msg;
            }


            $scope.emotions = [];
            $scope.tagList = [];

            $scope.addTag = function(item){
                var index = $scope.tagList.indexOf(item);
                if(index === -1){
                    $scope.tagList.push(item);
                }

            }
            $scope.removeTag = function(usr){
                    var index = $scope.tagList.indexOf(usr);
                    if(index >=0){
                        $scope.tagList.splice(index, 1);
                    }
            };
            $scope.chooseEmotion = function(subCat){
                $scope.emotions.length = 0;//note : now we only support one media at a limt
                $scope.emotions.push(subCat);
            }



        }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }



    feedApp.controller("feedRingboxShareController",feedRingboxShareController);
    feedRingboxShareController.$inject = ['$scope', '$boxInstance', '$controller', 'localData'];
    function feedRingboxShareController($scope, $boxInstance, $controller, localData ) {

        $scope.params = {
          feed: localData.feed,
          afterShareCallback : $scope.$close,
          showSharePostBox: true
        };

        $controller('feedShareController', {$scope: $scope});

    }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }



    feedApp.controller("feedMediaShareController",feedMediaShareController);//using in ringbox media controller
    feedApp.controller("feedInlineShareController",feedInlineShareController);
    feedInlineShareController.$inject = ['$scope',  '$controller'];
    function feedInlineShareController($scope, $controller) {

        $scope.params = {
          feed: $scope.feed,
          afterShareCallback : $scope.closeShareBox,
          showSharePostBox : true
        };

        $controller('feedShareController', {$scope: $scope});

        ////////////////////////////////////
       /*
        function afterShareCallback(){
            $scope.showShareBox = false;
        }
        */

    }

    feedMediaShareController.$inject = ['$scope','$controller'];
    function feedMediaShareController($scope,$controller){
            $scope.params = {
              feed: null,
              afterShareCallback : angular.noop,
              showSharePostBox : true
            };
            $scope.closeShareBox = function(){
                $scope.$close();
            }
            $scope.autoAdjustScroll = "false";
            $controller('feedShareController', {$scope: $scope});
    }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller("FeedAddController",['fileUploadService', '$rootScope','$scope','feedFactory','$timeout','$routeParams','SystemEvents','OPERATION_TYPES', 'rgDropdownService','PrivacySet',
        function(fileUploadService, $rootScope,$scope,feedFactory,$timeout,$routeParams,SystemEvents,OPERATION_TYPES, rgDropdownService,PrivacySet){



            // privacy and privacy dropdowns
            //var privacyCode = 2;
            $scope.privacySet = PrivacySet;
            if($scope.forAdd=='circle' || $scope.forAdd === 'friend'){
                $scope.showPrivacy = false;
            }else{
                $scope.showPrivacy = true;
                $scope.privacy = PrivacySet.PVC2;
            }
            
            $scope.setPrivacy = function(actionObj) {
                actionObj.event.preventDefault();
              //  privacyCode = actionObj.privacy;
                $scope.privacy = PrivacySet['PVC'+actionObj.privacy];
                rgDropdownService.close();
                $scope.$rgDigest();
            };
            //$scope.privacyHtml = 'pages/dropdowns/privacy-dropdown.html';
            $scope.privacyTemplate =
                    '<div class="ng-cloak action  ab-drop postbox-action">'+
                        '<div class="a-box" ><a rg-click="ddAction()({event: $event, privacy:ddControl.PVC1.value})" href="#"><span class="{{::ddControl.PVC1.icon}} ab-delete"></span> {{::ddControl.PVC1.text}}</a></div>' +
                        '<div class="a-box"><a rg-click="ddAction()({event: $event, privacy:ddControl.PVC2.value})" href="#"><span class="{{::ddControl.PVC2.icon}} ab-delete"></span> {{::ddControl.PVC2.text}} </a></div>' +
                        '<div class="a-box"><a rg-click="ddAction()({event: $event, privacy:ddControl.PVC3.value})" href="#"><span class="{{::ddControl.PVC3.icon}} ab-delete"></span> {{::ddControl.PVC3.text}}</a></div>' +
                    '</div>' ;


            $scope.feedText = "";
            $scope.feedLocation = {};
            $scope.ogData = {};

            $scope.filterOnProgress = false;
            $scope.ogDataLoading = false;
            $scope.ogShowPreview = false;

            // $scope.uploadEnabled = !$scope.ogData || !$scope.ogData.url ;

            $scope.inputDisabled = false;

            $scope.getValidityValues = function(){
                return new Array(30);
            };

            $scope.showTimeout = false;
            $scope.validity = -1;
            var gdata = {vldt : $scope.validity};

            if($scope.forAdd === 'friend'){
                gdata.friend = $routeParams.uId;

            }else if($scope.forAdd === 'circle'){
                gdata.group = $routeParams.circleId;
                //data.isCircle = true;
            }
            $rootScope.$on(SystemEvents.FILE_UPLOAD.QUEUE_START,function(){
                $scope.inputDisabled = true;
                $scope.$rgDigest();
            });

            $rootScope.$on(SystemEvents.FILE_UPLOAD.QUEUE_COMPLETE,function(){
                $scope.inputDisabled = false;
                $scope.$rgDigest();
            });

            $scope.shouldDisableInput = function(){
                return ( $scope.inputDisabled || $scope.ogDataLoading || $scope.filterOnProgress);
            };

            var lastAddStatusTime = new Date().getTime(),now,i;


            $scope.addFeed = function(){

                var data = {vldt : $scope.validity};
                //var feedItemCount = 0;

                $scope.inputDisabled = true;
                data = angular.extend({},gdata,{
                    //fpvc: $scope.privacy.value,//privacyCode,
                    text: $scope.feedText,
                    vldt : $scope.validity,
                    images: fileUploadService.imageFiles,
                    videos: fileUploadService.videoFiles,
                    audios: fileUploadService.audioFiles
                });

                if($scope.privacy){
                    data.fpvc = $scope.privacy.value;
                }

                //if(data.images.length > 0) {
                //    feedItemCount++; // only images can be posted
                //}
                //if(data.videos.length > 0) {
                //    feedItemCount++; // only videos can be posted
                //}

                if(!!$scope.feedLocation.description){
                    data.lctn = $scope.feedLocation.description;
                    data.lat = $scope.feedLocation.lat;
                    data.lng = $scope.feedLocation.lng;
                }

                if(!!$scope.ogData.url){
                    data.lnkDmn = $scope.ogData.lnkDmn || $scope.ogData.url || '';
                    data.lnkDsc = $scope.ogData.description || '';
                    data.lnkTtl = $scope.ogData.title || '';
                    data.lnkURL = $scope.ogData.url || '';
                    data.lnlImgURL = $scope.ogData.image || '';

                }

                if($scope.emotions.length){
                    data.mdIds = [$scope.emotions[0].id];// we will support one emotion at a time for now
                    $scope.emotions.length = 0;//emptying emotion
                }


                if($scope.tagList.length){
                    data.tFrndIds = [];
                    for(i=0;i<$scope.tagList.length;i++){
                        data.tFrndIds.push($scope.tagList[i].getUtId());
                    }
                    $scope.tagList.length = 0;
                }

                var originalFeedText = $scope.feedText;
                //http://192.168.1.117/ringID/ringIDWeb/issues/472
                if( data.text != '' && !!data.lnkURL ) {

                    var dataTextProtocolStriped = data.text.replace('https', '').replace('http', '');
                    var feedLinkUrlProtocolStriped = data.lnkURL.replace('https', '').replace('http', '');

                    if (dataTextProtocolStriped[dataTextProtocolStriped.length - 1] == '/') {
                        dataTextProtocolStriped = dataTextProtocolStriped.slice(0, -1);
                    }

                    if (feedLinkUrlProtocolStriped[feedLinkUrlProtocolStriped.length - 1] == '/') {
                        feedLinkUrlProtocolStriped = feedLinkUrlProtocolStriped.slice(0, -1);
                    }

                    if (dataTextProtocolStriped == feedLinkUrlProtocolStriped) {
                        data.text = '';
                    }

                }



                function canPostEmptyStatus(){
                    return !!data.text
                        || !!data.lnkURL
                        || data.images.length > 0
                        || data.videos.length > 0
                        || data.audios.length > 0
                        || (!!data.mdIds && data.mdIds.length > 0)
                        || (!!data.lctn)
                        || (!!data.tFrndIds && data.tFrndIds.length > 0);
                }

                function addFeedRequest(){
                    lastAddStatusTime = now;

                    feedFactory.addFeed(data,$scope.currentUser).then(function(json){

                       $scope.setFeed();
                        //$scope.$broadcast('cleareditor');
                        $scope.$parent.$rgDigest();
                    },function(){

                       $scope.setFeed();
                       $scope.feedText = originalFeedText;
                       $scope.$broadcast('seteditor');
                       $scope.$parent.$rgDigest();
                    },function(state){ // on progress notify call

                    });

                    fileUploadService.imageFiles.length = 0;
                    fileUploadService.imageFiles= [];
                    fileUploadService.videoFiles.length = 0;
                    fileUploadService.videoFiles= [];
                    fileUploadService.audioFiles.length = 0;
                    fileUploadService.audioFiles= [];
                    $scope.feedText = "";
                    $scope.validity = -1;
                    $scope.feedLocation = {};
                    $scope.ogData = {};
                    $scope.ogShowPreview = false;
                    $scope.inputDisabled = false;
                    $scope.errorMessage = false;
                    $scope.setFeed();
                    $scope.$broadcast('cleareditor');
                    $scope.$rgDigest();
                }

                if( !canPostEmptyStatus() && data.text === ''){

                    $scope.feedText = "";
                    $scope.inputDisabled = false;
                    $scope.errorMessage = true;
                    $scope.ogShowPreview = false;
                    $scope.$rgDigest();
                    //if (data.images.length === 0) {
                        //$rootScope.$broadcast('cleareditor',{sucs:false});
                   // }
                }else{
                     now = new Date().getTime();
                    if(now - lastAddStatusTime < 200){
                        setTimeout(addFeedRequest,200)
                    }else{
                        addFeedRequest();
                    }

                }

            };

            $scope.selectOptions = [];
            $scope.selectOptions[0] = {
                value : -1,
                title : 'Unlimited'
            };
            for(i=1;i<=30;i++){
                $scope.selectOptions[i] = {
                    value : i,
                    title : i + " Day"
                };
            }

            $scope.selectedTimeout = function(item){
                $scope.validity = item;
                $scope.$rgDigest();
            };
            $scope.selectedLocation = function(location){
                //$scope.$apply(function(){
                    $scope.feedLocation = location;
                //});
                $scope.$rgDigest();
            };

            $scope.resetFeedLocation = function(){
                $scope.feedLocation = {};
                $scope.$rgDigest();
            };

           // $scope.showEmotion = false;
            $scope.emotions = [];
            $scope.tagList = [];

            $scope.addTag = function(item){
                var index = $scope.tagList.indexOf(item);
                if(index === -1){
                    $scope.tagList.push(item);
                }
                $scope.$rgDigest();

            };

            $scope.removeTag = function(usr){
                    var index = $scope.tagList.indexOf(usr);
                    if(index >=0){
                        $scope.tagList.splice(index, 1);
                    }
                    $scope.$rgDigest();
            };

            $scope.chooseEmotion = function(subCat){
                $scope.emotions.length = 0;//note : now we only support one media at a limt
                $scope.emotions.push(subCat);
                $scope.$rgDigest();
            };

            var pageVal = feedFactory.getCurrentPageValue();

            $scope.showAddTag  = pageVal.action !== OPERATION_TYPES.SYSTEM.TYPE_GROUP_NEWS_FEED;

             // ##DIGEST_DEBUG_START##
                   if(RingLogger.tags.DIGEST){
                       $scope.$watch(function(){
                            RingLogger.info("from FeedAddController",RingLogger.tags.DIGEST);
                        });
                   }
             // ##DIGEST_DEBUG_END##


        }]);
})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }
    feedApp.controller('FeedDashboardController', ['$scope','$controller','OPERATION_TYPES','Ringalert',
        function ($scope,$controller,OPERATION_TYPES,Ringalert){
            $scope.pagekey = OPERATION_TYPES.SYSTEM.TYPE_NEWS_FEED + '.all';
            $scope.action = OPERATION_TYPES.SYSTEM.TYPE_NEWS_FEED;
            $scope.params = {actn:OPERATION_TYPES.SYSTEM.TYPE_NEWS_FEED};
            $scope.forAdd = "my";
            $controller('FeedMainController', {$scope: $scope});

        }]);

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('FeedProfileController',['$scope','$controller','$routeParams','OPERATION_TYPES',
        function($scope,$controller,$routeParams,OPERATION_TYPES){

            var uId = $routeParams.uId,
                helperob,
                mapkey = uId,action;

            /* helperob ( Helper Object) sets where to submit the post, my wall or fiends wall
            *  my post : @value : "my"
            *  friend post : @value : "friend
            *
            * */

            if($scope.currentUser && $scope.currentUser.equals(uId)){
                helperob = "my";
                action = OPERATION_TYPES.SYSTEM.TYPE_MY_NEWS_FEED;

            }else{
                helperob = "friend";
                action = OPERATION_TYPES.SYSTEM.TYPE_FRIEND_NEWSFEED;
            }
            mapkey = action +"."+ uId;

            $scope.pagekey = mapkey;
            $scope.action = action;
            $scope.params = {actn:action,fndId:uId};
            $scope.forAdd = helperob;
            $scope.sortBy = 'at';
            $controller('FeedMainController', {$scope: $scope});
        }]);


})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('FeedCircleController',['$scope','$controller','$routeParams','OPERATION_TYPES', 'feedFactory',
        function($scope,$controller,$routeParams,OPERATION_TYPES, feedFactory){
            //$scope.column = helper.feedColumn();
            var feeds = [],
                page= 'circle',
                cicleId = $routeParams.circleId,
                helperob,
                mapkey = OPERATION_TYPES.SYSTEM.TYPE_GROUP_NEWS_FEED + "." + cicleId;

            $scope.pagekey = mapkey;

            $scope.action = OPERATION_TYPES.SYSTEM.TYPE_GROUP_NEWS_FEED;

            $scope.params = {actn:OPERATION_TYPES.SYSTEM.TYPE_GROUP_NEWS_FEED, grpId:cicleId};

            $scope.forAdd = page;
            $scope.shareMenuDisabled = true;
            
            $controller('FeedMainController', {$scope: $scope});

        }]);


})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', ['ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('feedTagUserListController',feedTagUserListController);
    feedTagUserListController.$inject = ['$scope','remoteData','userFactory','InviteFactory'];

    function feedTagUserListController($scope, remoteData ,User,InviteFactory){
        var tagUserIds = remoteData.fTgLst;
        $scope.usersUtIds =[];
        $scope.users =[];
        var usercount = tagUserIds.length;
        if(usercount){
            $scope.total = usercount;
            for(var i = 0;i < tagUserIds.length;i++){
                tagUserIds[i].fn = tagUserIds[i].nm;
                $scope.users.push(User.createByUtId(tagUserIds[i],true));
            }
        }

        $scope.getMutualFriend = function(user) {
            return{
                data: function() {
                    return {
                        target: user
                    };
                },
                promise: InviteFactory.getMutualFriend(user)
            };
        };

    }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', ['ringid.utils', 'ringid.config'
            ]);
    }
    feedApp.filter("filterUserByName",function(){
        return function(items, name) {
                            if (items) {
                                var filtered = [];
                                var nameMatch = new RegExp(name, 'i');
                                for (var i = 0; i < items.length; i++) {
                                    if(items[i].getName().match(nameMatch)){
                                        filtered.push(items[i]);
                                    }
                                }
                                return filtered;
                            }
                };
            });
    feedApp.controller('feedEditTagController',feedEditTagController);
    feedEditTagController.$inject = ['$scope','localData', 'remoteData', '$$connector','feedFactory','OPERATION_TYPES','userFactory','$filter','friendsFactory','Ringalert', 'Auth'];

    function feedEditTagController($scope, localData, remoteData, $$connector,feedFactory,OPERATION_TYPES,User,$filter,friendsFactory,Ringalert, Auth){

        var feed = localData.feed,
            sentRequest=false,
            friends = [], //feed.getTagUsers();
            tagUsers = [],
            tagUsersBackup = [],
            users = [];
        
        $scope.users = [] ;
        $scope.filterText='';
        $scope.loading = true;
        $scope.currentType = 'a';//all shows at  first

        var currentUser = Auth.currentUser();

        function setUsers(){
            $scope.users = $filter('filterUserByName')(users,$scope.filterText);
        }

        function searchRequest(){
            if(sentRequest)return;
            friendsFactory.searchContact({schPm: $scope.filterText}, true);
            $scope.loading = true;
            sentRequest = true;
        } 

        $scope.$watch('filterText', function(newValue, oldValue) {

            setUsers();
            if($scope.users.length < 5 && newValue.length > oldValue.length){ //newValue.length > oldValue.length for making sure not sending request while backspacing
                sentRequest = false;
                searchRequest();
            }else{
                sentRequest = false;
                $scope.loading = false;
            }
        });

        $scope.$watch(friendsFactory.friends.length(), function(newValue, oldValue) {

            crossMatch();
            $scope.loading = false;
            sentRequest = false;

        });

        function crossMatch(){

            if($scope.currentType !== 'a'){
                setUsers();return;
            }

            friendsFactory.friends.doForAll(function(item){

                var liteu = item.getLiteUser();

                if( users.contains( liteu, function(a,b){ return a.equals(b,'utId'); } ) !== -1){
                    return;
                }

                if( tagUsers.contains(liteu,function(a,b){ return a.equals(b,'utId'); }) === -1){
                    users.push(liteu);
                }

            });

            var temp = tagUsers.filter(function(templu){
                return users.contains( templu, function(a,b){ return a.equals(b,'utId'); } ) === -1;
            });

            users = users.concat(temp);
            setUsers();
        }



        if( !!remoteData ){

            if(remoteData.fTgLst && remoteData.fTgLst.length){

                for(var i = 0;i < remoteData.fTgLst.length;i++){

                    remoteData.fTgLst[i].fn = remoteData.fTgLst[i].nm;


                    if( tagUsers.contains(remoteData.fTgLst[i].utId,function(a,b){ return a.equals(b,'utId'); }) === -1)
                    {
                        tagUsers.push(User.createByUtId(remoteData.fTgLst[i],true));//saving the lite user
                        tagUsersBackup.push(tagUsers[i]);
                    }

                }

                crossMatch();

            }
        }

        $scope.loading = false;




        if(!feed.hasTagUsers()){
            crossMatch();
        }

        $scope.toggle = function(type){
            if($scope.currentType == type){
                return;
            }
            $scope.currentType = type;
            if(type == 'a'){
                users = [];
                crossMatch();
            }else{
                users = tagUsers;
                setUsers();
            }
            
        };

        $scope.checked = function(item){
            return tagUsers.indexOf(item) > -1;
        };

        $scope.loadMore = function(){
            if($scope.filterText.length){
                searchRequest();
            }else{
                friendsFactory.getContactDetails();
                $scope.loading = true;
            }            
            
        };

        $scope.addRemoveTag = function(event,item){
            var index = tagUsers.indexOf(item);
            if(index > -1){
                tagUsers.splice(index, 1);
            }else{
                tagUsers.push(item);
                if(($scope.users.length - tagUsers.length) < 5){
                    $scope.loadMore();
                }
            }
        };

        $scope.saveTagUser = function(){

                var removed = tagUsersBackup.difference(tagUsers),
                    added = tagUsers.difference(tagUsersBackup),
                    index;

                if(!removed.length && !added.length){
                    Ringalert.show("Please Make Your Changes Before Submit",'warning');
                    return;
                 }

                 if(added.length === 0 && removed.length === tagUsersBackup.length){ //all user has been removed so if feed is empty we should not post the request
                    if(!feed.validateForUpdateTag()){
                        Ringalert.show("You can't submit an empty feed",'warning');
                        return;
                    }
                 }
                var removedTaggedFriends = {};
                var newTaggedFriends = {};

                if(removed.length){
                    for(index=0;index<removed.length;index++){
                        removedTaggedFriends[removed[index].getUtId()] = true;
                    }
                }

                if(added.length){
                    for(index=0;index<added.length;index++){
                        newTaggedFriends[added[index].getUtId()] = true;
                    }
                }

                var tagFriendIds = {
                    'removed' : Object.keys(removedTaggedFriends),
                    'new' : Object.keys(newTaggedFriends)
                };

                feedFactory.updateFeed(currentUser,
                    feed.getKey(),
                    feed.text(),
                    feed.getLocationInfo(),
                    false,
                    feed.getFeelings(),
                    tagFriendIds
                ).then(function (json) {
                    feed.updateTagUser(json);
                    $scope.$close(feed);

                },function(json){
                    Ringalert.show(json,'error');
                });


                 //$$connector.request(dataToUpdate,OPERATION_TYPES.SYSTEM.REQUEST_TYPE.UPDATE).then(function(json){//success function
                 //       if(json.sucs){
                 //           feed.updateTagUser(json);
                 //           $scope.$close(feed);
                 //       }else{
                 //           Ringalert.show(json,'error');
                 //       }
                 //},function(reason){//error function
                 //   Ringalert.show(reason,'error');
                 //});
        };
        $scope.$on('$destroy', function () {
            //$$connector.unsubscribe(subKey);
        });

    }

})();

/*
 * © Ipvision
 */
//window.WebSocket = null;
//window.onbeforeunload = function (e) {
//	return "Are you sure you want to navigate away from this page";
//};
(function () {
    'use strict';
    var app;
    app = angular
        .module('ringid', [
            //'ngCookies',
            'ngRoute',
            'ringid.config',
            'ringid.language',
            'ngWebSocket',
            'ui-notification',
            'ringid.connector',
            'ringid.filters',
            'ringid.sticker',
            'ringid.common.factories',
            'ringid.common.services',
            'ringid.common.controllers',
            'ringid.common.ringalert',
            'ringid.notification',
            'ringid.ringbox',
            'ringid.auth',
            'ringid.profile',
            'ringid.friend',
            'ringid.feed',
            'ringid.circle',
            'ringid.tagchat',
            'ringid.chat',
            'ringid.common.directives',
            //'ringid.api.dashboard'
        ]);

})();

/*
 * © Ipvision
 */
//window.WebSocket = null;
//window.onbeforeunload = function (e) {
//	return "Are you sure you want to navigate away from this page";
//};
(function () {
    'use strict';
    var app;
    app = angular
        .module('ringid')
        .controller('ApplicationController', ApplicationController);

    ApplicationController.$inject = ['SystemEvents', '$scope', '$rootScope', '$$connector', 'Storage', 'Auth', 'StickerFactory', 'OPERATION_TYPES', '$location','Ringalert', 'utilsFactory','RING_ROUTES','feedFactory'];
    function ApplicationController(SystemEvents, $scope, $rootScope, $$connector, Storage, Auth, StickerFactory, OPERATION_TYPES, $location,Ringalert, utilsFactory,RING_ROUTES,feedFactory) {
        var intkey, OTYPES = OPERATION_TYPES.SYSTEM.AUTH;
        var lastChecked = +Storage.getCookie('la');

        $scope.activePath = null; // for active menu link
        $scope.currentUser = Auth.currentUser();
        $scope.templatePath = Auth.indexTemplate; //'pages/index-login.html';
        $scope.isLoggedIn = false;

                // ##DIGEST_DEBUG_START##
                if(RingLogger.tags.DIGEST){
                    $rootScope.$watch(function(){
                        RingLogger.info("from ROOTSCOPE",RingLogger.tags.DIGEST);
                    });
                }
                // ##DIGEST_DEBUG_END##

        $rootScope.showRightBar = true;
        $$connector.subscribe(function (json) {
            if (json.actn === OTYPES.TYPE_MULTIPLE_SESSION) {
                 RingLogger.print("multiple session warning",json,RingLogger.tags.AUTH);
                 Ringalert.alert({
                    title : 'Signed Out!',
                    message : 'You are signed in from another device',
                    showCancel : false,
                    okCallback : doLogoutTask
                 });
                // doLogoutTask();

            }else{

                 RingLogger.print("invalid session",json,RingLogger.tags.AUTH);

                if (!json.sucs) {

                    if(!$rootScope.doingSilentLogin) {
                         RingLogger.print("Requested for silent Login",RingLogger.tags.AUTH);
                            if(!Auth.isLoggedIn() || json.actn === OTYPES.TYPE_SESSION_VALIDATION ){
                                doLogoutTask(true);
                            }else{
                                checkForValidSession();
                            }
                    }else{
                         RingLogger.print("Not Requested for silent Login",RingLogger.tags.AUTH);
                        //todo what should be here
                    }


                } else {
                     RingLogger.print("Connector resumes on invalid session",RingLogger.tags.AUTH);
                    $$connector.resume();
                    $scope.templatePath = 'pages/index-dashboard.html';
                }
            }
            $scope.$rgDigest();


        }, {
            action: [OTYPES.TYPE_SESSION_VALIDATION, OTYPES.TYPE_INVALID_LOGIN_SESSION, OTYPES.TYPE_MULTIPLE_SESSION]
        });

        function appInit() {
            $scope.isLoggedIn = Auth.isLoggedIn();
            $$connector.init();

            if (!$scope.isLoggedIn) {
                doSilentLogin();
                $scope.templatePath = 'pages/index-loader.html';
            } else {
                $$connector.resume();
                $$connector.keepAlive();
                //if($location.url() === RING_ROUTES.HOME){
                    //feedFactory.initFeedRequest();//for faster load dashboard feed
                //}
                $scope.templatePath = 'pages/index-dashboard.html';
                StickerFactory.initStickerData();
            }
            //$scope.$digest();
        }


        appInit();

        $scope.$on(SystemEvents.AUTH.LOGIN, function (event, data) {

            if(data.silent){
                $rootScope.doingSilentLogin = false;
            }

            $scope.currentUser = Auth.currentUser();
            //$scope.templatePath = 'pages/index-dashboard.html';
            appInit();
            $scope.$rgDigest();


        });

        $scope.$on('CONNECTION_ERROR',function(){
            var reloaded = Storage.getCookie('reloaded');
            if(!reloaded){
                Storage.setCookie('reloaded',1);
                //Auth.reloadHome();
            }else{
                $$connector.reset();
            }
        });

        //var lastDigestCallTime = new Date().getTime();
        //var printDigest = function(){
        //
        //    var cTime = new Date().getTime();
        //    var diff = cTime - lastDigestCallTime;
        //    //if( diff > 1){
        //    lastDigestCallTime = cTime;
        //        RingLogger.print('Digest Called', cTime, ' diff ', diff, RingLogger.tags.DIGEST);
        //    //}
        //
        //    $rootScope.$$postDigest(this);
        //
        //};
        //
        //$rootScope.$$postDigest(printDigest);

        //$rootScope.$watch(function(){
        //
        //});

        function pauseSystemForLogin() {
            $$connector.stop();
            Auth.clearCookies(true);
            $scope.templatePath = 'pages/index-login.html';
        }


        function doLogoutTask(preserveConnection) {
            Auth.logout(true);//forcing to logout
            //$scope.templatePath = Auth.indexTemplate;
             RingLogger.print("Doing logout task",RingLogger.tags.AUTH);
            if( preserveConnection){
                $$connector.stop();
            }else{
                $$connector.reset();
            }
            $scope.$rgDigest();
        }

        function doSilentLogin() {
            /**
             *
             *  Tries for login from local data,
             *    Failed status will redirect to logout page.
             */
            $rootScope.doingSilentLogin = true;
             RingLogger.print("Requesting silent login",RingLogger.tags.AUTH);
            Auth.loginFromLocalData().then(function (success) {
                $rootScope.doingSilentLogin = false;
                RingLogger.print("Requesting silent login response",success,RingLogger.tags.AUTH);
                if (!success) {
                    pauseSystemForLogin();
                }else{
                    // todo check what should do here
                }
                $scope.$rgDigest();
            }, function (err) {
                $rootScope.doingSilentLogin = false;
                pauseSystemForLogin();
                $scope.$rgDigest();
            });
            $scope.$rgDigest();
        }


        function checkForValidSession(){
            var validSessionTimeout;
            var now = Date.now(),miniuteDiff,msec;

            msec = now - lastChecked;
            miniuteDiff = Math.floor(msec/1000/60);

            //if(miniuteDiff > 5){
               $$connector.stop();
               validSessionTimeout = setTimeout(function() {
                    doLogoutTask();
                    $scope.$rgDigest();
               }, 2000);

                Auth.isValidSession().then(function(valid){
                    clearTimeout(validSessionTimeout);
                    lastChecked = now;
                    Storage.setCookie('la',lastChecked);
                    //if(!valid){
                    RingLogger.alert(valid, RingLogger.tags.AUTH);
                    if(Storage.getCookie('sId') === valid.sId) {
                        doLogoutTask();
                    }else{
                        $$connector.resume();
                        $scope.templatePath = 'pages/index-dashboard.html';
                    }
                    $scope.$rgDigest();
               },function(invalid){
                    clearTimeout(validSessionTimeout);
                    doLogoutTask();
                    $scope.$rgDigest();
                });
                $scope.$rgDigest();
           // }
        }

        $scope.$on('$destroy', function (e) {
            if (intkey)$$connector.removeInterval(intkey);
        });
                // ##DIGEST_DEBUG_START##
                if(RingLogger.tags.DIGEST){
                    $scope.$watch(function(){
                         RingLogger.info("from AppController",RingLogger.tags.DIGEST);
                    });
                }
                // ##DIGEST_DEBUG_END##
        /**
         * for api testing purpose
         * @param data to send as string or object
         */

        $scope.send = function(data,request_type){
            request_type = request_type || OPERATION_TYPES.SYSTEM.REQUEST_TYPE.REQUEST;
            if(angular.isString(data)){
                data = angular.fromJson(data);
            }
            $$connector.send(data,request_type);
        };
        /**
         * @params : path : target path to change, force : if location is already the current location the a force reload
         */


    }


})();

/*
 * © Ipvision
 */
//window.WebSocket = null;
//window.onbeforeunload = function (e) {
//	return "Are you sure you want to navigate away from this page";
//};
(function () {
    'use strict';
    var app;
    app = angular
        .module('ringid')
        .run(['$rootScope', '$window', '$document','$$connector', 'settings','$ringhttp', function ($rootScope, $window, $document,$$connector, settings,$ringhttp) {
            //$http.defaults.headers.common['x-app-version']= settings.apiVersion;
           // $$connector.init();
            var windowElement = angular.element($window),
                vendorPrefix, prevEvent;
                $$connector.init();
                function activeTab(event){
                    if (prevEvent !== 'inactive') {
                        $rootScope.$broadcast('ringInactive', event);
                    }
                    prevEvent = 'inactive';
                }
            function inactiveTab(event) {
                if (prevEvent !== 'active') {
                    $rootScope.$broadcast('ringActive', event);
                }
                prevEvent = 'active';
            }
            windowElement.on('inactive',activeTab);

            windowElement.on('active', inactiveTab);
            //console.log(languageLoader.get('default'));
            //$rootScope.__ = function (key,lang){
            //    return languageLoader.get(key);
            //};


            function windowVisibilityChangeHandler(event) {
                if (this[vendorPrefix ? vendorPrefix + 'Hidden' : 'hidden'] && prevEvent !== 'inactive') {
                    $rootScope.$broadcast('ringInactive', event);
                    prevEvent = 'inactive';
                } else if (prevEvent !== 'active') {
                    $rootScope.$broadcast('ringActive', event);
                    prevEvent = 'active';
                }

            }

            if ('hidden' in $document) {
                vendorPrefix = '';
            } else {
                angular.forEach(['moz', 'webkit', 'ms'], function (prefix) {
                    if ((prefix + 'Hidden') in $document[0]) {
                        vendorPrefix = prefix;
                    }
                });
            }
            if (angular.isDefined(vendorPrefix) && vendorPrefix !== '') {
                $document[0].addEventListener(vendorPrefix + 'visibilitychange', windowVisibilityChangeHandler);
            }


            // NEED TO ENABLE LATER WHEN SERVER RESPONSE IS CORRECT
            //$ringhttp.get(settings.constantServer).success(function(json){
                //var ob = angular.fromJson(json);
                    //settings.updateUrlBase(ob);
                    //ob = null;
            //});


            // SOCIAL LOGIN SIGNUP
            //$window.fbAsyncInit = function() {
              //FB.init({
                //appId      : settings.fbAppId,
                //cookie     : true,  // enable cookies to allow the server to access
                                    //// the session
                //xfbml      : true,  // parse social plugins on this page
                //version    : 'v2.2' // use version 2.2
              //});
            //};


            //// Load the SDK asynchronously
            //(function(d, s, id) {
                //var js, fjs = d.getElementsByTagName(s)[0];
                //if (d.getElementById(id)) { return;}
                //js = d.createElement(s); js.id = id;
                //js.src = "//connect.facebook.net/en_US/sdk.js";
                //fjs.parentNode.insertBefore(js, fjs);
            //}(document, 'script', 'facebook-jssdk'));

        }]);

})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid')
        .config(['$compileProvider','$routeProvider', '$locationProvider','$httpProvider' , 'RING_ROUTES',
                function ($compileProvider, $routeProvider, $locationProvider,$httpProvider, RING_ROUTES){

                $compileProvider.debugInfoEnabled(true);
                $httpProvider.useApplyAsync(true);
                $routeProvider.
                        when(RING_ROUTES.HOME, {
                            templateUrl: 'pages/index.html'
                        }).when(RING_ROUTES.LOGIN_SOCIAL, {
                            templateUrl: 'pages/index.html'
                            //resolve: {
                                //'urlfix': ['$location', function($location) {
                                    //RingLogger.informaiton('loginUrl: ' + $location.url(), RingLogger.tags.AUTH);
                                //}]
                            //}
                        }).when(RING_ROUTES.SIGNUP_SOCIAL, {
                            templateUrl: 'pages/index.html'
                        }).when(RING_ROUTES.USER_PROFILE, {
                            templateUrl: 'pages/profile/profile.html',
                            resolve: {
                                user: ['profileFactory', '$route', '$location', '$q', 'Ringalert', function(profileFactory, $route, $location, $q, Ringalert) {
                                    var deferred = $q.defer();
                                    profileFactory.getUserDetailsByUId($route.current.params.uId).then(function(user){
                                        deferred.resolve(user);
                                    }, function() {
                                        Ringalert.show('User not found', 'error');
                                        // if going to profile redirect to home
                                        if ($location.path().indexOf('profile') > -1) {
                                            $location.path('/');
                                        }
                                        deferred.reject();
                                    });

                                    return deferred.promise;
                                }]
                            }
                        }).when(RING_ROUTES.CIRCLE_HOME, {
                            templateUrl: 'pages/home/circle.html'
                        }).when(RING_ROUTES.SINGLE_FEED, {
                            templateUrl: 'pages/index-singlefeed.html'
                        }).when(RING_ROUTES.WHO_SHARED_FEED, {
                            templateUrl: 'pages/index-who-sharedfeed.html'
                        }).when('/media', {// for media page test pupose
                            templateUrl: 'pages/media-list.html'
                        }).when('/media/:albumtype',{
                            templateUrl:'pages/mediasearch/albums.all.html',
                            controller:'allAlbumTypeController'
                        }).when('/media/:stype/:sk?', {// for media page test pupose
                            templateUrl: 'pages/mediasearch/search.result.html',
                            controller:'mSearchResultController'
                        }).when('/media/:albumtype/:utid/:albumid',{
                            templateUrl:'pages/mediasearch/albums.all.html',
                            controller:'allAlbumTypeController'
                        }).when('/chat',{
                            templateUrl: 'pages/partials/chat/single-page/home.html',
                            controller : 'ChatHistoryController'
                        })
                        // .when(RING_ROUTES.SINGLE_IMAGE, {
                        //     templateUrl: 'pages/index-singleimage.html'

                        // })
                        .when(RING_ROUTES.FAQ, {
                            redirectTo: function(params, currentPath, currentSearch) {
                                window.location.href = location.protocol + '//' + location.host + '/faq.xhtml';
                            }
                        }).when(RING_ROUTES.API_DASHBOARD, {
                            templateUrl: 'app/apidashboard/templates/api.index.html'
                        }).otherwise({
                            redirectTo: '/'
                        });


                //check browser support
                //if(window.history && window.history.pushState){
                    //$locationProvider.html5Mode(true); //will cause an error $location in HTML5 mode requires a  tag to be present! Unless you set baseUrl tag after head tag like so: <head> <base href="/">

                    // to know more about setting base URL visit: https://docs.angularjs.org/error/$location/nobase

                    // if you don't wish to set base URL then use this
                    //$locationProvider.html5Mode({
                    //    enabled: true,
                    //    requireBase: false
                    //});
                //}

            }])
        .run(['$rootScope', '$location', 'Auth', 'rgDropdownService', 'rgSearchService', '$ringbox', 'RING_ROUTES', 'Storage', '$browser',
             function($rootScope, $location, Auth, rgDropdownService, rgSearchService, $ringbox, RING_ROUTES, Storage, $browser) {
                $rootScope.$on('$routeChangeStart', function(event, next, current) {
                    // if not logged in go to login page
                    if(!Auth.isLoggedIn() && !$rootScope.doingSilentLogin &&  $location.url() !==  '/' )  {
                        $location.path('/');
                        // check if social login signup in progress
                        //var socialData = Storage.getData('social');
                        //if (socialData.hasOwnProperty('timestamp') && ( socialData.timestamp + 180000) > new Date().getTime() ) {
                            //// redirect to sogin login or signup path
                            //var token = $location.url().match('access_token') ? $location.url().replace('/access_token=', '') : '';
                            //if (token.length > 10) {
                                //Storage.setData('social', {'operation': socialData.operation, 'platform': socialData.platform, 'token': token, 'timestamp': new Date().getTime()});
                                ////RingLogger.information('redirect to : ' + '/#/social/' + socialData.operation + '/' + socialData.platform + '/' + token, RingLogger.tags.AUTH);
                                ////$location.path('/social/' + socialData.operation + '/' + socialData.platform + '/' + token );
                                ////window.location = window.location.origin + '/#social/' + socialData.operation + '/' + socialData.platform + '/' + token;
                                ////$location.path('/');
                                ////window.location = window.location.origin;
                            //}
                        //} else {
                        //}

                    } else {
                        $ringbox.closeAll();
                        // close any dropdown if any is open
                        rgDropdownService.close();
                        // close search dropdown if open
                        rgSearchService.close();
                    }

                   revertScopes(true);

                });


                 requestAnimationFrame(function(){
                    var loader = document.querySelector('#global-loader');
                    loader.style.display = 'none';
                    loader = null;
                 });


                /* $rgGigest start*/


                var $rgQueue =[];
                var $root = Object.getPrototypeOf($rootScope);
                var childHead = [];
                $rootScope.$ignoreScopes = [];
                $root.$coreDigest = $root.$digest;

                function revertScopes(reset) {

                    for(var i=0;i<$rootScope.$ignoreScopes.length;i++) {

                        if(childHead[$rootScope.$ignoreScopes[i].$id]) {
                            $rootScope.$ignoreScopes[i].$$childHead = childHead[$rootScope.$ignoreScopes[i].$id];
                         }
                    }

                    childHead = [];

                    if(reset) {
                      $rootScope.$ignoreScopes = [];
                    }
                }

                function notifyScopes() {
                    revertScopes();
                    for(var i=0;i<$rootScope.$ignoreScopes.length;i++) {

                          if($rootScope.$ignoreScopes[i]) {
                              $rootScope.$ignoreScopes[i].$broadcast('$destroy');
                              //$rootScope.$ignoreScopes[i].$destroy();
                          }
                    }
                }


                $root.$rgDigest = function() {


                    if (!$rootScope.$$phase) {

                        if(this.$id==1 && $rootScope.$ignoreScopes.length > 0) {

                           for(var i=0;i<$rootScope.$ignoreScopes.length;i++) {
                              childHead[$rootScope.$ignoreScopes[i].$id] = $rootScope.$ignoreScopes[i].$$childHead;
                              $rootScope.$ignoreScopes[i].$$childHead = null;
                           }

                          $rootScope.$$postDigest(function() {
                               revertScopes();
                           });
                        }

                        this.$coreDigest();
              	    }
                    else {

                    	if($rgQueue.indexOf(this) ==-1 && this.$id != 1) {
                   		  	  $rgQueue.push(this);
                   		  	  $rgQueue.sort(function(a, b) { return    a.$id - b.$id });

                   	      	var queue = [], target, current, parent;

                   		  	  while($rgQueue.length > 1) {

                   		          target = $rgQueue.pop();
                   			        for(var i=$rgQueue.length-1; i >= 0; i--) {
                       		   		    current = $rgQueue[i];
                       		   		    parent = target.$parent;
                       		    	    while( parent != current && parent != null) {
                       		       	    parent = parent.$parent;
                       			 	      }
                   			 	        if(parent != null)  break;
                   			        }
                   		         if(parent == null) queue.push(target);
                   		      }

                   		      while(target = queue.pop()) {
                   		         $rgQueue.push(target);
                   		      }
                      }

                   	  $rootScope.$$postDigest(function(){
                     	    if($rgQueue.length > 0) $rgQueue.pop().$rgDigest();
                      });
                    }
              };
           /* end of $rgGigest */

           $root.$digest = function() {
               this.$rgDigest();
           };

           $root.addIgnore = function() {
              if($rootScope.$ignoreScopes.indexOf(this) == -1) {
                 $rootScope.$ignoreScopes.push(this);
              }
           }

           $root.removeIgnore = function() {
              var index;
              if ((index = $rootScope.$ignoreScopes.indexOf(this)) > -1) {
                 $rootScope.$ignoreScopes.splice(index, 1);
              }
           }

           /*Utility function that returns total watchers*/
           $root.calc = function() {

          		var total = 0, total_scope=0, target, current, next, t0 = window.performance.now();
           		target = this;
           		current = target;

                do {
             		total += (current.$$watchers)?current.$$watchers.length:0;
             		total_scope++;

             		if (!(next = (current.$$childHead ||
                		(current !== target && current.$$nextSibling)))) {
              			while (current !== target && !(next = current.$$nextSibling)) {
                		 current = current.$parent;
              		    }
            		}
          		 } while ((current = next));

          		RingLogger.information('Total watchers: '+total + ' & total scopes:'+total_scope+' & traverse Time:'+(window.performance.now()-t0)+'ms', RingLogger.tags.DIGEST);
           };

       }
    ]);

})();
