<<<<<<< HEAD
=======
var RingWorker;
var RingMessageChannel;
try{
    RingMessageChannel = new MessageChannel();
}catch(e){ 
    RingMessageChannel = new BroadcastChannel('ring_channel') 
}

    'use strict';
    function generateTabId(){
      var currentTopId = Cookies.get('top'),current;
               if(!!currentTopId){
                    current = parseInt(currentTopId) + 1;
                    if(current > 255){ // tab id on backend is one byte
                        current = 1;
                    }
               } else {
                    current = 1;
               }
            Cookies.set('top',current);
            return current
    }
    window._cti = generateTabId();//current tab id
    try{
      if (!window.location.origin) { // ie 10 doesnot support location.origin so its watfall
        window.location.origin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
      }
      RingWorker = new Worker(window.location.origin+'/js/worker/com');
    }catch(e){
        console.warn("Your Browser Is Out Dated. Please Update Your Browser To Use RingId");
        RingWorker = {
          addCallback : angular.noop,
          addEventListener : angular.noop,
          postMessage : angular.noop
        };

    }

    RingWorker.FNS = {};
    RingWorker.addCallback = function(notifier,fn,fnContext){
      if(!this.FNS[notifier]){
        this.FNS[notifier] = [];
      }
      fnContext = fnContext || null;
      this.FNS[notifier].push({ctx:fnContext,fn : fn})
    }
    RingWorker.send = function(data,packId,port,flooding){
        if(port && data){
            this.postMessage({
              command : 'SEND',
              packetId : packId,
              data : data,
              flooding:flooding,
              port : port,
              action : data.actn
             });
        }else{
          throw new Error("You must sent data and port");
        }

    };
    RingWorker.addEventListener('message',function(message){
        var fnss,i;
      if(message.data.notifier && this.FNS[message.data.notifier]){
        for(i=0;i<this.FNS[message.data.notifier].length;i++){
            fnss = this.FNS[message.data.notifier][i];
            fnss.fn.call(fnss.ctx,message.data);
        }
      }else{
      }
    });

    RingWorker.addCallback("debug",function(message){
          //for(var key in message.m){
         // }

    },RingWorker);

    RingWorker.addEventListener('error',function(e){
    });

    RingWorker.pushMessage = function(ob, port){
      try{
            if(!!port){
                this.postMessage(ob, port);
            }else{
                this.postMessage(ob);
            }
       }catch(e){
       }     
    };
    
    RingWorker.pushMessage({
         command : 'SETTINGS',
         url : 'wss://'+ window.location.host +'/DataSocket/' + window._cti,
         tabId : window._cti,
         aSkey : Cookies.get('sId'),//auth server sId
         sKey : Cookies.get('sessionID'),//session id webserver
         CLIENT_DATA_SIZE : 460
    }, [RingMessageChannel.port1]);




(function(window,DataView){
    'use strict';
// ie8 wat
//    /**
//      window.emojiSupported
//      window.eventFix
//      window.scrollToYOffset
//      Function.prototype.bind
//
//      ##string features
//      String.prototype.format
//      String.prototype.supplant
//      String.prototype.repeat
//      String.prototype.trim
//      String.prototype.utf8Encode
//      String.prototype.toCharCodeArray
//
//      ##array feature added##
//      Array.prototype.indexOf
//      Array.prototype.contains
//      Array.prototype.filter
//      Array.prototype.difference
//      Array.prototype.joinAsDataView
//
//      ## dataview feature added
//      DataView.prototype.copy
//      DataView.prototype.merge
//      DataView.prototype.addAttributeInt
//      DataView.prototype.addAttributeString
//      DataView.prototype.addAttributeData
//      DataView.prototype.print_r
//      DataView.prototype.getString
//      DataView.prototype.getIntByByte
//      DataView.prototype.setUint64
//      DataView.prototype.getBool
//      DataView.prototype.getUint24
//    */

    window.emojiSupported = (function() {
  	  var node = document.createElement('canvas');
  	  if (!node.getContext || !node.getContext('2d') || typeof node.getContext('2d').fillText !== 'function') return false;
  	  var ctx = node.getContext('2d');
  	  ctx.textBaseline = 'top';
  	  ctx.font = '32px Arial';
  	  ctx.fillText('\ud83d\ude03', 0, 0);
  	  return ctx.getImageData(16, 16, 1, 1).data[0] !== 0;
	})();

    window.eventFix = function(e){

        e = e || window.event;

        var pageX = e.pageX;
        var pageY = e.pageY;
        if (pageX === undefined) {
            pageX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
            pageY = e.clientY + document.body.scrollTop + document.documentElerment.scrollTop;
        }
    }

    window.scrollToYOffset = function(targetYOffset, scrollDuration) {
        console.log(targetYOffset);
        var scrollStep = targetYOffset / (scrollDuration / 15),
        scrollInterval = setInterval(function(){
            console.log(window.scrollY," tar",targetYOffset);
            if ( window.scrollY < targetYOffset ) {
                window.scrollBy( 0, scrollStep );
            }else clearInterval(scrollInterval);
        }, 15);
    };

    if (!Function.prototype.bind) {
      Function.prototype.bind = function(oThis) {
        if (typeof this !== 'function') {
          // closest thing possible to the ECMAScript 5
          // internal IsCallable function
          throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
        }

        var aArgs   = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP    = function() {},
            fBound  = function() {
              return fToBind.apply(this instanceof fNOP
                     ? this
                     : oThis,
                     aArgs.concat(Array.prototype.slice.call(arguments)));
            };

        if (this.prototype) {
          // native functions don't have a prototype
          fNOP.prototype = this.prototype;
        }
        fBound.prototype = new fNOP();

        return fBound;
      };
    }

   if (!String.prototype.format) {
        String.prototype.format = function() {
          var args = Object.prototype.toString.call(arguments[0] ) === '[object Array]' ?arguments[0]:arguments;
          return this.replace(/{(\d+)}/g, function(match, number) {
            return typeof args[number] != 'undefined'
              ? args[number]
              : match
            ;
          });
        };
      }

    if (!String.prototype.supplant) {
        String.prototype.supplant = function (o) {
            return this.replace(
                /\{([^{}]*)\}/g,
                function (a, b) {
                    var r = o[b];
                    return typeof r === 'string' || typeof r === 'number' ? r : a;
                }
            );
        };
    }

    if (!String.prototype.repeat) {
        String.prototype.repeat = function(count) {
           return Array(count+1).join(this);

        };
    }
    if (!String.prototype.trim) {
          String.prototype.trim = function () {
            return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
          };
     }

    String.prototype.utf8Encode = function(){
       return unescape(encodeURIComponent(this));
    };

    String.prototype.toCharCodeArray = function(){
        var codes = [];
        for (var i = 0; i < this.length;i++) {
            codes.push(this.charCodeAt(i));
        }
        return codes;
    };

    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function(elt /*, from*/) {
            var len = this.length >>> 0;
            var from = Number(arguments[1]) || 0;
            from = (from < 0) ? Math.ceil(from) : Math.floor(from);
            if (from < 0) {
                from += len;
            }

            for (; from < len; from++) {
                if (from in this && this[from] === elt) { return from; }
            }
            return -1;
        };
    }
    if (!Array.prototype.contains) {
        Array.prototype.contains = function(val,fn) { // fn is the function for equality match function if provided else it will macth whole object
            if(!fn)return this.indexOf(val);
            var len = this.length >>> 0;
            var from = Number(arguments[1]) || 0;
            from = (from < 0) ? Math.ceil(from) : Math.floor(from);
            if (from < 0) {
                from += len;
            }

            for (; from < len; from++) {
                if (from in this && fn.call(this,this[from],val)){ return from; }
            }
            return -1;

        };
    }
    if (!Array.prototype.filter) {
          Array.prototype.filter = function(fun/*, thisArg*/) {
            'use strict';

            if (this === void 0 || this === null) {
              throw new TypeError();
            }

            var t = Object(this);
            var len = t.length >>> 0;
            if (typeof fun !== 'function') {
              throw new TypeError();
            }

            var res = [];
            var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
            for (var i = 0; i < len; i++) {
              if (i in t) {
                var val = t[i];

                // NOTE: Technically this should Object.defineProperty at
                //       the next index, as push can be affected by
                //       properties on Object.prototype and Array.prototype.
                //       But that method's new, and collisions should be
                //       rare, so use the more-compatible alternative.
                if (fun.call(thisArg, val, i, t)) {
                  res.push(val);
                }
              }
            }

            return res;
          };
    }

    if(!Array.prototype.keyValues){
        Array.prototype.keyValues = function(key){
            var index, values = [];
            for( index = 0; index < this.length; index++){
                if(!!this[index][key]){
                    values.push(this[index][key]);
                }

            }
            return values;
        };
    }

    if(!Array.prototype.values){
        Array.prototype.values = function(){
            var index, values = [];
            for( index = 0; index < this.length; index++){
                values.push(this[index]);
            }
            return values;
        };
    }


    //{utids : ""} considers all array element is instance of DataView and returns a DataView Object of all element after merge
    Array.prototype.joinAsDataView = function(){
            var self = this,currentIndex=0,dataViewLength= 0,buffer,view;
            if(!self.length)return new DataView(new ArrayBuffer(0)); // if no elements then just returns a DataView
            for(var i=0;i<self.length;i++){
                if(self[i] instanceof DataView){
                    dataViewLength += self[i].byteLength;
                }
            }
            if(!dataViewLength)return new DataView(new ArrayBuffer(0));
              buffer = new ArrayBuffer(dataViewLength);
              view = new DataView(buffer);
            for(var i=0;i<self.length;i++){
                if(self[i] instanceof DataView){
                    for(var j=0;j<self[i].byteLength;j++){
                        view.setUint8(currentIndex++,self[i].getUint8(j));
                    }
                }
            }
        return view;

    };

    Array.prototype.difference = function(elementsToRemove){
        if( !elementsToRemove || !elementsToRemove.length || !this.length){
            return this;
        }

        var mapElementsToRemove = {},
            outputArray = [],
            index = 0;


        /* Cache elementsToRemove Array */
        while( index < elementsToRemove.length ){

            mapElementsToRemove[elementsToRemove[index]] = true;
            index++;
        }

        for(index=0; index < this.length; index++ ){
            if( !mapElementsToRemove[ this[index] ] ){
                outputArray.push( this[index] )
            }
        }
        return outputArray;

    };

    DataView.prototype.copy = function(offset,length){
       //var self = this;
       //offset = offset || 0;
       //length = length || self.byteLength;
       //// var diff = length-offset;
       //var buffer = new ArrayBuffer(length);
       //var view = new DataView(buffer);
       //for(var i=0;i<length;i++){
       //     view.setUint8(i,self.getUint8(offset++));
       //}
       // return view
        return new DataView(this.buffer,offset,length);
    };
    DataView.prototype.merge = function(from,fromLength,toview,to,toLength){
        var self = this, i,j;
          var mergea = new DataView(this.buffer,from,fromLength),
            buf = new ArrayBuffer(mergea.byteLength+(toLength-to+1)),
            view = new DataView(buf);
        for(i=0;i<mergea.byteLength;i++){
            view.setUint8(i,mergea.getUint8(i));
        }
       // console.info("from : "+from +" fl : "+fromLength + " to :"+to + " length : "+toLength +" current : "+i +" to range" +torange);
        for(j=i;j<view.byteLength;j++){
            view.setUint8(j,toview.getUint8(to++));
        }
        return view;


    };
    DataView.prototype.addAttributeInt = function(i,code,len,value){
       // console.info("index : "+ i + " attr : " + code +"\n");
        this.setUint8(i++,code);
       // console.info("index : "+ i + " len : " + len +"\n");
        this.setUint8(i++,len);
        //console.info("index : "+ i + " "+len+"val : " + value +"\n");
        switch(len){
            case 1:
                this.setUint8(i++,value);
                break;
            case 2:
                this.setUint16(i,value);
                i +=2;
                break;
            case 4:
                this.setUint32(i,value);
                i+=4;
                break;
        }
        return i;

    };
    DataView.prototype.addAttributeString = function(i,code,value){
       // console.info("index : "+ i + " attr : " + code +"\n");
        this.setUint8(i++,code);
       // console.info("index : "+ i + " "+value.length+" strval : " + value +"\n");
        this.setUint8(i++,value.length);
        for (var j = 0; j< value.length;j++) {
            this.setUint8(i++,value.charCodeAt(j));
        }
      return i;
    };
    DataView.prototype.addAttributeData = function(i,code,view,fromIndex,length){
        fromIndex = fromIndex || 0;
        length = length || view.byteLength;
        this.setUint8(i++,code);
        this.setUint16(i,length);
        i+=2;
        for(var j=0;j<length;j++){
            this.setUint8(i++,view.getUint8(fromIndex++));
        }
        return i;
    };
    DataView.prototype.print_r = function(debug,starting,length){
        starting = starting || 0;
        length = length || this.byteLength;

        var str = "Index\t\tBinary\t\tInteger\t\tChar\n";
        var full="", c,inte;
        for(var i=starting;i<length;i++){
         inte = this.getUint8(i);
            c = String.fromCharCode(inte);

          str += i + "\t\t \t\t" + inte.toString(2) + "\t\t\t\t"+ inte + "\t\t\t\t"+c+"\n";
            full +=c;
        }
        if(!!debug && typeof debug !== 'string'){
            console.log(str);
            console.log("\n length : "+str.length);
        }else{
            return full;
        }

        console.log(full);

    };

    DataView.prototype.printBytes = function(){
        var bytes = [];
        for(var i=0;i<this.byteLength;i++){
            bytes.push(this.getUint8(i));
        }
        bytes.push(-1000);
        console.log(bytes.join('\n'));

    };

    DataView.prototype.getString = function(offset,length){
        var self = this,bitArray = [], firstByte, highSurrogate, lowSurrogate, codePoint;
        length = length || self.byteLength;

         /* utf8 format ref: http://www.fileformat.info/info/unicode/utf8.htm */

         while( length > 0  ) {
            firstByte = self.getUint8(offset);
            if(self.getUint8(offset) <= 127) {
              bitArray.push(self.getUint8(offset++));
              length--;
            }
            else if(self.getUint8(offset) >= 128 && self.getUint8(offset) <= 223) {

              bitArray.push(((self.getUint8(offset++) & 0x1F) << 6) | (self.getUint8(offset++) & 0x3F));
              length -=2;
            }
            else if(self.getUint8(offset) >= 224 && self.getUint8(offset) <= 239) {
              bitArray.push(((self.getUint8(offset++) & 0x1F) << 12) | ((self.getUint8(offset++) & 0x3F) << 6 | (self.getUint8(offset++) & 0x3F)));
              length -=3;
            }
            else {
               /* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint */
               codePoint = ((self.getUint8(offset++) & 0x07) << 18) | (((self.getUint8(offset++) & 0x3F) << 12) | ((self.getUint8(offset++) & 0x3F) << 6 | (self.getUint8(offset++) & 0x3F)));
               codePoint -= 0x10000;
               highSurrogate = (codePoint >> 10) + 0xD800;
               lowSurrogate = (codePoint % 0x400) + 0xDC00;
               bitArray.push(highSurrogate, lowSurrogate);
               length -=4;
            }
        }

        //var func =  new Function("function(){ return String.fromCharCode("+bitArray.join(",")+");}");
        return String.fromCharCode.apply(null,bitArray);
        //return bitArray.length ? :'';
    };


	DataView.prototype.getStringUtf16 = function(length, offset, bom) {
		offset = offset | 0;
		length = length || (this.byteLength - offset);
		var littleEndian = false,
			str = '',
			useBuffer = false;

		if (typeof Buffer !== 'undefined') {
			str = [];
			useBuffer = true;
		}
		if (length < 0) {
			length += this.byteLength;
		}
		if (bom) {
			var bomInt = this.getUint16(offset);
			if (bomInt === 0xFFFE) {
				littleEndian = true;
			}
			offset += 2;
			length -= 2;
		}

		for(var i = offset; i < (offset + length); i += 2) {
			var ch = this.getUint16(i, littleEndian);
			if((ch >= 0 && ch <= 0xD7FF) || (ch >= 0xE000 && ch <= 0xFFFF)) {
				if (useBuffer) {
					str.push(ch);
				} else {
					str += String.fromCharCode(ch);
				}
			} else if(ch >= 0x10000 && ch <= 0x10FFFF) {
				ch -= 0x10000;
				if (useBuffer) {
					str.push(((0xFFC00 & ch) >> 10) + 0xD800);
					str.push((0x3FF & ch) + 0xDC00);
				} else {
					str += String.fromCharCode(((0xFFC00 & ch) >> 10) + 0xD800) + String.fromCharCode((0x3FF & ch) + 0xDC00);
				}
			}
		}
		if (useBuffer) {
			return str.toString();
		} else {
			return decodeURIComponent(escape(str));
		}
	}


    DataView.prototype.getIntByByte = function(offset,length){
        var self = this;
        switch (length){
            case 1:
                return self.getUint8(offset);
            case 2:
                return self.getUint16(offset);
            case 4:
                return self.getUint32(offset);
            case 6:
            case 8://javascript doesn't support 64-bit integer so we assuming first two byte in our system is not used. so we cropping it
                var str="", i,tempInt;
                for(i=offset;i<offset+length;i++){
                    tempInt = self.getUint8(i).toString(2);
                    str += tempInt.length < 8 ? "0".repeat(8-tempInt.length)+tempInt:tempInt;
                }
                return parseInt(str,2);
           default : return self.getUint8(offset);
        }
    };

    DataView.prototype.getSynch = function(num) {
        var out = 0,
        mask = 0x7f000000;
        while(mask) {
            out >>= 1;
            out |= num & mask;
            mask >>= 8;
        }
        return out;
    }

    //function isInt(value) {
    //    return !isNaN(value) && (function(x) { return (x | 0) === x; })(parseFloat(value))
    //}
    //if(!Number.prototype.isInteger){
    //    Number.prototype.isInteger = function(){
    //        return !isNaN(value);
    //    };
    //};

    Number.isInteger = Number.isInteger || function(value) {
        return typeof value === "number" &&
            isFinite(value) &&
            Math.floor(value) === value;
    };
    /*ArrayBuffer.slice method polyfill for IE-10:starts: rabbi*/
    if (!ArrayBuffer.prototype.slice) {
        //Returns a new ArrayBuffer whose contents are a copy of this ArrayBuffer's
        //bytes from `begin`, inclusive, up to `end`, exclusive
        ArrayBuffer.prototype.slice = function (begin, end) {
            //If `begin` is unspecified, Chrome assumes 0, so we do the same
            if (begin === void 0) {
                begin = 0;
            }

            //If `end` is unspecified, the new ArrayBuffer contains all
            //bytes from `begin` to the end of this ArrayBuffer.
            if (end === void 0) {
                end = this.byteLength;
            }

            //Chrome converts the values to integers via flooring
            begin = Math.floor(begin);
            end = Math.floor(end);

            //If either `begin` or `end` is negative, it refers to an
            //index from the end of the array, as opposed to from the beginning.
            if (begin < 0) {
                begin += this.byteLength;
            }
            if (end < 0) {
                end += this.byteLength;
            }

            //The range specified by the `begin` and `end` values is clamped to the
            //valid index range for the current array.
            begin = Math.min(Math.max(0, begin), this.byteLength);
            end = Math.min(Math.max(0, end), this.byteLength);

            //If the computed length of the new ArrayBuffer would be negative, it
            //is clamped to zero.
            if (end - begin <= 0) {
                return new ArrayBuffer(0);
            }

            var result = new ArrayBuffer(end - begin);
            var resultBytes = new Uint8Array(result);
            var sourceBytes = new Uint8Array(this, begin, end - begin);

            resultBytes.set(sourceBytes);

            return result;
        };
    }
    /*ArrayBuffer.slice method polyfill for IE-10:ends: rabbi*/
    DataView.prototype.setUint64 = function(offset, value){
        var self = this;
        var binary = Number.isInteger(value) ? value.toString(2) : parseInt(value).toString(2);
        binary = binary.length < 64 ? "0".repeat(64-binary.length) + binary : binary;
        var binaryArray = binary.match(/.{1,32}/g);
        var intArray = binaryArray.map(function(binaryByte){
            return parseInt(binaryByte, 2);
        });
        // sorting won't be needed
        //intArray.sort(function(a, b) {
        // return a - b;
        //});//sorting in ascending order as we'll put byte in bigendian
        for(var i = 0; i< intArray.length; i++){
            self.setUint32(offset+i*4, intArray[i]);
        }
    };

    DataView.prototype.getBool = function(offset){ // length is always one byte
        return this.getUint8(offset) === 1;
    };
    /**
     * @description : ie can't sent dataview directly to socket. its sends Dataview.toString so its a pitfall for ie
     *    to send Uint8Array. note : ie can sent Uint8Array via socket
     */
    // DataView.prototype.toString = function(){
    //    return new Uint8Array(this.buffer).toString();
    // }

    
    /*Utilities DOM functions*/
    //matches polyfill
	window.Element && function(ElementPrototype) {
    	ElementPrototype.matches = ElementPrototype.matches ||
    	ElementPrototype.matchesSelector ||
   		ElementPrototype.webkitMatchesSelector ||
    	ElementPrototype.msMatchesSelector ||
    	function(selector) {
        	var node = this, nodes = (node.parentNode || node.document).querySelectorAll(selector), i = -1;
        	while (nodes[++i] && nodes[i] != node);
        	return !!nodes[i];
    	}
	}(window.Element.prototype);

	// closest polyfill
	window.Element && function(ElementPrototype) {
    	ElementPrototype.closest = ElementPrototype.closest ||
    	function(selector) {
        	var el = this;
        	while (el.matches && !el.matches(selector)) el = el.parentNode;
        	return el.matches ? el : null;
    	}
	}(window.Element.prototype);
  
    window.requestAnimationFrame = window.requestAnimationFrame || 
                                    window.mozRequestAnimationFrame || 
                                    window.webkitRequestAnimationFrame ||
                                    window.msRequestAnimationFrame;


    DataView.prototype.getUint24 = function(offset, littleEndian) {
		if(littleEndian) {
			return this.getUint8(offset) + (this.getUint8(offset + 1) << 8) + (this.getUint8(offset + 2) << 16);
		}
		return this.getUint8(offset + 2) + (this.getUint8(offset + 1) << 8) + (this.getUint8(offset) << 16);
    };

    Math.easeIn = function (t, b, c, d) {

        t /= d/2;
        if (t < 1) {
            return c/2*t*t + b
        }
        t--;
        return -c/2 * (t*(t-2) - 1) + b;
    };                                

    window.decodeEntities = (function() {
        // this prevents any overhead from creating the object each time
        var element = document.createElement('div');

        function decodeHTMLEntities (str) {
          if(str && typeof str === 'string') {
            // strip script/html tags
            str = str.replace(/<script[^>]*>([\S\s]*?)<\/script>/gmi, '');
            str = str.replace(/<\/?\w(?:[^"'>]|"[^"]*"|'[^']*')*>/gmi, '');
            element.innerHTML = str;
            str = element.textContent;
            element.textContent = '';
          }

          return str;
        }

        return decodeHTMLEntities;
      })();


      if (typeof Object.assign != 'function') {
        (function () {
            Object.assign = function (target) {
                'use strict';
                if (target === undefined || target === null) {
                    throw new TypeError('Cannot convert undefined or null to object');
                }

                var output = Object(target);
                for (var index = 1; index < arguments.length; index++) {
                    var source = arguments[index];
                    if (source !== undefined && source !== null) {
                        for (var nextKey in source) {
                            if (source.hasOwnProperty(nextKey)) {
                                output[nextKey] = source[nextKey];
                            }
                        }
                    }
                }
                return output;
            };
        })();
    }



})(window,DataView);

// date custom format extending

/*
 * © Ipvision
 */



(function() {
	'use strict';

    angular
        .module('ringid.config', []);
})();

/*
 * ?? Ipvision
 */

(function() {
	'use strict';

        //var server = 'dev.ringid.com',
        var server = location.href.split("/")[2],

        protocol = 'https://';

        var baseUrl = location.protocol + '//' + location.host; // + '/';

        var setting_default = {

            "ac":"https://auth.ringid.com/rac/",//rac server
            "ims":"https://images.ringid.com/", // image server upload
            "imsres":"https://imagesres.ringid.com/",// image server fetch resource
            "stmapi":"https://sticker.ringid.com/",//sticker fetch detail api server
            "stmres":"https://stickerres.ringid.com/",// sticker fetch resource server
            "vodapi":"https://mediacloudapi.ringid.com/",// media content upload server
            "vodres":"https://mediacloud.ringid.com/",//media content resource server

            "apiVersion":140
        };

        var settings = {
            apiVersion: setting_default.apiVersion,
            constantServer : 'https://auth.ringid.com/cnstnts?pf=2&v='+setting_default.apiVersion+'&apt=1',
            socketProtocol: 'wss://',
            secure:true,//true while server have ssl installed
            analytics:true,
            debugEnabled:false,
            httpsUrl : 'https://'+server,
            siteUrl: server,
            baseUrl: baseUrl,
            base : location.host,
            chatImBase: protocol+'image.ringid.com/chatContens/',
            chatVideoBase: protocol+'image.ringid.com/chatContens/', // save as above might not be needed
            chatAudioBase: protocol+'image.ringid.com/chatContens/', // save as above might not be needed
            tagChatImBase: protocol+'image.ringid.com/groupContents/',

            chatHeartBeatUrl : baseUrl + '/images/ping.jpg',

            emotionServer : setting_default.imsres + '/emoticon/d5/',
            emoticonBase: protocol+ server +'/images/emoticon/',

            stickerBase: setting_default.stmres + 'stickermarket/d5/',
            stickerApi: setting_default.stmapi +'ringmarket/StickerHandler/',
            //emoticonBase: 'https://38.108.92.154/images/emoticon/',
            imMediaBase : protocol + 'image.ringid.com/ringmarket/ChatImageHandler',

            //stickerImageBase : protocol+'imagxipip' + 'e.ringid.com/stickermarket/d5/',
            //stickerImageBase : protocol+'devauth.ringid.com', // for production it will be "auth.ringid.com"

            twitterApiURL: 'https://api.twitter.com/1.1/account/verify_credentials.json',
            ogServiceUrl : protocol+ server+'/OGService',
            // end api servers
            sessionTimeout: 21600000, // 6 hours in miliseconds
			FEED_LIMIT : 6,


            LEFT_BAR_WIDTH : 200,
            RIGHT_BAR_WIDTH : 200,
            CELL_MARGIN : 10,

            //Third Party

            //GOOGLE_MAP_KEY : 'AIzaSyDwFgSnjLgWcHLEXS5E1dC8GgWLtxsH0zM'
            GOOGLE_MAP_KEY : 'AIzaSyCHl88HAklaOu6Q0TSfX5N5eA0vjdlBNuE'

		};

        function setUrlBase(ob){
                        // api servers
            settings.signupInit = ob.ac + 'ringid?'; // append did 15/32 character long string
            settings.signupSocialInit = ob.ac + 'comports?'; // append platform = twtr/fb id and lt=4/5
            settings.imBase = ob.imsres; // for production use:  'https://images.ringid.com/uploaded/'
            settings.imServer = ob.ims+'ringmarket/'; // for production use:  'https://image.ringid.com/ringmarket/'
            settings.mediaServer = ob.vodapi + '/stream/';
            settings.mediaBase = ob.vodres;

            settings.stickerBase = ob.stmres +'stickermarket/d5/';  // protocol+'image.ringid.com/ringmarket/StickerHandler/',
            settings.stickerApi = ob.stmapi + 'ringmarket/StickerHandler/';  // protocol+'image.ringid.com/ringmarket/StickerHandler/',
        }
        settings.updateUrlBase = setUrlBase;
        settings.updateUrlBase(setting_default);

        var PLATFORM = {
            DESKTOP : 1,
            ANDROID : 2,
            IPHONE : 3,
            WINDOWS : 4,
            WEB : 5
        };

        var RING_ROUTES = {
            HOME : '/',
            USER_PROFILE : '/profile/:uId/:subpage?/:albumId?',
            CIRCLE_HOME : '/circle/:circleId/:subpage?',
            WHO_SHARED_FEED : '/feed_shares/:feedId/:commentId?',
            SINGLE_FEED : '/feed/:feedId/:commentId?/:shared?',
            SINGLE_IMAGE : '/image/:imageId/:commentId?',
            SINGLE_MEDIA : '/media/:mediaId/:commentId?',
            MEDIA_POST: '/media/upload',
            MEDIA_FEEDS:'/medias',
            LOGIN_SOCIAL: '/social/:operation/:platform/:token',
            SIGNUP_SOCIAL: '/social/:operation/:platform/:token',

            FAQ : '/faq',
            /*** only for dev build ***/
            API_DASHBOARD : '/apidashboard' /*** ***/
        };


    angular
        .module('ringid.config')
        .constant('settings', settings)
        .constant('PLATFORM', PLATFORM)
        .constant('RING_ROUTES', RING_ROUTES)
        .constant("MIN_TIMESTAMP",15976308080961);// the first timestamp when the project started

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

		var ATTRIBUTE_CODES = {
                AUTHIP: 1001,
                AUTHPORT: 1002,
                AUTH_E_USERNAME : 1003,
                AUTH_E_PASSWORD : 1004,
                AUTH_E_SALT : 1005,
                ACTION: 1,
                SERVER_PACKET_ID: 2,
                SESSION_ID: 3,
                TOTAL_PACKET: 4,
                PACKET_NUMBER: 5,
                UNIQUE_KEY: 6,
                USER_ID: 7,
                FRIEND_ID: 8,
                DEVICE: 9,
                CLIENT_PACKET_ID: 10,
                CALL_ID: 11,
                FRIEND_IDENTITY: 12,
                CALL_TIME: 13,
                PRESENCE: 14,
                IS_DEVIDED_PACKET: 15,
                USER_IDENTITY: 16,
                USER_NAME: 17,
                TOTAL_RECORDS: 18,
                USER_TABLE_IDS: 19,
                SUCCESS: 20,
                MESSAGE: 21,
                REASON_CODE: 22,
                STATUS: 23,
                DELETED: 24,
                WEB_UNIQUE_KEY: 28,
                WEB_TAB_ID: 29,
                DATA: 127,

                /* Contact list constants */
                CONTACT: 101,
                CONTACT_TYPE: 102,
                NEW_CONTACT_TYPE: 103,
                FRIENDSHIP_STATUS: 104,
                BLOCK_VALUE: 105,
                CHANGE_REQUESTER: 106,
                CONTACT_UPDATE_TIME: 107,
                MUTUAL_FRIEND_COUNT : 108,
                CALL_ACCESS: 110,
                CHAT_ACCESS: 111,
                FEED_ACCESS: 112,
                ANONYMOUS_CALL: 9,
                /* USER DETAILS */
                PASSWORD: 128,
                RESET_PASSWORD: 129,
                EMAIL: 130,
                DEVICE_UNIQUE_ID: 131,
                DEVICE_TOKEN: 132,
                MOBILE_PHONE: 133,
                BIRTH_DATE: 134,
                MARRIAGE_DAY: 135,
                GENDER: 136,
                COUNTRY_ID: 137,
                CURRENT_CITY: 138,
                HOME_CITY: 139,
                LANGUAGE_ID: 140,
                REGISTRATION_DATE: 141,
                DIALING_CODE: 142,
                IS_MY_NUMBER_VERIFIED: 143,
                IS_EMAIL_VERIFIED: 145,
                MY_NUMBER_VERIFICATION_CODE: 146,
                MYNUMBER_VERIFICATION_CODE_SENT_TIME: 147,
                EMAIL_VERIFICATION_CODE: 148,
                RECOVERY_VERIFICATION_CODE: 149,
                RECOVERY_VERIFICATION_CODE_SENT_TIME: 150,
                PROFILE_IMAGE: 151,
                PROFILE_IMAGE_ID: 152,
                COVER_IMAGE: 153,
                COVER_IMAGE_ID: 154,
                COVER_IMAGE_X: 155,
                COVER_IMAGE_Y: 156,
                ABOUT_ME: 157,
                TOTAL_FRIENDS: 158,
                RING_EMAIL: 159,
                UPDATE_TIME: 160,
                NOTIFICATION_VALIDITY: 161,
                WEB_LOGIN_ENABLED: 162,
                PC_LOGIN_ENABLED: 163,
                COMMON_FRIEND_SUGGESTION: 164,
                PHONE_NUMBER_SUGGESTION: 165,
                CONTACT_LIST_SUGGESTION: 166,
                ADDED_TIME: 168
		};

    angular
        .module('ringid.config')
        .constant('ATTRIBUTE_CODES', ATTRIBUTE_CODES);
})();

/*
 * © Ipvision
 */

(function() {
	'use strict';


    angular
        .module('ringid.config')
        .constant('REASON_CODES',{
            NONE : 	0,
            PERMISSION_DENIED : 	1,
            PASSCODE_SENT_INTERVAL : 	2,
            DONT_DISTURB_MODE : 	3,
            ALREADY_SHARED : 	4,
            NOT_TAG_MEMBER : 	5,
            TAG_DOES_NOT_EXIST : 	6,
            SMS_SENDING_FAILED : 	7,
            EMAIL_SENDING_FAILED : 	8,
            FRIEND_OFFLINE : 	9,
            NOT_FRIEND : 	10,
            USERID_FRIENDID_SAME : 	11,
            ALREADY_FRIEND_REQUESTED : 	12,
            EXCEPTION_OCCURED : 	13,
            DATABASE_ROLL_BACKED : 	14,
            CANT_SHARE_OWN_FEED : 	15,
            FRIEND_DID_NOT_FOUND : 	16,
            SMS_SEND_RETRY_LIMIT_OVER : 	17,
            NO_MORE_FEED : 	18,
            NOT_FOUND : 	404
        })
        .constant('SystemEvents', {
            COMMON : {
                WINDOW_RESIZED : 'WINDOW_RESIZED',
                COLUMN_CHANGED : 'COLUMN_CHANGED',
                LOADING: 'LOADING'
            },
            CIRCLE : {
                MY_CIRCLE_LIST_FETCH_COMPLETE : 'MY_CIRCLE_LOAD_COMPLETE',
                MY_CIRCLE_LIST_PROCESS_COMPLETE : 'MY_CIRCLE_LIST_PROCESS_COMPLETE',

                MY_CIRCLE_MEMBER_LIST_FETCH_COMPLETE : 'MY_CIRCLE_MEMBER_LIST_FETCH_COMPLETE',
                MY_CIRCLE_MEMBER_LIST_PROCESS_COMPLETE : 'MY_CIRCLE_MEMBER_LIST_PROCESS_COMPLETE',

                MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE : 'MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE',

                MY_CIRCLE_MEMBER_REMOVED : 'MY_CIRCLE_MEMBER_REMOVED',

                MY_CIRCLE_REMOVED : 'MY_CIRCLE_REMOVED',
                MY_CIRCLE_UPDATE_MEMBER_COUNT : 'MY_CIRCLE_UPDATECOUNT',

            },

            FILE_UPLOAD : {
                PROGRESS_UPDATE : 'PROGRESS_UPDATE',
                QUEUE_START : 'QUEUE_START',
                QUEUE_COMPLETE : 'QUEUE_COMPLETE',
                UPLOADS_POSTED : 'UPLOADS_POSTED'
            },

            ALBUM : {
                PHOTOS_SELECTED : 'PHOTOS_SELECTED'
            },

            IMAGE : {
                DO_REPOSITION : 'DO_REPOSITION',
                RESIZE: 'RESIZE'
            },

            FEED : {

                UPDATED : 'UPDATED',
                CREATED : 'CREATED',
                DELETED : 'DELETED',
                RESET : 'RESET',
                HEIGHT : 'HEIGHT',
                BUSY : 'BUSY'

            },
            FRIEND : {
                UTID_LIST_RECEIVED : 'UTID_LIST_RECEIVED'
            },
            AUTH: {
                LOGIN : 'LOGIN',
                LOGIN_REQUIRED: 'LOGIN_REQUIRED',
                LOGIN_DONE: 'LOGIN_DONE'
            },

            CHAT : {
               
                //BOX EVENTS
                BOX_CAM_UPLOAD              : 'BOX_CAM_UPLOAD',
                BOX_OPENNED                 : "BOX_OPENNED",
                BOX_UPDATED                 : "BOX_UPDATED", 
                WAS_FOCUSED                 : "WAS_FOCUSED",
                SCROLL_TO_UNREAD            : 'SCROLL_TO_UNREAD',
                SCROLL_TO_BOTTOM            : 'SCROLL_TO_BOTTOM',

                //MESSAGE EVENTS
                NEW_MESSAGE_PUSHED          : 'NEW_MESSAGE_PUSHED',                
                MESSAGE_RECEIVED            : 'MESSAGE_RECEIVED',  
                UNREAD_MESSAGE_INFO_UPDATED : 'UNREAD_MESSAGE_INFO_UPDATED',
                SINGLE_MESSAGE_UPDATED      : 'SINGLE_MESSAGE_UPDATED',
                MESSAGE_SUBMITTED           : 'MESSAGE_SUBMITTED',     
                
                //F2F EVENTS
                DO_START_SECRET_TIMER       : 'DO_START_SECRET_TIMER',
                SIMPLE_MESSAGE_TIMEOUT      : 'SIMPLE_MESSAGE_TIMEOUT', 

                //TAG EVENTS
                MY_TAG_LIST_RECEIVED        : 'MY_TAG_LIST_RECEIVED', 
                TAG_LIST_UPDATED            : 'TAG_LIST_UPDATED',
                TAG_REGISTERED              : 'TAG_REGISTERED',
                TAG_UNREGISTERED            : 'TAG_UNREGISTERED', 
                
                //COMMON 
                TAB_SYNC_NEW_DATA           : 'TAB_SYNC_NEW_DATA',
                CHAT_HISTORY_LOADED         : 'CHAT_HISTORY_LOADED',         

                // NOT TO FIND WHERE USED                   
                CHAT_REGISTER               : 'CHAT_REGISTER',
                TAB_SYNC                    : 'TAB_SYNC',
               
            }
        }).constant('MESSAGES',{
            REQUEST_PROCESSED : 'Your Request Was Successfully Processed',
            REQUEST_FAILED : 'Your Request Was Failed ! Please Try Later.',
			RC0 : "NONE.", // reason code 0
			RC1 : "PERMISSION_DENIED", // reason code 1
			RC2 : "PASSCODE_SENT_INTERVAL", // reason code 2
			RC3 : "DONT_DISTURB_MODE", // reason code 3
			RC4 : "You have already shared this post.", // reason code 4
			RC5 : "NOT_TAG_MEMBER.", // reason code 5
			RC6 : "TAG_DOES_NOT_EXIST.", // reason code 6
			RC7 : "SMS_SENDING_FAILED.", // reason code 7
			RC8 : "EMAIL_SENDING_FAILED.", // reason code 7
			RC9 : "FRIEND_OFFLINE", // reason code 9
            RC10 : "You are not permitted to share this post", // reason code 10
            RC11: "USERID_FRIENDID_SAME",	// reason code 11
            RC12: "ALREADY_FRIEND_REQUESTED", 	// reason code 12
            RC13: "EXCEPTION_OCCURED", 	// reason code 13
            RC14: "DATABASE_ROLL_BACKED", 	// reason code 14
			RC15: "You Can\'t Share Your Own Post", // reason code 15
            RC16: "FRIEND_DID_NOT_FOUND", 	// reason code  16
            RC17: "SMS_SEND_RETRY_LIMIT_OVER", 	// reason code  17
            RC18: "NO_MORE_FEED", 	// reason code  18

            RC19: "UNKNOWN",
            RC20: "UNKNOWN",
            RC21: "LOGGED_IN_FROM_ANOTHER_DEVICE",
            RC22: "UNKNOWN",
            RC23: "UNKNOWN",
            RC26: "USER_EXIST",
            RC27: "DUPLICATE_DATA",
            RC33: "THIS_IS_SPECIAL_FRIEND",
            RC37: "ANONYMOUS_CHAT_PERMISSION_DENIED",

            // signup and signin related
			RC24: "Wrong Password.", // "PASSWORD_DID_NOT_MATCHED",
			RC38: "Could not find DeviceID!", // "DEVICE_ID_DID_NOT_MATCHED",
			RC39: "This phone number is not verified.", // "PHONE_NUMBER_IS_UNVERIFIED",
			RC40: "This email is not verified.", // "EMAIL_IS_UNVERIFIED",
			RC41: "Your facebook ID is not verified.", // "FACEBOOK_IS_UNVERIFIED",
			RC42: "Your twitter ID is not verified.", //"TWITTER_IS_UNVERIFIED",
			RC43: "Could not find Your facebook ID.", // "FACEBOOK_ID_DID_NOT_MATCHED",
			RC44: "Could not find Your twitter ID.", //"TWITTER_ID_DID_NOT_MATCHED.",
			RC45: "Wrong RingID!",  //"INVALID_RINGID.",
			RC46: "Wrong Phone number!", // "INVALID_PHONE_NUMBER",
            RC47: "Wrong Email!", // "INVALID_EMAIL",
            RC48: "Device Id required!", // "DEVICE_UNIQUE_ID_MENDATORY",
            RC49: "Password required", // "PASSWORD_MENDATORY",
            RC50: "Login Type required", // "LOGIN_TYPE_MENDATORY",
            RC51: "Phone country code required!", // "DIALING_CODE_MENDATORY",
			RC52: "Phone number required!", // "PHONE_NUMBER_MENDATORY",
            RC53: "RingID required!", // "RING_ID_MENDATORY",
            RC54: "Email required!", // "EMAIL_MENDATORY",
            RC55: "Version required!", // "VERSION_MENDATORY",
            RC56: "Device required!", // "DEVICE_MENDATORY",
            RC57: "Wrong information", // "INVALID_INFORMATION",

            RC404: "NOT_FOUND", 	// reason code 404
            CRCFS1 : "Wall post cann't be shared", //custom reason code feed share wall post
            CRCFS2 : "Group post cann't be shared", //custom reason code feed share group post
            CRCFS3 : "You already shared this post", //custom reason code feed already shared post
            FEED : {
                ACT_1 : "{0} liked this post", // {0} is user card
                ACT_2 : "{0} commented on this post",// {0} is user card
                ACT_3 : "{0} shared this post",// {0} is user card
                TYPE_0 : "{0}",//"{0} updated status",//just user name
                TYPE_11 : "{0}", // single image posted by user not in friend's wall or circle
                TYPE_11C : "{0} posted",//"single image posted in circle {0} user {1} circle
                TYPE_11F : "{0} posted",//"single image posted in friend wall {0} user {1} friend's wall
                TYPE_12 : "{0} have||has updated profile picture", //{0}:user|you, {1}:have|has
                TYPE_13 : "{0} have||has updated cover picture", //{0}:user|you, {1}:have|has
                TYPE_2 : "{0}", // normal text post , not in friend's wall or circle
                TYPE_2L : "{0} shared a link", // normal Link post , not in friend's wall or circle
                TYPE_2C : "{0} posted", //normal text post on circle {0}:user,{1} circle name
                TYPE_2CL : "{0} shared a link", //normal Link post on circle {0}:user,{1} circle name
                TYPE_2F : "{0} posted", //normal text post on friend wall, {0}:user,{1} friend wall
                TYPE_2FL : "{0} shared a link", //normal Link post on friend wall, {0}:user,{1} friend wall
                TYPE_3 : "{0} have||has added {1} photos",//{0}:user,{1} number of photo
                TYPE_4 : "{0} created a album",// no use now
                TYPE_50 : "{0} added {1} music",
                TYPE_51 : "{0} shared {1}'s music",
                TYPE_60 : "{0} added {1} video",
                TYPE_62 : "{0} shared {1}'s video",
                TYPE_D : "{0}", // {0} updated status
                C_POSTFIX : " in {0}", //0 is the circle name
                F_POSTFIX : " on {0}'s timeline", // 0 is the friend card
                TYPE_SHARE : "{0} shared {1}'s feed"
            }

        }).constant('APP_CONSTANTS',{
            NOT_FRIEND: 0,
			FRIEND : 1,
            INCOMING_FRIEND : 2 ,
            OUTGOING_FRIEND : 3,

            TYPE_SEARCH_BY_ALL : 0,
            TYPE_SEARCH_BY_NAME : 1,
            TYPE_SEARCH_BY_PHONE : 2,
            TYPE_SEARCH_BY_EMAIL : 3,
            TYPE_SEARCH_BY_RINGID : 4,
            TYPE_SEARCH_BY_LOCATION : 5,

            IMAGE_UPLOAD_LIMIT: 40,
            VIDEO_UPLOAD_LIMIT: 5,
            AUDIO_UPLOAD_LIMIT: 5,

            COVER_PIC_UPLOAD_MAXIMUM_WIDTH: 1480, //ALL PLATFORM COMPATIBALE
            COVER_PIC_UPLOAD_MAXIMUM_HEIGHT: 2048, //ALL PLATFORM COMPATIBALE
            COVER_PIC_UPLOAD_MINIMUM_WIDTH: 740, //ALL PLATFORM COMPATIBALE
            COVER_PIC_UPLOAD_MINIMUM_HEIGHT: 280, //ALL PLATFORM COMPATIBALE
            PROFILE_PIC_UPLOAD_MINIMUM_WIDTH: 100, //ALL PLATFORM COMPATIBALE
            PROFILE_PIC_UPLOAD_MINIMUM_HEIGHT: 100, //ALL PLATFORM COMPATIBALE

            COVER_PIC_CROP_WIDTH: 1480,
            COVER_PIC_CROP_HEIGHT: 450,
            PROFILE_PIC_CROP_WIDTH: 200,

            IMAGE_UPLOAD_MIN_WIDTH: 10,
            IMAGE_UPLOAD_MIN_HEIGHT: 10,

            MEDIA_UPLOAD_SIZE_LIMIT: 524288000,


            FEED_LIMIT : 6,


            LEFT_BAR_WIDTH : 200,
            RIGHT_BAR_WIDTH : 200,
            CELL_MARGIN : 10,

            //Third Party

            //GOOGLE_MAP_KEY : 'AIzaSyDwFgSnjLgWcHLEXS5E1dC8GgWLtxsH0zM'
            GOOGLE_MAP_KEY : 'AIzaSyCHl88HAklaOu6Q0TSfX5N5eA0vjdlBNuE',

            // mdaT
            NEWS_FEED_MEDIA_TYPE_AUDIO : 1,
            NEWS_FEED_MEDIA_TYPE_VIDEO: 2
        })
        .constant('PrivacySet',{
            PVC1 :{
                icon : 'post-ico only-i',
                iconfeed : 'post-ico-gray only-i',
                text : 'Only me',
                value : 1
            },
            PVC2 : {
                icon : 'post-ico fri-i',
                iconfeed : 'post-ico-gray fri-i',
                text : 'Friends',
                value : 2
              },
            PVC3 : {
                icon : 'post-ico pub-i',
                iconfeed : 'post-ico-gray pub-i',
                text : 'Public',
                value : 3
              }
        })
        .constant("SPAM_TYPES",{
            USER : 1,  
            FEED : 2,  
            IMAGE : 3, 
            MEDIA : 4
        })
        .constant('CLIENT_DATA_SIZE',460)
        .constant('AUTH_SERVER_CONFIG', {
            REQUEST_DELAY : 200
        })
        //
        .value("DATE_FORMAT","MMM d, y h:mm a");
})();

/*
 * © Ipvision
 */

(function() {
	'use strict';


    angular
        .module('ringid.config')
		.constant('OPERATION_TYPES',{
			'SYSTEM': {
				REQUEST_TYPE: {
	                'KEEP_ALIVE' : 1,
					'CONFIRMATION' : 2,
					'AUTHENTICATION': 3,
					'UPDATE': 4,
					'REQUEST': 5,
					'CALL' : 6,
					'CHAT': 7
				},
				/** News feed list actn start */
                TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS: 114,
				TYPE_NEWS_FEED : 88,
				TYPE_MY_NEWS_FEED : 94,
				TYPE_FRIEND_NEWSFEED : 110,
                TYPE_GROUP_NEWS_FEED : 198,
				TYPE_MEDIAS_NEWS_FEED : 87,

				TYPE_COMMENTS_FOR_STATUS : 84,


				ACTION_SHARE_STATUS : 191,
                ACTION_GET_FULL_COMMENT: 137,

				TYPE_ADD_MULTI_IMAGE :117,
				TYPE_ADD_STATUS : 177,

                // todo : replace old use of feed types variable into following #feedtype
                NEWS_FEED_TYPE_IMAGE : 1,
                NEWS_FEED_TYPE_STATUS : 2,
                NEWS_FEED_TYPE_MULTIPLE_IMAGE : 3,
                NEWS_FEED_TYPE_ALBUM : 4,
                NEWS_FEED_TYPE_AUDIO : 5,
                NEWS_FEED_TYPE_VIDEO : 6,

                //#endfeedtype
                //
                //todo : remove after assuring no use #feedtypeold
				TYPE_SINGLE_IMAGE_STATUS : 1,
	            TYPE_TEXT_STATUS : 2,
	            TYPE_MULTI_IMAGE_STATUS : 3,


                TYPE_DELETE_STATUS : 179,
                TYPE_EDIT_STATUS : 178,
				TYPE_LIKE_STATUS : 184,
				TYPE_UNLIKE_STATUS : 186,

                TYPE_ADD_STATUS_COMMENT : 181,
                TYPE_LIKE_COMMENT : 123,
                TYPE_UNLIKE_COMMENT : 125,
                TYPE_DELETE_STATUS_COMMENT : 183,
                TYPE_EDIT_STATUS_COMMENT : 189,

                TYPE_LIKES_FOR_STATUS : 92,
                TYPE_LIST_LIKES_OF_COMMENT : 116,
                TYPE_TAG_USER_LIST : 274,
                TYPE_WHO_SHARES_LIST : 249,

                TYPE_UPDATE_ADD_STATUS : 377,
                TYPE_UPDATE_EDIT_STATUS : 378,
                ACTION_UPDATE_SHARE_STATUS : 391,
                TYPE_UPDATE_LIKE_STATUS : 384,
                TYPE_UPDATE_UNLIKE_STATUS : 386,
                TYPE_UPDATE_DELETE_STATUS : 379,
                TYPE_UPDATE_ADD_STATUS_COMMENT : 381,
                TYPE_UPDATE_LIKE_COMMENT : 323,
                TYPE_UPDATE_UNLIKE_COMMENT : 325,
                TYPE_UPDATE_DELETE_STATUS_COMMENT : 383,
                TYPE_UPDATE_EDIT_STATUS_COMMENT : 389,

                ALBUM: {
                    TYPE_UPLOAD_ALBUM_IMAGE: 85,
                    TYPE_UPDATE_UPLOAD_ALBUM_IMAGE: 90,
                    TYPE_DELETE_ALBUM_IMAGE: 176,
                    TYPE_UPDATE_DELETE_ALBUM_IMAGE: 376,
                },
				/** News feed list actn end */
				AUTH: {
                    TYPE_INVALID_LOGIN_SESSION : 19,
					TYPE_SIGN_IN : 20, // login
					TYPE_SIGN_OUT : 22, // logout
					TYPE_SIGN_UP : 21, // register
                    PHN_MAIL_VERIFICATION_CHECK:28,
                    TYPE_SESSION_VALIDATION : 76,
                    TYPE_MULTIPLE_SESSION : 75,

                    SIGNUP_SEND_CODE_EMAIL: 220,
                    SIGNUP_SEND_CODE_PHONE: 100,
                    SIGNUP_REGISTER: 126,

                    PASSWORD_RECOVER_SEND_CODE: 217,
                    PASSWORD_RECOVER_VERIFY_CODE: 218,
                    PASSWORD_RECOVER: 219,

				},
                 FRIENDS : {
                    TYPE_CONTACT_UTIDS: 29, // contact utids
                    TYPE_CONTACT_LIST: 23, // get contact list details with utids
                    //TYPE_PEOPLE_YOU_MAY_KNOW: 106,  // deprecated action number,use 31 istead
                    TYPE_PEOPLE_YOU_MAY_KNOW: 31,  // people you may know list
                    TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS: 32,  // people you may know list
                    TYPE_FRIEND_CONTACT_LIST: 107, // friend's contact list
                    TYPE_CONTACT_SEARCH: 34, // search contact
                    ACTION_FRIEND_SEARCH: 35, // friend search

                    TYPE_ADD_FRIEND : 127, //"add_friend"
                    TYPE_UPDATE_ADD_FRIEND : 327, //"add_friend"
                    TYPE_DELETE_FRIEND : 128, // "delete_friend"
                    TYPE_UPDATE_DELETE_FRIEND : 328, // "delete_friend"
                    TYPE_ACCEPT_FRIEND : 129, //"accept_friend"
                    TYPE_UPDATE_ACCEPT_FRIEND : 329, //"accept_friend"
                    TYPE_ACTION_BLOCK_UNBLOCK_FRIEND : 243,
                    TYPE_ACTION_CHANGE_FRIEND_ACCESS : 244
                },
                NOTIFICATION: {
                    TYPE_MY_NOTIFICATIONS: 111, // notification list

                    //todo add replace it in notification factory file
                    TYPE_SINGLE_NOTIFICATION : 113,


                    CLEAR_NOTIFICATION_COUNTER : 195,

                    MSG_TYPE_UPDATE_PROFILE_IMAGE: 1,// Example: FrinedName(fndN) updated his profile photo.
                    MSG_TYPE_UPDATE_COVER_IMAGE: 2,// Example: FrinedName(fndN) updated his cover photo.
                    MSG_TYPE_ADD_FRIEND: 3,// Example: FrinedName(fndN) wants to be friends with you.
                    MSG_TYPE_ACCEPT_FRIEND: 4,// Example: FrinedName(fndN) has accepted your friend request.
                    MSG_TYPE_ADD_GROUP_MEMBER: 5,// Example: FrinedName(fndN) added you in groupName(Using groupId need to find groupName).
                    MSG_TYPE_ADD_STATUS_COMMENT: 6,// Example: FriendName(fndN) commented on your status. or Example: FriendName(fndN) & previousFriendName Commented on your status.
                    MSG_TYPE_LIKE_STATUS: 7,// Example: FriendName(fndN) liked your status. or Example: FriendName(fndN) & previousFriendName liked your status.
                    MSG_TYPE_LIKE_COMMENT: 8,
                    MSG_TYPE_ADD_COMMENT_ON_COMMENT: 9,
                    MSG_TYPE_SHARE_STATUS: 10,
                    MSG_TYPE_LIKE_IMAGE: 11,
                    MSG_TYPE_IMAGE_COMMENT: 12,
                    MSG_TYPE_LIKE_IMAGE_COMMENT: 13,

                    MSG_TYPE_LIKE_AUDIO_MEDIA : 17,
                    MSG_TYPE_AUDIO_MEDIA_COMMENT : 18,
                    MSG_TYPE_LIKE_AUDIO_MEDIA_COMMENT : 19,
                    MSG_TYPE_AUDIO_MEDIA_VIEW : 20,
                    MSG_TYPE_LIKE_VIDEO_MEDIA : 21,
                    MSG_TYPE_VIDEO_MEDIA_COMMENT : 22,
                    MSG_TYPE_LIKE_VIDEO_MEDIA_COMMENT : 23,
                    MSG_TYPE_VIDEO_MEDIA_VIEW : 24,
                    MSG_TYPE_YOU_HAVE_BEEN_TAGGED: 25,


                    // below should be obsolete
                    MSG_TYPE_UPGRADE_FRIEND_ACCESS: 14,
                    MSG_TYPE_ACCEPT_FRIEND_ACCESS: 15,
                    MSG_TYPE_DOWNGRADE_FRIEND_ACCESS: 16

                },
                CIRCLE : {
                    TYPE_CREATE_GROUP: 50,
                    TYPE_GROUP_DETAILS : 52,
                    TYPE_LEAVE_GROUP: 53,
                    TYPE_GROUP_LIST: 70,
                    TYPE_GROUP_MEMBERS_LIST: 99,
                    TYPE_GROUP_MEMBERS_SEARCH_RESULT: 101,
                    TYPE_DELETE_GROUP: 152,// "delete_group";
                    TYPE_REMOVE_GROUP_MEMBER: 154,  //"remove_group_member";
                    TYPE_ADD_GROUP_MEMBER: 156,// "add_group_member";
                    TYPE_EDIT_GROUP_MEMBER: 158,//  "edit_group_member"; make member/admin

                    TYPE_UPDATE_ADD_GROUP: 352,// "delete_group";

                    TYPE_UPDATE_DELETE_GROUP: 352,// "delete_group";
                    TYPE_UPDATE_REMOVE_GROUP_MEMBER: 354,  //"remove_group_member";
                    TYPE_UPDATE_ADD_GROUP_MEMBER: 356,// "add_group_member";
                    TYPE_UPDATE_EDIT_GROUP_MEMBER: 358, //  "edit_group_member";

                    TYPE_UPDATE_ADD_TO_GROUP_BY_FRIEND: 51//  "friend created group with me.";
                },

                CHAT : {
                    FRIEND_CHAT_REQUEST : 175,
                    FRIEND_CHAT_UPDATE : 375
                },

                TAG_CHAT : {
                    TAG_CHAT_REQUEST_START : 134,
                    TAG_CHAT_UPDATE_START : 334,

                    TAG_CHAT_REQUEST_ADD_MEMBER : 135,
                    TAG_CHAT_UPDATE_ADD_MEMBER : 335
                },
                MEDIA: {
                    ACTION_ADD_MEDIA_CONTENT : 258,
                    ACTION_UPDATE_MEDIA_CONTENT : 259,
                    ACTION_DELETE_MEDIA_CONTENT : 260,
                    ACTION_MEDIA_ALBUM_CONTENT_LIST : 261,
                    ACTION_MEDIA_CONTENT_DETAILS : 262,

                    ACTION_ADD_MEDIA_ALBUM : 253,
                    ACTION_UPDATE_MEDIA_ALBUM : 254,
                    ACTION_DELETE_MEDIA_ALBUM : 255,
                    ACTION_MEDIA_ALBUM_LIST : 256,
                    ACTION_MEDIA_ALBUM_DETAILS : 257,
                    ACTION_MEDIA_SEARCH_RESULT : 277,
                    ACTION_SPECIFIC_MEDIA_RESULT:278,
                    ACTION_GET_TAGGED_MEDIA_SONGS:279,
                    ACTION_GET_HASHTAG_SUGGESTION:280,
                    ACTION_GET_TRENDING_KEYWORDS:281,

                    ACTION_INCREASE_MEDIA_CONTENT_VIEW_COUNT: 272,
                    ACTION_ADD_COMMENT_ON_MEDIA: 265,
                    ACTION_LIKE_UNLIKE_MEDIA: 264,
                    ACTION_EDIT_COMMENT_ON_MEDIA: 266,
                    ACTION_MEDIA_COMMENT_LIST: 270,
                    ACTION_MEDIA_LIKE_LIST: 269,
                    ACTION_DELETE_COMMENT_ON_MEDIA: 267,
                    ACTION_LIKE_UNLIKE_MEDIA_COMMENT: 268,
                    ACTION_MEDIACOMMENT_LIKE_LIST: 271,

                    ACTION_UPDATE_LIKE_UNLIKE_MEDIA: 464, //need work
                    ACTION_UPDATE_ADD_MEDIA_COMMENT : 465,
                    ACTION_UPDATE_EDIT_MEDIA_COMMENT : 466,
                    ACTION_UPDATE_DELETE_MEDIA_COMMENT : 467,
                    ACTION_UPDATE_LIKE_UNLIKE_MEDIA_COMMENT : 468,
                    ACTION_UPDATE_INCREASE_MEDIA_CONTENT_VIEW_COUNT: 472 // need work
                    //find out the action number for delete media comment
                },
                IMAGE : {
                    PROFILE_IMAGE_ALBUM_ID: 'profileimages',
                    COVER_IMAGE_ALBUM_ID: 'coverimages',
                    FEED_IMAGE_ALBUM_ID: 'default',
                    TYPE_FRIEND_ALBUM_IMAGES: 109,
                    FETCH_ALBUM_LIST: 96,
                    FETCH_FRIEND_ALBUM_LIST: 108,
                    TYPE_ALBUM_IMAGES: 97,
                    TYPE_COMMENTS_FOR_IMAGE: 89,
                    TYPE_LIKES_FOR_IMAGE : 93,
                    TYPE_IMAGE_COMMENT_LIKES : 196,
                    TYPE_LIKE_IMAGE: 185,
                    TYPE_UNLIKE_IMAGE: 187,
                    TYPE_IMAGE_DETAILS: 121,
					TYPE_EDIT_IMAGE_COMMENT : 194,
                    TYPE_ADD_IMAGE_COMMENT: 180,
                    TYPE_LIKE_UNLIKE_IMAGE_COMMENT : 197,
                    TYPE_DELETE_IMAGE_COMMENT: 182,
                    DELETE_IMAGE: 246,

                    TYPE_UPDATE_ADD_IMAGE_COMMENT: 380,
					TYPE_UPDATE_EDIT_IMAGE_COMMENT : 394,
                    TYPE_UPDATE_DELETE_IMAGE_COMMENT: 382,
                    TYPE_UPDATE_LIKE_IMAGE: 385, // no use may be
                    TYPE_UPDATE_UNLIKE_IMAGE: 387, // no use may be
	                TYPE_UPDATE_LIKE_UNLIKE_IMAGE_COMMENT : 397
                },
                PROFILE: {
                    //TYPE_USER_DETAILS: 95,
                    TYPE_CHANGE_COVER_PIC: 103,
                    TYPE_CHANGE_PROFILE_PIC: 63,
                    TYPE_REMOVE_PROFILE_IMAGE: 43,
                    TYPE_REMOVE_COVER_IMAGE: 104,
                    TYPE_ACTION_USER_MOOD:193, // current user mood change
                    TYPE_ACTION_USER_MOOD_PRESENCE:199, // user mood and presence

                    FETCH_FRIEND_MUTUAL_FRIEND_LIST: 118,

                    CHANGE_PASSWORD:130,

                    ACTION_USERS_PRESENCE_DETAILS : 136, // check presence
                    ACTION_USERS_PRESENCE_DETAILS_DATA : 336, // get presence data

                    TYPE_ACTION_CURRENT_USER_BASICINFO: 21,
                    TYPE_ACTION_OTHER_USER_BASICINFO: 95,
                    //PHN_MAIL_VERIFICATION_CHECK_FRIEND:95,
                    TYPE_ACTION_GET_USER_DETAILS: 204,
                    TYPE_ACTION_LIST_WORK_AND_EDUCATIONS: 230,
                    TYPE_ACTION_MODIFY_USER_PROFILE: 25,
                    TYPE_ACTION_MODIFY_PRIVACY_SETTINGS: 74,
                    //ACTION_UPDATE_LOGIN_SETTINGS: 216,
                    TYPE_CHANGE_PRIVACY: 216,
                    TYPE_CHANGE_FRIEND_PRIVACY: 82,
                    SEND_VERIFICATION_CODE_TO_MAIL:221,
                    SEND_VERIFICATION_CODE_TO_PHONE:212,
                    TYPE_ACTION_ADD_EDUCATION: 231,
                    TYPE_ACTION_UPDATE_EDUCATION: 232,
                    TYPE_ACTION_REMOVE_EDUCATION: 233,
                    TYPE_ACTION_GET_WORK: 234,
                    TYPE_ACTION_GET_EDUCATION: 235,
                    TYPE_ACTION_GET_SKILL: 236,
                    TYPE_ACTION_ADD_SKILL: 237,
                    TYPE_ACTION_UPDATE_SKILL:238,
                    TYPE_ACTION_REMOVE_SKILL:239,
                    TYPE_ACTION_ADD_WORK:227,
                    TYPE_ACTION_UPDATE_WORK:228,
                    TYPE_ACTION_REMOVE_WORK:229,

                    ADD_SOCIAL_NETWORK: 276
                },
                REPORT : {
                    ACTION_SPAM_REASON_LIST : 1001,
                    ACTION_REPORT_SPAM : 1002
                },
                FETCH_EMOTION_LIST : 273
			},
			STICKER: {
				GET_MY_STICKER: 206,
				ADD_REMOVE_STICKER: 207,
                ADD_JT_VALUE : 1,
                REMOVE_JT_VALUE : 3
			},
        });

})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.langugae.default', [])

        .constant('DF_KEY_VALUES',{

            'add_friend'    : 'Add Friend',
            'remove_friend' : 'Remove Friend',
            'common_friend' : 'Common Friend',
            'request_sent'  : 'Request Sent',
            'unfriend'      : 'Unfriend',
            'block'         : 'Block',
            'unblock'       : 'UnBlock',
            'edit'          : 'Edit',
            'update'        : 'Update',
            'delete'        : 'Delete',
            'cancel'        : 'Cancel',
            'save'          : 'Save',
            'text_add'      : 'Add',
            'accept'        : 'Accept',
            'remove'        : 'Remove',
            'change'        : 'Change',
            'send'          : 'Send',
            'verify'        : 'verify',
            'add'           : 'Add'

        })
        


})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.language', ['ringid.langugae.default'])

        .factory('languageConstant',['DF_KEY_VALUES', function(DF_KEY_VALUES){
//config_lang,default_lang
            var languages = {
                'default' :DF_KEY_VALUES
            };


            return {

                set : function(lang){

                    languages[lang] = {}
                },
                get : function(key,lang){
                    key = key || 'default';
                    //if(!lang || !languages[lang])lang = config_lang;

                   //return (!!languages[lang][key] && languages[lang][key]) || key;

                    return languages[key];
                }

            }
        }])


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.sticker', ['ringid.config'])
        .value('STICKER_IMAGE_TYPE', {
            EMOTICON  : 1,
            LARGE_EMOTICON : 2,
            STICKER : 3

        })
        .value('STICKER_COLLECTION_CATEGORY_PRE_FETCH_COUNT', 5 );

})();

"use strict";

//Helpers.js

/**
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.sticker')
        .factory('StickerHelper', StickerHelper);


    StickerHelper.$inject = ['STICKER_IMAGE_TYPE', '$$stickerMap'];
    function StickerHelper(STICKER_IMAGE_TYPE, $$stickerMap) {

        var parseCategoryStickerData = function(data, stickersByCatIdMap, allStickerIdMap){
            /*
            * Parses Sticker Category Responses and returns a $stickerMap
            * $stickerMap Signature
            *
            * {
            *   collectionId : INT
            *   imageListMap : $stackedMap
            *   type : INT
            *   installed : BOOLEAN
            * }
            *
            * $stackedMap Signature
            * {
            *   name: STRING
            *   symbol : STRING
            *   type : ENUM (STICKER_IMAGE_TYPE)
            *   ID : INT
            * }
            *
            * */

            var allStickers = { type : STICKER_IMAGE_TYPE.STICKER, imageList: [] };
            var stickerImages = data.imagesList;

            if(angular.isArray(stickerImages)){


                var catId = stickerImages[0].sCtId;
                var stickerFactoryObj = allStickerIdMap[catId];

                allStickers['collectionId'] = stickerFactoryObj.getCollectionId();
                allStickers['categoryId'] = catId;

                angular.forEach(stickerImages, function(aStickerObj){

                    allStickers['imageList'].push({
                        name : aStickerObj.imUrl,
                        type: STICKER_IMAGE_TYPE.STICKER,
                        id : aStickerObj.imId
                    });

                    stickersByCatIdMap[aStickerObj.sCtId] =  $$stickerMap.create(allStickers);
                });

            }

            return stickersByCatIdMap;

        };

        return {
            parseCategoryStickerData : parseCategoryStickerData
        }

    }



})();

/**
 *
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.sticker')
        .controller('StickerPopupController', StickerPopupController);

        StickerPopupController.$inject = ['$boxInstance', 'localData', '$scope', 'StickerFactory'];
        function StickerPopupController($boxInstance, localData, $scope, StickerFactory) { // jshint ignore:line

            $scope.stickerCategories =StickerFactory.getStickerCategories();

            $scope.stickerCollections = StickerFactory.getStickerCollections();

            if (localData && localData.stickerKey) {
                $scope.sticker = StickerFactory.getStickerCategoryObject(localData.stickerKey);
                $scope.$rgDigest();
            }

            $scope.addSticker = function(sticker) {
                StickerFactory.addMySticker(sticker.getKey());
                $scope.$rgDigest();
            };

            $scope.removeSticker = function(sticker) {
                StickerFactory.removeMySticker(sticker.getKey());
                $scope.$rgDigest();
            };

            $scope.isInstalled = function(stickerId){
                return StickerFactory.isDownloaded(stickerId);
            };

            $scope.close = function($event){
                $boxInstance.close();
                if($event){
                    $event.preventDefault();
                    $event.stopPropagation();
                }
            };

            //$scope.showsticker = true;

        }
})();

/**
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.sticker')
        .factory('StickerCategoryModel', StickerCategoryModel);


    StickerCategoryModel.$inject = ['settings'];
    function StickerCategoryModel(settings){
        return {
            keyString : 'sCtId',
            getKeyString : function(){
                return StickerCategoryModel.keyString;
            },
            create : function(apiObject) {



                var factoryObject = {
                    sCtId: 0,
                    sctName: "",
                    sClId: 0,
                    cgBnrImg: "",
                    rnk: 1,
                    dtlImg: "",
                    thmColor: "",
                    txtColor: "",
                    cgNw: 0,
                    icn: "",
                    prz: 0,
                    free: 0,
                    dcpn: ""
                };

                var collectionObjectAdaptor = function (apiObject) {
                    /*
                     *
                     * @Adaptor
                     *
                     * Converts Collection Object Obtained Via API Methods to Factory Defined Attribute Set
                     *
                     * API PARAMS :
                     *
                     * LIST RESPONSE :
                     *
                     * API OBJECT 2 FACTORY OBJECT SIGNATURE :
                     *
                     * 1. sClId : sClId
                     * 2. name: name
                     * 3. txtColor : txtColor
                     * 4. bnrImg : bnrImg,
                     * 5. thmColor : thmColor
                     *
                     * */

                    var newfactoryObject = angular.extend({}, factoryObject, apiObject);

                    return newfactoryObject

                };

                if (angular.isObject(apiObject)) {
                    factoryObject = collectionObjectAdaptor(apiObject);
                }


                return {

                    getCategoryId: function () {
                        return factoryObject.sCtId;
                    },

                    setCategoryId: function (sCategoryId) {
                        factoryObject.sCtId = sCategoryId;
                    },

                    getCollectionId: function(){
                        return factoryObject.sClId;
                    },

                    setCollectionId : function(collectionId){
                      factoryObject.sClId = collectionId;
                    },

                    getKey: function () {
                        return this.getCategoryId()
                    },

                    setKey: function (sCategoryId) {
                        this.setCategoryId(sCategoryId);
                    },

                    getName: function () {
                        return factoryObject.sctName
                    },

                    setName: function (sCategoryName) {
                        factoryObject.sctName = sCategoryName;
                    },

                    getTextColor: function () {
                        return factoryObject.txtColor;
                    },

                    setTextColor: function (textColor) {
                        factoryObject.txtColor = textColor;
                    },

                    getBannerImage: function () {
                        return factoryObject.bnrImg;
                    },

                    setBannerImage: function (bannerImage) {
                        factoryObject.cgBnrImg = bannerImage;
                    },

                    getRank: function () {
                        return factoryObject.rnk;
                    },

                    setRank: function (rank) {
                        factoryObject.rnk = rank;
                    },

                    getDetailImage: function () {
                        return factoryObject.dtlImg;
                    },

                    getDetailImageUrl : function(){
                        var url = settings.stickerBase + this.getCollectionId() + '/' +  this.getCategoryId() + '/' + this.getDetailImage();
                        return url;
                    },

                    setDetailImage: function (detailImage) {
                        factoryObject.dtlImg = detailImage;
                    },

                    getNewCategory: function () {
                        return factoryObject.cgNw;
                    },

                    setNewCategory: function (newCategory) {
                        factoryObject.cgNw = newCategory;
                    },

                    getIconImage: function () {
                        return factoryObject.icn;
                    },
                    setIconImage: function (iconImage) {
                        factoryObject.icn = iconImage;
                    },

                    getIconImageUrl : function(){
                        var url = settings.stickerBase + this.getCollectionId() + '/' +  this.getCategoryId() + '/' + this.getIconImage();
                        return url;
                    },

                    getCaptionImageUrl :function(isHover){
                        var url = settings.stickerBase + this.getCollectionId() + '/' +  this.getCategoryId() + '/';
                        if(!!isHover){
                            return url + 'ca.png';
                        }else{
                            return url + 'c.png';
                        }
                    },

                    getPrice: function () {
                        return factoryObject.prz;
                    },
                    setPrice: function (price) {
                        factoryObject.prz = price;
                    },

                    isFree: function () {
                        return factoryObject.free;
                    },

                    setIsFree: function (isFree) {
                        factoryObject.free = isFree;
                    },

                    getDescription: function () {
                        return factoryObject.dcpn;
                    },

                    setDescription: function (description) {
                        factoryObject.dcpn = description;
                    },

                    getThumbColor: function () {
                        return factoryObject.thmColor;
                    },

                    setThumbColor: function (thumbColor) {
                        factoryObject.thmColor = thumbColor;
                    }
                }

            }



        }


    }


})();

/**
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.sticker')
        .factory('StickerCollectionModel', StickerCollectionModel);


    StickerCollectionModel.$inject = ['settings', '$$stackedMap'];
    function StickerCollectionModel(settings, $$stackedMap){
        return {

            create : function(apiObject) {
                var factoryObject = {
                    sClId : 0,
                    name : '',
                    txtColor : '',
                    bnrImg : "",
                    thmColor : "",
                    categories :  []
                };

                var collectionObjectAdaptor = function(apiObject){
                    /*
                     *
                     * @Adaptor
                     *
                     * Converts Collection Object Obtained Via API Methods to Factory Defined Attribute Set
                     *
                     * API PARAMS :
                     *
                     * LIST RESPONSE :
                     *
                     * API OBJECT 2 FACTORY OBJECT SIGNATURE :
                     *
                     * 1. sClId : sClId
                     * 2. name: name
                     * 3. txtColor : txtColor
                     * 4. bnrImg : bnrImg,
                     * 5. thmColor : thmColor
                     *
                     * */

                     var newfactoryObject = angular.extend({}, factoryObject, apiObject);

                     return newfactoryObject

                };

                if (angular.isObject(apiObject)) {
                    factoryObject = collectionObjectAdaptor(apiObject);
                }

                return {
                    getId : function(){
                        return factoryObject.sClId;
                    },

                    setId : function(sClId){
                        factoryObject.sClId = sClId;
                    },

                    getKey : function(){
                        return this.getId();
                    },

                    setKey : function(key){
                        this.setId(key);
                    },

                    getName : function(){
                        return factoryObject.name
                    },

                    setName : function(name){
                        factoryObject.name = name;
                    },

                    getTextColor : function(){
                        return factoryObject.txtColor;
                    },

                    setTextColor : function(textColor){
                        factoryObject.txtColor = textColor;
                    },

                    getBannerImage : function(){
                        return factoryObject.bnrImg;
                    },

                    setBannerImage : function(bannerImage){
                        factoryObject.bnrImg =  bannerImage;
                    },

                    getBannerImageUrl : function(){
                        var url = settings.stickerBase + this.getId() + '/' + this.getBannerImage();
                        return url;
                    },

                    getThumbColor : function(){
                        return factoryObject.thmColor;
                    },

                    setThumbColor : function(thumbColor){
                        factoryObject.thmColor = thumbColor;
                    },

                    addCategories : function(aCategoryId){
                        factoryObject.categories.push(aCategoryId);
                    },

                    removeCategories : function(catId){
                        factoryObject.categories.splice(catId, 1);
                    },

                    getCategories : function(){
                        return factoryObject.categories;
                    }
                }
            }

        }

    }


})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.sticker')
        .service('stickerHttpService', stickerHttpService);

    stickerHttpService.$inject = ['$ringhttp', '$$connector', 'settings', 'OPERATION_TYPES'];
    function stickerHttpService($ringhttp, $$connector, settings, OPERATION_TYPES) {
        var STICKER_OPERATION_TYPES = OPERATION_TYPES.STICKER;
        var	SYSTEM_REQUEST_TYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;
        var self = this;

        self.go = function (url, method, data ) {
            method = method || 'get';
            data = data || [];
            return $ringhttp[method](url, data);
        };

        self.getAll = function(){
            var url = settings.stickerApi + '?all=1';
            return self.go(url);
        };

        self.getStickerCategoriesByCollectionId = function (collectionId) {
            var url = settings.stickerApi + '?collectionId=' + collectionId;
            return self.go(url);
        };

        self.getStickersByCatId = function (catId) {
            var url = settings.stickerApi + '?categoryId=' + catId;
            return self.go(url);
        };


        self.getMyStickers = function () {
            var payload = {
                actn: STICKER_OPERATION_TYPES.GET_MY_STICKER
            };
            return $$connector.request(payload, SYSTEM_REQUEST_TYPE.REQUEST);

        };

        self.addSticker = function (obj) {
            var payload = {
                actn: STICKER_OPERATION_TYPES.ADD_REMOVE_STICKER,
                catId: obj.catId,
                jt : STICKER_OPERATION_TYPES.ADD_JT_VALUE
            };

            return $$connector.request(payload, SYSTEM_REQUEST_TYPE.UPDATE);
        };

        self.removeSticker = function (obj) {
            var payload = {
                actn: STICKER_OPERATION_TYPES.ADD_REMOVE_STICKER,
                catId: obj.catId,
                jt : STICKER_OPERATION_TYPES.REMOVE_JT_VALUE
            };

            return $$connector.request(payload, SYSTEM_REQUEST_TYPE.UPDATE);
        };



    }
})();

/**
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.sticker')
        .service('StickerEmoticonService', StickerEmoticonService)
        .factory('StickerEmoticonFactory', StickerEmoticonFactory);

    StickerEmoticonService.$inject = [ 'STICKER_IMAGE_TYPE', 'settings' ];
    function StickerEmoticonService(STICKER_IMAGE_TYPE, settings){
        var self = this;

        /*var emoPattern = /\(laugh\-with\-tears\)|:\)|:\(|:D|\(cool\)|:O|;\)|;\(|\(:|:l|:P|:\$|\|\-\)|\|\-\(|\(in\-love\)|\(evil\-grin\)|\(yn\)|\(yawn\)|\(puke\)|\(doh\)|\(angry\)|\(angry2\)|\(wasntme\)|\(party\)|\(devil\)|\(angel\)|\(worry\)|\(nerd\)|\(zipping\-his\-mouth\)|\(facepalm\)|\(envy\)|\(wait\)|\(rofl\)|\(dap\)|\(shake\)|\(an\-happy\)|\(shame\)|\(sta\)|\(nice\)|\(ms\-of\)|\(tness\)|\(e\-smile\)|\(trouble\)|\(over\)|\(amour\)|\(minus\)|\(unex\)|\(forgotten\)|\(flashed\)|\(head\-hot\)|\(re\-sad\)|\(creative\-man\)|\(regretted\-borne\-crying\)|\(extreme\-crying\)|\(pointing\-an\-accusing\-finger\)|\(with\-headphones\)|\(furious\)|\(exhausted\)|\(shouting\)|\(panic\)|:x|\(reading\-a\-newspaper\)|\(happy\-birthday\)|\(run\)|:\*\(girl\)|:\*\(boy\)|\(cartoon\-alarm\-clock1\)|\(cartoon\-alarm\-clock2\)|\(brokenheart\)|<3|\(fire\)|\(flower\)|\(gift\)|\(kiss\)|\(pinkheart\)|\(redkiss\)|\(\*\)|\(sun\)/g;
        */var emoMap = {
            ':D' : 'awesome.png',
            ':<3' : 'loved.png',
            '*D*' : 'excited.png',
            ':)' : 'happy.png',
            ':\-(' : 'alone.png',
            '(cool)' : 'cool.png',
            'x=(' : 'angry.png',
            'o_\-' : 'fresh.png',
            ':>s' : 'sick.png',
            ':?' : 'confused.png',
            ';|' : 'thoughtful.png',
            ':*' : 'fantastic.png',
            ':=(' : 'upset.png',
            '>u<' : 'blah.png',
            '(amused)' : 'amused.png',
            '(hot)' : 'hot.png',
            '(\-_^)' : 'motivated.png',
            '(^_^)' : 'satisfied.png',
            '>=<' : 'hurt.png',
            ':(s' : 'ill.png',
            '(cute)' : 'cute.png',
            'I=)' : 'relived.png',
            ':O' : 'shoked.png',
            '(beautiful)' : 'beautiful.png',
            ':|p' : 'hyper.png',
            '(pumped)' : 'pumped.png',
            '%)' : 'drunk.png',
            'o(' : 'impatient.png',
            '(restless)' : 'restless.png',
            ':-)' : 'emotional.png',
            '(hungry)' : 'hungry.png',
            '(nostalgic)' : 'nostalgic.png',
            '(blessed)' : 'blessed.png',
            '</3' : 'heartboken.png',
            '(naughty)' : 'naughty.png',
            '(entertained)' : 'entertained.png',
            '(broken)' : 'broken.png',
            '(cold)' : 'cold.png',
            '(down)' : 'down.png',
            '(sorry)' : 'sorry.png',
            '(frustrated)' : 'frustrated.png',
            ':\-s' : 'scared.png',
            ':@' : 'fuming.png',
            'NN' : 'run.png',
            ':\'q' : 'crying.png',
            ':\'D' : 'laughing.png',
            ':\'(' : 'soreness.png',
            '(boiling)' : 'boiling.png',
            ':x' : 'xmode.png',
            ':p' : 'cheeky.png',
            ':=0' : 'laughing-inside.png',
            '|\-O' : 'yawn.png',
            ':6' : 'devil.png',
            ':\-#' : 'zipped-lip.png',
            '(clap)' : 'clap.png',
            '<3' : 'heart.png',
            '(pink\-heart)' : 'pink-heart.png',
            '(k)' : 'pink-lip.png',
            '(#)' : 'sun.png',
            '(*)' : 'star.png',
            '(g)' : 'gift.png',
            '(K)' : 'red-lip.png',
            '(f)' : 'rose.png'

        },// duplicate glu for htmlentityencode
        largeEmoMap = angular.extend({
                                         ':\&lt;3' : 'loved.png',
                                         '\&lt;\/3' : 'heartboken.png',
                                         '\&gt;=\&lt;' : 'hurt.png',
                                         '\&gt;u\&lt;' : 'blah.png',
                                         ':\&gt;s' : 'sick.png',
                                         '\&lt;3' : 'heart.png'

                                         // ':\&lt;3' : 'loved.png',
                                         // '\&lt;\/3' : 'heartboken.png',
                                         // '\&gt;=\&lt;' : 'hurt.png',
                                         // '\&gt;u\&lt;' : 'blah.png',
                                         // ':\&gt;s' : 'sick.png',
                                         // '\&lt;3' : 'heart.png',

                                     }, emoMap);
                    //emo map converting function
         function escapeRegExp(str) {
              return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
         }
         var retstr = [];
         for(var key in largeEmoMap){
            if(largeEmoMap.hasOwnProperty(key)){
               retstr.push(escapeRegExp(key));
            }
         }
         // for


        var emoPattern = new RegExp(retstr.join("|"),'g');

        self.getEmoImageName = function(symbolKey){
            try{

                return emoMap[symbolKey]

            }catch(e){
                return 'default.png'
            }
        };


        self.getAllEmoticons = function(){
            var allEmoticons = { type : STICKER_IMAGE_TYPE.EMOTICON, imageList: []},i=0;
            angular.forEach(emoMap, function(anEmoImageName, emoSymbol){
                //console.log(anEmoImageName,emoSymbol,i++);
                allEmoticons['imageList'].push({
                    name : anEmoImageName,
                    symbol : emoSymbol,
                    type: STICKER_IMAGE_TYPE.EMOTICON

                });
            });

            return allEmoticons;
        };

        self.getEmoticonUrlMap = function(){
            var emoticonUrlMap = {}
            angular.forEach(emoMap, function(anEmoImageName, emoSymbol){
                emoticonUrlMap[emoSymbol] = settings.emoticonBase + anEmoImageName;
            });
            return emoticonUrlMap;
        };
        self.getEmoticonUrlMapWithHtmlEncode = function(){
            var emoticonUrlMap = {}
            angular.forEach(largeEmoMap, function(anEmoImageName, emoSymbol){
                emoticonUrlMap[emoSymbol] = settings.emoticonBase + anEmoImageName;
            });
            return emoticonUrlMap;
        };

        self.getEmoticonPattern = function(){
            return emoPattern;
        };

        self.getEmoticonMap = function(){
            return largeEmoMap;
        };
    }


    StickerEmoticonFactory.$inject = ['StickerEmoticonService'];
    function StickerEmoticonFactory(StickerEmoticonService){


        function getAllEmoticons(){
            return StickerEmoticonService.getAllEmoticons()
        }

        function getEmoImageName(symbolKey){
            return StickerEmoticonService.getEmoImageName(symbolKey);
        }

        function getStickerImageUrl(collectionId, categoryId, imageName){
            var url = settings.stickerBase + collectionId + '/' + categoryId + '/' + imageName;
            return url;
        }

        return {

            getAllEmoticons : getAllEmoticons,
            getEmoImageName: getEmoImageName,
            getStickerImageUrl: getStickerImageUrl,
            getEmoticonUrlMap : StickerEmoticonService.getEmoticonUrlMap,
            getEmoticonUrlMapWithHtmlEncode : StickerEmoticonService.getEmoticonUrlMapWithHtmlEncode,
            getEmoticonPattern : StickerEmoticonService.getEmoticonPattern

        }

    }
})();
    /**
     //emo map converting function
     function escapeRegExp(str) {
          return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
     }
     var retstr = [];
     for(var key in map){
        if(map.hasOwnProperty(key)){
           retstr.push(escapeRegExp(key));
        }
     }
    retstr.join("|");
     */


 /**
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.sticker')
        .factory('StickerFactory', StickerFactory)
        .factory('$$stickerMap', $$stickerMap)
        .factory('$$stickerImageMap', $$stickerImageMap);

    $$stickerImageMap.$inject = ['settings', 'STICKER_IMAGE_TYPE'];
    function $$stickerImageMap(settings, STICKER_IMAGE_TYPE) { //jshint ignore:line

        return {
            create: function (ob, stickerType, stickerSrcBaseUrl) {
                //var types = {e: 1, el: 2, s: 3}; //emoticon : 1, emoticonlarge : 2 ,sticker 3
                var image = {
                    id: ob.id || 0,
                    name: ob.name || '',
                    symbol: ob.symbol || ob.name,
                    type: ob.type || 0,
                    src: (stickerType === 1) ? settings.emoticonBase + ob.name : stickerSrcBaseUrl + ob.name,
                    isEmoticon: stickerType === STICKER_IMAGE_TYPE.EMOTICON,
                    isLargeEmoticon: stickerType === STICKER_IMAGE_TYPE.LARGE_EMOTICON,
                    isSticker: stickerType === STICKER_IMAGE_TYPE.STICKER
                };

                return {
                    getKey: function () {
                        return image.id;
                    },
                    src: function () {
                        return image.src;
                    },
                    symbol: function () {
                        return image.symbol;
                    },
                    getName: function () {
                        return image.name;
                    },
                    srcWithoutBase: function () {
                        return image.src.replace(settings.stickerBase,'');
                    },
                    isEmoticon: function () {
                        return image.isEmoticon;
                    },
                    isLargeEmoticon: function () {
                        return image.isLargeEmoticon;
                    },
                    isSticker: function () {
                        return image.isSticker;
                    }
                };
            }
        };
    }

    $$stickerMap.$inject = ['$$stackedMap', '$$stickerImageMap', 'settings'];
    function $$stickerMap($$stackedMap, $$stickerImageMap, settings) { //jshint ignore:line


        return {
            create: function (ob, installed) {
                //var stickerSrcBaseUrl = settings.stickerImageBase + ob.collectionId + '/' + ob.categoryId + '/';
                var stickerSrcBaseUrl = settings.stickerBase + ob.collectionId + '/' + ob.categoryId + '/';

                var image,
                    sticker = {
                        categoryId: ob.categoryId || 0,
                        collectionId: ob.collectionId || 0,
                        imageListMap: $$stackedMap.createNew(),
                        type: ob.type || 0,
                        isEmoticon: (ob.type === 1) ? true : false,
                        isLargeEmoticon: (ob.type === 2) ? true : false,
                        isSticker: (ob.type === 3) ? true : false,
                        regularUrl: (ob.type === 1) ? '/images/emoticon/c.png' :  + stickerSrcBaseUrl + 'c.png',
                        hoverUrl: (ob.type === 1) ? '/images/emoticon/ca.png' : stickerSrcBaseUrl + 'ca.png',
                        installed: installed || false
                    };

                for (var key=0;key<ob.imageList.length;key++) {
                    image = $$stickerImageMap.create(ob.imageList[key], sticker.type, stickerSrcBaseUrl);
                    sticker.imageListMap.add(image.getKey(), image);
                }

                return {
                    sortBy: function () {
                        return sticker.categoryId;
                    },
                    isInstalled: function () {
                        return sticker.installed;
                    },
                    setInstalled: function (isInstalled) {
                        sticker.installed = isInstalled;
                    },
                    isEmoticon: function () {
                        return sticker.isEmoticon;
                    },
                    isLargeEmoticon: function () {
                        return sticker.isLargeEmoticon;
                    },
                    isSticker: function () {
                        return sticker.isSticker;
                    },
                    getKey: function () {
                        return sticker.categoryId;
                    },
                    getImages: function () {
                        return sticker.imageListMap;
                    },
                    getType: function () {
                        return sticker.type;
                    },
                    link: function () {
                        return sticker.regularUrl;
                    },
                    hoverLink: function () {
                        return sticker.hoverUrl;
                    }
                };
            }
        };
    }

    StickerFactory.$inject = ['$$stackedMap', '$$stickerMap', 'stickerHttpService', 'StickerEmoticonFactory', 'StickerHelper',
        'StickerCategoryModel', 'StickerCollectionModel',  'STICKER_IMAGE_TYPE', '$$q', 'Storage'];
    function StickerFactory($$stackedMap, $$stickerMap, stickerHttpService, StickerEmoticonFactory, StickerHelper, // jshint ignore:line
                            StickerCategoryModel, StickerCollectionModel,  STICKER_IMAGE_TYPE, $q, Storage) {

        var localStorageKey = 'stickerData';

        var myStickerLocalStorageKey = 'myStickers';

        /* Cashes All FactoryStickerObj By CategoryId */
        var allStickerIdMap = {};

        /* Cashes sticker details by catIds */
        var stickersByCatIdMap = {};

        /* Stores the sticker categories by group */
        var stickerCategories = {
            free : [],
            new : [],
            top : []
        };

        /* Stores sticker categories by collection id */
        var stickerCollections = {};

        /* Stores My Sticker CatIds */
        var myStickerList = {};


        /* $stickerMap holds the Emoticon and Sticker*/

        /* All Emoticon $stickerMap */
        var allEmoticon = StickerEmoticonFactory.getAllEmoticons();
        var emoticonMap = $$stickerMap.create(allEmoticon,true);

        /* All Sticker $stickerMap */
        //var allStickersMap = $$stickerMap.create(allEmoticon,true);

        var myStickerRefreshed = false;


        var initStickersByCatId = function(catId){
            var deferred = $q.defer();

            if(!stickersByCatIdMap[catId]){
                stickerHttpService.getStickersByCatId(catId)
                    .success(function(data){
                        if(!!data && data.sucs  === true){
                            StickerHelper.parseCategoryStickerData(data, stickersByCatIdMap, allStickerIdMap);
                            deferred.resolve(data);

                        }else{
                        }

                    }).error(function(response){
                        deferred.reject(response);
                    });
            }

            return deferred.promise;
        };

        function initCollectionCategories(collectionFactoryObject){

            /* Parses Collection Categories To PRE FETCH LIMIT
             *
             * Does API Request To Get Categories under a collections.
             *
             * */
            // todo add limit on this call if there are too many collections, paginate support

            try{

                var collectionId = collectionFactoryObject.getKey();

                stickerHttpService.getStickerCategoriesByCollectionId(collectionId)
                    .success(function(data){
                        if(!!data && data.sucs === true && !!data.categoriesList){

                            var categoryList = data.categoriesList;

                            if(angular.isArray(categoryList)){
                                angular.forEach(categoryList, function(aCategory){

                                    var keyString = aCategory[StickerCategoryModel.getKeyString()];
                                    var stickerCategoryFactoryObject = allStickerIdMap[keyString];

                                    if(!stickerCategoryFactoryObject){
                                        stickerCategoryFactoryObject = StickerCategoryModel.create(aCategory);
                                        allStickerIdMap[stickerCategoryFactoryObject.getKey()] = stickerCategoryFactoryObject;
                                    }

                                    collectionFactoryObject.addCategories(stickerCategoryFactoryObject.getKey());

                                });
                            }

                        }else{
                        }
                    }).error(function(response){
                    });

            }catch(e){
            }

        }

        function initStickerCollectionAndCategories(dataList){

            /* Parse Free Categories */
            try{
                angular.forEach(dataList.freeCategoriesList, function(aCategory){

                    var aStickerCategoryFactoryObject = StickerCategoryModel.create(aCategory);
                    allStickerIdMap[aStickerCategoryFactoryObject.getKey()] = aStickerCategoryFactoryObject;
                    stickerCategories.free.push(aStickerCategoryFactoryObject.getKey());

                });
            }catch(e){
            }

            /* Parse Top Categories */
            try{
                angular.forEach(dataList.topCategoriesList, function(aCategory){

                    var aStickerCategoryFactoryObject = StickerCategoryModel.create(aCategory);
                    allStickerIdMap[aStickerCategoryFactoryObject.getKey()] = aStickerCategoryFactoryObject;
                    stickerCategories.top.push(aStickerCategoryFactoryObject.getKey());

                });
            }catch(e){
            }

            /* Parse New Categories */
            try{
                angular.forEach(dataList.stNewCategoriesList, function(aCategory){

                    var aStickerCategoryFactoryObject = StickerCategoryModel.create(aCategory);
                    allStickerIdMap[aStickerCategoryFactoryObject.getKey()] = aStickerCategoryFactoryObject;
                    stickerCategories.new.push(aStickerCategoryFactoryObject.getKey());

                });
            }catch(e){
            }

            /* Parse Collections */
            try{
                angular.forEach(dataList.stickerCollectionsList, function(aCollection){

                    var aStickerCollectionFactoryObject = StickerCollectionModel.create(aCollection);

                    stickerCollections[aStickerCollectionFactoryObject.getKey()] = aStickerCollectionFactoryObject;

                    initCollectionCategories(aStickerCollectionFactoryObject);

                });
            }catch(e){
            }

        }

        function fetchAllStickerData(){
            stickerHttpService.getAll().
                success(function(data){
                    try{
                        if(!!data && data.sucs === true){
                            saveStickerData(data);
                            initStickerCollectionAndCategories(data);
                            initMyStickers();
                        }
                    }catch(e){
                    }

                }).error(function(response){
                });
        }

        function getStickerData(){
            try{
                return Storage.getData(localStorageKey);
            }catch(e){
                return false;
            }
        }

        function saveStickerData(data){
            Storage.setData(localStorageKey, data);
        }

        function saveMyStickers(){
            Storage.setData(myStickerLocalStorageKey, myStickerList);
        }

        function initMyStickers(){
            myStickerList = Storage.getData(myStickerLocalStorageKey);
            if(!myStickerRefreshed || !myStickerList) {
                myStickerList = {};
                stickerHttpService.getMyStickers().then(function(response){
                    if(response.sucs === true){
                        angular.forEach(response.catIds, function(aCatId){
                            myStickerList[aCatId] = 1;
                            if(!!stickersByCatIdMap[aCatId]) {
                                stickersByCatIdMap[aCatId].setInstalled(true);
                            }
                        });
                        saveMyStickers();
                    }
                });

            }
        }

        function initStickerData(allData){
            try{
                initStickerCollectionAndCategories(allData);
            }catch(e){
            }
        }

        function getStickerObjectById(stickerId) {
            try{
                return allStickerIdMap[stickerId];
            }catch(e){
                return {};
            }
        }

        return {

            initStickerData : function(refresh){
                if(refresh === true){
                    fetchAllStickerData();
                }else{
                    var localData = getStickerData();
                    if(!angular.isObject(localData)){
                        fetchAllStickerData();
                    }else{
                        initStickerData(localData);
                        initMyStickers();
                    }
                }

            },
            getNoOfMyStickers: function () {
                return myStickerList ? Object.keys(myStickerList).length : 0;
            },

            getStickerCategories : function(type){
              return type ? stickerCategories[type] : stickerCategories;
            },

            getStickerCollections : function(){
              return stickerCollections;
            },

            getMyStickerCatIds: function () {
                return myStickerList ? Object.keys(myStickerList) : [];
            },

            getStickerMapByCatId :function(catId){
                var deferred = $q.defer();

                if(!!stickersByCatIdMap[catId]){
                    deferred.resolve(stickersByCatIdMap[catId]);

                }else{
                    initStickersByCatId(catId).then(function(){
                        deferred.resolve(stickersByCatIdMap[catId]);

                    }, function(response){
                        deferred.reject(response);
                    });
                }
                return deferred.promise;

            },
            isDownloaded : function(stickerCatId){
                return !!myStickerList[stickerCatId];
            },

            getStickerCategoryObject: function (key) {
                return getStickerObjectById(key);
            },

            getEmoticonMap: function () {
                return emoticonMap;
            },

            getMyStickers : function(){
                return stickerHttpService.getMyStickers();
            },

            addMySticker: function (stickerCatId) {
                try{
                    myStickerList[stickerCatId] = 1;
                    saveMyStickers();

                    if(!!stickersByCatIdMap[stickerCatId]) {
                        stickersByCatIdMap[stickerCatId].setInstalled(true);
                    }

                }catch(e){
                }

                stickerHttpService.addSticker({catId: stickerCatId}).then(function (data) {
                    if(data.sucs !== true){
                        myStickerList[stickerCatId] = 0;
                        stickersByCatIdMap[stickerCatId].setInstalled(false);
                    }
                },function (errData) {

                });
            },
            removeMySticker: function (stickerCatId) {
                try{
                    delete myStickerList[stickerCatId];
                    saveMyStickers();

                    if(!!stickersByCatIdMap[stickerCatId]) {
                        stickersByCatIdMap[stickerCatId].setInstalled(false);
                    }

                }catch(e){
                }

                stickerHttpService.removeSticker({catId: stickerCatId}).then(function (data) {
                    if(data.sucs !== true){
                        myStickerList[stickerCatId] = 1;
                        stickersByCatIdMap[stickerCatId].setInstalled(true);
                    }
                },function (errData) {
                });

            }

        };
    }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.sticker')
        .directive('rgStickerCategory', rgStickerCategory);

        rgStickerCategory.$inject=['StickerFactory'];

        function rgStickerCategory(StickerFactory) {
            return {
                restrict: 'E',
                templateUrl: 'pages/partials/stickers/sticker-category.html',
                scope : {
                    categories : '=categories'
                },
                link: function(scope) {

                    scope.getStickerCategory = StickerFactory.getStickerCategoryObject;

                    scope.showPreview = function(stickerId) {
                        return function() {
                            return {stickerKey: stickerId};
                        };
                    };

                    scope.isInstalled = function(stickerId){
                        return StickerFactory.isDownloaded(stickerId);
                    };

                    scope.addSticker = function(stickerId) {
                        StickerFactory.addMySticker(stickerId);
                        scope.$rgDigest();
                    };

                    scope.removeSticker = function(stickerId) {
                        StickerFactory.removeMySticker(stickerId);
                        scope.$rgDigest();
                    };


                }
            };
        }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.sticker')

        .directive('rgStickerCategoryList',
        function () {
            return {
                restrict: 'E',
                templateUrl: 'pages/partials/stickers/sticker-category-list.html',
                scope : {
                    categories : '=categories'
                }
            };
        }
    )



})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.sticker')

        .directive('rgStickerCollectionList',
        function () {
            return {
                restrict: 'E',
                templateUrl: 'pages/partials/stickers/sticker-collection-list.html',
                scope : {
                    'collections' : '='
                },
                link: function(scope) {

                    scope.currentCollectionIdToShow = 0;

                    scope.shouldShowCollectionCategories = function(collectionId){
                        return scope.currentCollectionIdToShow == collectionId;
                    };

                    scope.showCollectionCategories =  function(collectionId){
                        scope.displayingCollections = !scope.displayingCollections;
                        scope.currentCollectionIdToShow = collectionId;
                        scope.$rgDigest();
                    };

                    scope.displayingCollections = true;
                }
            };
        }
    );



})();


(function() {
    'use strict';

    angular
        .module('ringid.utils',[
            'ringid.config',
            'rg.custom.compiler.directive',
            //'ringid.common.stacked_map',
            'ringid.sticker',
            //'rg.custom.compiler.directive'
        ]);


})();

(function () {
    'use strict';
    var app;
      
      angular.module('rg.custom.compiler.directive', [], ['$compileProvider',function($compileProvider) {
    // configure new 'compile' directive by passing a directive
    // factory function. The factory function injects the '$compile'
    $compileProvider.directive('rgCompile', ['$compile',function($compile) {
      // directive factory creates a link function
      return function(scope, element, attrs) {
        
        scope.$watch(
          function(scope) {
             // watch the 'compile' expression for changes
            return scope.$eval(attrs.rgCompile);
          },
          function(value) {
            // when the 'compile' expression changes
            // assign it into the current DOM
            element.html(value);

            // compile the new DOM and link it to the current
            // scope.
            // NOTE: we only compile .childNodes so that
            // we don't get into infinite loop compiling ourselves
            $compile(element.contents())(scope);
          }
        );
      };
    }]);
  }]);

})();

(function() {
    'use strict';
    var app;
    app = angular.module('ringid.utils');

    app.factory('utilsFactory',utilsFactory);

    utilsFactory.$inject = ['$window','$document','APP_CONSTANTS', 'settings', '$filter','Storage','StickerEmoticonFactory', 'StickerEmoticonService', 'RING_ROUTES','MESSAGES', '$ringhttp', '$$q','Storage','$rootScope','SystemEvents','$location'];

    function utilsFactory($window,$document,APP_CONSTANTS, settings, $filter,StorageFactory,StickerEmoticonFactory,StickerEmoticonService, RING_ROUTES, MESSAGES, $ringhttp, $q,Storage,$rootScope,SystemEvents,$location){

        var self = this,

            returnOb = {},
        //urlPattern = /((http|ftp|https):)?\/\/[\w-]+(\.[\w-]+)+([\w.,@?^=%&amp;:\/~+#-]*[\w@?^=%&amp;\/~+#-])?/gi,
        //    urlPattern = /[(http(s)?):\/\/(www\.)?a-zA-Z0-9@:\-%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/gi,
            urlPattern = /(((http|https):\/{2})?((([0-9a-z_-]+\.)+(aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mn|mn|mo|mp|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|nom|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ra|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw|arpa)|(0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])))(:[0-9]+)?((\/([~0-9a-zA-Z\#\+\%@\.\/_-]+))?(\?[0-9a-zA-Z\.\+\%@\/&\[\];=_-]+)?(\?[\w|\W]+)?)?))\b/im,

            emopattern = StickerEmoticonFactory.getEmoticonPattern(),
            Emomapper = StickerEmoticonService.getEmoticonMap();

        var viewportsize = function() {
            var w = $window,
                d = $document,
                e = d[0].documentElement,
                g = d[0].getElementsByTagName('body')[0],
                x = w.innerWidth || e.clientWidth || g.clientWidth,
                y = w.innerHeight|| e.clientHeight|| g.clientHeight,
                yo = w.pageYOffset;
            return {x:x,y:y,yo:yo};
        };
        //  console.dir($window.Math);
        /**
         * @description : convert html entity to text.
         */
        var htmlentityencode = function(html){ //
            return String(html).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        };
        var addHttps = function(url){
            if (!/^(f|ht)tps?:\/\//i.test(url)) {
                url = "http://" + url;
            }
            return url;
        };
        /**
         * @description text perser for link and emoticon
         * @param text
         * @returns converted text as html
         */
        var textParseForLinkAndEmo = function(text, flag){
            //if(/<[a-z][\s\S]*>/i.test(text)){
            text = htmlentityencode(text);
            //}

            var out=text;
            var utfEmo = /\ud83d[\udc00-\ude4f]|\ud83d[\ude80-\udeff]/g;

            if(!flag){
                flag = 0;
            }

            // for temp uploaded image file starts
            if(out.substring(0,9) === 'blob:http'){// this was for tempImage; actionObj.imageSource was being used
                //if(text.substring(0,22) == 'data:image/jpeg;base64'){// this is now for tempImage; getPreview() is being used
                out = '<img width="100%" src="' + out + '" />';
                flag = 2;
            }
            // for temp uploaded image file ends

            if(flag === 0){
                //replacing the link
                out =  out.replace(urlPattern, function(match) {
                    var url = addHttps(match);
                    return '<a class="feedanchor" target="_blank" href="' + url + '"> ' + match + '</a>';
                });//replacing the link
            }

            out =  out.replace(emopattern, function(match) {
                //var img = new Image();
                //img.src = Emomapper[match];
                return '<span class="em_list '+Emomapper[match].replace(/\.[A-Za-z]{3}/,'')+'" data-link="'+match+'" title="' + match + '">&nbsp;</span>';
            });//replacing the emo

            /* utf emoticon */
            if(!window.emojiSupported) {
                out =  out.replace(utfEmo, function(match) {
                    var hi, low, hex;
                    hi = match.charCodeAt(0);
                    low = match.charCodeAt(1);
                    hex = (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000).toString(16);
                    return '<u class="emo_list U_'+hex+'"></u>';
                });
            }
            if(flag === 1){
                out = text;
            }
            return out;
        };

        var getUniqueId = function(prefix){
            if (!prefix){
                prefix = '';
            }

            return prefix + (window._cti|| "") + $window.Math.floor($window.Math.random() * (new $window.Date()).getTime());
        };

        var hasEmoticon = function(text){
            var utfEmo = /\ud83d[\udc00-\ude4f]|\ud83d[\ude80-\udeff]/g;

            if(!text){
                return false;
            }else{
                return utfEmo.test(text) || emopattern.test(text);
            }
        };



        var getGoogleMapStaticUrl = function (lat, lng, title) {
            if( !title ){
                title = "({0},{1})".format(lat,lng);
            }

            var url = "https://maps.googleapis.com/maps/api/staticmap?center={0},{1}&zoom=18&size=640x170&key={3}&markers=color:orange|label:A|{2}|{0},{1}";
            url = url.format(lat, lng, title, APP_CONSTANTS.GOOGLE_MAP_KEY);
            return url;
        };

        var getGoogleMapJSUrl = function (lat, lng, location, embed) {
            var url;
            if(!lat || !lng){
                url = "http://maps.google.com?q={0}".format(location)
            }else{
                url = "https://maps.google.com/maps?q={0},{1}&hl=en;z=18;iwd=1".format(lat, lng);
            }

            if(!!embed){
                url += "&output=embed";
            }

            return url;
        };



        //};



        function getDefaultColumn(){
            if(!returnOb.viewport){
                returnOb.viewport = viewportsize();
            }
            var windowWidth = returnOb.viewport.x;

            if(windowWidth < 1280) { // device between 720 and 980
                return 1;
            }else if(windowWidth >= 1280 && windowWidth <=1800){
                return 2;
            }else if(windowWidth > 1800){
                if($location.path() == "/" ){
                    return 3;
                }else{
                    return 2;
                }
                
            }
        }

        function feedColumn(){
            var default_col = getDefaultColumn();
            var col = parseInt(Storage.getCookie('col'));
            if(!col || col > default_col){
                default_col = default_col > 2 ? 2 : default_col;
                //Storage.setCookie('col',default_col);
                return default_col
            }
            return col;

        }

        //function availableCellWidthByWindow(feedCol){
            //return (returnOb.viewport.x - (APP_CONSTANTS.LEFT_BAR_WIDTH + APP_CONSTANTS.RIGHT_BAR_WIDTH + (feedCol * APP_CONSTANTS.CELL_MARGIN)))/feedCol;
        //}

        function cellWidthByCss(col){
            // from media css
            var width = returnOb.viewport.x;
            if(col ===1 && width >=1280){
                return 600;
            }
            if(width >= 768 && width <= 799){ //col =1
                return 329;
            }else if(width >=800 && width <= 979){ // col =1
                return 361;
            }else if(width >=980 && width <= 1279){//col 1 and 2
                return 541;
            }else if(width >=1280 && width <= 1349){//col = 2
                return 423;
            }else if(width >=1350 && width <= 1399){//col = 2
                return 458;
            }else if(width >=1400 && width <= 1499){//col = 2
                return 475;
            }else if(width >=1500 && width <= 1649){//col = 2
                return 510;
            }else if(width >=1650 && width <= 1799){//col = 2
                return 560;
            }else if(width <= 1920){//col 3
                return 487;
            }else if(width <= 2650){//col 3
                return 487;
            }else{
                return 500;
            }
        }

        function FeedCellWidth(){
            var feedCol = feedColumn();
            feedCol = parseInt(feedCol);
            if(feedCol === 1){
                return 600;
            }else{
                return cellWidthByCss(feedCol);
            }
            //     availableWidthByWindow = cellWidthByCss(feedCol);

            // if(feedCol == 1){
            //     cellWidth = availableWidthByWindow > 500 ? 500 : availableWidthByWindow;
            // }else if(feedCol == 2){
            //     cellWidth = availableWidthByWindow > 475 ? 475 : availableWidthByWindow;
            // }else if(feedCol == 3){
            //     cellWidth = availableWidthByWindow > 440 ? 440 : availableWidthByWindow;
            // }


            // return cellWidth;
        }

        function _getOGDetails(url){
            return $ringhttp.get(settings.ogServiceUrl + '?url=' + encodeURIComponent(url));
        }

        function _getReasonMessageFromResponse(responseObj){
            if(!!responseObj.mg){
                return responseObj.mg;
            }else{
                return _getReasonMessage(responseObj.rc);
            }
        }

        function _getReasonMessage(reasonCode){
            if(!!MESSAGES['RC' + reasonCode]){
                return MESSAGES['RC' + reasonCode];
            }

            return "";
        }

        function _debounce(func, wait, immediate) {
            var timeout;
            return function() {
                var context = this, args = arguments;
                var later = function() {
                    timeout = null;
                    if (!immediate){ func.apply(context, args); }
                };
                var callNow = immediate && !timeout;
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                if (callNow) {
                    func.apply(context, args);
                }
            };
        }

        function _getImageUrlDimension(imgUrl){
            var defer = $q.defer();

            var img = new Image();
            img.onload = function() {
                defer.resolve({imgUrl: this.src, width : this.width, height: this.height});
            };
            img.src = imgUrl;

            setTimeout(function(){
                defer.resolve({width : 0, height: 0});
            }, 30000);

            return defer.promise;

        }

        function _dataURLToBlob(dataURL) {
            var BASE64_MARKER = ';base64,',
                parts,
                contentType,
                binary;

            if (dataURL.indexOf(BASE64_MARKER) == -1) {
                parts = dataURL.split(',');
                contentType = parts[0].split(':')[1];
                binary = decodeURIComponent(parts[1]);

                return new Blob([binary], {type: contentType});
            }

            parts = dataURL.split(BASE64_MARKER);
            contentType = parts[0].split(':')[1];
            binary = window.atob(parts[1]);

            var uInt8Array = new Uint8Array(binary.length);

            for (var i = 0; i < binary.length; ++i) {
                uInt8Array[i] = binary.charCodeAt(i);
            }

            return new Blob([uInt8Array], {type: contentType});

        }

        function _filterImagesByDimentions(imageUrls, lowestDimension){
            var defer = $q.defer();

            var allImageDimensionPromises = [];
            var filteredImages = [];

            if(!lowestDimension.width){
                lowestDimension.width = 0;
            }

            if(!lowestDimension.height){
                lowestDimension.height = 0;
            }


            angular.forEach(imageUrls, function(anImageUrl){
                setTimeout(function(){

                    _getImageUrlDimension(anImageUrl).then(function(anImageDimension){
                        var widthValid, heightValid;

                        if( !!anImageDimension.width && ( anImageDimension.width >= lowestDimension.width ) ){
                            widthValid = true;
                        }

                        if( !!anImageDimension.height && ( anImageDimension.height >= lowestDimension.height ) ){
                            heightValid = true;
                        }

                        if(!!widthValid && !!heightValid){
                            filteredImages.push(anImageDimension.imgUrl);
                            if( filteredImages.length == imageUrls.length ){
                                defer.resolve(anImageDimension.imgUrl);
                            }else{
                                defer.notify(anImageDimension.imgUrl);
                            }
                        }
                    });
                });        
            });

            // $q.all(allImageDimensionPromises).then( function(allImageDimensions){
            //     console.log(allImageDimensions);
            //     angular.forEach(allImageDimensions, function(anImageDimension){
            //         var widthValid, heightValid;

            //         if( !!anImageDimension.width && ( anImageDimension.width >= lowestDimension.width ) ){
            //             widthValid = true;
            //         }

            //         if( !!anImageDimension.height && ( anImageDimension.height >= lowestDimension.height ) ){
            //             heightValid = true;
            //         }

            //         if(!!widthValid && !!heightValid){
            //             filteredImages.push(anImageDimension.imgUrl);
            //         }

            //     });

            //     return defer.resolve(filteredImages);

            // });

            setTimeout(function(){ 
                if( filteredImages.length == 0){
                    defer.resolve([]);
                }                
            },20000);

            return defer.promise;

        }

        function _callXTimeAfterYIntervalStopOnSuccess(callback, successChecker, onFailCallback, maxExecutionCount, interval){
            var currentExecutionCount = 0;

            var doExecute = function(){
                if( !currentExecutionCount || ( currentExecutionCount < maxExecutionCount && !successChecker.call(null, currentExecutionCount) ) ){

                    callback.call();
                    currentExecutionCount++;
                    setTimeout(doExecute, interval);

                }else{

                    if(!successChecker.call(null, currentExecutionCount)){
                        onFailCallback.call();
                    }
                }
            };

            doExecute();
        }

        function _executeAfterX(func, wait, immidiate){
            if(!immidiate){
                setTimeout(func, wait);
            }else{
                func.call();
            }
        }

        function _executeXTimesAfterY(func, wait, immidiate, noOfTimes){
            var count = 0, intervalRef;

            if(!noOfTimes){
                noOfTimes = GENERAL_CONSTANTS.API_FETCH_RETRY_COUNT;
            }

            if(!!immidiate){
                func.call();
                count = 1;
            }

            intervalRef = setInterval(function(){
                count++;
                func.call();
                if( count === noOfTimes ){
                    clearInterval(intervalRef);
                    console.log('Interval Cleared');
                }
            }, wait);

        }


        var _requestMultipleTime = function(func, args){

            var defer = $q.defer();
            var success = false;

            _callXTimeAfterYIntervalStopOnSuccess(function(){

                var response = func.apply(this, args);

                if(!!response.then){

                    response.then(function(response){
                        success = true;
                        defer.resolve(response);

                    }, function(response){
                        success = true;
                        defer.reject(response);
                    });

                }else{
                    defer.reject({sucs :false, rc : 'Invalid' });
                }

            }, function(){

                return success;

            }, function(){
                if( !success){
                    defer.reject({timeout : true, sucs :false })
                }
            }, 5, 3000);

            return defer.promise;
        };

        function _triggerCustomEvent(eventName, data){
            var event = document.createEvent('Event');
            event.initEvent(eventName, true, true);
            event.data = data;
            document.dispatchEvent(event);
        }

        //function _onCustomEvent(eventName, callback){
        //    document.addEventListener(eventName, function(response){
        //        callback.call(this, response.data);
        //    });
        //
        //}
        function _onCustomEvent(eventName, callback){
            var funcRef = function(response){
                callback.call(this, response.data);
            };

            document.addEventListener(eventName, funcRef);

            return funcRef;

        }

        function _removeCustomEvent(eventName, callback){
            document.removeEventListener(eventName, callback);
        }

        //function _extendIfSet(target, firstSource){
        //    var targetKeys = Object.keys(target);
        //
        //    for(var index = 0; index < targetKeys.length; index++){
        //        var aTargetKey = targetKeys[index];
        //        if( !!firstSource[aTargetKey] ){
        //            target[aTargetKey] = firstSource[aTargetKey];
        //        }
        //    }
        //
        //    return target;
        //
        //}
        /**
         * return current selected range from current input. if nothing selected and cursor focusing some element its return current cursor point
         *
         */
        function getSelection() {
            var sel;
            sel = window.getSelection();
            if (sel.getRangeAt) {

                return sel.getRangeAt(0);

            } else if (document.selection && document.selection.createRange) {
                var range = document.createRange();
                range.setStart(selection.anchorNode, selection.anchorOffset);
                range.setEnd(selection.focusNode, selection.focusOffset);
                return range;
            }
            return null;
        }

        function _string2ArrayBuffer(str) {
            var arr = str.split(","),
                view = new Uint8Array( arr );
            return view.buffer;
        }

        function _arrayBuffer2String(buf) {
            var view = new Uint8Array( buf );
            return Array.prototype.join.call(view, ",");
        }

        function safeDigest($scope){
            if ( $scope.$parent && $scope.$parent.$id !== 1){
                $scope.$parent.$rgDigest();
            }else{
                $scope.$rgDigest();
            }
        }

        function generateUUID() {
            var d = new Date().getTime();
            if(window.performance && typeof window.performance.now === "function"){
                d += performance.now(); //use high-precision timer if available
            }
            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = (d + Math.random()*16)%16 | 0;
                d = Math.floor(d/16);
                return (c=='x' ? r : (r&0x3|0x8)).toString(16);
            });
            return uuid;
        }

        var animationStart, animationCurrentTime, animationChange, animationDuration = 500;

        function _resetScroll() {
            animationStart = document.documentElement.scrollTop || document.body.parentNode.scrollTop || document.body.scrollTop,
            animationCurrentTime = 0,
            animationChange = (-1)*animationStart;
        }

        function _animateScroll() {

                animationCurrentTime += 25;
                var val = Math.easeIn(animationCurrentTime, animationStart, animationChange, animationDuration);

                document.documentElement.scrollTop = val;
                document.body.parentNode.scrollTop = val;
                document.body.scrollTop = val;

                if (animationCurrentTime < animationDuration) {
                     requestAnimationFrame(_animateScroll);
                }
        }

        function getScrollBarWidth() {

                var inner = document.createElement('p');
                inner.style.width = "100%";
                inner.style.height = "200px";

                var outer = document.createElement('div');
                outer.style.position = "absolute";
                outer.style.top = "0px";
                outer.style.left = "0px";
                outer.style.visibility = "hidden";
                outer.style.width = "200px";
                outer.style.height = "150px";
                outer.style.overflow = "hidden";
                outer.appendChild(inner);

                document.body.appendChild(outer);
                var w1 = inner.offsetWidth;
                outer.style.overflow = 'scroll';
                var w2 = inner.offsetWidth;

                if (w1 == w2) {
                    w2 = outer.clientWidth;
                }

                document.body.removeChild(outer);
                inner = outer = null;
                return (w1 - w2);
        }

        function _getUserLocation(geocode){

            var defer = $q.defer();
            var returnPromise = defer.promise;

            //Check Local Does Local Storage Contains Values
            var locationInfo = Storage.getData('uLocationInfo');
            if( !!locationInfo && !!locationInfo.lat ){
                locationInfo['sucs'] = true;
                returnPromise = locationInfo;

            }else{

                // if the browser supports the w3c geo api
                if(navigator.geolocation){
                  // get the current position
                  navigator.geolocation.getCurrentPosition(

                  // if this was successful, get the latitude and longitude
                  function(position){
                    var lat = position.coords.latitude;
                    var lng = position.coords.longitude;

                    var latLng = {lat : lat, lng: lng }
                    if( !!geocode ){
                        var geocoder = new google.maps.Geocoder;
                        geocoder.geocode({'location': latLng}, function(results, status) {
                            if (status === google.maps.GeocoderStatus.OK) {
                                
                                Storage.setData('uLocationInfo', {lat : lat, lng: lng, description : results[1].formatted_address})

                                defer.resolve({sucs: true, lat : lat, lng : lng, description : results[1].formatted_address});

                            }else{
                                
                                Storage.setData('uLocationInfo', {lat : lat, lng: lng})
                                
                                defer.resolve({sucs: true, lat : lat, lng : lng});
                            }
                        });

                    }else{

                        Storage.setData('uLocationInfo', {lat : lat, lng: lng})

                        defer.resolve({sucs: true, lat : lat, lng : lng});
                    }
                    
                  },
                  // if there was an error
                  function(error){
                    defer.resolve({sucs: false, error : error })
                  });
                }

            }

            return $q.when(returnPromise);
        }


        returnOb =  {

            generateUUID                         : generateUUID,

            getRingRoute                         : getRingRoute,
            getOGDetails                         : _getOGDetails,
            getReasoneMessage                    : _getReasonMessage,
            getReasonMessageFromResponse         : _getReasonMessageFromResponse,
            debounce                             : _debounce,
            tabId                                : window._cti,
            //getTabId                           : getTabId,
            animateScroll                        : _animateScroll,
            resetScroll                          : _resetScroll,

            viewport                             : viewportsize(),
            viewportsize                         : viewportsize,
            scrollbarWidth                       : getScrollBarWidth(),
            feedCellWidth                        : FeedCellWidth(),
            string2ArrayBuffer                   : _string2ArrayBuffer,
            arrayBuffer2String                   : _arrayBuffer2String,

                   
            feedColumn                           : feedColumn,
            getDefaultColumn                     : getDefaultColumn,
            getToken                             : '234', //$document[0].getElementById('sectoken').getAttribute('data-sec'),
            getUserLocation                      : _getUserLocation,

            getImageUrlDimension                 : _getImageUrlDimension,
            filterImagesByDimentions             : _filterImagesByDimentions,
            dataURLToBlob                        : _dataURLToBlob,
            callXTimeAfterYIntervalStopOnSuccess : _callXTimeAfterYIntervalStopOnSuccess,
            executeAfterX                        : _executeAfterX,
            executeXTimesAfterY                  : _executeXTimesAfterY,
            requestMultipleTime                  : _requestMultipleTime,
            triggerCustomEvent                   : _triggerCustomEvent,
            onCustomEvent                        : _onCustomEvent,
            removeCustomEvent                    : _removeCustomEvent,
            getSelection                         : getSelection,
            getGoogleMapStaticUrl                : getGoogleMapStaticUrl,
            getGoogleMapJSUrl                    : getGoogleMapJSUrl,

            hasEmoticon                          : hasEmoticon,
            safeDigest                           : safeDigest,

            setFeedCellWidth : function(){
                returnOb.feedCellWidth = FeedCellWidth();
            },
            hasSocket : function(){
                return true;
                //console.log($localStorage.socketon);
                //console.log($localStorage.loginData.socketOn);
                //return $localStorage.loginData && !!$localStorage.loginData.socketOn;
            },
            parseForLE : function(text, flag){ // prases for link and emoticon
                return textParseForLinkAndEmo(text, flag);
            },
            init:function(){
                //returnOb.viewport = viewportsize();
            },

            setFeedColumn : function(num){
                Storage.setCookie('col',parseInt(num));
            },
            getUniqueID: function (prefix) {
                return getUniqueId(prefix);
            },
            getRandomString: function(length) {
                var result = '',
                    chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

                for (var i = length; i > 0; --i) {
                    result += chars[Math.round(Math.random() * (chars.length - 1))];
                }

                return result;
            },
            chatVerbalDate: function(timestamp){
                //return $filter('date')(timestamp,"MMM d, yyyy 'at' h:mm a");
                return $filter('date')(timestamp,"h:mm a");
            },
            profileVerbalDate: function(timestamp){
                return $filter('date')(timestamp,"yyyy-MM-dd");
            },
            verbalDate : function(timestamp,fromTimeStamp){
                var date,diff,day_diff,Math = $window.Math,today = new Date();

                fromTimeStamp = fromTimeStamp || Date.now();

                if(isNaN(timestamp)){
                    date = new Date((timestamp || "").replace(/-/g,"/").replace(/[TZ]/g," ")),
                        timestamp = date.getTime();
                }else{
                    date = new Date(timestamp);
                }
                diff = ((fromTimeStamp - timestamp) / 1000);//diff in second
                day_diff = Math.floor(diff / 86400);// 1 day = 86400 second// its calculate diff in day
                // if ( isNaN(day_diff) || day_diff < 0 )
                if (isNaN(day_diff))
                    return "";
                switch (true){
                    case day_diff < 1: // time is equal from date
                        switch(true){
                            case diff < 60:
                                return "just now";
                            case diff < 120 :
                                return "1 minute ago";
                            case diff < 3600 : // within a hour
                                return Math.floor( diff / 60 ) + " minutes ago";
                            case diff < 7200 :
                                return "1 hour ago";
                            case diff < 86400 : //within a day show as minute
                                return Math.floor( diff / 3600 ) + " hours ago";
                            default :
                                return $filter('date')(timestamp,"MMM d, h:mm a");
                        }
                        break;
                    case day_diff === 1 : // 1 day before from date
                        return "yesterday at "+ $filter('date')(timestamp,"h:mm a");
                    case day_diff < 7 :
                        return $filter('date')(timestamp,"EEEE 'at' h:mm a");
                    case day_diff < 365 :
                       if(today.getUTCFullYear() === date.getUTCFullYear()){
                            return $filter('date')(timestamp,"MMMM d 'at' h:mm a");
                       }
                        return $filter('date')(timestamp,"MMMM d yyyy 'at' h:mm a");
                    default :
                        return $filter('date')(timestamp,"MMM d, yyyy");
                }
            }

           
        };





        ////////////////////////////


        function getRingRoute(name, params){

            if( !RING_ROUTES[name] )
                return '';

            var routeString = RING_ROUTES[name];

            switch (name){
                case 'HOME':
                case 'FAQ' :
                    break;

                case 'SINGLE_FEED':
                    if( !!params['feedId']){
                        routeString =  routeString.replace(':feedId', params['feedId']);
                    }

                    var shared = !!params['shared'] ? 'shared' : '';
                    routeString =  routeString.replace(':shared?', shared );

                    var commentId;
                    if( !!shared){
                        commentId = params['commentId'] || 0;
                        routeString =  routeString.replace(':commentId?', commentId);
                    }else{
                        commentId = params['commentId'] || '';
                        routeString =  routeString.replace(':commentId?/', commentId);
                    }


                    break;

                case 'WHO_SHARED_FEED' :
                    if( !!params['feedId']){
                        routeString =  routeString.replace(':feedId', params['feedId']);
                    }

                    var commentId = params['commentId'] || '';
                    routeString =  routeString.replace(':commentId?', commentId);

                    break;


                case 'SINGLE_IMAGE':
                    if( !!params['imageId']){
                        routeString = routeString.replace(':imageId', params['imageId']);
                    }

                    var commentId = params['commentId'] || '';
                    routeString =  routeString.replace(':commentId?', commentId);

                    break;

                case 'SINGLE_MEDIA':
                    if( !!params['mediaId']){
                        routeString = routeString.replace(':mediaId', params['mediaId']);
                    }

                    var commentId = params['commentId'] || '';
                    routeString =  routeString.replace(':commentId?', commentId);

                    break;
                case 'USER_PROFILE':
                    if( !!params['uId']){
                        routeString = routeString.replace(':uId', params['uId']);
                    }else{

                    }

                    if( !!params['utId']){
                        routeString = routeString.replace(':utId', params['utId']);
                    }else{
                        routeString = routeString.replace('/:utId', '');
                    }

                    if( !!params['albumId']){
                        routeString = routeString.replace(':albumId?', params['albumId']);
                    }else{
                        routeString = routeString.replace('/:albumId?', '');
                    }
                    break;

                case 'CIRCLE_HOME':
                    if( !!params['circleId']){
                        routeString = routeString.replace(':circleId', params['circleId']);
                    }
                    break;


            }

            if( !!params['subpage']){
                routeString = routeString.replace(':subpage?', params['subpage']);
            }else{
                routeString = routeString.replace('/:subpage?', '');
            }

            return '/#' + routeString;

        }

        function ResizeProcessor() {
            // moved here from rg-resize directive
                    requestAnimationFrame(function() {
                      
                          var newValue =returnOb.viewportsize();

                          $rootScope.windowHeight = newValue.y;
                          $rootScope.windowWidth = newValue.x;
                          returnOb.viewport.x = newValue.x;
                          returnOb.viewport.y = newValue.y;
                          returnOb.viewport.yo = newValue.yo;
                          returnOb.setFeedCellWidth();

                          $rootScope.$broadcast(SystemEvents.COMMON.WINDOW_RESIZED,returnOb.viewport);

                    });
                  
              }

             var wEl = angular.element($window);

             wEl.bind('resize',ResizeProcessor);   



        return returnOb;




    }




})();

(function () {
    'use strict';
    var app;
    app = angular.module('ringid.utils');

    app.directive('rgKeyUp',function(){
        return function(scope,element,attr){
            function process(e){
                try{
                 scope[attr.rgKeyUp](e);
                 scope.$rgDigest();
                }catch(err){
                }
            }
            element.bind("keyup",process);
            scope.$on('$destroy', function(){
                element.unbind("keyup",process)
            });
         };
    });

    app.directive('rgKeyPress',function(){
        return function(scope,element,attr){
            function process(e){
                try{
                 scope[attr.rgKeyUp](e);
                 scope.$rgDigest();
                }catch(err){
                }
            }
            element.bind("keypress",process);
            scope.$on('$destroy', function(){
                element.unbind("keypress",process)
            });
         };
    });
        
    app.directive('rgScroll',rgScroll);
    rgScroll.$inject = ['utilsFactory','$window'];
    function rgScroll (utilsFactory,$window) {
        return function (scope,element,attr) {

             var wEl = angular.element($window);

             wEl.bind('scroll', function () {

                    requestAnimationFrame(function() {
                      
                          var newValue =utilsFactory.viewportsize();

                          utilsFactory.viewport.x = newValue.x;
                          utilsFactory.viewport.y = newValue.y;
                          utilsFactory.viewport.yo = newValue.yo;
                    });
                  
              });   
        }
    };     

})();

(function() {
    'use strict';

    angular
        .module('ringid.syncher',[
            //'ringid.common.stacked_map',
            'ringid.utils'
        ])
        .factory('$$rgsyncher',rgSynchar);

        rgSynchar.$inject = ['$$stackedMap','$rootScope', 'utilsFactory']; // injecting rootscope to digest changes

        function rgSynchar($$stackedMap,$rootScope, utilsFactory){
            /*
            * rgSynchar
            *
            *
            * */

            var syncfns = $$stackedMap.createNew();

            var _synch = function(){//to manually fire focus event
                if(syncfns.length() > 0)
                    process();
            };

            var process = function(){
                var scopeToDigest;
                syncfns.doForAll(function(fn){
                    scopeToDigest = fn.call(null); // fn should return scope to digest if any changes occurs
                    if(!!scopeToDigest && !scopeToDigest.$$phase){
                        scopeToDigest.$digest();//safe digesting the current scope
                    }
                });
            };

            $rootScope.$on('ringActive', _synch);

            return {
                add : function(fn){
                    var key = utilsFactory.getUniqueID();
                    syncfns.add(key,fn);
                    return key
                },
                remove : function(key){
                    return syncfns.remove(key);
                },
                synch : _synch
            };
        }


})();

(function(DataView,String) {// placing dataview and String globals to locals for better performance
    'use strict';
    angular
        .module('ringid.connector', [
            'ngWebSocket',
            'ringid.utils',
            'ringid.config',
            //'ringid.common.stacked_map',
            'ringid.syncher'])

})(DataView,String);

(function() {
    'use strict';
    angular
    .module('ringid.connector')
    //.factory('RingParser',RingParser) // header parser
    //.service('parserService', parserService)//broken packet parser
    .service('mergerService', mergerService);//broken packet parser

    // RingParser.$inject = ['ATTRIBUTE_CODES', 'parserService'];
    // function RingParser(ATTRIBUTE_CODES, parserService){ //jshint ignore:line
    //     var ReturnObject,packetDataStorage={};// for accessing from self property assigning to be returned object to a variable
    //     var ByteParsers = {};

    //     var parseHeader = function(dataViewObject, offset){
    //         var index,len,attribute,headerObject={},val;//offset = offset || 1;

    //         for(index=offset;index<dataViewObject.byteLength;){
    //             attribute = dataViewObject.getUint16(index);// reading int from 2 byte
    //             index +=2;// so increasing the index to two
    //             len = dataViewObject.getUint8(index++);// one byte of length
    //             //val = dataViewObject.getInt16(index);
    //             val = dataViewObject.getIntByByte(index,len);
    //             switch(attribute){
    //                 case ATTRIBUTE_CODES.ACTION:// one byte
    //                     headerObject.actn = val;
    //                     break;
    //                 case ATTRIBUTE_CODES.SERVER_PACKET_ID:
    //                     headerObject.pckFs = val;
    //                     break;
    //                 case ATTRIBUTE_CODES.CLIENT_PACKET_ID:
    //                     headerObject.pckId = dataViewObject.getString(index,len);
    //                     break;
    //                 case ATTRIBUTE_CODES.WEB_UNIQUE_KEY:// TODO : find use
    //                     break;
    //                 case ATTRIBUTE_CODES.WEB_TAB_ID:
    //                     headerObject.tabId = val;
    //                     break;
    //                 case ATTRIBUTE_CODES.AUTHIP:
    //                     headerObject.authServer = dataViewObject.getString(index,len);
    //                     break;
    //                 case ATTRIBUTE_CODES.AUTHPORT:
    //                     headerObject.comPort = val;
    //                     break;
    //                 case ATTRIBUTE_CODES.AUTH_E_USERNAME:
    //                     headerObject.authEUsername = dataViewObject.getString(index,len);
    //                     break;
    //                 case ATTRIBUTE_CODES.AUTH_E_PASSWORD:
    //                     headerObject.authEPassword = dataViewObject.getString(index,len);
    //                     break;
    //                 case ATTRIBUTE_CODES.AUTH_E_SALT:
    //                     headerObject.authESalt = dataViewObject.getString(index,len);
    //                     break;
    //                 case ATTRIBUTE_CODES.TOTAL_PACKET:
    //                     headerObject.total = val;//total number of packet int
    //                     break;

    //                 case ATTRIBUTE_CODES.PACKET_NUMBER:
    //                     headerObject.current = val;//current number of packet int
    //                     break;

    //                 case ATTRIBUTE_CODES.UNIQUE_KEY:
    //                     headerObject.key = val;//packet Identification number long
    //                     break;
    //                 default:
    //                     index -=3;// we readed attribute and len for three byte so fallback three bytes because there is no match for header tag
    //                     headerObject.headerLength = index;// setting header length
    //                     return headerObject;
    //             }
    //             // if not returning from switch case, its means we find a match for header variable so moving index to len byte
    //             index += len;
    //         }
    //         return headerObject;

    //     };

    //     var parseBrokenPacketHeader = function(dataViewObject,offset){
    //         var index,len,attribute,
    //             headerObject = {//defaults values
    //                 actn : 0,
    //                 pckFs : 0,
    //                 total : 0,
    //                 current:0,
    //                 key :0
    //             },val;offset = offset || 1;

    //         for(index=offset;index<dataViewObject.byteLength;){
    //             attribute = dataViewObject.getUint8(index++);// reading int from 1 byte

    //             len = dataViewObject.getUint8(index++);// one byte of length
    //             val = dataViewObject.getIntByByte(index,len);
    //             //val = dataViewObject.getInt32(index);
    //             switch(attribute){
    //                 case ATTRIBUTE_CODES.ACTION:// one byte
    //                     headerObject.actn = val;//int
    //                     break;

    //                 case ATTRIBUTE_CODES.SERVER_PACKET_ID:
    //                     headerObject.pckFs = val;//long
    //                     break;

    //                 case ATTRIBUTE_CODES.TOTAL_PACKET:
    //                     headerObject.total = val;//total number of packet int
    //                     break;

    //                 case ATTRIBUTE_CODES.PACKET_NUMBER:
    //                     headerObject.current = val;//current number of packet int
    //                     break;

    //                 case ATTRIBUTE_CODES.UNIQUE_KEY:
    //                     headerObject.key = val;//packet Identification number long
    //                     break;

    //                 case ATTRIBUTE_CODES.DATA:
    //                     // for data len is in two byte so for returning to previsous byte
    //                     index--;
    //                     len = dataViewObject.getUint16(index);//reading int from two byte
    //                     index +=2;//incresing it by two byte
    //                     headerObject.data = dataViewObject.copy(index,len);
    //                     break;

    //                 case ATTRIBUTE_CODES.WEB_UNIQUE_KEY:// TODO : find use
    //                     break;
    //                 case ATTRIBUTE_CODES.WEB_TAB_ID:
    //                     headerObject.tabId = val;
    //                     break;

    //                 default:
    //                     console.log("Attribute COde Not Found" +attribute);
    //                     //len = (bytes[index++] & 0xFF);
    //                     break;


    //             }
    //             // if not returning from switch case, its means we find a match for header variable so moving index to len byte
    //             index += len;


    //         }
    //         return headerObject;
    //     };

    //     var parse = function(DataViewObject){
    //         /**
    //          * Data view object keeps beffer returning from server
    //          */
    //         var
    //             /**
    //              * packet_type is the first byte of any packet represents the packet format
    //              * 0 : the response contains complete json formatted data
    //              * 2 : the response contains complete byte formatted data
    //              * 1 : the response contains broken json formatted data needed to merge
    //              * 3 : the response contains broken byte formatted data needed to merge
    //              * */
    //             packet_type,
    //         // to keep header information after parsing
    //             header,
    //             bp_header,//broken packet header different from orginal packet header
    //             return_data,
    //             full_packet
    //             ;

    //         packet_type = DataViewObject.getUint8(0);// first byte represent what type of packet
    //         //return_data = header;
    //         switch (packet_type){
    //             case 0://json complete packet
    //             case 2://byte complete packet
    //                 header = parseHeader(DataViewObject,1);
    //                 if(header.actn === 200) {
    //                     return false; }
    //                 if(packet_type === 0){// json complete packet
    //                     return_data = DataViewObject.getString(header.headerLength,DataViewObject.byteLength-header.headerLength);
    //                     try{
    //                         return_data = angular.fromJson(return_data);
    //                         return_data = angular.extend({},header,return_data);
    //                     }
    //                     catch(e){
    //                         console.warn(return_data);
    //                         return_data = false;
    //                         return false;
    //                     }
    //                     return return_data;
    //                     //return return_data ? angular.extend({},header,angular.fromJson(return_data)):false;
    //                 }else{// byte complete packet
    //                     // todo : byte processor
    //                     return_data = parserService.parseData(DataViewObject, header.headerLength);
    //                     return return_data ? angular.extend({},header,return_data):false;
    //                 }

    //                 break;
    //             case 1:// json broken data
    //             case 3://byte broken data
    //                 bp_header = parseBrokenPacketHeader(DataViewObject,1);//broken packet header
    //                 //console.dir(bp_header);
                    
    //                 if(!bp_header.key){ return false; }//returning if header key not found cause if key is not there then we can't identify broken packet
    //                 if(!packetDataStorage[bp_header.key]) { // packet with this key not present in the map
    //                     packetDataStorage[bp_header.key] = [];
    //                     packetDataStorage[bp_header.key].packetLength = 1;
    //                 }else{
    //                     packetDataStorage[bp_header.key].packetLength++;
    //                 }
    //                 packetDataStorage[bp_header.key][bp_header.current] = bp_header.data;

    //                 if(bp_header.total === packetDataStorage[bp_header.key].packetLength){ //all packet has arrived so marge it and parse as normal header
    //                     full_packet = packetDataStorage[bp_header.key].joinAsDataView();
    //                     delete packetDataStorage[bp_header.key];
    //                     header = parseHeader(full_packet,0);
    //                     if(packet_type === 1){// json broken packet
    //                         return_data = full_packet.getString(header.headerLength,full_packet.byteLength-header.headerLength);
    //                         try{
    //                             return_data = angular.fromJson(return_data);
    //                             return_data = angular.extend({},header,return_data);
    //                         }
    //                         catch(e){
    //                             return_data = false;
    //                             return false;
    //                         }
    //                         return return_data;


    //                         //return angular.extend({},header,angular.fromJson(return_data));
    //                     }else{// byte broken packet
    //                         // todo: byte processor
    //                         //console.log('broken packet');
    //                         return_data = parserService.parseData(full_packet, header.headerLength);
    //                         return return_data ? angular.extend({},header,return_data):false;
    //                     }
    //                 }
    //                 return false;
    //         }
    //         //if(header.pckFs > 0){
    //         // TODO check if there needs to sent any confirmation message to the server
    //         //}
    //     };
    //     ReturnObject =  {
    //         parse : function(viewob){
    //             //viewob.print_r(true);
    //             //console.log(viewob.getString(0, viewob.byteLength));
    //             return parse(viewob);
    //         },
    //         addParser : function(action,fn){
    //             ByteParsers[action] = fn;
    //         }
    //     };

    //     return ReturnObject;

    // }


    // parserService.$inject = ['OPERATION_TYPES', 'ATTRIBUTE_CODES', '$$stackedMap'];
    // function parserService(OPERATION_TYPES, ATCODE, $$stackedMap) { //jshint ignore:line
    //     var self = this, //jshint ignore:line
    //         attrMap =  [];

    //         /*
    //          * ATTRIBUTE CODE 108 missing. got data for actn 23
    //          */
    //         attrMap[ATCODE.SUCCESS] =  'sucs';
    //         attrMap[ATCODE.REASON_CODE] = 'reasonCode';
    //         attrMap[ATCODE.MESSAGE] = 'message';
    //         attrMap[ATCODE.TOTAL_PACKET] = 'totalPacket';
    //         attrMap[ATCODE.PACKET_NUMBER] = 'packetNo';
    //         attrMap[ATCODE.TOTAL_RECORDS] =  'totalRecord';
    //         attrMap[ATCODE.USER_TABLE_IDS] = 'utIds';
    //         attrMap[ATCODE.USER_ID] = 'utId';
    //         attrMap[ATCODE.USER_IDENTITY] =  'uId';
    //         attrMap[ATCODE.USER_NAME] = 'fn';
    //         attrMap[ATCODE.PROFILE_IMAGE] = 'prIm';
    //         attrMap[ATCODE.PROFILE_IMAGE_ID] = 'prImId';
    //         attrMap[ATCODE.UPDATE_TIME] = 'ut';
    //         attrMap[ATCODE.CONTACT_UPDATE_TIME] = 'cut';
    //         attrMap[ATCODE.CONTACT_TYPE] = 'ct';
    //         attrMap[ATCODE.NEW_CONTACT_TYPE] = 'nct';
    //         attrMap[ATCODE.DELETED] = 'deleted';
    //         attrMap[ATCODE.BLOCK_VALUE] = 'bv';
    //         attrMap[ATCODE.FRIENDSHIP_STATUS] = 'frnS';
    //         attrMap[ATCODE.CHANGE_REQUESTER] = 'changeRequester';
    //         attrMap[ATCODE.CONTACT] = 'contacts';
    //         attrMap[ATCODE.CALL_ACCESS] = 'cla';
    //         attrMap[ATCODE.CHAT_ACCESS] = 'chta';
    //         attrMap[ATCODE.FEED_ACCESS] = 'fda';
    //         attrMap[ATCODE.ANONYMOUS_CALL] = 'anc';
    //         attrMap[ATCODE.ADDED_TIME] = 'adt';


    //         attrMap[ATCODE.SESSION_ID] = 'sessionId';
    //         attrMap[ATCODE.MUTUAL_FRIEND_COUNT] = 'mutualFriends';

    //     self.parseData = function(dataView, offset) {
    //         var attribute,
    //             length,
    //             Data = {};

    //         for (var index = offset; index < dataView.byteLength; ) {
    //             attribute = dataView.getUint16(index);
    //             index += 2;
    //             length = 0;

    //             switch(attribute) {
    //                 case ATCODE.SUCCESS:
    //                     length = dataView.getUint8(index++);
    //                     Data[attrMap[attribute]] = dataView.getBool(index);
    //                     break;
    //                 case ATCODE.REASON_CODE://1
    //                 case ATCODE.TOTAL_PACKET://1
    //                 case ATCODE.PACKET_NUMBER://1
    //                 case ATCODE.TOTAL_RECORDS://1
    //                 case ATCODE.USER_ID://1
    //                 case ATCODE.PROFILE_IMAGE_ID://1
    //                 case ATCODE.UPDATE_TIME:
    //                 case ATCODE.CONTACT_UPDATE_TIME:
    //                 case ATCODE.CONTACT_TYPE:
    //                 case ATCODE.NEW_CONTACT_TYPE:
    //                 case ATCODE.DELETED:
    //                 case ATCODE.BLOCK_VALUE:
    //                 case ATCODE.FRIENDSHIP_STATUS:
    //                 case ATCODE.CHANGE_REQUESTER:
    //                 case ATCODE.MUTUAL_FRIEND_COUNT:
    //                 case ATCODE.CALL_ACCESS:
    //                 case ATCODE.CHAT_ACCESS:
    //                 case ATCODE.FEED_ACCESS:
    //                 case ATCODE.ADDED_TIME:
    //                     length = dataView.getUint8(index++);
    //                     Data[attrMap[attribute]] = dataView.getIntByByte(index, length);
    //                     break;
    //                 case ATCODE.MESSAGE:
    //                 case ATCODE.USER_NAME:
    //                 case ATCODE.USER_IDENTITY:
    //                 case ATCODE.PROFILE_IMAGE:
    //                 case ATCODE.SESSION_ID:
    //                 case ATCODE.ADDED_TIME:
    //                     length = dataView.getUint8(index++);
    //                     Data[attrMap[attribute]] = dataView.getString(index, length);
    //                     break;
    //                 case ATCODE.USER_TABLE_IDS:
    //                     length = dataView.getUint16(index);
    //                     index += 2;
    //                     Data[attrMap[attribute]] = []; //$$stackedMap.createNew();
    //                     var utId, contactType, matchBy, frnS;

    //                     for(var i = index; i < index+length; ) {
    //                         utId = dataView.getIntByByte(i, 8);
    //                         i += 8;
    //                         contactType = dataView.getUint8(i++);
    //                         matchBy = dataView.getUint8(i++);
    //                         frnS = dataView.getUint8(i++);
    //                         Data[attrMap[attribute]].push({
    //                                 key: utId,
    //                                 value: {
    //                                     ct: contactType,
    //                                     mb: matchBy,
    //                                     frnS: frnS
    //                                 }
    //                             });
    //                             ////Data[attrMap[attribute]].save(
    //                             //utId, {
    //                                 //'ct': contactType,
    //                                 //'matchBy': matchBy
    //                             //}
    //                         //);
    //                     }
    //                     break;
    //                 case ATCODE.CONTACT:
    //                    // console.info('CONTACT');
    //                     // LONG PROCESS
    //                     length = dataView.getUint16(index);
    //                     index += 2;
    //                     if (! angular.isArray(Data[attrMap[attribute]])) {
    //                         Data[attrMap[attribute]] = [];
    //                     }
    //                     Data[attrMap[attribute]].push( self.parseData(dataView.copy(index, length), 0) );
    //                     break;
    //                 default:
    //                     length = dataView.getUint8(index++);
    //                     break;
    //             }
    //             index += length;
    //         }

    //         return Data;
    //     };
    // }


mergerService.$inject = ['$$q'];
function mergerService($q){ //jshint ignore:line

        var ob = {
            defer : function(){
                    var defer = $q.defer();
                    var PACKET_DATA = {};
                return {
                    resolve : function(json){
                        var key, pack_info, seperatorPos;
                        var pack_no, pack_count;
                        if(json.seq || json.totalPacket){
                            key = json.pckId;
                            if(!PACKET_DATA[json.pckId]){
                                PACKET_DATA[json.pckId] = [];
                            }

                            defer.notify(json);// just notifying caller

                            //pack_info = json.seq ? json.seq.split("/") : json.packetNo;
                            if (json.seq) {
                                seperatorPos = json.seq.lastIndexOf('/');
                                pack_no =  json.seq.substr(0, seperatorPos);
                                pack_count = json.seq.substr(seperatorPos+1, json.seq.length);
                            } else {
                                pack_no = json.packetNo;
                                pack_count = json.totalPacket;
                            }
                            //if(!!PACKET_DATA[json.pckId]['sq'+pack_info[0]]){
                            if(!!PACKET_DATA[json.pckId]['sq'+pack_no]){
                                return true;// see what to return
                            }

                            //PACKET_DATA[json.pckId]['sq'+pack_info[0]] = true;
                            PACKET_DATA[json.pckId]['sq'+pack_no] = true;
                            PACKET_DATA[json.pckId].push(json);
                            if(pack_count == PACKET_DATA[json.pckId].length){ // all packet received
                                var obj = {};
                                for(var i = 0;i < PACKET_DATA[json.pckId].length;i++){
                                    for(key in PACKET_DATA[json.pckId][i]){
                                        if(PACKET_DATA[json.pckId][i][key] instanceof Array){
                                            obj[key]  = (obj[key] || []).concat(PACKET_DATA[json.pckId][i][key]);
                                        }else{
                                            obj[key] = PACKET_DATA[json.pckId][i][key];
                                        }
                                    }
                                }

                                defer.resolve(obj);
                                delete PACKET_DATA[json.pckId];
                             }else{
                                return true;
                             }
                        } else {
                            defer.resolve(json);
                        }
                    },
                    promise : defer.promise
                };


            }
        };
        return ob;
}



})();

(function(DataView) {// placing dataview and String globals to locals for better performance
    'use strict';
    angular
        .module('ringid.connector')
        .factory('$$connector',$$connector);

           $$connector.$inject =
                ['settings','Storage', '$rootScope','$websocket','$$stackedMap','ATTRIBUTE_CODES',
                    'utilsFactory','$$q','OPERATION_TYPES','CLIENT_DATA_SIZE','mergerService'];
         function $$connector(settings,Storage, $rootScope,$websocket,$$stackedMap,ATTRIBUTE_CODES, //jshint ignore:line
                     utilsFactory,$q,OPERATION_TYPES,CLIENT_DATA_SIZE,mergerService){
                var ObjectToBeReturn,
                    sessionID = Storage.getCookie('sessionID'),
                    CurrentuId = Storage.getCookie('uId'),
                    socket,
                    keepAliveSender,
                    deferToBeResolved={},
                    resolvedPacket={},
                    stopSending=!1,
                    sendQueue = [],
                    lastSendingTime = Date.now(),
                    timeoutSetted = false,
                    keepAlive = false,
                    subscribers=$$stackedMap.createNew(),
                    floodingData = {},
                    floodingDataInterval,
                    reconnectCountError = 0,
                    UnresolvedData = [],
                    intervalFunctions = $$stackedMap.createNew();

                function getMessageFilterByActionNumber(action_number){

                    return function(message){// websocket message event
                        if (!message || !message.actn){ return false; }
                        if(angular.isArray(action_number)){
                            for(var i=0;i<action_number.length;i++){
                                if(message.actn === action_number[i]){
                                    return true;
                                }
                            }
                        }else{
                            return message.actn === action_number;
                        }
                        return false;

                    };
                }
               function parseMessageData(DataViewObject){
                    if(!DataViewObject) { return {}; }
                     return RingParser.parse(DataViewObject);
                    //if(angular.isString(message.data)){
                    //    return angular.fromJson(message.data);
                    //}else if(angular.isObject(message.data)){
                    //    return message.data;
                    //}else{
                    //    return message;
                    //}
               }
               function resolvePendingRequest(message){
                    if(deferToBeResolved[message.pckId] === true){
                        return true;
                    }
                    if(!!deferToBeResolved[message.pckId]){
                        var a = deferToBeResolved[message.pckId].resolve.call(deferToBeResolved[message.pckId],message);

                        if(!a){
                            deferToBeResolved[message.pckId] = !!a;
                            setTimeout(function(){
                                delete deferToBeResolved[message.pckId];
                            },3000);
                        }
                        //deleting after processing
                        return true;
                    }else{
                        return false;
                    }
               }

               function broadcastUpdates(message){
                    var foundSubscriber = false;
                   if(subscribers.length() > 0){
                        subscribers.doForAll(function(currentCallBackObject){
                           var should_call_with,pattern = currentCallBackObject.filter;
                            if (pattern) {
                                if(angular.isFunction(pattern)){
                                    should_call_with = pattern.call(null,message);
                                    if(!!should_call_with){
                                        foundSubscriber = true;
                                        currentCallBackObject.fn.call(currentCallBackObject,message);
                                    }
                                }
                            }else{
                                currentCallBackObject.fn.call(null, message);
                            }
                            // if (currentCallBackObject.autoApply && !currentCallBackObject.scope.$$phase) {
                            //     currentCallBackObject.scope.$digest(); // safe digest
                            // }
                        });
                      if(!foundSubscriber){
                      }
                   }
                   return foundSubscriber;

               }

                function processOnMessageListners(json){
                    if(!json){ return; }

                    var MadeRquest,resolved;
                    if(json.actn === OPERATION_TYPES.SYSTEM.AUTH.TYPE_INVALID_LOGIN_SESSION){
                        broadcastUpdates(json);return;
                    }
                    if(json.hasOwnProperty('pckId')){ // its a response of a request so process resolve the defer of this packet id
                        MadeRquest = resolvePendingRequest(json);
                    }
                    //if(json.hasOwnProperty('pckFs')){ // packet id From Server so its update need to process subscriber
                        //var pack = json.pckFs;
                        //if(!resolvedPacket[pack]){
                        //    broadcastUpdates(json);
                           // resolvedPacket[pack] = true;
                        //}
                    //}
                    if(!MadeRquest){
                       resolved = broadcastUpdates(json);
                       if(!resolved){
                          UnresolvedData.push(json);
                       }
                    }
                }

                function MainOnMessageHandler(message){ // if message has pckId then its a request response, if message has pckFs its a subscriber
                    //if(!message.received)return;
                    var DataViewObject;
                    try{
                        //if(window.Blob && ((message.data ||message) instanceof Blob)){
                        //
                        //}
                        DataViewObject = new DataView(message.data || message);
                        if(!DataViewObject.byteLength){
                            throw new Error("Byte Length of Zero");
                        }
                    }catch(e){ // buffer is not a arrayBuffer so throws exception
                        // console.dir(e);
                        return;
                    }
                   // DataViewObject.print_r(); //ajax is banned
                   // if(!socket.socket ){ //data coming via ajax so coming as 2-byte integer padded
                   //     for(var i=0;i<DataViewObject.byteLength;){
                   //          length = DataViewObject.getUint16(i,!0); // length as 2-byte integer
                   //           i+=2;
                   //         if(length > 0){
                   //             try{
                   //                 tempDataView = DataViewObject.copy(i,length);
                   //                 message = parseMessageData(tempDataView);
                   //                // tempDataView.print_r();
                   //                 processOnMessageListners(message);
                   //             }catch(e){
                   //                 console.warn("Invalid Array Buffer to Parse : "+ e.message);
                   //             }finally{
                   //                 i+=length;
                   //             }
                   //         }
                   //     }
                   // }else{ // data coming via socket .. so no need to parse as byte array
                        message = parseMessageData(DataViewObject);
                        processOnMessageListners(message);
                  //  }

                    // for broken packets and falsy data
                }

            // function getKeepAlivePacket(){

            //     var sess = Storage.getCookie('sId') || '',index=2;
            //     if (!sess.length){ return false; }
            //     var dataTosend = new ArrayBuffer(sess.length +2),
            //         dataview  = new DataView(dataTosend);

            //      dataview.setUint8(0,OPERATION_TYPES.SYSTEM.REQUEST_TYPE.KEEP_ALIVE);
            //      dataview.setUint8(1,0);//complete packet
            //         angular.forEach(sess.toCharCodeArray(),function(val){
            //             dataview.setUint8(index++,val);
            //         });
            //     return dataview;
            //  }

             function init(){
                // console.log("socket Init Called");
                             window.onbeforeunload = function(){

                                 if($rootScope.unloadWarn) {
                                   return "You have unsaved changes.  Do you want to leave this page and lose your changes?";
                                 }
                               }
                return;
              }
                   //  if(angular.isObject(socket)){
                   //      if(!socket.isOpen() && socket.readyState !== 0){
                   //          socket.reconnect();
                   //      }
                   //      return; // if socket is already initiated then return
                   //  }
                   // if(utilsFactory.hasSocket()){
                   //     try{
                   //         socket = $websocket( settings.socketProtocol + settings.siteUrl +'/DataSocket/' + utilsFactory.tabId);
                   //         if(false === socket){
                   //              return;
                   //         }
                   //         socket.onError(function(e){
                   //            if(reconnectCountError > 2){
                   //              $rootScope.$broadcast('CONNECTION_ERROR');
                   //            }else{
                   //              reconnectCountError++;
                   //            }

                   //         });
                   //         socket.onOpen(function(){
                   //             Storage.removeCookie('reloaded');
                   //             if(sendQueue.length){
                   //               send();
                   //             }
                   //            //  var t0 = window.performance().now();
                   //            // setInterval(function(){
                   //            //   var t1 = window.performance().now();
                   //            // },200);
                   //         });
                   //         socket.onClose(function(e){
                   //         });
                   //         window.onbeforeunload = function(){

                   //               if($rootScope.unloadWarn) {
                   //                 return "You have unsaved changes.  Do you want to leave this page and lose your changes?";
                   //               }

                   //               closeConnection();

                   //               //return "are You Sure";
                   //         };

                   //     }catch(e){
                   //          //$rootScope.$broadcast('CONNECTION_ERROR');
                   //     }
                   //     socket.onMessage(MainOnMessageHandler,{});
                   // }else{
                   //      //$rootScope.$broadcast('CONNECTION_ERROR');
                   //     alert("Your browser seem back dated. To use RingId with greater user experience we advice you to use modern browser. ");
                   //     return; //ajax is removed
                   // }

              // }
             // function initInterval(){
             //    var kpPacket = getKeepAlivePacket();
             //        if (!kpPacket){ return; }
             //        kpPacket.keepalive = true;//for log purpose
             //     keepAliveSender = window.setInterval(function(kpPacket){
             //         processIntervals();
             //         if(!kpPacket){
             //             stopInterVal();return;//sessionId not found so stopping the interval
             //         }
             //         //if(!socket.socket){ // ajax stop working
             //           //  socket.fetch(getKeepAlivePacket());
             //        // }else{ // else socket
             //           //  RingWorker.send(kpPacket,'keepalive');
             //        // }
             //     }.bind(null,kpPacket),5000);
             // }
             // function connectionReset(){
             //    // throw new Error("Socket Reset");
             //    // socket.socket.binaryType = 'arraybuffer';
             //     stopInterVal();
             //     socket.close();
             //     socket = null;
             //     stopSending = true;
             //     init();
             //     stopSending = false;
             //     //socket.socket.binaryType = 'arraybuffer';
             //     //if(!socket.socket){
             //     //  socket.init(getKeepAlivePacket());
             //     //}
             //     if (keepAlive){ initInterval(); }
             // }
             // function closeConnection(){
             //    // throw new Error("Socket Closed");
             //     if(keepAliveSender){
             //         //$interval.cancel(keepAliveSender);
             //         window.clearInterval(keepAliveSender);
             //     }

             //     if(socket.isOpen()){
             //         socket.close();
             //     }else{
             //        if (socket.socket.readyState === 0){
             //            socket.onOpen(function(){
             //            socket.close();
             //         });
             //        }

             //     }

             // }

             // function stopInterVal(){
             //   //  $interval.cancel(keepAliveSender);
             //   window.clearInterval(keepAliveSender);
             // }
             // function sendBrokenPacket(request_type,messageViewArray,data,packetId){ //message expected as string
             //     var packets = [],hi, i,headerLength=129,full_packet,packet_start=0,packet_end,// with full packet there are two bytes of request type and packet type sp excluding it
             //         len = messageViewArray.byteLength,header,headbuf,last_sent = Date.now(),now;

             //     var totalPacket = Math.ceil(len/CLIENT_DATA_SIZE),
             //         uniqueKey =  (CurrentuId || "")  + utilsFactory.tabId + utilsFactory.getUniqueID().toString(),
             //         glu = totalPacket < 128 ? 1:2;//one byte or two byte
             //     for(i=0;i<totalPacket;i++){
             //         packet_end = (CLIENT_DATA_SIZE*(i+1))-1;
             //         if(packet_end > len){
             //             packet_end = len-1;//if its over the data
             //         }
             //         headbuf = new ArrayBuffer(headerLength+(packet_end-packet_start+1));
             //         header = new DataView(headbuf);
             //         header.setUint8(0,request_type);//setting request type on first byte
             //         header.setUint8(1,1);//setting packet type on second byte
             //         hi = 2;
             //         if(data.actn){
             //             hi = header.addAttributeInt(hi,ATTRIBUTE_CODES.ACTION,2,data.actn);
             //         }
             //         if(!!packetId){
             //             packetId = packetId.toString();
             //             hi = header.addAttributeString(hi,ATTRIBUTE_CODES.CLIENT_PACKET_ID,packetId);
             //         }
             //         hi = header.addAttributeInt(hi,ATTRIBUTE_CODES.TOTAL_PACKET,glu,totalPacket);
             //         hi = header.addAttributeInt(hi,ATTRIBUTE_CODES.PACKET_NUMBER,glu,i);//current packet number
             //         hi = header.addAttributeString(hi,ATTRIBUTE_CODES.UNIQUE_KEY,uniqueKey);
             //         hi = header.addAttributeData(hi,ATTRIBUTE_CODES.DATA,messageViewArray,packet_start,(packet_end-packet_start+1));
             //         packet_start = packet_end+1;
             //         //full_packet = header.merge(0,hi,messageViewArray,packet_start,packet_end);
             //         //data_packet = messageViewArray.copy(packet_start,packet_end+1);
             //         //console.info("packet Number" + i);
             //         full_packet = header.copy(0,hi);
             //          // if(!socket.socket){
             //              // packets.push(header.copy(0,hi));
             //          // }else{
             //         packets.push(full_packet);
             //          // }
             //       }
             //    // console.log()
             //        var sendPacket = function sendPackInner(){
             //            while(packets.length){
             //                var pack;
             //                now = Date.now();
             //                if(now - last_sent >=180){
             //                    pack = packets.shift();
             //                    send(pack);
             //                    last_sent = now;
             //                }else{
             //                    setTimeout(sendPackInner,180);
             //                    return;
             //                }
             //            }
             //        };
             //        sendPacket();
             //     return false;
             // }

             // function changeMessageToByte(message,packetType,request_type){ // message as string/object
             //     if (!angular.isString(message)) {
             //        message = angular.toJson(message);
             //     }

             //     var buffer,messageViewArray,index= 0,len = packetType ? message.length : message.length + 2;
             //     buffer = new ArrayBuffer(len);
             //     messageViewArray = new DataView(buffer);
             //     if(!packetType){ // for broken packet 1, else 0 so we have to add two byte if its complete packet
             //         messageViewArray.setUint8(index++,request_type);
             //         messageViewArray.setUint8(index++,0);
             //     }
             //     if(message.length){
             //         angular.forEach(message.toCharCodeArray(),function(val){
             //             messageViewArray.setUint8(index++,val);
             //         });
             //     }
             //     return messageViewArray;
             // }
                //init(); //initing the socket
             // function buildPacketToSend(packetId, data,request_type){//append sessionIdBefore Send
             //        var message,messageViewArray,sId = Storage.getCookie('sId');
             //        data = data || {};
             //        data.pckId = packetId;
             //        if (!!sId) {
             //            data.sId = sId;
             //        }
             //        data.tbid = utilsFactory.tabId;
             //        data.dvc = 5;
             //        message = angular.toJson(data);

             //        //if(data.actn === 134) {
             //        //    //return sendBrokenListPacket(request_type,data,packetId);
             //        //}else

             //        if((message.length + 2 > CLIENT_DATA_SIZE)&& data.actn !== 23 && data.actn !== 25 && request_type !== 3){ // including request_type and packet_type
             //            messageViewArray = changeMessageToByte(message,1,request_type);//broken packet type is 1
             //            return sendBrokenPacket(request_type,messageViewArray,data,packetId);
             //        }else{
             //            return changeMessageToByte(message,0,request_type); // complete packet type is 0
             //        }

             // }

                 // var send = function sendD(data,force){
                 //     if(!!data){
                 //         sendQueue.push(data);
                 //     }
                 //     if(stopSending && !force){
                 //         return;
                 //     }
                 //     if(socket.socket.readyState === 0){
                 //        return;
                 //     }
                 //     if(!socket.isOpen() && socket.socket.readyState !== 0){
                 //        socket.reconnect();return;
                 //     }
                 //     // if(socket.readyState === 0){
                 //     //     if(!timeoutSetted){
                 //     //         setTimeout(function(){
                 //     //             timeoutSetted = false;
                 //     //             sendD();
                 //     //         },1000);
                 //     //         timeoutSetted = true;
                 //     //     }
                 //     //     return;
                 //     // }
                 //     while (sendQueue.length) {
                 //         var now = Date.now(),timediff = now - lastSendingTime; // for testing pupose
                 //       //  if(timediff > 200){ // Auth Server Drop Out Packets if previous packet receives in 200ms
                 //             var tempdata = sendQueue.shift();
                 //             socket.send(tempdata);
                 //             lastSendingTime = now;
                 //        // }else{
                 //           // setTimeout(function(){
                 //              //  send();
                 //            //},200-timediff);
                 //       //  }
                 //     }
                 // };

                function sendData(data,request_type,defer,flooding){
                    var message,packetId;
                    packetId = data.pckId || utilsFactory.getUniqueID();
                    //message = buildPacketToSend(packetId,data,request_type);
                    data.pckId = packetId;

                    if(!!defer) {
                        deferToBeResolved[packetId] = defer;//keeping defer to resolve while data catched with this packet Id
                    }
                    if(data){
                        return RingWorker.send(data,packetId,request_type,flooding);
                        //return send(message,request_type === OPERATION_TYPES.SYSTEM.REQUEST_TYPE.AUTHENTICATION);
                    }
                    // sending through socket or ajax
                }

                function initDeferRequest(data,request_type,mergeData,flooding){
                    var defer = mergeData ? mergerService.defer():$q.defer(),res;
                    res = sendData(data,request_type,defer,flooding);
                    //if(!socket.socket){ // for ajax request
                      //  res.success(function(data,status,headers){
                      //response that coming result on request with ajax for example auth request
                      //      MainOnMessageHandler(data,true);
                      //  });//sending byte view data through socket/ajax
                  //  }else{
                        // note : for websocket it just sent the data and waits for receive
                  //  }
                    //setTimeout(function(){
                    //    defer.notify(CUSTOM_PROMISE.REQUEST_SENT);
                    //},10);
                    return defer.promise;
                 }
                 // function initDeferRequestSafeMode(data,request_type, mergeData){
                 //    var defer = mergeData ? mergerService.defer():$q.defer();
                 //    if(!floodingData[data.actn]){
                 //      floodingData[data.actn] = [];
                 //    }
                 //    floodingData[data.actn].push(sendData.bind(null,data,request_type,defer));
                 //    if(!floodingDataInterval){
                 //      floodingDataInterval = setInterval(processSafeModeSender,300);
                 //    }
                 //    return defer.promise;
                 // }

                 // function processSafeModeSender(){
                 //    var actn,fn,floodingFlag=false;
                 //    for(actn in floodingData){
                 //        if(floodingData.hasOwnProperty(actn) && floodingData[actn].length){
                 //            fn = floodingData[actn].shift();
                 //            fn.call();
                 //            if(!floodingData[actn].length){
                 //                delete floodingData[actn];
                 //            }else{
                 //              floodingFlag = true;
                 //            }
                 //        }
                 //    }
                 //    if(!floodingFlag && floodingDataInterval){
                 //        clearInterval(floodingDataInterval);
                 //        floodingDataInterval = angular.noop();
                 //    }
                 // }

                 function processIntervals(){
                        intervalFunctions.doForAll(function(f){
                            f.call(null);
                        });
                 }


                ObjectToBeReturn = {
                    init : init,
                    close : function(){
                    },
                    send : function(data,request_type, flooding){ // do not return any promise
                        sendData(data,request_type, false, flooding);
                    },
                    request : function(data, request_type, flooding){//returns a $q promise
                        //if(!flooding){
                            return initDeferRequest(data, request_type,false,flooding);
                         //}else{
                            //return initFloddingRequest(data,request_type);
                        // }

                    },
                    pull : function(data, request_type, flooding){//returns a $q promise
                       // if(!flooding){
                            return initDeferRequest(data, request_type, true,flooding);
                      //}else{
                         //  return initFloddingRequest(data, request_type, true);
                      //  }
                    },
                    subscribe : function(callback,options){
                      var i,should_call_with,backUp = [];

                        options = options || {};
                        options.key = options.key || utilsFactory.getUniqueID();
                        options.scope = options.scope || $rootScope;
                        options.autoApply = false;
                        options.fn = callback || angular.noop;
                        // filter must be a function
                        if(!options.filter && !!options.action){
                            options.filter = getMessageFilterByActionNumber(options.action);
                        }

                        subscribers.add(options.key,options);
                        if(!!options.callWithUnresolved){
                            for(i = 0;i<UnresolvedData.length;i++){
                                   should_call_with = options.filter.call(null,UnresolvedData[i]);
                                    if(!!should_call_with){
                                        options.fn.call(null,UnresolvedData[i]);
                                    }else{
                                      backUp.push(UnresolvedData[i]);
                                    }
                            }
                            UnresolvedData.length = 0;
                            UnresolvedData = backUp;
                        }
                        return options.key;// key returned : useful when need to unsubscribe
                    },
                    unsubscribe : function(key){
                        subscribers.remove(key);
                    },
                    stop :function(){
                        stopSending = true;
                    },
                    resume : function(){
                         stopSending = false;
                        // if(!socket.isOpen() && socket.socket.readyState !== 0){
                        //     socket.reconnect();
                        // }
                        //send();

                    },
                    reset : function(){
                        //connectionReset();
                       // send();
                    },
                    addInterval : function(func){
                        var key = utilsFactory.getUniqueID();
                        intervalFunctions.add(key,func);
                        return key;
                    },
                    removeInterval :function(key){
                        intervalFunctions.remove(key);
                    },
                    keepAlive : function(){
                        keepAlive = true;
                        //initInterval();
                        RingWorker.pushMessage({
                            command : 'KEEPALIVE',
                            aSkey : Storage.getCookie('sId'),
                            uKey : Storage.getCookie('uId')
                        });
                    },
                    notifyRouteChange : function(){
                      RingWorker.pushMessage({
                            command : 'ROUTE_CHANGE'
                        });
                    }
                };

                // var worker = new Worker(settings.baseUrl+'js/worker/worker.js');
                // var feed = {
                //     a : 1,
                //     b : 2
                // };
                // worker.addEventListener('message',function(message){

                // });

                // worker.addEventListener('error',function(e){
                // });
                // worker.postMessage({
                //      command : 'connect',
                //      url : 'ws://'+ settings.siteUrl +'/DataSocket/' + utilsFactory.tabId,
                //      feed  : feed,
                // });



             //$cookies.act = utilsFactory.tabId;
             //$cookies.tt = ($cookies.tt && ($cookies.tt+1)) || 1;

             //var actChecker = setInterval(function(){
             //       if($cookies.a)
             //},1000);
             // we will keep a single connection if multiple tab is opened
             // so on $rootScope ringactive we should re connect and in ringInactive we should close connection

             $rootScope.$on('ringInactive',function(event){
                // console.log("soccket stat : " + socket.isOpen() +" currentTabId :" + utilsFactory.tabId );
                // closeConnection();
                 //setTimeout(function(){
                 //   if($cookies.act === utilsFactory.tabId){
                 //       if(!socket.isOpen()){
                 //           connectionReset();
                 //       }
                 //   }
                 //},3000);
                 //$rootScope.$on('$destroy',function(){
                 //       console.log("hello");
                 //});
                 //console.info("Window Is Not Active");
                 //if($cookies.sessionID != sessionID) {
                     //sessionID = $cookies.sessionID;
                     //connectionReset();
                 //}
             });

             $rootScope.$on('$locationChangeStart', function( event ) {
                 //var answer = confirm("Are you sure you want to leave this page?")
                 //if (!answer) {
                 //    event.preventDefault();
                 //}
             });

             RingWorker.addCallback('received',function(message){
                  processOnMessageListners(message.data);
              });

             RingWorker.addCallback('event',function(message){
                if(message.name){
                  $rootScope.$broadcast(message.name);
                }
              });

                return ObjectToBeReturn;
            }
})(DataView);





/*
* © Ipvision
*/

(function() {
    'use strict';
    angular
        .module('ringid.global.services', [
                'ringid.config',
                'ringid.connector',
                'ringid.common.services',
                'ringid.common.factories',
                'ringid.common.directives',
                'ringid.utils',
                'ui-notification'
            ]);
})();

/*
 * copyright Ipvision
 */



(function(){
    'use strict';

    angular
        .module('ringid.global.services')
        .factory('$ringhttp', ringhttp);


    ringhttp.$inject = ['settings', '$templateCache'];
    function ringhttp(settings, $templateCache) { //jshint ignore:line
        var timeStamp =  new Date().getTime();
        var requestQueue = {},
            config = {
            //contentType: 'application/x-www-form-urlencoded'
            'contentType': 'multipart/formdata'
        };
        var parse = function (req) {
            var result;
            try {
                result = JSON.parse(req.responseText);
            } catch (e) {
                result = req.response;
            }
            return [result, req];
        };

        function XHR(type, url, data, responseType) {
            var templateRequest = false,
                methods = {
                success: function() {},
                error: function() {},
                abort: function() {},
                progress: function() {}
            };


            var templateIndex = url;
            url = /^(http|https):\/\//.test(url) ? url : settings.baseUrl + (url.indexOf('/') === 0 ? url : '/' + url);

            var ajaxRequest = {
                success: function(callback) {
                    methods.success = callback;
                    return ajaxRequest;
                },
                error: function(callback) {
                    methods.error = callback;
                    return ajaxRequest;
                },
                abort: function(callback) {
                    methods.abort = callback;
                    return ajaxRequest;
                },
                progress: function(callback) {
                    methods.progress = callback;
                    return ajaxRequest;
                },
                abortRequest: function() {
                    xhr.abort();
                }
            };

            try {
                var xhr = new XMLHttpRequest();
                templateRequest =  (type === 'GET' && /\.html$/.test(url));
                if (templateRequest && requestQueue.hasOwnProperty(templateIndex)) {
                        requestQueue[templateIndex].push(methods);
                } else if (templateRequest && $templateCache.get(templateIndex)) {
                    setTimeout(function() {
                        //if (requestQueue[url]) {
                            //requestQueue[url].forEach(function(methods) {
                                //methods.success.apply(methods, [$templateCache.get(templateIndex), xhr]);
                            //});
                            //delete requestQueue[url];
                        //} else {
                            methods.success.apply(methods, [$templateCache.get(templateIndex), xhr]);
                        //}
                    });
                } else {
                    if (templateRequest) {
                        url = url + '?time=' + timeStamp; // new Date().getTime();
                        requestQueue[templateIndex] = [];
                        requestQueue[templateIndex].push(methods);
                    }
                    xhr.open(type, url, true);
                    //xhr.setRequestHeader('x-app-version', settings.apiVersion )
                    xhr.responseType = responseType || 'text';

                    xhr.onreadystatechange = function() {
                        var response ;
                        if (xhr.readyState === 4) {
                            response = parse(xhr);
                            if (xhr.status === 200 ) {
                                // if template put it inside templatecache
                                if (templateRequest) {
                                    $templateCache.put(templateIndex, response[0]);
                                    requestQueue[templateIndex].forEach(function(methods) {
                                        methods.success.apply(methods, [$templateCache.get(templateIndex), xhr]);
                                    });
                                    delete requestQueue[templateIndex];
                                } else {
                                    methods.progress.apply(methods, [100]);
                                    methods.success.apply(methods, response);
                                }
                            } else {
                                methods.error.apply(methods, response);
                            }
                        }

                    };

                    xhr.upload.onabort = function() {
                        methods.abort.apply(methods);
                    };

                    xhr.upload.onprogress= function(e) {
                        methods.progress.apply(methods, [Math.round(e.loaded / e.total * 100) - 1]);
                    };

                    xhr.send(data);
                }

            } catch (e) {
            }


            return ajaxRequest;
        }



        return {
            //create: XHRWorking,
            get: function(url, headers, responseType) {
                return XHR('GET', url, headers, responseType);
            },
            post: function(url, data, responseType) {
                return XHR('POST', url, data, responseType);
            },
            getTemplatePromise : function(url,headers,responseType){
                // var request,defer = $q.defer();




                // return defer.promise;
            }
        };

    }


})();


/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.global.services')
        .factory('GlobalEvents', GlobalEvents);


    GlobalEvents.$inject = ['$document'];
    function GlobalEvents($document){
        var handlers = [];


        var handleClick = function(event) {
            /*
            * http://ringgit.com/ringID/ringIDWeb/issues/99
            *
            * Firefox right click also detect as click
            *
            * */
            if( event.which === 3 || handlers.length === 0){
                return;
            }


            for(var i = 0, l = handlers.length; i < l; i++) {
                handlers[i].call(null, event);
            }
            event.preventDefault();
            //event.stopPropagation();
        };



        return {
            bindHandler: function(attachTo, eventType,  handler) {
                handlers.push(handler);
                if(handlers.length === 1) { // only once bind when handlers goes from 0 to 1
                    $document.bind('click', handleClick);
                }

            },
            unbindHandler: function(removeFrom, eventType, handler) {
                setTimeout(function() {
                    handlers.splice( handlers.indexOf(handler), 1 );
                    if(handlers.length === 0) { // remove event binding when no handlers present
                        $document.unbind('click', handleClick);
                    }
                });
            }
        };
    }


})();

(function () {
    "use strict";
    angular
        .module('ringid.global.services')
        .factory('Ringalert', Ringalert);

        Ringalert.$inject = ['$ringbox','Notification','MESSAGES'];
       function Ringalert($ringbox,Notification,MESSAGES){
           /*
               Notification factory API's
               Notification(), Notification.primary()	Show the message with bootstrap's primary class
               Notification.info()	Show the message with bootstrap's info class
               Notification.success()	Show the message with bootstrap's success class
               Notification.warning()	Show the message with bootstrap's warn class
               Notification.error()	Show the message with bootstrap's danger class
               Notification.clearAll()	Remove all shown messages
           */
           var defaultNotificationOptions = {
                delay : 3000,
                positionX : 'right',
                positionY : 'top',
                replaceMessage : true
           };
           var defaultAlertOptions = {
                title : 'Warning',
                message : 'Click ok to continue',
                showOk : true,
                showCancel : true,
                craac : false, //close ringbox after action
                textOk : 'OK',
                textCancel : 'Cancel',
                okCallback : angular.noop,
                cencelCallback : angular.noop
           };
           return {
               show : function(messageObject,type){//message is either object or string
                    type = type || 'info';//Notification property default we shows info
                    if(angular.isString(messageObject)){
                        messageObject = {
                            message : messageObject
                        };
                    }
                    messageObject.message = messageObject.message || messageObject.mg;
                   if(!messageObject.message){
                       if('success' === type){
                           messageObject.message = MESSAGES.REQUEST_PROCESSED;
                       }else if('error' === type){
                           messageObject.message = MESSAGES.REQUEST_FAILED;
                       }
                   }
                   try{
                        Notification[type](angular.extend({},defaultNotificationOptions,messageObject));
                   }catch(e){
                       console.info(messageObject.message);
                   }

               },
               clear : function(){
                   Notification.clearAll();
               },
               alert  :function(ob){
                  ob = ob || {};
                  ob = angular.extend({},defaultAlertOptions, ob);

                     var boxInstance = $ringbox.open({
                        type : 'remote',
                        scope:false,
                        scopeData : ob,
                        templateUrl : ob.templateUrl || 'pages/popups/ring-alert.html'
                      });

               boxInstance.result.then(function(data){
                  var check = typeof data === "string" ? data : data.sucs;
                  if(check === 'ok' && angular.isFunction(ob.okCallback)){
                      ob.okCallback.call(null,data);
                  }else{
                      ob.cencelCallback.call(null,data);
                  }
               });


               }
           };
       }
})();

(function () {
    "use strict";
    angular
        .module('ringid.global.services')
        .factory('$$stackedMap', function () {
            return {
                createNew: function (dosort, order) {
                    var stack = [], self = this;
                    dosort = dosort || false;
                    order = order || "desc";

                    //function sortIt(){
                    //    stack.sort(function(a,b){
                    //        return (order === 'desc')? b.value['sortBy']() - a.value['sortBy']():a.value['sortBy']() - b.value['sortBy']();
                    //    });
                    //}
                    function sortIt(prop_index) {
                        prop_index = prop_index || 'sortBy';
                        var gt = -1, lt = 1;
                        if (order === 'desc') {
                            gt = 1;
                            lt = -1;
                        }
                        stack.sort(function (a, b) {
                            if (b.value[prop_index]() > a.value[prop_index]())
                                return gt;
                            if (a.value[prop_index]() > b.value[prop_index]())
                                return lt;
                            return 0;
//                                return (order === 'desc') ? b.value[prop_index]() > a.value[prop_index]() : a.value[prop_index]() > b.value[prop_index]();
                        });
                    }
                    function getIndex(key) {
                        for (var i = 0; i < stack.length; i++) {
                            if (key == stack[i].key) {
                                return i;
                            }
                        }
                        return -1;
                    }

                    function navigateNext(key) {
                        var index = getIndex(key);
                        if (index === -1 || index === (stack.length - 1))
                            return false;

                        return stack[index + 1].value;

                    }

                    function navigatePrevious(key) {
                        var index = getIndex(key);
                        if (index === -1 || index === 0)
                            return false;

                        return stack[index - 1].value;

                    }

                     var ObjectToReturn = {
                        concat:  function(stackedMap) {
                            stack = stack.concat(stackedMap);
                        },
                        reset: function () {
                            //stack.length = 0;
                            stack = [];
                        },
                        all: function () {
                            return stack;
                        },
                        setStack: function (st) {
                            stack = st;
                        },
                        add: function (key, value) {
                            stack.push({
                                key: key,
                                value: value
                            });
                            if (dosort !== false) {
                                sortIt();
                            }
                            return false;
                        },
                        next: function (key) {
                            return navigateNext(key);
                        },
                        previous: function (key) {
                            return navigatePrevious(key);
                        },
                        getByIndex : function(i,withIndex){
                             if(stack.length && (i>=0 || i < stack.length)){
                                 return (withIndex) ?stack[i] : stack[i].value;
                             }
                             return false;
                         },
                        getIndex: function (key) {
                            return getIndex(key);
                        },
                        get: function (key) {
                            var i = getIndex(key);
                            return i >= 0 ? stack[i].value : !1;
                        },
                        save: function (key, value) {
                            var idx;
                            idx = getIndex(key);
                            if (idx === -1) {
                                ObjectToReturn.add(key, value);//pushing if not existing index
                            } else {
                                stack[idx] = {key: key, value: value};//saving if existing index
                            }
                            if (dosort !== false) {
                                sortIt();
                            }
                        },
                        sort: function (type, prop_index) {
                            if (type)
                                order = type;
                            sortIt(prop_index);

                        },

                        keys: function () {
                            var keys = [];
                            for (var i = 0; i < stack.length; i++) {
                                keys.push(stack[i].key);
                            }
                            return keys;
                        },
                        values : function(){

                            var values = [];
                            for (var i = 0; i < stack.length; i++) {
                                values.push(stack[i].value);
                            }
                            return values;
                        },
                        top: function (withIndex) {
                            if(!stack.length)return false;
                            withIndex = !!withIndex;//
                            return (withIndex) ?stack[stack.length - 1] : stack[stack.length - 1].value;
                        },
                        bottom: function(withIndex) {
                            if(!stack.length)return false;
                            withIndex = !!withIndex;//
                            return (withIndex) ?stack[0] : stack[0].value;
                        },
                        sliceBy: function (length, starting_index) {
                            //if(!length)return stack;
                            if (!starting_index)starting_index = 0;
                            if (length > stack.length || !length)length = stack.length;
                            return stack.slice(starting_index, length);
                        },


                        remove: function (key) {
                            var idx = getIndex(key);
                            //return idx > -1 ? stack.splice(idx, 1)[0]:[];
                            if(idx > -1) {
                                stack.splice(idx, 1);
                                return true;
                            } else {
                                return false;
                            }
                        },
                        removeTop: function () {
                            return stack.splice(stack.length - 1, 1)[0];
                        },
                        length: function () {
                            return stack.length;
                        },
                        nonClosedLength: function(){
                            var count = 0;
                            //var boxesArray = boxes.all();
                            angular.forEach(stack, function(box, key){
                                count += box.closedBox ? 1 : 0;
                            });
                            return count;
                        },
                        copy: function () { // shallow copy pushing just into a new stack but the value reference is same
                            var ob = self.createNew(dosort, order);
                            for (var i = 0; i < stack.length; i++) {
                                ob.add(stack[i].key, stack[i].value);
                            }
                            return ob;
                        },
                        doForAll : function(fn){ // looping through all and process a function
                            for (var i = 0; i < stack.length; i++) {
                               fn.call(null,stack[i].value);
                            }
                        }
                    };

                     return ObjectToReturn;
                }
            };
        });
})();
//{"dvc":5,"lot":1429161670578,"actn":175,"rc":0,"chIp":"38.127.68.55","sucs":true,"fndId":"2000003519","pckId":"20000045691429161692648","psnc":2,"chRp":1500,"pckFs":172412}
//{"dvc":5,"lot":1429161692821,"actn":175,"rc":0,"chIp":"38.127.68.55","sucs":true,"fndId":"2000004569","psnc":2,"chRp":1500,"pckFs":172412}




/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
    .module('ringid.global.services')
        .factory('Auth', AuthFactory);


        AuthFactory.$inject = ['SystemEvents', '$rootScope', 'Storage', 'utilsFactory', '$q', '$ringhttp', 'settings', 'OPERATION_TYPES',
                             'userFactory', '$ringbox', 'Ringalert', 'countryListService', '$$connector',  'rgDropdownService', '$ocLazyLoad'];
        function AuthFactory(SystemEvents, $rootScope, Storage, utilsFactory, $q, $ringhttp, settings, OPERATION_TYPES,  // jshint ignore:line
                                 userFactory, $ringbox, Ringalert, countryListService, $$connector,  rgDropdownService, $ocLazyLoad) {


            var sessionID = Storage.getCookie('sessionID'),
                invalidLoginProcessed = false,
                invalidSesssionProcessed = false,
                pendingLogin = true,
                loginInProgress = false,
                OTYPES = OPERATION_TYPES.SYSTEM.AUTH,
                REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE,
                _permission = {},
                _countryList = [],
                _countryData  = {
				    code : '+880',
                    flagcode  :  'b880'
                    },
                _sId = Storage.getCookie('sId'),
                _uId = Storage.getCookie('uId'),
                _utId = Storage.getCookie('utId'),
                _did = utilsFactory.generateUUID();

             $rootScope.$on('ringActive',function(){
                if(Cookies.get('sessionID') !== sessionID){

                    window.location.reload();
                }

             });



             function prepareApiData(which, obj, optionalParam) {
                 var payload = {
                 };

                switch(which) {
                    case 'recoveryVerifyCode':
                        payload.actn  = OTYPES.PASSWORD_RECOVER_VERIFY_CODE;
                        payload.uId  = obj.uId;
                        payload.vc  = obj.vc;
                        payload.wk  = utilsFactory.getUniqueID();
                        payload.lt  = 1; // server dependency sendSms ? 2 : 3
                        break;
                    case 'recoverySendCode':
                        payload.actn = OTYPES.PASSWORD_RECOVER_SEND_CODE;
                        payload.wk = utilsFactory.getUniqueID();

                        if(optionalParam) {
                            payload.lt = 2;
                            payload.rb = obj.mblDc+obj.mbl;
                            payload.mbl = obj.mbl;
                            payload.mblDc = obj.mblDc;
                        } else {
                            payload.lt = 3;
                            payload.rb = obj.email;
                            payload.el = obj.email.utf8Encode();
                        }
                        break;
                    case 'resetPassword':
                        payload.actn  = OTYPES.PASSWORD_RECOVER;
                        payload.uId  = obj.uId;
                        payload.nPw  = obj.password;
                        payload.wk  = utilsFactory.getUniqueID();
                        payload.lt  = 1; // server dependency  sendSms ? 2 : 3
                        break;
                    case 'isValidSession':
                        payload.actn  = OTYPES.TYPE_SESSION_VALIDATION;
                        payload.dvcc = 5;
                        payload.utId  = _utId;
                        payload.did = _did;
                        break;
                    case 'logout':
                        payload.actn = OTYPES.TYPE_SIGN_OUT;
                        break;
                    case 'validSocialId':
                        var url = (obj.platform === 'facebook') ?
                            settings.signupSocialInit + 'fb=' + obj.id + '&lt=4' : settings.signupSocialInit + 'twtr=' + obj.id + '&lt=5';
                        payload = url + '&time=' + new Date().getTime();
                        break;
                    case 'signupSendCode':
                        payload.wk = utilsFactory.getUniqueID();
                        payload.uId = obj.uId;
                        payload.did = obj.did;
                        payload.lt = 1; // server dependency

                        if (obj.authMethod === 'email') {
                            payload.el = obj.email.utf8Encode();
                            payload.actn = OTYPES.SIGNUP_SEND_CODE_EMAIL;
                        } else {
                            payload.actn = OTYPES.SIGNUP_SEND_CODE_PHONE;
                            payload.mbl = obj.mbl;
                            payload.mblDc = obj.mblDc;
                        }
                        break;
                    case 'signupVerifyCode':
                            payload.wk  = utilsFactory.getUniqueID();
                            payload.uId = obj.uId;
                            payload.did = obj.did;
                            payload.lt = 1; // server dependency

                            if((obj.authMethod === 'email')) {
                                payload.actn = OTYPES.SIGNUP_SEND_CODE_EMAIL;
                                payload.el = obj.email.utf8Encode();
                                payload.evc = obj.vc;
                            } else {
                                payload.actn = OTYPES.SIGNUP_SEND_CODE_PHONE;
                                payload.mbl = obj.mbl;
                                payload.mblDc = obj.mblDc;
                                payload.vc = obj.vc;
                            }
                            break;
                    case 'signup':
                        payload.actn  = OTYPES.SIGNUP_REGISTER;
                        payload.wk  = utilsFactory.getUniqueID();
                        payload.uId = obj.uId;
                        payload.did = obj.did;
                        payload.nm = obj.name.utf8Encode();
                        payload.usrPw = obj.password;
                        payload.lt = 1; // server dependency
                        // for all signup mobile no is required these are new params
                        payload.ispc = 0; // default for auth server
                        payload.mbl  = obj.mbl;
                        payload.mblDc  = obj.mblDc;

                        switch(obj.authMethod) {
                            case 'email':
                                payload.el = obj.email.utf8Encode();
                                payload.evc = obj.vc;
                                break;
                            case 'facebook':
                                payload.fb = obj.id;
                                payload.it = obj.access_token;
                                payload.lt = 4;
                                break;
                            case 'twitter':
                                payload.twtr = obj.id;
                                //var tokenObj = {
                                    //url: 'https://api.twitter.com/1.1/account/verify_credentials.json',
                                    //qs: 'oauth_timestamp=' + obj.oauthParameters.oauth_timestamp + '&oauth_version=' + obj.oauthParameters.oauth_version + '&oauth_consumer_key=' + obj.oauthParameters.oauth_consumer_key +
                                          //'&oauth_signature=' + obj.oauthParameters.oauth_signature + '&oauth_token=' + obj.access_token + '&oauth_nonce=' + obj.oauthParameters.oauth_nonce + '&oauth_signature_method=' + obj.oauthParameters.oauth_signature_method
                                //};
                                //payload.it = JSON.stringify(tokenObj);
                                //payload.it = 'oauth_token=' + obj.oauth_token +  '&verifier=' + obj.oauth_verifier;
                                payload.it = obj.access_token;
                                payload.lt = 5;
                                break;
                            default:
                                // with mobile
                                payload.mbl = obj.mbl;
                                payload.mblDc = obj.mblDc;
                                payload.vc = obj.vc;
                                //payload.lt = 1; // server dependency
                        }
                        break;
                    case 'login':
                            if (obj.hasOwnProperty('silent') && obj.silent === true) {
                                payload.actn = OTYPES.TYPE_SIGN_IN;
                                payload.vsn = settings.apiVersion;
                                payload.wk = utilsFactory.getUniqueID(); // default for auth server
                                payload.dvc = 5;
                                payload.tbid = utilsFactory.tabId;
                                return payload;
                            } else {
                                payload.actn = OTYPES.TYPE_SIGN_IN;
                                payload.vsn = settings.apiVersion;
                                payload.usrPw = obj.password;
                                payload.lt = 1;
                                payload.sn = settings.apiVersion; // auth server version
                                payload.wk = utilsFactory.getUniqueID();
                                payload.dvc = 5;
                                payload.tbid = utilsFactory.tabId;
                                payload.did = obj.did;

                                switch(obj.authMethod) {
                                    //case '+878': // ringid login
                                    case 'ringid': // ringid login
                                        payload.lt = 1;
                                        // URGENT. NEED TO CHECK WHAT IS THE SITUATION WITH BELOW CHECK
                                        payload.uId = !obj.silent ? '21' + obj.ringid : obj.ringid;
                                        //payload.uId = '21' + obj.ringid;
                                        break;
                                    case 'email': // email login
                                        payload.lt = 3;
                                        payload.el = obj.email.utf8Encode();
                                        break;
                                    case 'facebook':
                                        payload.uId = obj.uId;
                                        payload.pen = 1;
                                        payload.lt = 4;
                                        payload.apt = 1;
                                        payload.smid = obj.id;
                                        payload.it = obj.access_token;
                                        delete payload.usrPw;
                                        break;
                                    case 'twitter':
                                        payload.uId = obj.uId;
                                        delete payload.usrPw;

                                        payload.smid = obj.id;
                                        //var tokenObj = {
                                            //url: 'https://api.twitter.com/1.1/account/verify_credentials.json',
                                            //qs: 'oauth_timestamp=' + obj.oauthParameters.oauth_timestamp + '&oauth_version=' + obj.oauthParameters.oauth_version + '&oauth_consumer_key=' + obj.oauthParameters.oauth_consumer_key +
                                                  //'&oauth_signature=' + obj.oauthParameters.oauth_signature + '&oauth_token=' + obj.access_token + '&oauth_nonce=' + obj.oauthParameters.oauth_nonce + '&oauth_signature_method=' + obj.oauthParameters.oauth_signature_method
                                        //};
                                        //payload.it = JSON.stringify(tokenObj);
                                        //payload.it = 'oauth_token=' + obj.oauth_token +  '&verifier=' + obj.oauth_verifier;
                                        payload.it = obj.access_token;
                                        payload.lt = 5;
                                        break;
                                    default: // phone login
                                        payload.lt = 2;
                                        payload.mbl = obj.mbl;
                                        payload.mblDc = obj.mblDc;
                                }

                                /* Remember Me Salt and Previous sID */
                                if( !!obj.salt && !!obj.sId ){
                                    payload.salt = obj.salt;
                                    payload.sId = obj.sId;
                                }
                            }
                            break;
                    default:
                        payload = obj;
                 }

                 return payload;

             }




            function save(user) {
                Service._currentUser = user;
                //updateLoginData();
                return user;
            }


            function updateLocalStorageLoginData(loginData){
                if(!!loginData){
                    Service.loginData = loginData;
                    Storage.setData('loginData', loginData);
                }

            }


            var delete_cookie = function(name) {
                document.cookie = name + '=;expires=Thu, 01 Jan 1970 00:00:01 GMT;';
            };
            var clearCookies = function(keepSessionId){
                delete_cookie('uId');
                delete_cookie('utId');
                delete_cookie('sId');
                delete_cookie('authServer');
                delete_cookie('comPort');
                delete_cookie('la');
                delete_cookie('col');
                if(!keepSessionId){
                    delete_cookie('sessionID');
                    sessionID = undefined;
                }

                delete_cookie('la'); // last checked for login
            };

            var setCookies = function (loginData, days) {
                Storage.setCookie('uId', loginData.uId || '', days);
                Storage.setCookie('sId', loginData.sId || '', days);
                Storage.setCookie('utId', loginData.utId || '', days);
                // from login request
                if (days) {
                    Storage.setCookie('la', new Date().getTime(), days);
                }

                if (loginData.authServer) {
                    Storage.setCookie('authServer', loginData.authServer || '', days);
                }
                if (loginData.comPort) {
                    Storage.setCookie('comPort', loginData.comPort || '', days);
                }

                //var sessionId = Storage.getCookie('sessionID');
                //Storage.setCookie('sessionID', sessionId, 30);

                };

            var reloadHome = function(timeout, withRand) {

                if (!!timeout) {
                    clearCookies();
                    Storage.reset();
                }

                if(withRand) {
                    setTimeout(function() {
                        window.location = '/?rand=' + utilsFactory.getUniqueID();
                    }, timeout);

                } else {
                    setTimeout(function() {
                        window.location = '/';
                    }, timeout);
                }

            };

            function _saveDataForRememberMe(credentials, loginData, days){

                try {
                    var remData = {
                        usrPw : loginData.authEPassword,
                        salt : loginData.authESalt,
                        sId : loginData.sId,
                        lt : credentials.lt

                    };

                    switch(credentials.lt) {
                        case 1:
                            remData.uId = loginData.authEUsername;
                            break;
                        case 2:
                            remData.mbl = loginData.authEUsername;
                            remData.mblDc = credentials.mblDc;
                            break;
                        case 3:
                            remData.el = loginData.authEUsername;
                            break;
                        default:
                    }

                    Storage.setData('remInfo', remData);

                    var sessionId = Storage.getCookie('sessionID');
                    Storage.setCookie('sessionID', sessionId, days);


                } catch (e) {
                }

            }


            function initializeSignup(credentials, isSocial) {
                var defer = $q.defer();
                // step 1 ;
			    $ringhttp.get(settings.signupInit + 'did=' + _did + '&time=' + new Date().getTime()).success(function(response) {
                    if (response.success === true) {
                        // set auth ip and comport
                        setCookies({
                            uId: response.ringID,
                            authServer: response.authServerIP,
                            comPort: response.comPort
                        });
                        // signup step 2
                        credentials = angular.extend(credentials, {uId: response.ringID, did: _did});
                        // non social signup
                        if (!isSocial) {

                            $$connector.request(prepareApiData('signupSendCode', credentials), REQTYPE.AUTHENTICATION).then(function(json) {
                                defer.resolve(angular.extend(json, {uId: response.ringID}));
                            }, function(errJson) {
                                defer.reject(errJson);
                            });
                        } else {
                        // social signup
                            defer.resolve(credentials);
                        }
                    } else {
                        defer.reject(response);
                    }
                }).error(function() {
                    defer.reject();
                });
                return defer.promise;
            }


            function requestLogin(loginRequestData, defer) {
                loginInProgress = true;
                loginRequestData.did = _did;

                $$connector.request(prepareApiData('login', loginRequestData), REQTYPE.AUTHENTICATION).then(function (json) {
                    loginInProgress  = false;
                    if (json.sucs === true) {
                        Service._validSession = true;
                        if (loginRequestData.remember) {
                            _saveDataForRememberMe(loginRequestData, json, 30);
                            Storage.setData('remember', true);
                        } else {
                            // remove remember data if not checked
                            Storage.deleteData('remInfo');
                            Storage.deleteData('remember');

                        }

                        if (loginRequestData.authMethod) {
                            Storage.setData('activeTab', loginRequestData.authMethod); // only succesfull login request should set activeTab to localStorage upon response
                        }

                        doLoginTasks(json, true);
                        defer.resolve(json);
                    } else {
                        Service._validSession = false;
                        defer.reject(json);
                    }
                }, function (json) {
                    if (json.sucs === false && json.rc === 1111){
                        requestLogin(loginRequestData, defer);
                    } else {
                        Service._validSession = false;
                        loginInProgress  = false;
                        defer.reject({sucs: false, mg: 'Reqeust Failed'});
                    }
                });
            }


            //function ensureLoginState(sessionCheckDone) {
            function ensureLoginState() {
                var loginData =  Storage.getData('loginData');
                //var remInfo = Storage.getData('remInfo');
                // is login possible from localData or remember me ?
                if (loginData && (!window.hasOwnProperty('ringLoggedIn') || window.ringLoggedIn)) {
                    //$rootScope.$on('AUTH.LOGIN_REQUIRED', function() {
                        //Service.loginFromLocalData();
                    //});
                    //$rootScope.$on('AUTH.LOGIN_DONE', function() {
                        //$rootScope.$broadcast(SystemEvents.AUTH.LOGIN, true);
                    //});
                    doLoginTasks(loginData);
                    // is session check done and session is valid ?
                    //if (sessionCheckDone && Service._validSession) {
                        //if (loginData) {
                            //doLoginTasks(loginData);
                        //} else {
                            //Service.loginFromLocalData();
                        //}
                    //} else if (!sessionCheckDone) {
                        //checkSession(true);
                    //} else {
                        //doLogoutTasks();
                    //}
                } else {
                    doLogoutTasks();
                }


            }

            function handleInvalidSession(json) {
                switch(json.actn) {
                    case OTYPES.TYPE_MULTIPLE_SESSION:
                        if (!loginInProgress) {
                             Ringalert.alert({
                                title : 'Signed Out!',
                                message : 'You are signed in from another device',
                                showCancel : false,
                                okCallback : function() {
                                  doLogoutTasks(true);
                                }
                             });
                        }
                        break;
                    case OTYPES.TYPE_INVALID_LOGIN_SESSION:
                        //if (!loginInProgress && !invalidLoginProcessed) {
                        if (!loginInProgress ) {
                            invalidLoginProcessed = true;
                            Service.loginFromLocalData();
                        }
                        break;
                    case OTYPES.TYPE_SESSION_VALIDATION:
                        //if (!loginInProgress && !invalidSesssionProcessed) {
                        if (!loginInProgress ) {
                            invalidSesssionProcessed = true;
                            if (!Service.isLoggedIn()) {
                                Service.loginFromLocalData();
                            } else {
                                doLogoutTasks(true);
                            }
                        }
                        break;

                }

            }



            function fetchPrivacy() {
                return $$connector.request( {
                    actn: OTYPES.PHN_MAIL_VERIFICATION_CHECK//28
                }, REQTYPE.REQUEST);
            }



            var Service = {
                // holds current user
                _currentUser: null,

                _validSession: false,
                isPendingAsync: function() {
                    var pendingInterval,
                        defer = $q.defer();

                    if (pendingLogin) {
                        pendingInterval = setInterval(function() {
                            if (!pendingLogin) {
                                clearInterval(pendingInterval);
                                if (Service._validSession) {
                                    defer.resolve();
                                } else {
                                    defer.reject();
                                }
                            }
                        }, 1000);
                    } else {
                        defer.resolve();
                    }
                    return defer.promise;
                },
                isPending: function() {
                     return pendingLogin;
                },

                // template for login/ dashboard page
                sendCode: initializeSignup,
                updateLocalStorageLoginData : updateLocalStorageLoginData,
                verifyCode: function(credentials) {
                    credentials = angular.extend({}, credentials, {did: _did});
			        return $$connector.request(prepareApiData('signupVerifyCode', credentials), REQTYPE.AUTHENTICATION);
                },
                signup: function(credentials) {
                    var deferred = $q.defer();
                    // TODO BELOW COMMENTED CODE IS NECESSARY. MAKE SURE SERVER SUPPORTS THIS. NOW ALWAYS FALSE IS RETURNED
                    //authHttpService.validMobileNo({mbl: credentials.mbl, mblDc: credentials.mblDc , lt: 1 }).success(function(json) {
                        //if (json.sucs === true) {
                            angular.extend(credentials, {did: _did});

                            $$connector.request(prepareApiData('signup', credentials), REQTYPE.AUTHENTICATION).then(function(json) {
                                deferred.resolve(json);
                            }, function() {
                                deferred.reject();
                            });
                        //} else {
                            //// this mobile no already used in another account. let him signin or change the mobile
                            //deferred.reject({mg: 'This Mobile no is used in another account. If this is yours, try Forgot Password option or change this no'});
                        //}
                    //}).error(function() {
                        //deferred.reject();
                    //});
                    return deferred.promise;
                },
                // facebook and twitter signup
                openSignup: function(socialData, credentials) {
                    var deferred = $q.defer();

                    $ringhttp.get(prepareApiData('socialData')).success(function(response) {
                        if (response.success === false && response.rc === 2) {
                            // now show signup step 3 in popup
                           $ringbox.open({
                                    type : 'remote',
                                    scope:false,
                                    controller: 'SignUpController',
                                    resolve : {
                                        localData: {
                                            socialData:  socialData,
                                            credentials: credentials
                                        },
                                        remoteData : angular.noop //initializeSignup(socialData, true)
                                    },
                                    templateUrl : 'pages/welcome/ring-signup-popup.html'
                            });
                            deferred.resolve();
                        } else {
                            deferred.reject({rc: 'dologin', mg: 'Already Registered Social ID'});
                            // login anyway
                        }
                    }).error(function() {
                        deferred.reject({rc: 0, mg: 'Request Failed'});
                    });
                    return deferred.promise;
                },

                // login user
                login: function (loginRequestData, isSocial) {
                    var defer = $q.defer();
                    if (isSocial) {
                        angular.extend(loginRequestData, {did: _did});
                        $ringhttp.get(prepareApiData('validSocialId', loginRequestData)).success(function(json) {
                            if (json.success === true || json.success === 'true')  {
                                setCookies({
                                    uId: json.ringID,
                                    authServer: json.authServerIP,
                                    comPort: json.comPort
                                });
                                // attempt to login
                                loginRequestData.uId = json.ringID;
                                //loginRequestData.lt = loginRequestData.lt;
                                loginRequestData.authMethod = loginRequestData.platform;
                                requestLogin(loginRequestData, defer);
                            } else {
                                defer.reject({rc: 'invalidsocialid', mg: 'Unregistered Social ID. Please Register.'});
                            }
                        }).error(function() {
                            defer.reject({rc: 0, mg: 'Request Failed'});
                        });
                    } else {
                        // set current user auth method email, ringid or phonenumber for autofill
                        switch(loginRequestData.authMethod) {
                            case 'email':
                                Storage.setData('autoFill', loginRequestData.email);
                                break;
                            case 'ringid':
                                Storage.setData('autoFill', loginRequestData.ringid);
                                break;
                            case 'phone':
                                Storage.setData('autoFill', loginRequestData.mbl);

                        }
                        requestLogin(loginRequestData, defer);
                    }

                    return defer.promise;
                },

                // logout user
                logout: function(force) {
                    if(Service.isLoggedIn()) {
                        $rootScope.$broadcast(SystemEvents.LOADING, true);
			            $$connector.request(prepareApiData('logout'),REQTYPE.AUTHENTICATION).then(function(response) {
                            $rootScope.$broadcast(SystemEvents.LOADING, false);
                            //reloadHome(1);
                            doLogoutTasks(true);
                        });
                    }

                    setTimeout(function() {
                         doLogoutTasks(true);
                    }, 1000);

                    $$connector.stop();

                    //if(!!force){
                        //doLogoutTasks(true);
                        ////reloadHome(1);
                    //}else{
                        //do
                        //reloadHome(1000);
                    //}


                },
                clearCookies : function(keepSessionId){
                    clearCookies(keepSessionId);
                },

                loginFromLocalData: function () {
                    var remInfo = Storage.getData('remInfo');

                    if (!loginInProgress && !!remInfo && (remInfo.uId || remInfo.el || remInfo.mbl ) ) {
                        var loginRequestParams = {
                            remember: true,
                            silent : true
                        };
                        angular.extend(loginRequestParams, remInfo);

                        Service.login(loginRequestParams).then(function (json) {
                            if(!!json.sucs){
                                doLoginTasks(json);
                            }else{
                                doLogoutTasks();
                            }
                        }, function () {
                            doLogoutTasks();
                        });
                    } else {
                        doLogoutTasks();
                    }

                },

                // get current user
                currentUser: function() {
                    return Service._currentUser;
                },

                // checkes login status
                isLoggedIn: function() {
                    return !!Service._currentUser &&  !!Storage.getCookie('sId') && !!Storage.getCookie('sessionID');
                },
                // check Session Validity
                isValidSession: function(){
                   var defer = $q.defer();
                    if (_utId && _sId && _uId) {
                        $$connector.request(prepareApiData('isValidSession')).then(function(response) {
                            if(response.sucs) {
                                Service._validSession = true;
                                defer.resolve(response);
                            } else {
                                Service._validSession  = false;
                                defer.reject(response);
                            }
                        },function(){
                            defer.reject(Service._validSession);
                        });
                    } else {
                            defer.reject(Service._validSession);

                   }
                    return defer.promise;
                },
                reloadHome : reloadHome,
                getCountry: function() {
                    var countryData = Storage.getData('country');
                    if (countryData && countryData.country) {
                        _countryData.code  = countryData.code;
                        _countryData.flagcode = countryData.flagcode;
                    }

                    return _countryData;
                },
                getCountryList: function() {
                    return _countryList;
                },
                getPermission: function() {
                    return _permission;
                },
                setAchatPermission: function(param) {
                    _permission.ancht = param;
                },
                setAinfndreqPermission: function(param) {
                    _permission.aifr = param;
                },
                setAfamPermission: function(param) {
                    _permission.afam = param;
                },
                setAafPermission: function(param) {
                    _permission.aaf = param;
                },

                ensureLoginState: ensureLoginState,
                handleInvalidSession: handleInvalidSession,
                fetchPrivacy: fetchPrivacy,
                recoverySendCode : function(obj, sendSms) {
                    return $$connector.request(prepareApiData('recoverySendCode', obj, sendSms), REQTYPE.AUTHENTICATION);
                },
                recoveryVerifyCode : function(obj) {
                    return $$connector.request(prepareApiData('recoveryVerifyCode', obj), REQTYPE.AUTHENTICATION);
                },
                resetPassword : function(obj) {
                    return $$connector.request(prepareApiData('resetPassword', obj), REQTYPE.AUTHENTICATION);
                }

            };



             // preloading templates
            var preloadTemplates = [
                '/pages/dropdowns/notification-dropdown.html',
                '/pages/dropdowns/friend-request-dropdown.html',
                '/pages/partials/emoticon-window.html',
                '/pages/dropdowns/circle-list-dropdown.html',
                '/pages/dropdowns/search-dropdown.html',
                '/pages/partials/hovercards/profile-hover.html',

                '/pages/partials/notification/image-popup.html',
                '/pages/partials/notification/media-popup.html',
                '/pages/partials/notification/feed-popup_with_image.html',
                '/pages/partials/stickers/popups/sticker-market.html'
            ];

            function preLoad(templateUrl) {
                setTimeout(function() {
                    $ringhttp.get(templateUrl).success(function() {
                    });
                }, 100);
            }



            function fetchCountries() {
                if (_countryList.length === 0)  {
                    countryListService.getList().success( function(data) {
                        _countryList = data;
                        var country = Storage.getData('country');
                        if (!country || !country.country) {
                            $ringhttp.get(settings.baseUrl + '/country').success(function(country) {
                                if (country && country.length > 0) {
                                    country = country.toLowerCase();
                                    for (var i = 0; i < _countryList.length; i++) {
                                        if (_countryList[i].country.toLowerCase() === country) {
                                            _countryData.code   = _countryList[i].code;
                                            _countryData.flagcode = _countryList[i].flagcode;
                                            Storage.setData('country', _countryList[i]);
                                            break;
                                        }

                                    }
                                }
                            });
                        } else {
                            _countryData.code = country.code;
                            _countryData.flagcode = country.flagcode;
                        }
                    });
                }
            }

            function doLogoutTasks (reload) {
                save(null);
                pendingLogin = false;
                Service.clearCookies(true);
                Storage.reset();

                // cloase any ringbox if open
                $ringbox.closeAll();
                // close any dropdown if any is open
                rgDropdownService.close();

                if (reload) {
                    reloadHome(1);
                } else {
                    fetchCountries();
                    $rootScope.$broadcast(SystemEvents.AUTH.LOGIN, false);
                }
            }

            function doLoginTasks (loginData, fromLogin) {
                //$ocLazyLoad.load('ringidFriends');
                //$ocLazyLoad.load('ringidFeed');

                Service.loginData = loginData;
                setCookies(loginData, fromLogin ? 30 : false);

                // save current user
                save(userFactory.create(loginData, true, true));
                // init localStorage
                Storage.init(loginData);

                // preload templates
                setTimeout(function() {
                  preloadTemplates.forEach(preLoad)   ;
                }, 2000);


                $$connector.resume();
                $$connector.keepAlive();

                // pull current user permissions
                //if (fromLogin) {
                    pendingLogin = false;
                    $rootScope.$broadcast(SystemEvents.AUTH.LOGIN, true);
                //}

                setTimeout(function() {
                    fetchPrivacy().then(function(json) {
                        pendingLogin = false;
                        if (json.sucs === true) {
                            Service._validSession = true;
                            _permission = json;
                            //if (!fromLogin) {
                                //$rootScope.$broadcast(SystemEvents.AUTH.LOGIN, true);
                            //}

                        } else {
                            Service._validSession = false;
                            //if (!fromLogin) {
                                //Service.loginFromLocalData();
                            //}
                        }
                    }, function() {
                        pendingLogin = false;
                        //if (!fromLogin) {
                            //Service.loginFromLocalData();
                        //}
                    });
                });

            }

            //function checkSession(force) {
                //var lastChecked =  parseInt(Storage.getCookie('la')),
                    //nowTime = new Date().getTime();

                //if (force || (lastChecked &&  (lastChecked + settings.sessionTimeout) < nowTime ) ) { // more than 6 hours old
                    //// need to validate session
                    //Service.isValidSession(true).then(function(){
                        //Storage.setCookie('la', nowTime);
                        //if (Service._validSession) {
                            //ensureLoginState(true);
                        //} else {
                            //doLogoutTasks();
                        //}
                   //},function(){
                        //doLogoutTasks();
                    //});
                    //return false;
                //} else {
                    //return true;
                //}
            //}


        return Service;

    }


})();



(function(){
    'use strict';
    angular
    .module('ringid.global.services')
    .factory('chatHistoryFactory', ['Storage', 'Auth', 'userFactory',  'SystemEvents', 'utilsFactory',
            function (Storage, Auth, userFactory, SystemEvents, utilsFactory) {

                var CHAT_GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;
                var CHAT_VERSION_INFO = CHAT_APP.Constants.CHAT_VERSION_INFO;
                var chatOpenedBoxes= {},
                    chatBoxes = {},
                    unreadMessageInfos = {},
                    unreadMessageCount = 0,
                    coversationCount  = 0;

                var loadChatBoxes = function(){
                    chatOpenedBoxes = Storage.getData('chatOpenedBoxes') || {};
                    chatBoxes = Storage.getData('chatBoxes') || {};

                };

                //var initUnreadMessageCount = function(){

                //var chatOpenedBoxes= {},
                    //chatBoxes = {},
                    //unreadMessageInfos = {},
                    //unreadMessageCount = 0;

                //var loadChatBoxes = function(){
                    //chatOpenedBoxes = Storage.getData('chatOpenedBoxes') || {};
                    //chatBoxes = Storage.getData('chatBoxes') || {};

                //};

                var _getUnreadConversationCount = function(){
                    return coversationCount;
                };

                var _resetConversationCount = function(){
                    coversationCount = 0;
                };

                var initUnreadMessageCount = function(){
                    coversationCount = 0
                    Object.keys(unreadMessageInfos).forEach(function(val, key){
                        unreadMessageCount += Object.keys(val).length;
                        coversationCount++;
                    });
                };              

                var loadUnreadMessageInfos = function(){

                    var _unreadMessageInfos = Storage.getData('unreadMessageIds');

                    unreadMessageCount = 0;
                    coversationCount = 0;

                    if( !_unreadMessageInfos ){

                        unreadMessageInfos =  {};

                    }else{
                        
                        Object.keys(_unreadMessageInfos).forEach(function(aBoxId, key){

                            unreadMessageInfos[aBoxId] = {};

                            _unreadMessageInfos[aBoxId].forEach(function(packetId, key){
                                unreadMessageInfos[aBoxId][packetId] = true;
                                unreadMessageCount++;
                            })

                            coversationCount++;

                        });
                    }

                };

                var _updateUnreadMessageInfos = function(async){
                    if(async !== false){
                        async = true
                    }

                    var _unreadMessageInfos = {}
                    Object.keys(unreadMessageInfos).forEach(function(aBoxId, key){
                        _unreadMessageInfos[aBoxId] = Object.keys(unreadMessageInfos[aBoxId]);
                    })

                    Storage.setData('unreadMessageIds', _unreadMessageInfos, async);

                    utilsFactory.triggerCustomEvent(SystemEvents.CHAT.UNREAD_MESSAGE_INFO_UPDATED);

                };

                var migrateLocalDb = function(){
                    chatOpenedBoxes= {};
                    chatBoxes = {};
                    _updateChatBoxes(false);
                    _updateChatOpenBoxes(false);
                    _updateUnreadMessageInfos(false);
                    saveChatGeneralInfo(CHAT_VERSION_INFO, false);
                };

                var loadChatGeneralInfo = function(){

                    var cgInf = Storage.getData('cgInf');

                    if( !cgInf || !cgInf.version || cgInf.version != CHAT_VERSION_INFO.version){
                        migrateLocalDb();
                    }

                    if(!cgInf){
                        saveChatGeneralInfo();
                    }else{
                        angular.extend(CHAT_VERSION_INFO, cgInf);
                    }

                };

                var saveChatGeneralInfo = function(info, async){
                    if(async !== false){
                        async = true
                    }

                    if(!!info){
                        angular.extend(CHAT_VERSION_INFO, info);
                    }

                    Storage.setData('cgInf', CHAT_VERSION_INFO, async);
                };

                var getHistoryMessageObject = function(message){

                    if( !message.user){
                        message.user = userFactory.create(message.user);
                    }

                    var userId = message.user;
                    try{
                        var userId = message.user.getKey();    
                    }catch(e){}                    

                    var messageObject = {
                        key              : message.key,
                        packetId         : message.packetId || message.key,
                        packetType       : message.packetType || 6,
                        brokenPacketType : message.brokenPacketType || 8,
                        platform         : message.platform || 5,
                        text             : message.text || message.message || message.mg,
                        hrtime           : message.hrtime,
                        status           : message.status || 0,
                        //status         : message.status || 'Received',
                        seenSent         : message.seenSent || false,
                        messageDate      : message.messageDate,
                        isDeleted        : message.isDeleted,
                        latitude         : message.latitude,
                        longitude        : message.longitude,
                        messageDateString: message.messageDateString || '',
                        timeout          : message.timeout,
                        messageType      : message.messageType,
                        tag_chat         : message.tag_chat,
                        isSecretVisible  : message.isSecretVisible,
                        secretTimedOut   : message.secretTimedOut ? message.secretTimedOut : false,
                        //user           : angular.isObject(user) ? user : userFactory.getUser(message.uId),
                        user             : userId
                    };

                    if( !!message.usersToChange ){
                        messageObject.usersToChange = message.usersToChange;
                    }

                    if( !!message.statusType){
                        messageObject.statusType = message.statusType;
                    }

                    return messageObject;

                };

                var _updateChatBoxes = function(async){
                    if(async !== false){
                        async = true
                    }

                    Storage.setData('chatBoxes', chatBoxes, async);
                };

                var _updateChatOpenBoxes = function(async){
                    if(async !== false){
                        async = true
                    }

                    Storage.setData('chatOpenedBoxes', chatOpenedBoxes, async);
                };


                var _addOpenBoxes = function (boxId, isTagChat) {
                    var boxId = boxId.toString();

                    if (!chatOpenedBoxes) {
                        chatOpenedBoxes = {};
                    }
                    if(!chatOpenedBoxes[boxId]){
                        chatOpenedBoxes[boxId] = {
                            boxId : boxId,
                            isTagChat : isTagChat
                        };
                    }

                    _updateChatOpenBoxes();
                };

                var _getMessageByPacketId = function(boxId, packetId){
                    if(!!chatBoxes[boxId]){
                        var messages = chatBoxes[boxId]['messages'];
                        if(!!messages){
                            for(var index = 0, length = messages.length; index < length; index++){
                                if( messages[index].key == packetId){
                                    return messages[index];
                                }
                            }
                        }
                    }
                    return false;
                };

                var _addUnreadMessageInfo  = function(boxId, messageId){

                    if(!unreadMessageInfos[boxId]){
                        unreadMessageInfos[boxId] = {};                        
                        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.UNREAD_MESSAGE_INFO_UPDATED);
                    }

                    if( !unreadMessageInfos[boxId][messageId]){
                        unreadMessageInfos[boxId][messageId] = true;
                        unreadMessageCount++;
                    }

                    coversationCount = Object.keys(unreadMessageInfos).length;

                };



                var _removeUnreadMessageInfo = function(boxId, messageId){
                    if( !unreadMessageInfos[boxId] || !unreadMessageInfos[boxId][messageId]){
                        return;
                    }else{
                        delete unreadMessageInfos[boxId][messageId];
                        unreadMessageCount--;
                    }

                    _updateUnreadMessageInfos();
                };

                var _removeUnreadMessageInfoByBoxId = function(boxId){
                    var aBox = chatBoxes[boxId];
                    if( !unreadMessageInfos[boxId] ){
                        return;
                    }

                    var boxUnreadCount = Object.keys(unreadMessageInfos[boxId]).length;
                    delete unreadMessageInfos[boxId]
                    unreadMessageCount -= boxUnreadCount;

                    if( unreadMessageCount < 0){
                        unreadMessageCount = 0;
                    }

                    _updateUnreadMessageInfos();
                    
                    coversationCount = Object.keys(unreadMessageInfos).length;
                    utilsFactory.triggerCustomEvent(SystemEvents.CHAT.UNREAD_MESSAGE_INFO_UPDATED);


                };

                var _getUnreadMessageInfos = function(){
                    return unreadMessageInfos;
                };

                var _getUnreadMessageCount = function(){
                    return unreadMessageCount;
                };

                var _getUnreadMessageCountByBoxId = function(boxId){
                    if( !unreadMessageInfos[boxId] ){
                        return 0;
                    }

                    return Object.keys(unreadMessageInfos[boxId]).length
                };

               


                var _init = function(){

                    loadChatGeneralInfo();
                    loadChatBoxes();
                    loadUnreadMessageInfos();

                }

                var ReturnOb =  {

                    init : _init,

                    loadChatBoxes : loadChatBoxes,
                    loadChatGeneralInfo : loadChatGeneralInfo,
                    saveChatGeneralInfo : saveChatGeneralInfo,
                    updateChatOpenBoxes : _updateChatOpenBoxes,
                    updateChatBoxes : _updateChatBoxes,

                    addUnreadMessageInfo : _addUnreadMessageInfo,
                    removeUnreadMessageInfo : _removeUnreadMessageInfo,
                    updateUnreadMessageInfos :_updateUnreadMessageInfos,
                    getUnreadMessageInfos : _getUnreadMessageInfos,
                    getUnreadMessageCount : _getUnreadMessageCount,
                    getUnreadConversationCount : _getUnreadConversationCount,
                    resetConversationCount : _resetConversationCount,
                    getUnreadMessageCountByBoxId : _getUnreadMessageCountByBoxId,
                    removeUnreadMessageInfoByBoxId : _removeUnreadMessageInfoByBoxId,

                    getMessageByPacketId : _getMessageByPacketId,

                    getChatOpenBoxes : function(){
                        return chatOpenedBoxes;
                    },

                    getChatBoxes : function(){
                        return chatBoxes;
                    },

                    addOpenBox: _addOpenBoxes,

                    removeOpenBox: function (boxId) {

                        if(!!chatOpenedBoxes[boxId]){
                            delete chatOpenedBoxes[boxId];
                        }

                        _updateChatOpenBoxes();

                    },

                    countOpenBoxes: function () {

                        if (chatOpenedBoxes) {
                            return Object.keys(chatOpenedBoxes).length;
                        } else {
                            return 0;
                        }
                    },
                    getAllOpenBoxes: function () {

                        if(chatOpenedBoxes && Object.keys(chatOpenedBoxes).length > 0){
                            return chatOpenedBoxes;
                        }else{
                            return false;
                        }
                    },
                    addBox: function (box) {

                        _addOpenBoxes(box.key, box.isTagChat);

                        var box = {
                            key            : box.key,
                            ip             : box.ip,
                            rPort          : box.rPort,
                            closedBox      : box.closedBox,
                            isMinimized    : box.isMinimized,
                            isHidden       : box.isHidden,
                            isFocused      : box.isFocused,
                            blinkOn        : box.blinkOn,
                            timeout        : box.timeout,
                            secretChat     : box.secretChat,
                            nonDomBox      : box.nonDomBox,
                            offlineStatus  : box.offlineStatus,
                            isTagChat      : box.isTagChat,
                            chatBoxClass   : box.chatBoxClass,
                            unreadCount    : box.unreadCount,
                            isSecretVisible: box.isSecretVisible,
                            blocked        : box.blocked,
                            blockedByUtId  : box.blockedByUtId,
                            //serverTimeDiff: box.serverTimeDiff,
                            messages       : []
                        };

                        if (!chatBoxes) {
                            chatBoxes = {};
                        }

                        if(!chatBoxes[box.key]){
                            chatBoxes[box.key] = box;
                        }

                        _updateChatBoxes();

                    },
                    updateBox: function (box) {

                        var box       = {
                            key            : box.key,
                            ip             : box.ip,
                            rPort          : box.rPort,
                            closedBox      : box.closedBox,
                            isMinimized    : box.isMinimized,
                            isHidden       : box.isHidden,
                            isFocused      : box.isFocused,
                            blinkOn        : box.blinkOn,
                            timeout        : box.timeout,
                            secretChat     : box.secretChat,
                            nonDomBox      : box.nonDomBox,
                            offlineStatus  : box.offlineStatus,
                            isTagChat      : box.isTagChat,
                            isSecretVisible: box.isSecretVisible,
                            blocked        : box.blocked,
                            blockedByUtId  : box.blockedByUtId,
                            chatBoxClass   : box.chatBoxClass,
                            unreadCount    : box.unreadCount
                            //serverTimeDiff: box.serverTimeDiff
                        };

                        if (!chatBoxes) {
                            chatBoxes = {};
                        }

                        if(!chatBoxes[box.key]){
                            chatBoxes[box.key] = box;
                        }else{
                            angular.extend(chatBoxes[box.key], box);
                        }

                        _updateChatBoxes();

                    },
                    getBox: function (key) {

                      if(!chatBoxes[key]){
                          return false;
                      }

                      return chatBoxes[key];

                    },
                    addMessage: function (message, boxId) {
                        var boxId = boxId.toString();

                        if(!!chatBoxes[boxId]){

                            if( !message.user || !message.user.getKey){
                                message.user = userFactory.create(message.user);
                            }

                            var messageObject = {
                                key              : message.key || message.packetId,

                                packetId         : message.packetId || message.key,
                                packetType       : message.packetType || 6,
                                brokenPacketType : message.brokenPacketType || 8,
                                platform         : message.platform || 5,

                                text             : message.text || message.message || message.mg,
                                hrtime           : message.hrtime || '',
                                status           : message.status || 0,
                                fullName         : message.fullName || '',
                                tagName          : message.tagName || '',
                                messageDate      : message.messageDate,
                                seenSent         : message.seenSent || false,
                                isDeleted        : message.isDeleted || false,

                                messageDateString: message.messageDateString || '',
                                timeout          : message.timeout || 0,
                                messageType      : message.messageType,
                                tag_chat         : message.tag_chat,
                                isSecretVisible  : message.isSecretVisible,
                                secretTimedOut   : message.secretTimedOut ? message.secretTimedOut : false,
                                user             : message.user.getKey(),
                                userId           : message.user.getKey()
                            };

                            if( !message.user){
                            }


                            if( !!message.statusType){
                                messageObject.statusType = message.statusType;
                            }

                            if( !!message.usersToChange ){
                                messageObject.usersToChange = message.usersToChange;
                            }

                            if(!chatBoxes[boxId].messages){
                                chatBoxes[boxId].messages = [];
                            }

                            //find if that message(check with messageKey/packetId) exists, if exists then dont push otherwise does
                            var messageKeyFlag = 0;
                            try{
                                for(var j=0; j<chatBoxes[boxId].messages.length; j++){
                                    if(chatBoxes[boxId].messages[j].key === messageObject.key){
                                        messageKeyFlag = 1;
                                        break;
                                    }
                                }
                            }catch(e){
                            }


                            if(messageKeyFlag ===0){
                                chatBoxes[boxId].messages.push(messageObject);

                                chatBoxes[boxId].messages.sort(function(aMessage, bMessage){
                                    return aMessage.messageDate - bMessage.messageDate
                                });

                                chatBoxes[boxId].messages.splice(0, chatBoxes[boxId].messages.length - CHAT_GENERAL_CONSTANTS.HISTORY_MAX_MESSAGE);

                            }
                        }


                        _updateChatBoxes();
                    },
                    removeMessage: function (messageKey, boxId) {

                        var boxId = boxId.toString();

                        var removed = false;
                        if(chatBoxes) {
                            if (!!chatBoxes[boxId]) {
                                for (var j = 0; j < chatBoxes[boxId].messages.length; j++) {
                                    if (chatBoxes[boxId].messages[j].key === messageKey) {
                                        chatBoxes[boxId].messages.splice(j, 1);
                                        removed = true;
                                        // _removeUnreadMessageInfo(messageKey);
                                    }
                                }
                            }
                        }

                        if(removed){
                            _updateChatBoxes();
                        }
                    },

                    updateMessage: function (message, boxId) {

                        var boxId = boxId.toString();

                        var currentUserId = Auth.loginData.uId;

                        if(!!chatBoxes[boxId]){

                            if( !angular.isObject(message.user)){
                                message.user = userFactory.create(message.user);
                            }

                            var messageObject = {
                                key              : message.key,

                                packetId         : message.packetId || message.key,
                                packetType       : message.packetType || 6,
                                brokenPacketType : message.brokenPacketType || 8,
                                platform         : message.platform || 5,

                                text             : message.text || message.message || message.mg,
                                hrtime           : message.hrtime,
                                status           : message.status || 0,
                                //status: message.status || 'Received',
                                seenSent         : message.seenSent || false,
                                messageDate      : message.messageDate,
                                isDeleted        : message.isDeleted,
                                latitude         : message.latitude,
                                longitude        : message.longitude,
                                messageDateString: message.messageDateString || '',
                                timeout          : message.timeout,
                                messageType      : message.messageType,
                                isSecretVisible  : message.isSecretVisible,
                                tag_chat         : message.tag_chat,
                                secretTimedOut   : message.secretTimedOut ? message.secretTimedOut : false,
                                //user: angular.isObject(user) ? user : userFactory.getUser(message.uId),
                                user             : message.user.getKey()
                            };

                            if( !!message.usersToChange ){
                                messageObject.usersToChange = message.usersToChange;
                            }

                            if( !!message.statusType){
                                messageObject.statusType = message.statusType;
                            }

                            for(var j=0; j<chatBoxes[boxId].messages.length; j++){
                                if(chatBoxes[boxId].messages[j].key == messageObject.key){
                                    chatBoxes[boxId].messages[j] = messageObject;
                                    break;
                                }
                            }
                        }

                        _updateChatBoxes();
                    },

                    updateMessages: function (messages, boxId) {

                        if(! messages.length ){
                            return;
                        }

                        var boxId = boxId.toString();

                        var messagesCache = {};
                        for(var index = 0, len = messages.length; index < len; index++){
                            messagesCache[messages[index].key] = messages[index];
                        }

                        if(chatBoxes){
                            var currentUserBox = chatBoxes[boxId];

                            for(var j=0; j<currentUserBox.messages.length; j++){
                                var historyMessage = currentUserBox.messages[j];
                                var cachedMessage = messagesCache[historyMessage.key];
                                if( !!cachedMessage){
                                    currentUserBox.messages[j] = getHistoryMessageObject(cachedMessage);
                                }
                            }

                        }

                        _updateChatBoxes();
                    },

                    isInLocalStorageChatMsgMap : function(boxId, packetId){
                       try{
                           return !!chatBoxes[boxId][packetId];
                       }catch(e){
                            return false;
                        }
                    },
                    countMessage: function (boxId) {
                        var currentUserId = Auth.loginData.uId;

                        if(chatBoxes[boxId]){
                            var box = chatBoxes[boxId];
                            return !!box.messages ? box.messages.length : 0;
                        }

                        return false;

                    },
                    getMessages: function (boxId) {

                        if(chatBoxes[boxId]){
                            var box = chatBoxes[boxId];
                            return box.messages;
                        }

                        return [];
                    },

                    getMessage : function(boxId, packetId){
                        if( !!chatBoxes[boxId] && !!chatBoxes[boxId].messages){
                            for(var j=0; j<chatBoxes[boxId].messages.length; j++){
                                if(chatBoxes[boxId].messages[j].key == packetId){
                                    return chatBoxes[boxId].messages[j];
                                }
                            }
                        }
                        return false;
                    }
                };

                return ReturnOb;

            }
        ]);

})();


/*
* © Ipvision
*/

(function(){
    'use strict';
    angular
        .module('ringid.global.services')
        .factory('Storage', StorageFactory);


        StorageFactory.$inject = [];
        function StorageFactory() {
            var _storeKey,
                gotStore = false,
                storage;

            var _storageAvailable = function(type) {
                try {
                    var testStorage = window[type],
                        x = '__storage_test__';
                    testStorage.setItem(x, x);
                    testStorage.removeItem(x);
                    gotStore = true;
                    return window[type];
                }
                catch(e) {
                    gotStore = false;
                    return {};
                }
            };

            storage = _storageAvailable('localStorage');

            var _setKey = function(key) {
                _storeKey = key;
                if( angular.isDefined(storage[_storeKey]) )  { // in case localStorage data does not have key/utId
                    _setData(_storeKey, {});
                }
            };

            var _getKey = function(key) {
                switch(key) {
                        //key = 'ngStorage' + '-' + key;
                        //break;
                    case 'loginData':
                    case 'country':
                    case 'remInfo':
                    case 'stickerData':
                        break;

                    case 'chatOpenedBoxes':
                    case 'chatBoxes':
                    case 'cgInf':
                    case 'cts' :
                    case 'unreadMessageIds':
                    case 'uLocationInfo' :

                    case 'mood':
                    case 'utIds':
                    case 'incomingUtIds':
                    case 'outgoingUtIds':
                    case 'suggestionUtIds':
                    case 'contacts':
                    case 'notikeys':
                    case 'notiseen':
                    case 'oldNotiCount':
                    case 'mediaRecent':
                    case 'albumname':
                    case 'circledata':
                    case 'circleut':
                    case 'myStickers':
                        key = _storeKey + '-' + key;
                        break;
                    default:
                        // nothing to do. send key as is
                }
                return key;
            };

            var _setData = function(key, data) {
                key = _getKey(key);
                if(gotStore) {
                    storage.setItem(key, angular.toJson(data));
                } else {
                    storage[key] =  angular.toJson(data);
                }
            };

            var _getData = function(key) {
                key = _getKey(key);
                if(gotStore) {
                    return angular.fromJson(storage.getItem(key));
                } else {
                    return angular.fromJson(storage[key]);
                }
            };

            var _clearData = function(key) {
                key = _getKey(key);
                if(gotStore) {
                    storage.removeItem(key);
                } else {
                    delete storage[key];
                }
            };

            function _init(loginData) {
                var regExMatch;

                function initStorage() {
                    //if( !_getData('utIds') ) { // initialize in case no data from previous login
                        //_setData('utIds', []);
                    //}
                    //if( !_getData('incomingUtIds') ) { // initialize in case no data from previous login
                        //_setData('incomingUtIds', []);
                    //}

                    //if( !_getData('outgoingUtIds') ) { // initialize in case no data from previous login
                        //_setData('outgoingUtIds', []);
                    //}

                    if( !_getData('contacts')) {
                        _setData('contacts', {});
                    }

                    if( !_getData('chatOpenedBoxes')) {
                        _setData('chatOpenedBoxes', {});
                    }

                    if( !_getData('chatBoxes')) {
                        _setData('chatBoxes', {});
                    }

                    if( !_getData('unreadMessageIds')) {
                        _setData('unreadMessageIds', []);
                    }

                    if( !_getData('mediaRecent')) {
                        _setData('mediaRecent', []);
                    }

                    if( !_getData('notiseen')) {
                        _setData('notiseen', []);
                    }

                    if( !_getData('oldNotiCount')) {
                        _setData('oldNotiCount', 0);
                    }

                    if( !_getData('uLocationInfo')) {
                        _setData('uLocationInfo', {});
                    }

                    // check if other user data present and delete
                    if(gotStore) {
                        var removeKeys = [];
                        for ( var i = 0, len = storage.length; i < len; ++i ) {
                            regExMatch = storage.key(i).match(/(\d+)-([a-z]+)/i);
                            if(regExMatch && regExMatch.length > 1 && regExMatch[1] != _storeKey  ) {
                                // remove this other user data
                                //console.warn('deleted key: ' + storage.key(i));
                                //console.log(regExMatch);
                                removeKeys.push(storage.key(i));

                            }

                        }
                        removeKeys.forEach(function(key) {
                            _clearData(key);
                        });
                    }

                }

                if(loginData) {
                    loginData = angular.fromJson(loginData);
                    _setKey(loginData.utId);
                    _setData('loginData', loginData);
                    initStorage();
                } else  if (Cookies.get('utId')){
                    _setKey(Cookies.get('utId'));
                    initStorage();
                }


            }

            var _asyncSetData = function(key, value){
                setTimeout(function(){
                    _setData(key, value);
                }, 200);
            };

            _init(_getData('loginData'));

            return {
                init: function(loginData) {
                    _init(loginData);
                },
                reset: function() {
                    _clearData('loginData');
                    _clearData('remInfo');
                    _clearData('contacts');
                    _clearData('chatOpenedBoxes');
                    _clearData('suggestionUtIds');
                },
                setData: function(key, value, async) {
                    if( !!async){
                        _asyncSetData(key, value);
                    }else{
                        _setData(key, value);
                    }
                },
                getData: function(key) {
                    return _getData(key);
                },
                deleteData : function(key){
                    _clearData(key);
                },
                // customised setter and getters
                setContact: function(utId, contact) {
                    if (utId) {
                        var contacts = _getData('contacts') || {};
                        if(contacts.hasOwnProperty(utId)) {
                            contacts[utId] = angular.extend({}, contacts[utId], contact);
                        } else {
                            contacts[utId] = contact;
                        }
                        _setData('contacts', contacts);
                    }
                },
                getContact: function(utId) {
                    var contacts =  _getData['contacts'];
                    if(contacts && contacts[utId]) {
                        return contacts[utId];
                    } else {
                        return null;
                    }
                },

                updateLoginData: function(key, value) {
                    var loginData = _getData('loginData');
                    loginData[key] = value;
                    _setData('loginData', loginData);
                },
                //
                setCookie : function(key, val, days){

                    if(!!days){
                        Cookies.set(key, val, { expires: days });
                    }else{
                        Cookies.set(key, val);
                    }
                },

                getCookie : function(key){
                    return Cookies.get(key);

                },
                removeCookie : function(key){
                    return Cookies.remove(key);
                }

            };

            /////////

            function _writeCookie (key, value, days) {
                var date = new Date();

                // Default at 365 days.
                days = days || 365;

                // Get unix milliseconds at current time plus number of days
                date.setTime(+ date + (days * 86400000)); //24 * 60 * 60 * 1000

                window.document.cookie = key + "=" + value + "; expires=" + date.toGMTString() + "; path=/";

                return value;
            }

        }

})();

'use strict';

angular
    .module("ringid.global.services")
    .provider('$ringbox', function () {

        var $ringboxProvider = {
            boxes: [],
            boxeScopes: [],
            boxeDeferred: [],
            template : '<div class="ringbox">'
            					+'<div class="ringbox-overlay"></div>'
    							+'<div class="ringbox-outerContainer">'
        							 +'<div class="ringbox-content ringbox-invisible">'
        							 	+'<div class="ringbox-inner"></div>'
        							 	+'<div class="ringbox-loader"><div class="loader"><div class="circle1"></div><div class="circle2"></div><div class="circle3"></div></div>'
        							 +'</div>'
    							 +'</div>'
						+'</div>',
    		    init: function () {
    		       var boxDom = angular.element(this.template);
    		       this.boxes.push(boxDom);
    		       return boxDom;
    		    },
            adjustBoxes: function() {

               for(var i=0;i<this.boxes.length;i++) {
                  this.boxes[i].removeClass('rl_'+i);
               }
               for(var i=0;i<this.boxes.length;i++) {
                  this.boxes[i].addClass('rl_'+i);
               }
            },

            $get: ['$injector', '$rootScope', '$$q', '$templateCache', '$controller','$compile','$document', '$player','$ringhttp','$sniffer','Notification', 'SystemEvents', 'utilsFactory',
                function ($injector, $rootScope, $q, $templateCache, $controller, $compile, $document, $player,$ringhttp,$sniffer, Notification, SystemEvents, utilsFactory) {
                    var $ringbox = {}, $this = this, prefix = $sniffer.vendorPrefix.toLowerCase();

                    function getTemplatePromise(options) {
                        if(options.template){
                          return $q.when(options.template);
                        }
                        var url = angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl;
                        if($templateCache.get(url)){
                            return $q.when($templateCache.get(url));
                        }else{
                          var defer = $q.defer();
                          $ringhttp.get(url).success(function(result){
                                $templateCache.put(url,result);
                                defer.resolve(result);
                             // return result;
                          }).error(function(){
                              defer.reject();
                          });
                          return defer.promise;
                        }

                        // return options.template ? $q.when(options.template) :
                        //     $http.get(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl,
                        //         {cache: $templateCache}).then(function (result) {
                        //             return result.data;
                        //         });
                    }

                  function getResolvePromises(resolves) {
                      var promisesArr = [];
                       angular.forEach(resolves, function (value) {
                            if(angular.isDefined(value.promise)){
                                promisesArr.push(value.promise);
                            } else if (angular.isFunction(value)) {
                                promisesArr.push($q.when($injector.invoke(value)));
                            }else if(angular.isArray(value) || angular.isObject(value)){
                                    promisesArr.push(value);
                            }
                       });
                      return promisesArr;
                   }

                    $ringbox.minimizedBox = {dom:null, scope:null, deferred:null};

                    $ringbox.clear = function (scope, defer, param) {

                      if($this.boxes.length==0) {
                        document.body.className = document.body.className.replace('ringbox-opened','').trim();
                      }

                      if(scope) {
                        scope.$destroy();
                      }

                      if(defer) {
                        defer.resolve.apply(null, param);
                      }

                       /*clear player resource*/
                       if(!$player.miniPlayer.player && $this.boxes.length == 0) {
                          $player.destroyAll();
                       }

                    }

                    $ringbox.close = function(event) {
                        if (event && event.stopPropagation) {
                            event.stopPropagation();
                        }

                       if($this.boxes.length>0)
                       {
                         $this.boxes.pop().remove();
                         $ringbox.clear($this.boxeScopes.pop(), $this.boxeDeferred.pop(), arguments);
                       }

                    }

                    $ringbox.closeAll = function() {
                       for(var i=$this.boxes.length-1;i>=0;i--) {
                          $this.boxes.pop().remove();
                          $ringbox.clear($this.boxeScopes.pop(), $this.boxeDeferred.pop(), arguments);
                       }
                    }


                    /* required for mini player*/
                    var eventTranstionEnd = function () {

                        $ringbox.minimizedBox.dom[0].style.display = 'none';
                        $player.showMiniPlayer();

                        if($this.boxes.length == 0) {
                          document.body.className = document.body.className.replace('ringbox-opened','');
                        }
                    };

                    $ringbox.removeMinimize = function() {

                       if($ringbox.minimizedBox.dom) {
                          $ringbox.minimizedBox.dom.remove();
                       }

                       if($ringbox.minimizedBox.scope) {
                         $ringbox.minimizedBox.scope.$destroy();
                       }
                       /*
                       if($ringbox.minimizedBox.deferred) {
                         $ringbox.minimizedBox.deferred.resolve.apply(null, param);
                       } */

                    }

                    $ringbox.minimize = function() {

                       if($this.boxes.length>0) {

                             $ringbox.minimizedBox.dom = $this.boxes.pop();
                             $ringbox.minimizedBox.scope = $this.boxeScopes.pop();
                             $ringbox.minimizedBox.deferred = $this.boxeDeferred.pop();

                             var boxcontainer = $ringbox.minimizedBox.dom[0].querySelector('.ringbox-content'),
                             x = (boxcontainer.offsetLeft + ((boxcontainer.offsetWidth - 335)/2) - 200),
                        	   y = window.innerHeight - (boxcontainer.offsetTop + ((boxcontainer.offsetHeight - 150)/2)) - 120,
                             transfrom = ("translate(-" + x + "px," + y + "px) scale(0.35,0.24)");

                             $ringbox.minimizedBox.dom[0].querySelector('.pv-profile').style.display = 'none'; // hide comment part

                             boxcontainer.style.webkitTransition = 'transform 0.5s';
                  					 boxcontainer.style.MozTransition = 'transform 0.5s';
                  				   boxcontainer.style.msTransition = 'transform 0.5s';
                  					 boxcontainer.style.OTransition = 'transform 0.5s';
                  					 boxcontainer.style.transition = 'transform 0.5s';

                             boxcontainer.style.webkitTransform = transfrom;
                  					 boxcontainer.style.MozTransform = transfrom;
                  				   boxcontainer.style.msTransform = transfrom;
                  					 boxcontainer.style.OTransform = transfrom;
                  					 boxcontainer.style.transform = transfrom;

        					           //boxcontainer.addEventListener('webkitTransitionEnd', eventTranstionEnd);
                             //boxcontainer.addEventListener('msTransitionEnd', eventTranstionEnd);

                  					 boxcontainer.addEventListener(prefix+'TransitionEnd', eventTranstionEnd);
                  					 boxcontainer.addEventListener('transitionend', eventTranstionEnd);


                       }
                    }

                   $ringbox.maximize = function(parent, content) {

                     if($ringbox.minimizedBox.dom) {

                         var boxcontainer = $ringbox.minimizedBox.dom[0].querySelector('.ringbox-content');
                         var boxOverlayDom = $ringbox.minimizedBox.dom[0].querySelector('div.ringbox-overlay');


                         $ringbox.minimizedBox.dom[0].querySelector('.pv-profile').style.display = 'block';
                         $ringbox.minimizedBox.dom[0].style.display = 'table';
                         parent.appendChild(content);

                         boxcontainer.style.webkitTransform = 'initial';
            					   boxcontainer.style.MozTransform = 'initial';
            				     boxcontainer.style.msTransform = 'initial';
            					   boxcontainer.style.OTransform = 'initial';
            					   boxcontainer.style.transform = 'initial';

              					 $this.boxes.push($ringbox.minimizedBox.dom);
              					 $this.boxeScopes.push($ringbox.minimizedBox.scope);
                         $this.boxeDeferred.push($ringbox.minimizedBox.deferred);
                         if($this.boxes.length == 1) {
                            document.body.className = document.body.className.trim()+' ringbox-opened';
                         }

    					           $ringbox.minimizedBox = {dom:null, scope:null, deferred:null};

    					           //boxcontainer.removeEventListener('webkitTransitionEnd', eventTranstionEnd);
                		     //boxcontainer.removeEventListener('msTransitionEnd', eventTranstionEnd);
    					           //boxcontainer.removeEventListener('transitionend', eventTranstionEnd);


            					   boxcontainer.removeEventListener(prefix+'TransitionEnd', eventTranstionEnd);
            					   boxcontainer.removeEventListener('transitionend', eventTranstionEnd);

                      }

                   }
                   /*end of player api*/

                    $ringbox.open = function (boxOptions) {

                        var boxResultDeferred = $q.defer();
                        var boxOpenedDeferred = $q.defer();
                        var boxTimer = false, uiTimer = false;

                        var boxDom = $this.init(),
                         	boxContentDom = angular.element(boxDom[0].querySelector('div.ringbox-content')),
                         	boxLoaderDom = angular.element(boxContentDom[0].querySelector('div.ringbox-loader')),
                         	boxInnerDom = angular.element(boxContentDom[0].querySelector('div.ringbox-inner')),
                          boxOverlayDom = angular.element(boxDom[0].querySelector('div.ringbox-overlay'));

                        boxContentDom.css({'width':'200px','height':'95px','max-width':'200px','max-height':'95px'});
                        if(boxOptions.animation) {
                          boxContentDom.addClass('animation');
                        }
                        $this.adjustBoxes();
                        //merge and clean up options
                        boxOptions = angular.extend({}, boxOptions);
                        var boxScope = (boxOptions.scope || $rootScope).$new();
                        boxScope.boxIsLoading = true;
                        angular.forEach($ringboxProvider.options,function(value,key){
                            boxScope[key] = boxOptions[key];
                        });
                        if(angular.isObject(boxOptions.scopeData)){
                          angular.forEach(boxOptions.scopeData,function(value,key){
                            boxScope[key] = boxOptions.scopeData[key];
                        });
                        }
                        $this.boxeScopes.push(boxScope);
                        $this.boxeDeferred.push(boxResultDeferred);

                        var showLoader = function() {
                            boxContentDom.addClass('ringbox-invisible');
                            boxLoaderDom.css({'display':'block'});
                            boxInnerDom.css({'display':'none'});
                            boxContentDom.css({'width':'200px','height':'95px','max-width':'200px','max-height':'95px'});
                        };

                        var hideLoader = function() {

                           setTimeout(function() {
                                boxLoaderDom.css({'display':'none'});
                                boxInnerDom.css({'display':'inline-block'});
                                heightChagned();
                                boxContentDom.css({'width':'auto','height':'auto','max-width':'100%','max-height':'100%'});
                                boxContentDom.removeClass('ringbox-invisible');
                             }, 300);
                        };

                        var initUI = function() {
                            document.body.appendChild(boxDom[0]);
                            document.body.className = document.body.className.replace('ringbox-opened','');
                            document.body.className = document.body.className.trim()+' ringbox-opened';
                            uiTimer = false;
                        };


                        /*Start showing loader after 500ms*/
                        if(boxOptions.templateUrl && (boxOptions.templateUrl.indexOf('image-popup.html') || boxOptions.templateUrl.indexOf('media-popup.html'))) {
                           uiTimer = setTimeout(initUI,200);
                        }
                        else {
                          initUI();
                        }



                       // boxScope.$watch(heightChagned);


                        boxScope.$on(SystemEvents.FEED.HEIGHT, function($event, key){
                            heightChagned(true);
                        });

                      // var previousHeight = 0;

                       var heightChagned = function(event) {

                              if(event && boxLoaderDom.css('display') !='none') return;

                              if(boxContentDom && boxOptions.scrollable) {

                                   var boxOffsetHeight = boxInnerDom[0].offsetHeight, margin;

                                   margin = Math.max((utilsFactory.viewport.y/2 - boxOffsetHeight/2),40);
                                   boxContentDom.css({'margin-top':margin+'px'});

                                   if(boxOffsetHeight > utilsFactory.viewport.y ) {
                                     boxOverlayDom.css({'right':utilsFactory.scrollbarWidth+'px'});
                                   }
                                   else {
                                     boxOverlayDom.css({'right':'0px'});
                                   }
                               }
                        };


                        //verify options
                        if (!boxOptions.template && !boxOptions.templateUrl) {
                            throw new Error('One of template or templateUrl options is required.');
                        }

                        var templateAndResolvePromise =
                            $q.all([getTemplatePromise(boxOptions)].concat(getResolvePromises(boxOptions.resolve)));

                            var boxlInstance = {
                                result: boxResultDeferred.promise,
                                opened: boxOpenedDeferred.promise,
                                close: $ringbox.close,
                                closeAll: $ringbox.closeAll,
                                showLoader: showLoader,
                                hideLoader: hideLoader,
                                adjustHeight: heightChagned
                            };


                            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {

                             boxScope.boxIsLoading = false;
                             boxScope.$close = $ringbox.close;

                             if(!boxInnerDom) return;

                             if(boxTimer) {
                               clearTimeout(boxTimer);
                             }

                            var ctrlInstance, ctrlLocals = {};
                            var resolveIter = 1;

                            //controllers
                            if (boxOptions.controller) {
                                ctrlLocals.$scope = boxScope;
                                ctrlLocals.$boxInstance = boxlInstance;
                                for(var key in boxOptions.resolve){
                                  if(boxOptions.resolve.hasOwnProperty(key)){
                                    ctrlLocals[key] = tplAndVars[resolveIter++];
                                  }

                                }
                                // angular.forEach(boxOptions.resolve, function (value, key) {

                                // });

                                ctrlInstance = $controller(boxOptions.controller, ctrlLocals);
                                if (boxOptions.controllerAs) {
                                    boxScope[boxOptions.controllerAs] = ctrlInstance;
                                }
                            }

                             boxInnerDom.html(tplAndVars[0]);
                             $compile(boxInnerDom.contents())(boxScope);

                             if(uiTimer) {
                               clearTimeout(uiTimer);
                               boxLoaderDom.css({'display':'none'});
                               boxContentDom.removeClass('ringbox-invisible');
                               initUI();
                             }

                             boxContentDom.css({'width':'auto','height':'auto','max-width':'100%','max-height':'100%'});
                             hideLoader();

                             boxScope.$parent.$rgDigest();

                        }, function resolveError(reason) {
                            boxResultDeferred.reject(reason);
                                $ringbox.close();
                        });

                        templateAndResolvePromise.then(function () {
                            boxOpenedDeferred.resolve(true);
                        }, function () {
                            boxOpenedDeferred.reject(false);
                        });

                        /*Attached Event*/
                        if(boxOptions.scrollable) {
                           boxDom.addClass('scrollable');
                           heightChagned();
                        }

                        if(boxOptions.onBackDropClickClose) {

                           boxOverlayDom.on('click', function overlayCloseFn(event) {
                              boxOverlayDom.off('click',overlayCloseFn);
                              $ringbox.close(event);
                           });

                           /*This hack is required only if ringbox is scrollable*/
                           if(boxOptions.scrollable) {
                           		boxDom[0].addEventListener('click', function boxClick(evt) {
                                //evt.preventDefault();
                                evt.stopPropagation();
                             		if (evt.target.className.indexOf('ringbox-outerContainer') != -1) {
                                		boxDom[0].removeEventListener('click',boxClick);
                                		$ringbox.close();
                              		}
                           		}, false);
                           }
                        }

                        if(boxOptions.onEscape) {
                           $document.bind('keyup', function boxKeyup(evt) {
                               var keyCode = evt.which || evt.keyCode || evt.key;

                               if (keyCode != 32) {
                                 evt.stopImmediatePropagation();
                               }

                               if (keyCode == 27) {

                                  /* Player status */
                                  if($player.escapeKey) {
                                    $player.escapeKey = false;
                                    return;
                                  }

                                  $document.unbind('keyup',boxKeyup);
                                  $ringbox.close();
                                }
                                return false;
                           });
                        }

                        if(boxOptions.scrollable) {
                           		boxDom.bind('scroll', function boxScroll(evt) {
                             		  if((boxDom[0].scrollHeight - (boxDom[0].offsetHeight+boxDom[0].scrollTop)) < 100) {
                             		     if(angular.isFunction(boxScope.onScroll)) boxScope.onScroll();
                             		     if(angular.isFunction(boxScope.loadMore)) boxScope.loadMore();
                             		  }
                           		});

                              //boxContentDom[0].addEventListener(prefix+'AnimationStart', heightChagned, false);
                             // boxInnerDom[0].addEventListener('DOMNodeInserted', heightChagned, false);
                         }
                        /* End of events*/

                        boxScope.$on('$destroy',function(){
                           boxDom = null;
                           boxContentDom = null;
                           boxLoaderDom = null;
                           boxInnerDom = null;
                           boxlInstance = null;
                           boxOptions = null;
                           boxOverlayDom = null;
                           templateAndResolvePromise = null;
                        });

                        boxTimer = setTimeout(function() {

                            if(boxScope && boxScope.boxIsLoading) {
                              Notification.error({message: "Something went wrong! Please try again."});
                              $ringbox.close();
                            }

                        }, 20000);

                       return boxlInstance;
                    };

                    return $ringbox;
                }]
        };

        return $ringboxProvider;
    })
    .directive('rgRingbox',['$ringbox',function($ringbox){
        return {
            restrict : 'EA',
            scope:{
                ringboxData : '&',
                scopeData : '&',
                onRingBoxOpen : '&',
                onRingBoxClose : '&',
                onScroll : '&',
                ringboxFalsyFunc : '&',
                ringboxOpen : '&'
            },
            link : function(scope,element,attr){
                var scopeOffEvent;
                function mainFunction(event) {
                    event.preventDefault();
                    //event.stopPropagation();

                    var type,target,items={}, scopeDataItems = {};

                    type = attr.ringboxType;// html,remote:require template url
                    if(!type)type='html';//innerhtmlof the provided content or a data content

                    if(attr.ringboxData){
                        if(angular.isFunction(scope.ringboxData)){
                            items = scope.ringboxData();
                        }else{
                            items = scope.ringboxData;
                        }
                    }

                    if(attr.scopeData){
                        if(angular.isFunction(scope.scopeData)){
                            scopeDataItems = scope.scopeData();
                        }else{
                            scopeDataItems = scope.scopeData;
                        }
                    }

                    var tempitems = items.data ? items.data:items;
                    var ringOb = {
                        type : type,
                        scrollable: (attr.ringboxScrollable && (attr.ringboxScrollable=="true" || attr.ringboxScrollable==true))?true :false,
                        scope : attr.ringboxScope?scope:false,
                        scopeData : scopeDataItems || {},
                        controller: attr.ringboxController || '',
                        resolve : {
                            localData : tempitems,
                            remoteData : items.promise ? items:angular.noop
                        },
                        onBackDropClickClose : (attr.ringBackdropClose && (attr.ringBackdropClose=="false" || attr.ringBackdropClose==false))?false :true,
                        animation : (attr.ringboxAnimation && (attr.ringboxAnimation=="false" || attr.ringboxAnimation==false))?false :true,
                        onEscape : (attr.ringCloseEscape && (attr.ringCloseEscape=="false" || attr.ringCloseEscape==false))?false :true
                    };

                    if(type === 'remote'){
                        ringOb.templateUrl = attr.ringboxTarget || scope.ringboxTarget || attr.href || attr.src;
                    }else if(type === 'video') {

                    } else if (type === 'inline'){
                        ringOb.template = attr.ringboxTarget || scope.ringboxTarget;
                    } else {
                         type = 'html';
                         target = attr.ringboxTarget || scope.ringboxTarget;
                         if(!target){
                             ringOb.template = element.html();
                         }else{
                            ringOb.template = angular.element(document.querySelector(target));
                            if(ringOb.template.length > 0){
                                ringOb.template = ringOb.template[0].outerHTML;
                            } else{
                                throw new Error("Opps ! Your Provideed Target element Does Not Exist!");
                            }
                         }

                    }

                    var boxInstance = $ringbox.open(ringOb);

                    boxInstance.result.then(function (selectedItem) {
                        if(angular.isDefined(scope.onRingBoxClose) && angular.isFunction(scope.onRingBoxClose)){
                            scope.onRingBoxClose();
                        }

                    });

                    boxInstance.opened.then(function() {
                        if(angular.isDefined(scope.onRingBoxOpen) && angular.isFunction(scope.onRingBoxOpen)){
                            scope.onRingBoxOpen();
                        }
                    });

                };

                function bindEvent(fn) {
                    element.on("click",fn);
                    scopeOffEvent =  scope.$on('$destroy',function(){
                        element.off('click', fn);
                    });
                };

                function bindFalsyEvent(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if(angular.isFunction(scope.ringboxFalsyFunc)){
                        scope.ringboxFalsyFunc();
                    }
                }

                if(attr.ringboxOpen){
                    scope.$watch('ringboxOpen()', function(newValue) {
                        if(scopeOffEvent){
                          element.off("click",mainFunction);
                          element.off("click",bindFalsyEvent);
                          scopeOffEvent();
                        }
                         if(newValue){
                            bindEvent(mainFunction);
                         }else{
                            bindEvent(bindFalsyEvent);
                         }
                    });
                }else if(attr.rgRingbox === "" || attr.rgRingbox === "true" || attr.rgRingbox === true){
                  bindEvent(mainFunction);
                }else{
                  bindEvent(bindFalsyEvent);
                }
            }
        };
    }]);


/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
            .module('ringid.global.directives', [
                'ringid.common.factories',
                'ringid.global.services',
                'ringid.config'
            ]);
})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.global.directives')
        .directive('rgImgLoad', rgImgLoad)
        .directive('rgClick', rgClick)
        .directive('rgConditionalClick', rgConditionalClick);

        rgConditionalClick.$inject = [];

        function rgConditionalClick(){

            return function(scope,elem,attrs){
                if(angular.isFunction(attrs.rgConditionalClick)){
                    elem.bind("click", function(e){
                        attrs.rgConditionalClick();
                    });

                    scope.$on('$destroy',function(){
                        elem.unbind("click");
                    });
                }
            };

        }

        rgClick.$inject = ['$parse'];
        function rgClick($parse) {
            return {
                restrict: 'A',
                link: function(scope, element, attrs) {
                    var fn = $parse(attrs['rgClick']);
                    var noapply = attrs['rgClickNoapply'];
                    function clickfn(event) {
                        //event.preventDefault();
                        //event.stopPropagation();

                        fn(scope, {$event:event});
                        scope.$rgDigest();

                        // if (!noapply) {
                        //     scope.$apply(function() {
                        //         fn(scope, {$event:event});
                        //     });
                        // } else {
                        //     fn(scope, {$event:event});
                        //     scope.$digest();
                        // }

                    }
                    element.bind('click', clickfn);
                    scope.$on('$destroy', function(){
                        element.unbind('click',clickfn);
                    });
                }
            };
        }

        function rgImgLoad() {
            return {
                restrict: 'A',
                transclude: true,
                link: function(scope, element, attrs) {
                    //var imgSrc = element[0].attr('src');
                    //console.log('image source: ' + imgSrc);
                    //element[0].attr('src', '');
                    element.on('load', function () {
                        console.log('image loaded');
                    });
                }
            };
        }



})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.global.directives')
		.directive('rgScrollbar', rgScrollbar)
				.factory('rgScrollbarService', rgScrollbarService);

				function rgScrollbar() {

						function linkFunc(scope, element, attr) {

										// Configuration
										var config = {
												scrollbarWidth: 8,
												scrollbarAlways: false,
												dragSpeedModifier : 5,
												minThumbHeight: 10
										};

										if(attr.thumbHeight && parseInt(attr.thumbHeight) > 0) {
										   config.minThumbHeight = 	parseInt(attr.thumbHeight);
										}

										if(attr.disabled == "true" || attr.disabled ==true) {
											return;
										}
										var scrollbarContainer = null,
											scrollbarMousedown = false,
											scrollbarVisible = false,
											display = 'none',
											lastY =0,
											scrollHeight =0,
											offsetHeight = 0,
											hiddenHeight = 0,
											visibleHeight = 0,
											thumbHeight = 0,
											scrollbar = angular.element(document.createElement('div')),
											scrollbarThumb = angular.element(document.createElement('div')),
											doc = angular.element(document);

										element.wrap('<div class="ringscroll" style="position:relative;width:auto;overflow:hidden;height:100%;"></div>');
										element.css({
											 overflow: 'hidden'
										});

										scrollbarContainer = element.parent();
										scrollbarContainer.append(scrollbar[0]);
										scrollbarContainer.append(scrollbarThumb[0]);
										scrollbar.addClass('scrollbar');
										scrollbarThumb.addClass('thumb');

										fastdom.write(function() {
											    if(!scrollbar) return;
												scrollbar[0].style.width = config.scrollbarWidth+'px';
												scrollbar[0].style.height = '100%';
												scrollbar[0].style.right = '1px';
												scrollbar[0].style.top = 'px';
												scrollbar[0].style.position = 'absolute';
												scrollbar[0].style.zIndex = 1;

												scrollbarThumb[0].style.width = config.scrollbarWidth+'px';
												scrollbarThumb[0].style.right = '1px';
												scrollbarThumb[0].style.top = 'px';
												scrollbarThumb[0].style.position = 'absolute';
												scrollbarThumb[0].style.zIndex = 1;
						 				});

										function scroll(pos) {

											 	var ratio;
											 	fastdom.read(function() {

											            if(!scrollbar) return;

														hiddenHeight = element[0].scrollHeight - (element[0].offsetHeight);
														visibleHeight = element[0].offsetHeight - thumbHeight;
														ratio = pos/visibleHeight;
														pos= Math.min(Math.max(pos, 0), visibleHeight);

														fastdom.write(function(){
																element[0].scrollTop = hiddenHeight * ratio;
																scrollbarThumb[0].style.top = pos+'px';
														});

														 /*call bottom reach*/
														if(pos==visibleHeight && angular.isFunction(scope.bottomReached)) {
																scope.bottomReached();
														}
							 					});

										}


										function reCalculate() {

											 var ratio, pos, newScrollHeight;


											 var ratio, pos, newScrollHeight;

												fastdom.read(function() {

												        if(!element) return;

														newScrollHeight = element[0].scrollHeight;

														offsetHeight = element[0].offsetHeight;
														scrollHeight = newScrollHeight;
														hiddenHeight = scrollHeight - offsetHeight;
														visibleHeight = offsetHeight - thumbHeight;
														thumbHeight = Math.max((offsetHeight/scrollHeight) * offsetHeight, config.minThumbHeight);
														ratio = visibleHeight/hiddenHeight;
														pos = element[0].scrollTop * ratio;

														if(isNaN(thumbHeight) || thumbHeight=='Infinity') thumbHeight = 0;
														display = (thumbHeight>=offsetHeight) ? 'none' : 'block';

														fastdom.write(function(){
															if(!!scrollbar && !!scrollbar[0]){
																scrollbar[0].style.display = display;
																scrollbarThumb[0].style.height = thumbHeight + 'px';
																scrollbarThumb[0].style.display = display;
																scrollbarThumb[0].style.top = pos+'px';
															}
														});

							 				    });
										 }


										function hideScrollbar() {

											 if(config.scrollbarAlways) return ;

											 if(!scrollbarMousedown) {
													 scrollbar.css('opacity', 0);
													 scrollbarThumb.css('opacity', 0);

										    }
                                        }


										function hideScrollbar() {

											 if(config.scrollbarAlways) return ;

											 if(!scrollbarMousedown) {
													 scrollbar.css('opacity', 0);
													 scrollbarThumb.css('opacity', 0);
													 scrollbarVisible = false;
												}
										}

										function showScrollbar() {
												reCalculate();
												scrollbarVisible = true;
												scrollbar.css('opacity', 1);
												scrollbarThumb.css('opacity', 1);
										}

										function mousewheelCallback(event) {

												if(display=='none') return;
												event.preventDefault();
												if(!scrollbarVisible) showScrollbar();
												var barTop = parseFloat(scrollbarThumb.css('top'));
												var delta = (event.wheelDelta)? - 1/40 * event.wheelDelta : event.detail*3;
												var modifier = Math.max(parseInt((offsetHeight*2 / scrollHeight) * config.dragSpeedModifier),1);
												var newPos = barTop + (delta * modifier);
												scroll( newPos );
										}

										function mousedownCallback(event) {

												event.preventDefault();
												event.stopPropagation();

												if(!scrollbarVisible) showScrollbar();
												scrollbarMousedown = true;
												var mouseY= event.pageY;
												var barTop = parseFloat(scrollbarThumb.css('top'));

												doc.on('mousemove', function(event) {
														var newPos = barTop+event.pageY-mouseY;
														scroll( newPos );
												});

												doc.on('mouseup', function(event) {
														event.stopPropagation();
														scrollbarMousedown = false;
														doc.off('mousemove');
														doc.off('mouseup');
												});

										}

										function touchmoveCallback(event) {
												event.preventDefault();
												var currentY = event.touches[0].clientY;
												var barTop = parseFloat(scrollbarThumb.css('top'));
												var delta = 2;
												var modifier = Math.max(parseInt((offsetHeight*2 / scrollHeight) * config.dragSpeedModifier),1);
												var newPos = (currentY < lastY)  ? barTop + (delta * modifier) : barTop - (delta * modifier);
												scroll( newPos );
												lastY = currentY;
										}

										// Scroll on MouseWheel
										var mousewheel = (typeof InstallTrigger !== 'undefined')?'DOMMouseScroll':'mousewheel';
										element.on(mousewheel, mousewheelCallback);


										// Scroll on Drag
										scrollbarThumb.on('mousedown', mousedownCallback);

										var supportsTouch = 'ontouchstart' in window || navigator.msMaxTouchPoints;

										if(supportsTouch) {
											element.on('touchmove', touchmoveCallback);
										}


										// Show scrollbar on hover
										scrollbarContainer.on('mouseenter', showScrollbar);
										scrollbarContainer.on('mouseleave', hideScrollbar);

										// event listner
										scope.$on('scrollTop', function(event) {
											 if (event.stopPropagation) {
													event.stopPropagation();
											 }
												setTimeout(function() {
														scroll(0);
												}, 100);
										});

										scope.$on('scrollTo', function(event,percent, dir) { // percent e.g 10, 50, 100

												 if (event.stopPropagation) {
													 event.stopPropagation();
												 }

											 	switch (typeof percent) {
													case 'string':
														var elm = element[0].querySelector(percent);
														percent = 0;
														if(elm) {
															var elemHeight = (dir && dir=='bottom')? elm.offsetHeight:0;
															percent = parseInt(((elm.offsetTop+elemHeight) * 100) / scrollHeight);
														}
												 	break;
													case 'number':
														percent = parseInt(percent);
												 	break;
											 		default:
													 	percent = parseInt(percent);
												}

											  var pos =  (percent * visibleHeight) / 100;
											  setTimeout(function() {
														 scroll(pos);
												}, 10);
										 });

										 scope.$on('recalculate', function(event) {

												if (event.stopPropagation) {
													event.stopPropagation();
												}
												 reCalculate();
										 });

										 scope.$on('hasScroll', function(event, $scope) {

												if (event.stopPropagation) {
													event.stopPropagation();
												}
												$scope.scroll = (display=='none')?false:true;
										 });

										scope.$on("$destroy", function(){

											  element.off(mousewheel, mousewheelCallback);
											  element.off('touchmove', touchmoveCallback);

											  scrollbarThumb.off('mousedown', mousedownCallback);
											  scrollbarContainer.off('mouseenter', showScrollbar);
											  scrollbarContainer.off('mouseleave', hideScrollbar);

										      /*clear DOM reference*/
											  scrollbarContainer = null;
											  scrollbar = null;
											  scrollbarThumb = null;
									  });

						}

						return {
								restrict: 'A',
								scope: {
									bottomReached: '&'
								},
								link: linkFunc
						};

				}

				/*perf: bypass broadcast, think different*/
				function rgScrollbarService() {
						return {
								scrollTop: function(scope) {
										scope.$broadcast('scrollTop');
								},
								scrollTo: function(scope,percent, dir) {
										scope.$broadcast('scrollTo',percent, dir);
								},
								recalculate: function(scope) {
										scope.$broadcast('recalculate');
								},
								hasScroll: function(scope) {
								     scope.$broadcast('hasScroll', scope);
								}
						};
				}
})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
            .module('ringid.global.directives')
            .service('rgDropdownService', rgDropdownService)
            .directive('rgDropdown', rgDropdown);


    rgDropdownService.$inject = ['GlobalEvents'];
    function rgDropdownService(GlobalEvents) { //jshint ignore:line
        var self = this, // jshint ignore:line
            _scope = false,
            _detachTemplate = false;


        function closeDropdown () {
            if(_scope && angular.isFunction(_scope.ddBeforeClose)){
                _scope.ddBeforeClose();
            }
            _detachTemplate();
            GlobalEvents.unbindHandler('document', 'click', self.close);
        }

        function openDropdown () {
            _scope.ddOpened();
            GlobalEvents.bindHandler('document', 'click', self.close);
        }

        self.open = function open(detachTemplate, scope) {
            if (_detachTemplate) {
                closeDropdown();
            }
            _detachTemplate = detachTemplate;
            _scope = scope;
            openDropdown();
        };

        self.close = function close(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (_detachTemplate) {
                closeDropdown();
            }
            _detachTemplate = false;
            _scope = false;

        };

    }


    rgDropdown.$inject = ['$ringhttp', 'settings', '$compile', 'rgDropdownService', 'languageConstant', 'utilsFactory', 'rgScrollbarService'];
    function rgDropdown($ringhttp, settings, $compile, rgDropdownService, languageConstant, utilsFactory, rgScrollbarService) { //jshint ignore:line

        function linkFunc(scope, element) {
            var template,
                needHeightAdjust = true,
                adjustHeightTimeout,
                openDropdownEvent,
                dropdownMinHeight = 200,
                dropdownOriginalHeight = 0,
                templateHtml,
                dropdownOpen = false,
                onDropdown = false;

            scope.consType = languageConstant.get();

            function stopPropagation (event) {
                event.stopPropagation();
            }

            function handleDropdown(event) {
                if (!dropdownOpen) {
                    attachTemplate(event);
                    rgDropdownService.open(detachTemplate, scope);
                } else {
                    rgDropdownService.close();
                }
                stopPropagation(event);
            }

            function handleHover (event) {
                setTimeout(function() {
                    if (!onDropdown) {
                        handleDropdown(event);
                    } else {
                    }
                }, 500);
            }



            element.on('click', handleDropdown);

            if( !scope.ddHtml && !scope.ddTemplate){
            }else{
                if (scope.ddTemplate) {
                    //template = $compile(scope.ddTemplate)(scope);
                    templateHtml = scope.ddTemplate;
                } else {
                    //$ringhttp.get(settings.baseUrl + scope.ddHtml).success(function(response) {
                    $ringhttp.get(scope.ddHtml).success(function(response) {
                        //template = $compile(templateHtml)(scope);
                        templateHtml = response;
                    })
                    .error(function() {
                        scope.$rgDigest();
                    });
                }
            }



            function handleMouseEnter (event) {
                onDropdown = true;
                element.off('mouseleave', handleHover);
            }

            function handleMouseLeave (event) {
                onDropdown = false;
                handleHover(event);
                element.on('mouseleave', handleHover);
            }

            function attachTemplate(event) {
                dropdownOpen = true;
                template = $compile(templateHtml)(scope);
                if (scope.ddControl && scope.ddControl.hasOwnProperty('append') && !scope.ddControl.append) {
                    element.after(template);
                } else {
                    element.append(template);
                }
                //stopPropagation
                for(var i = 0; i < template.length; i++) {
                    template[i].addEventListener('click', stopPropagation);
                }

                if (scope.ddControl && scope.ddControl.showOnHover) {
                    element[0].addEventListener('mouseleave', handleHover);

                    template[template.length-1].addEventListener('mouseenter', handleMouseEnter);
                    template[template.length-1].addEventListener('mouseleave', handleMouseLeave);

                }

                //if (needHeightAdjust) {
                    //openDropdownEvent = event;
                    //adjustHeight();
                    //window.addEventListener('resize', adjustHeight);
                //}

                scope.$rgDigest();

            }

            function adjustHeight() {
                if (!adjustHeightTimeout) {
                    adjustHeightTimeout = setTimeout(calculateHeight, 200);
                }
            }

            function calculateHeight() {
                adjustHeightTimeout = 0;
                //clearTimeout(adjustHeightTimeout);

                if (needHeightAdjust) {
                    var elemRect,
                        mainTemplate,
                        availHeight;

                    var totalHeight = 0, i, j;
                    for(i = 0; i < template.length; i++) {
                        if (!template[i].clientHeight) {
                            if (template[i].children) {
                                for(j = 0; j < template[i].children.length; j++) {
                                    if (template[i].children[j].clientHeight > 0) {
                                        mainTemplate = template[i].children[j];
                                        totalHeight += template[i].children[j].clientHeight;
                                        elemRect = template[i].children[j].getBoundingClientRect();
                                        availHeight = utilsFactory.viewport.y - elemRect.height - elemRect.top;
                                    }
                                }

                            }
                        } else {
                            mainTemplate = template[i];
                            totalHeight += template[i].clientHeight;
                            elemRect = template[i].getBoundingClientRect();
                            availHeight = utilsFactory.viewport.y - elemRect.height - elemRect.top;
                        }
                    }


                    dropdownOriginalHeight = dropdownOriginalHeight > 0 ? dropdownOriginalHeight : totalHeight;



                    // stop further height adjustsments when any particular dropdown orignal height is below minimum
                    if (dropdownOriginalHeight < dropdownMinHeight)  {
                        needHeightAdjust = false;
                        window.removeEventListener('resize', adjustHeight);
                        return;
                    }

                    if ((availHeight - 10) < 0) {
                         // need to reduce height of dropdown
                        var reducedHeight = totalHeight + availHeight - 10;
                        reducedHeight = reducedHeight > dropdownMinHeight ? reducedHeight : dropdownMinHeight;
                        mainTemplate.style.height = reducedHeight + 'px';
                        rgScrollbarService.recalculate(scope);
                        scope.$rgDigest();
                    }
                    else if ( totalHeight < dropdownOriginalHeight ) {
                        var increasedHeight = totalHeight + availHeight - 10;
                        increasedHeight = dropdownOriginalHeight > increasedHeight ? increasedHeight : dropdownOriginalHeight;
                        mainTemplate.style.height = increasedHeight + 'px';
                        rgScrollbarService.recalculate(scope);
                        scope.$rgDigest();
                    }

                }

            }


            function detachTemplate() {
                    var i;
                    dropdownOpen = false;

                    for(i = 0; i < template.length; i++) {
                        template[i].removeEventListener('click', stopPropagation);
                    }
                    if (scope.ddControl && scope.ddControl.showOnHover) {
                         element[0].removeEventListener('mouseleave', handleHover);
                         template[template.length-1].removeEventListener('mouseenter', handleMouseEnter);
                         template[template.length-1].removeEventListener('mouseleave', handleMouseLeave);
                    }
                    //template[template.length-1].parentNode.removeChild(template[template.length-1]);
                    // for(i = 0; i < template.length; i++) {
                    //     template[i].parentNode.removeChild(template[i]);
                    // }
                    //template[template.length-1].parentNode.removeChild(template);
                    template.remove();
                    //if (needHeightAdjust) {
                        //window.removeEventListener('resize', adjustHeight);
                    //}
                    scope.$parent.$rgDigest();
                //});
            }

            scope.$on('$destory', function() {
                element[0].removeEventListener('click', handleDropdown);
                detachTemplate();
            });


        }


        return {
            restrict: 'AE',
            link: linkFunc,
            scope: {
                ddHtml: '=',
                ddControl: '=',
                ddTemplate: '=',
                ddAction: '&',
                ddOpened: '&',
                ddBeforeClose: '&'
            }
        };
    }

})();




(function () {
    'use strict';

    angular.module('ringid.global.directives')
    .directive('rgPageTitle', rgPageTitle );

    rgPageTitle.$inject = ['$rootScope', 'chatHistoryFactory', 'utilsFactory', 'SystemEvents'];
    function rgPageTitle($rootScope, chatHistoryFactory, utilsFactory, SystemEvents) {

        var blinkerInterval = 1000;
        var currentTitle = document.title;
        var timerRef;

        var getPageInActiveTitle = function(){
            var unreadMessageCount = chatHistoryFactory.getUnreadConversationCount();
            if(unreadMessageCount > 0){
                return '('+ unreadMessageCount +') ' + currentTitle;
            }else{
                return currentTitle;
            }

        };

        var getPageActiveTitle = getPageInActiveTitle;

        return {
            link: function () {

                $rootScope.$on('ringActive', function () {
                   clearInterval(timerRef);
                   document.title = getPageActiveTitle();
                });

                $rootScope.$on('ringInactive', function () {
                   timerRef = setInterval(function(){
                       var inActivePageTitle = getPageInActiveTitle();
                       document.title = document.title === inActivePageTitle ? currentTitle : inActivePageTitle;
                   }, blinkerInterval);
                });

                utilsFactory.onCustomEvent(SystemEvents.CHAT.UNREAD_MESSAGE_INFO_UPDATED, function(){
                   document.title = getPageActiveTitle();
                });

            }
        };
    }

})();

/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* * Copyright : Ipvision
*
* * File Name : video-metadata.service.js
*
* * Creation Date : 01-01-2015
*
* * Last Modified : Tue 03 Nov 2015 14:36:47 BDT
*
* _._._._._._._._._._._._._._._._._._._._._.*/


(function (DataView) {
    'use strict';

    var frameTypes = {
        /*
         * Textual frames
         */
        //'TALB': 'album',
        //'TBPM': 'bpm',
        //'TCOM': 'composer',
        //'TCON': 'genre',
        //'TCOP': 'copyright',
        //'TDEN': 'encoding-time',
        //'TDLY': 'playlist-delay',
        //'TDOR': 'original-release-time',
        //'TDRC': 'recording-time',
        //'TDRL': 'release-time',
        //'TDTG': 'tagging-time',
        //'TENC': 'encoder',
        //'TEXT': 'writer',
        //'TFLT': 'file-type',
        //'TIPL': 'involved-people',
        //'TIT1': 'content-group',
        'TIT2': 'title',
        //'TIT3': 'subtitle',
        //'TKEY': 'initial-key',
        //'TLAN': 'language',
        //'TLEN': 'length',
        //'TMCL': 'credits',
        //'TMED': 'media-type',
        //'TMOO': 'mood',
        //'TOAL': 'original-album',
        //'TOFN': 'original-filename',
        //'TOLY': 'original-writer',
        'TOPE': 'original-artist',
        //'TOWN': 'owner',
        'TPE1': 'artist',
        //'TPE2': 'band',
        //'TPE3': 'conductor',
        //'TPE4': 'remixer',
        //'TPOS': 'set-part',
        //'TPRO': 'produced-notice',
        //'TPUB': 'publisher',
        //'TRCK': 'track',
        //'TRSN': 'radio-name',
        //'TRSO': 'radio-owner',
        //'TSOA': 'album-sort',
        //'TSOP': 'performer-sort',
        //'TSOT': 'title-sort',
        //'TSRC': 'isrc',
        //'TSSE': 'encoder-settings',
        //'TSST': 'set-subtitle',
        /*
         * Textual frames (<=2.2)
         */
        //'TAL': 'album',
        //'TBP': 'bpm',
        //'TCM': 'composer',
        //'TCO': 'genre',
        //'TCR': 'copyright',
        //'TDY': 'playlist-delay',
        //'TEN': 'encoder',
        //'TFT': 'file-type',
        //'TKE': 'initial-key',
        //'TLA': 'language',
        //'TLE': 'length',
        //'TMT': 'media-type',
        'TOA': 'original-artist',
        //'TOF': 'original-filename',
        //'TOL': 'original-writer',
        //'TOT': 'original-album',
        'TP1': 'artist',
        //'TP2': 'band',
        //'TP3': 'conductor',
        //'TP4': 'remixer',
        //'TPA': 'set-part',
        //'TPB': 'publisher',
        //'TRC': 'isrc',
        //'TRK': 'track',
        //'TSS': 'encoder-settings',
        //'TT1': 'content-group',
        'TT2': 'title',
        //'TT3': 'subtitle',
        //'TXT': 'writer',
        /*
         * URL frames
         */
        //'WCOM': 'url-commercial',
        //'WCOP': 'url-legal',
        //'WOAF': 'url-file',
        //'WOAR': 'url-artist',
        //'WOAS': 'url-source',
        //'WORS': 'url-radio',
        //'WPAY': 'url-payment',
        //'WPUB': 'url-publisher',
        /*
         * URL frames (<=2.2)
         */
        //'WAF': 'url-file',
        //'WAR': 'url-artist',
        //'WAS': 'url-source',
        //'WCM': 'url-commercial',
        //'WCP': 'url-copyright',
        //'WPB': 'url-publisher',
        /*
         * Comment frame
         */
        //'COMM': 'comments',
        /*
         * Image frame
         */
        'APIC': 'image',
        'PIC': 'image'
    };

    /*
     * ID3 image types
     */
    var frameImageTypes = [
        'other',
        'file-icon',
        'icon',
        'cover-front',
        'cover-back',
        'leaflet',
        'media',
        'artist-lead',
        'artist',
        'conductor',
        'band',
        'composer',
        'writer',
        'location',
        'during-recording',
        'during-performance',
        'screen',
        'fish',
        'illustration',
        'logo-band',
        'logo-publisher'
    ];

    angular
        .module('ringid.common.media_metadata_service', ['ringid.utils'])
        .service('mediaMetadata', mediaMetadata);

        mediaMetadata.$inject = [ '$$q', 'Ringalert', 'utilsFactory'];
        function mediaMetadata( $q, Ringalert, utilsFactory) { //jshint ignore:line
            var self = this;  //jshint ignore:line

            function fetchVideoMeta(thisVideo) {
                    //var thisVideo = this;
                    var //canvas = document.createElement('canvas'),
                        thumb = {
                            drtn: Math.floor(thisVideo.duration),
                            tiw: thisVideo.videoHeight,
                            tih: thisVideo.videoWidth,
                            artst: '',
                            ttl: thisVideo.nameFromFile.substr(0, thisVideo.nameFromFile.lastIndexOf('.')) || thisVideo.nameFromFile,
                            //uniqueId: thisVideo.uniqueId,
                            //thmbURL: '',
                            //previewUrl: ''
                        };

                    //canvas.height = thumb.ih;
                    //canvas.width = thumb.iw;
                    //ctx = canvas.getContext('2d');

                    //ctx.drawImage(thisVideo, 0, 0, thumb.iw, thumb.ih);
                    //thumb.previewUrl= canvas.toDataURL('image/jpeg');
                    //thumb.file = utilsFactory.dataURLToBlob(thumb.previewUrl);


                    //thumb.file.name = 'video-thumb.jpg';

                    //if (thumb.file.size < 2000 && thisVideo.currentTime > 4) {
                        ////thisVideo.currentTime = thisVideo.currentTime - 0.5;
                        //thumb.previewUrl = '';
                    //}


                    window.URL.revokeObjectURL(thisVideo.src);

                    thisVideo.deferObj.resolve(thumb);

            }


            function parseFrameLegacy(buffer) {
                var dv = new DataView(buffer),
                    result = {tag: null, value: null},
                    encoding,
                    header = {
                        id: dv.getString(0, 3),
                        type: dv.getString(0, 1),
                        size: dv.getUint24(3)
                };
                /*
                * No support for compressed, unsychronised, etc frames
                **/
               if (!(header.id in frameTypes)) {
                   return false;
               }

               result.tag = frameTypes[header.id];
               if (header.type === 'T') {
                    encoding = dv.getUint8(7);

					result.value = dv.getString(7, dv.byteLength-7);
                    //if(header.id === 'TCO' && !!parseInt(result.value)) {
                        //result.value = Genres[parseInt(result.value)];
                    //}
				//} else if (header.type === 'W') {
					//result.value = dv.getString(7, dv.byteLength-7);
                //} else if (header.id === 'COM')	 {
                    //encoding = dv.getUint8(6);
                    //result.value = dv.getString(10, dv.byteLength-10);
                    //if (result.value.indexOf('\x00') !== -1) {
                        //result.value = result.value.substr(result.value.indexOf('\x00') + 1);
                    //}
               } else if (header.id === 'PIC') {
                    encoding = dv.getUint8(6);
                    var image = {
						type: null,
						mime: 'image/' + dv.getString(7, 3).toLowerCase(),
						description: null,
						data: null
                    };
                    image.type = frameImageTypes[dv.getUint8(11)] || 'other';
                    var variableStart = 11, variableLength = 0;
                    for(var i = variableStart;; i++) {
                        if(dv.getUint8(i) === 0x00) {
                            variableLength = i - variableStart;
                            break;
                        }
                    }
                    image.description = (variableLength === 0 ? null : dv.getString(variableStart, variableLength));
                    //image.data = new Uint8Array(buffer.slice(variableStart + 1));
                    result.value = new Blob(new Uint8Array(buffer.slice(variableStart + 1)), {type: image.mime});

                }

                return (result.tag ? result : false);
            }

            function parseFrame(buffer, major, minor) {
                minor = minor || 0;
                major = major || 4;

                if (major < 3) {
                    return parseFrameLegacy(buffer);
                }

				var dv = new DataView(buffer),
                    encoding,
                    result = {tag: null, value: null},
					header = {
						id: dv.getString(0, 4),
						type: dv.getString(0, 1),
						size: dv.getSynch(dv.getUint32(4)), //dv.getSynch(dv.getIntByByte(start+4, 4)),
						flags: [
							dv.getUint8(8),  // dv.getIntByByte(start+8, 1),
							dv.getUint8(9) //dv.getIntByByte(start+9, 1)
						]
					};

                //No support for compressed, unsychronised, etc frames
                if (header.flags[0] !== 0 || !(header.id in frameTypes)) {
                    return false;
                }

                result.tag = frameTypes[header.id];
				if(header.type === 'T') {
					encoding = dv.getUint8(10);
					/*
					 * TODO: Implement UTF-8, UTF-16 and UTF-16 with BOM properly?
					 */
					if(encoding === 0 || encoding === 3) {
						result.value = dv.getString(11, dv.byteLength-11);
					} else if(encoding === 1) {
						result.value = dv.getStringUtf16(-11, 11, true);
					} else if(encoding === 2) {
						result.value = dv.getStringUtf16(-11, 11);
					} else {
						return false;
					}
					//if(header.id === 'TCON' && !!parseInt(result.value)) {
						//result.value = Genres[parseInt(result.value)];
					//}
				//} else if(header.type === 'W') {
					//result.value = dv.getString(10, dv.byteLength-10);
				//} else if(header.id === 'COMM') {
					/*
					 * TODO: Implement UTF-8, UTF-16 and UTF-16 with BOM properly?
					 */
					//var variableStart = 14, variableLength = 0;
					//encoding = dv.getUint8(10);
					/*
					 * Skip the comment description and retrieve only the comment its self
					 */
					//for(var i = variableStart;; i++) {
						//if(encoding === 1 || encoding === 2) {
							//if(dv.getUint16(i) === 0x0000) {
								//variableStart = i + 2;
								//break;
							//}
							//i++;
						//} else {
							//if(dv.getUint8(i) === 0x00) {
								//variableStart = i + 1;
								//break;
							//}
						//}
					//}
					//if(encoding === 0 || encoding === 3) {
						//result.value = dv.getString(variableStart, dv.byteLength - variableStart);
					//} else if(encoding === 1) {
						////result.value = dv.getStringUtf16(-1 * variableStart, variableStart, true);
					//} else if(encoding === 2) {
						////result.value = dv.getStringUtf16(-1 * variableStart, variableStart);
					//} else {
                        //return false;
					//}
				} else if(header.id === 'APIC') {
					encoding = dv.getUint8(10);
					var image = {
							type: null,
							mime: null,
							description: null,
							data: null
						};
					var variableStart = 11, variableLength = 0;
					for(var i = variableStart;;i++) {
						if(dv.getUint8(i) === 0x00) {
							variableLength = i - variableStart;
							break;
						}
					}
					image.mime = dv.getString(variableStart, variableLength);
                    image.type = frameImageTypes[dv.getUint8(variableStart + variableLength + 1)] || 'other';
                    variableStart += variableLength + 2;
                    variableLength = 0;
                    for(var i = variableStart;; i++) {
                        if(dv.getUint8(i) === 0x00) {
                            variableLength = i - variableStart;
                            break;
                        }
                    }
                    image.description = (variableLength === 0 ? null : dv.getString(variableStart, variableLength));
                    //image.data = new Uint8Array(buffer.slice(variableStart + 1));
                    result.value = new Blob(new Uint8Array(buffer.slice(variableStart + 1)), {type: image.mime});
				}
				return (result.tag ? result : false);


            }

            function readID3Tags(buffer, meta) {
                var dv = new DataView(buffer),
                    metaV2 = {},
                    tagVersion,
                    tagSize = 0,
                    headerSize = 10,
                    tagFlags,
                    offset = dv.byteLength - 128;


                // id3v1
                if (dv.getString(offset, 3) === 'TAG') {
                    offset += 3;
                    meta.ttl = dv.getString(offset, 30).trim() || null;
                    offset += 30;
                    meta.artst = dv.getString(offset, 30).trim() || null;
                // id3v2
                } else {
                }

                // id3v2
                tagVersion = dv.getUint8(3);
                tagFlags = dv.getUint8(5); //dv.getIntByByte(5, 1);
                tagSize += dv.getSynch(dv.getUint32(6));
                if (tagSize > dv.byteLength || dv.getString(0, 3) !== 'ID3' || tagVersion > 4 || (tagFlags & 0x80) !== 0) {
                } else {
                    if ((tagFlags & 0x40) !== 0) {
                        headerSize += dv.getSynch(dv.getUint32(11));
                    }

                    // calculate the tag size to be read
                    while(headerSize < tagSize) {
                        var frame,
                            slice,
                            frameBit,
                            isFrame = true;

                        for(var i = 0; i < 3; i++) {
                            frameBit = dv.getUint8(headerSize+i);
                            if((frameBit < 0x41 || frameBit > 0x5A) && (frameBit < 0x30 || frameBit > 0x39)) {
                                isFrame = false;
                            }
                        }
                        if(!isFrame)  {
                            break;
                        }
                        /*
                         * < v2.3, frame ID is 3 chars, size is 3 bytes making a total size of 6 bytes
                         * >= v2.3, frame ID is 4 chars, size is 4 bytes, flags are 2 bytes, total 10 bytes
                         */
                        if(tagVersion < 3) {
                            slice = buffer.slice(headerSize, headerSize + 6 + dv.getUint24(headerSize + 3));
                        } else {
                            slice = buffer.slice(headerSize, headerSize + 10 + dv.getSynch( dv.getUint32(headerSize + 4) ));
                        }

                        frame = parseFrame(slice, tagVersion);


                        if(frame) {
                            metaV2[frame.tag] = frame.value;
                        }
                        headerSize += slice.byteLength;
                    }

                }

                // put id3v1 or id3v2 tags
                meta.ttl = metaV2.title ||  meta.ttl || '';
                meta.artst = metaV2.artist || metaV2['original-artist'] || meta.artst || '';
                // TODO FIX AUDIO IMAGE CAPTURE THEN ENABLE BELOW LINE
                //meta.thmbURL = metaV2.image || null;
            }


            function fetchAudioMeta()  {
                    var thisAudio = this, //jshint ignore:line
                        meta = {
                                drtn: Math.floor(thisAudio.duration),
                                tiw: 0,
                                tih: 0,
                                artst: '',
                                ttl: thisAudio.nameFromFile.substr(0, thisAudio.nameFromFile.lastIndexOf('.')) || thisAudio.nameFromFile,
                                thmbURL: '',
                                //uniqueId: thisAudio.uniqueId,
                        };



                    var reader = new FileReader();
                    reader.onload = function() {
                        readID3Tags(this.result, meta);
                        thisAudio.deferObj.resolve(meta);
                    };
                    reader.readAsArrayBuffer(thisAudio.fileObj);

            }


            function errorHandler(cause) {
                this.deferObj.reject(); //jshint ignore:line
            }

            self.generateMeta = function(uploadFile, mediaType) {
                var defer = $q.defer(),
                    mediaElement;


                if(mediaType === 'audio') {
                    mediaElement = document.createElement('audio');
                    mediaElement.addEventListener('loadeddata', fetchAudioMeta);
                    mediaElement.fileObj = uploadFile;
                } else {
                    mediaElement = document.createElement('video');
                    mediaElement.addEventListener('loadeddata', function() {
                        var thisVideo = this;
                        thisVideo.currentTime =  (thisVideo.duration > 20.0) ? 10.0 : thisVideo.duration / 2;

                        function fetchMeta() {
                            mediaElement.removeEventListener('timeupdate', fetchMeta);
                            fetchVideoMeta(thisVideo);
                        }

                        mediaElement.addEventListener('timeupdate', fetchMeta);
                    });

                }

                mediaElement.deferObj = defer;
                mediaElement.nameFromFile = uploadFile.name;
                //mediaElement.uniqueId = uploadFile.getKey();

                mediaElement.addEventListener('onerror', errorHandler);
                mediaElement.src = window.URL.createObjectURL(uploadFile);


                return defer.promise;
            };


        }

})(DataView);

/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* * Copyright : Ipvision
* _._._._._._._._._._._._._._._._._._._._._.*/

(function () {
    'use strict';

    angular
        .module('ringid.common.file_upload_service', ['ringid.utils'])
        .service('fileUploadService', fileUploadService);

        fileUploadService.$inject = [ '$$q', 'Storage', 'settings', '$rootScope', 'SystemEvents', 'Ringalert',  'utilsFactory', '$ringhttp', 'imageQuality', 'mediaMetadata'];
        function fileUploadService( $q, StorageFactory, settings, $rootScope, SystemEvents, Ringalert, utilsFactory, $ringhttp, imageQuality, mediaMetadata) { //jshint ignore:line
            var SCOPES = {};
            function getByteResponse(xhrResponse) {
                var DataViewObject = new DataView(xhrResponse),
                    success,
                    response,
                    responseLength;

                if(!DataViewObject.byteLength){
                    response = {sucs: false, mg: 'Failed. Response unreadable' };
                } else {
                    success = DataViewObject.getBool(0);
                    if(success === false) {
                        responseLength = DataViewObject.getUint8(1);
                        response = {sucs: false, mg: DataViewObject.getString(2, responseLength)};
                    } else if (success === true) {
                        responseLength = DataViewObject.getUint8(1);
                        response = {sucs: true, url: DataViewObject.getString(2, responseLength) };
                    }
                }
                return response;
            }


            // constructor function
            function UploadFile(uploadType, file,safeDigest) {
                var uploadPath = '',
                    deferred,
                    fileObj = {
                        //uniqueId: file.uniqueId || utilsFactory.getUniqueID(),
                        uniqueId: utilsFactory.getUniqueID(),
                        uploadType: uploadType,
                        file: file || null,
                        fileName: (file.name && file.name.substr(0, file.name.lastIndexOf('.'))) || 'uploadFile',
                        fileType: (file.name && file.type ? file.type.substr(0, file.type.indexOf('/')) : void 0) || 'image',
                        response: {
                            url: ''
                        },
                        //ttl: (uploadType !== 'status' ) ? obj.file.name.substr(0, obj.file.name.lastIndexOf('.')) || obj.file.name : '',
                        meta: {
                            ttl: (uploadType === 'status' || uploadType === 'image' || !file.name ) ? '' : file.name.substr(0, file.name.lastIndexOf('.')) || file.name
                        },
                        gotMeta: false,
                        previewUrl: '',
                        progressVal: 0,
                        queued: false,
                        uploadComplete: false,
                        uploadFail: false
                    };


                    switch(uploadType) {
                        case 'audio':
                            fileObj.fileName += '.mp3';
                            break;
                        case 'video':
                            fileObj.fileName += '.mp4';
                            break;
                        default:
                            fileObj.meta.ttl = fileObj.fileName;
                            fileObj.fileName += '.jpg';

                    }

                fileObj.previewUrl = settings.baseUrl + '/images/default_' + fileObj.fileType + '_image.jpg';
                //fileObj = angular.extend({}, fileObj, obj);

                if(uploadType === 'profilephoto' || uploadType === 'coverphoto') {
                    fileObj.repositionD = {ih: 0, iw: 0, cimX: 0, cimY: 0};
                }


                function onProgress(progress) {
                    //if (e.lengthComputable) {
                        //fileObj.progressVal = Math.round(e.loaded / e.total * 100);
                        fileObj.progressVal = progress;
                        if(fileObj.uploadType === 'coverphoto' || fileObj.uploadType === 'profilephoto') {
                            self.progress = fileObj.progressVal;
                        }
                        $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.PROGRESS_UPDATE);
                        safeDigest();
                    //}
                }

                function onLoad(responseData) {
                    var response;
                    // upload complete
                    switch(fileObj.uploadType) {
                        case 'chatimage':
                            response = getByteResponse(responseData);
                            if(response.sucs === true) {
                                //response.url = settings.chatImBase + response.url;
                                response.url = response.url;
                            }
                            self.uploadProgress = false;
                            angular.extend(response, fileObj.meta || {});
                            break;
                        case 'tagchatimage':
                            response = angular.fromJson(responseData);
                            if(response.sucs === true) {
                                response.url = response.iurl;
                            }
                            self.uploadProgress = false;
                            angular.extend(response, fileObj.meta || {});
                            break;
                        case 'video':
                            response = getByteResponse(responseData);
                            fileObj.meta.thmbURL = response.url ? response.url.substr(0, response.url.lastIndexOf('.')) + '.jpg' : '';
                            fileObj.previewUrl = response.url ? settings.mediaBase + fileObj.meta.thmbURL : '';
                            break;
                        case 'audio':
                            response = getByteResponse(responseData);
                            break;
                        case 'coverphoto':
                        case 'profilephoto':
                            response =  angular.fromJson(responseData);
                            // readjust ih, iw to image original height and width
                            response.ih =  fileObj.meta.ih;
                            response.iw =  fileObj.meta.iw;
                            self.uploadProgress = false;
                            break;
                        case 'image':
                            response = angular.fromJson(responseData);
                            fileObj.previewUrl = response.iurl ?
                                settings.imBase + response.iurl.substr(0, response.iurl.lastIndexOf('/')+1) + 'pthumb' + response.iurl.substr(response.iurl.lastIndexOf('/')+1)
                                    : '';
                            // revoke
                            break;
                        case 'thumb':
                            response = getByteResponse(responseData);
                            break;
                        default:
                            response =  angular.fromJson(responseData);
                    }


                    fileObj.response = angular.extend({}, fileObj.response, response );


                    if(response.sucs === true) {
                        fileObj.uploadComplete = true;
                    } else {
                        fileObj.uploadFail = true;
                    }
                    // fileObj.file = undefined;
                    fileObj.queued = false;


                    if(response.sucs !== true) {
                        Ringalert.show(response.mg || 'Failed', 'error');
                    }
                    deferred.resolve( response );

                    //safeDigest();
                }

                function onAbort() {
                    safeDigest();
                    deferred.reject();
                }

                function onError(response) {
                    if (response && response.mg) {
                        Ringalert.show(response.mg, 'error');
                    }
                    deferred.reject();
                }


                function fetchMeta(callBack) {
                    switch(fileObj.fileType) {
                        case 'video':
                        case 'audio':
                            mediaMetadata.generateMeta(fileObj.file, fileObj.fileType).then(function(meta) {
                                fileObj.meta = angular.extend({}, meta, fileObj.meta);
                                callBack({success: true});
                                safeDigest();
                            }, function(errMsg) {
                                Ringalert(errMsg, 'error');
                                fileObj.uploadFail = true;
                                if (deferred) {
                                    deferred.reject(errMsg);
                                } else {
                                    callBack({success: false, message: errMsg});
                                }
                                safeDigest();
                            });
                            break;
                        case 'image':
                            imageQuality.resizeImage(fileObj.file, fileObj.uploadType).then(function(meta) {
                                fileObj.file = meta.file;
                                fileObj.meta.ih = meta.ih;
                                fileObj.meta.iw = meta.iw;
                                fileObj.previewUrl = meta.previewUrl;
                                callBack({success: true});
                                safeDigest();
                            }, function(errMsg) {
                                fileObj.uploadFail = true;
                                if (deferred) {
                                    Ringalert.show(errMsg, 'error');
                                    deferred.reject(errMsg);
                                } else {
                                    callBack({success: false, message: errMsg});
                                }
                                safeDigest();
                            });
                            break;
                    }
                    fileObj.gotMeta = true;
                    safeDigest();
                }

                return {
                    getKey: function() {
                        return fileObj.uniqueId;
                    },
                    setRepositionData: function(obj) {
                        fileObj.repositionD  = angular.extend({}, fileObj.repositionD || {}, obj);
                    },
                    getRepositionData: function() {
                        if (fileObj.uploadType === 'profilephoto') {
                            return { pimX: fileObj.repositionD.cimX, pimY: fileObj.repositionD.cimY};
                        } else {
                            return { cimX: fileObj.repositionD.cimX, cimY: fileObj.repositionD.cimY};
                        }
                    },
                    getFile: function() {
                        return fileObj.file;
                    },
                    getName: function() {
                        return fileObj.file.name;
                    },
                    fetchMeta: fetchMeta,
                    initUpload: function() {
                        var formData = new FormData(),
                            responseType = 'text';

                        deferred = $q.defer();
                        fileObj.queued = true;

                        formData.append('sId', StorageFactory.getCookie('sId'));
                        formData.append('uId', StorageFactory.getCookie('uId'));
                        formData.append('authServer', StorageFactory.getCookie('authServer'));
                        formData.append('comPort', StorageFactory.getCookie('comPort'));
                        formData.append('x-app-version', settings.apiVersion);

                        // put additional data for image files
                        switch(fileObj.uploadType) {
                            case 'profilephoto':
                                uploadPath = settings.imServer + 'ImageUploadHandler';
                                break;
                            case 'coverphoto':
                                uploadPath = settings.imServer +  'CoverImageUploadHandler';
                                break;
                            case 'tagchatimage':
                                uploadPath = settings.imServer + 'GroupContentHandler';
                                break;
                            case 'chatimage':
                                uploadPath = settings.imServer + 'ChatImageHandler';
                                responseType = 'arraybuffer';
                                break;
                            case 'image':
                                uploadPath = settings.imServer + 'AlbumImageUploadHandler';
                                break;
                            case 'video':
                                uploadPath = settings.mediaServer + 'Mp4UploadHandler';
                                responseType = 'arraybuffer';
                                break;
                            case 'audio':
                                uploadPath = settings.mediaServer + 'Mp3UploadHandler';
                                responseType = 'arraybuffer';
                                break;
                            case 'thumb':
                                uploadPath = settings.mediaServer + 'ThumbImageHandler';
                                responseType = 'arraybuffer';
                                fileObj.gotMeta = true; // no need to fetch meta of thumb image
                                break;
                            default:

                        }

                        if (fileObj.gotMeta) {
                            sendFile();
                        } else {
                            fetchMeta(sendFile);
                        }

                        function sendFile() {
                            if (fileObj.uploadType === 'coverphoto' || fileObj.uploadType === 'profilephoto' ) {
                                Object.keys(fileObj.repositionD).forEach(function (key) {
                                    formData.append(key, fileObj.repositionD[key]);
                                });

                            }
                            formData.append('file', fileObj.file, fileObj.fileName) ;//(fileObj.file.name.substr(0, fileObj.file.name.lastIndexOf('.')) || 'imagefile')  + '.jpg');
                            fileObj.xhr = $ringhttp.post(uploadPath, formData, responseType)
                                .success(onLoad)
                                .error(onError)
                                .progress(onProgress)
                                .abort(onAbort);
                        }


                        return deferred.promise;
                    },
                    cptn: function(newCaption) {
                        //if (fileObj.meta) {
                            return arguments.length ? (fileObj.meta.ttl = newCaption) : fileObj.meta.ttl || fileObj.file.name;
                        //} else {
                            //return arguments.length ? (fileObj.ttl = newCaption) : fileObj.ttl;
                        //}
                        //if (fileObj.uploadType === 'audio') {
                        //} else {
                            //return arguments.length ? (fileObj.ttl = newCaption) : fileObj.ttl;
                        //}
                    }, // used in rg-upload directive to bind as a caption model for status images and maybe for video captions
                    getPreview: function() {
                        return fileObj.previewUrl;
                    },
                    cancelUpload: function() {
                        fileObj.uploadFail = true;
                        if (fileObj.xhr) {
                            fileObj.xhr.abortRequest();
                        } else if (fileObj.deferred) {
                            fileObj.deferred.reject();
                        }
                    },
                    setPreview: function(previewUrl) {
                        fileObj.previewUrl = previewUrl;
                    },
                    getProgress: function() {
                        return fileObj.progressVal;
                    },
                    uploadCompleted: function() {
                         return fileObj.uploadComplete;
                    },
                    uploadFailed: function() {
                        return fileObj.uploadFail;
                    },
                    getQueued: function() {
                        return fileObj.queued;
                    },
                    setQueued: function(bool) {
                        fileObj.queued = bool || true;
                    },
                    setMeta: function(metaObj) {
                        fileObj.meta =  metaObj;
                    },
                    getMeta: function() {
                        if(fileObj.hasOwnProperty('meta')) {
                            return fileObj.meta;
                        } else {
                            return false;
                        }
                    },
                    getAuthData: function(addTagList) {
                        var returnObj = {};

                        switch(fileObj.fileType) {
                            case 'image':
                                returnObj = {
                                    ih: fileObj.meta.ih,
                                    iw: fileObj.meta.iw,
                                    iurl: fileObj.response.iurl,
                                    cptn: fileObj.meta.ttl.utf8Encode()
                                };
                                break;
                            case 'video':
                                //returnObj =  {
                                    //strmURL: fileObj.response.url
                                //};
                                //returnObj = angular.extend({}, returnObj, fileObj.meta);
                                //returnObj.thmbURL = returnObj.strmURL.substr(0, returnObj.strmURL.lastIndexOf('.')) + '.jpg';
                                ////returnObj.previewURL = settings.imBase + returnObj.thmbURL;
                                //returnObj.ttl = fileObj.meta.ttl.utf8Encode(); // overriting video thumb ttl with user modified caption
                                //break;
                            case 'audio':
                                returnObj = {
                                    strmURL: fileObj.response.url,
                                    tiw: fileObj.meta.tiw,
                                    tih: fileObj.meta.tih,
                                    drtn: fileObj.meta.drtn,
                                    thmbURL: fileObj.meta.thmbURL,
                                    artst: fileObj.meta.artst.utf8Encode(),
                                    //ttl: fileObj.cptn.utf8Encode() //fileObj.meta.ttl
                                    ttl: fileObj.meta.ttl.utf8Encode()
                                };

                                if (addTagList) {
                                    for(var i = 0; i < self.tagList.length; i++) {
                                        self.tagList[i].sk =   self.tagList[i].sk.utf8Encode();
                                    }
                                    returnObj.htgLst = self.tagList;
                                }
                                break;
                            default:
                                returnObj = fileObj.response;
                        }

                        return returnObj;

                    }
                };
            }


            var self = this, // jshint ignore:line
                _albumId = -1;


            self.resetUpload = function resetUpload() {
                self.progress = 0;
                self.tagList = [];
                self.uploadProgress = false;
                self.profileImageFile = null;
                self.coverImageFile = null;
                self.imageFiles = [];
                self.videoFiles = [];
                self.audioFiles = [];
                self.chatImageFiles = {};

                self.selectFromAlbum = false; // from browse album.
            };

            self.resetUpload();

            self.createUploadFile = function(uploadType, obj) {
                return new UploadFile(uploadType, obj,safeDigest);
            };

            //self.statusMediaCount = function(uploadWhat) {
                //if(uploadWhat) {
                    //return self[uploadWhat+'Files'].length;
                //} else {
                    //return 0;
                //}
            //};

            self.setUploadAlbum = function(albumId) {
                _albumId = albumId;
            };
            self.getUploadAlbum = function() {
                return _albumId;
            };

            self.queueFile = function(uploadType, fileObj) {
                //_albumId = -1;
                switch(uploadType) {
                    case 'profilephoto':
                        self.progress = 0;
                        self.profileImageFile = new UploadFile(uploadType, fileObj,safeDigest);
                        return self.profileImageFile;
                    case 'coverphoto':
                        self.progress = 0;
                        self.coverImageFile = new UploadFile(uploadType, fileObj,safeDigest);
                        return self.coverImageFile;
                    case 'tagchatimage':
                    case 'chatimage':
                        return new UploadFile(uploadType, fileObj,safeDigest);
                    case 'image':
                        self.imageFiles.push( new UploadFile(uploadType, fileObj,safeDigest));
                        break;
                    case 'video':
                        self.videoFiles.push(new UploadFile(uploadType, fileObj,safeDigest));
                        break;
                    case 'audio':
                        self.audioFiles.push(new UploadFile(uploadType, fileObj,safeDigest));
                        break;
                    default:
                }
                safeDigest();
            };

            self.setReposition = function(dimension, uploadType) {
                if(uploadType === 'coverphoto') {
                    self.coverImageFile.setRepositionData(dimension);
                } else if (uploadType === 'profilephoto') {
                    self.profileImageFile.setRepositionData(dimension);
                } else {
                }
            };
            // used while changing cover and profile pic
            self.getReposition = function(uploadType) {
                if(uploadType === 'coverphoto') {
                    return self.coverImageFile.getRepositionData();
                } else if (uploadType === 'profilephoto') {
                    return self.profileImageFile.getRepositionData();
                } else {
                    return {};
                }
            };


            self.uploadQueue = function(uploadType, startIndex) {
                // for status videos, images, audios
                var promises = [],
                    endIndex,
                    whichFiles = uploadType + 'Files';

                if (startIndex < self[whichFiles].length) {
                    endIndex = (startIndex+2 < self[whichFiles].length) ? startIndex + 2 : self[whichFiles].length;
                    for (var i = startIndex; i < endIndex; i++) {
                        //reduce size if necessary and put to queue for upload
                        if ( self[whichFiles][i] &&
                            !self[whichFiles][i].getQueued() &&
                            !self[whichFiles][i].uploadFailed() ) {

                            promises.push(self[whichFiles][i].initUpload());
                            //promises.push(imageQuality.resizeImage(self[whichFiles][i].getFile(), $scope.rgUploadType));
                        } else {
                        }
                    }

                    // in case of failed uploads no promises
                    if (promises.length === 0) {
                        self.uploadQueue(uploadType, endIndex );
                        return;
                    }

                    $q.all(promises).then(function() {
                        removeFailed();
                        self.uploadQueue(uploadType, endIndex);
                        // show preview and resize postbox to accomodate image preview area
                    }, function(errData) {
                        endIndex = endIndex - removeFailed();
                        self.uploadQueue(uploadType, endIndex);
                    });

                } else {
                    var interval = setInterval(function() {
                        self.uploadProgress = false;
                        removeFailed(true);
                        for(var i = 0; i < self[whichFiles].length; i++) {
                            if (!self[whichFiles][i].uploadCompleted()) {
                                self.uploadProgress = true;
                                break;
                            }
                        }
                        if (!self.uploadProgress) {
                            clearInterval(interval);
                            $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.QUEUE_COMPLETE, uploadType);
                            // if media
                            //if (self[whichFiles].length > 0) {
                                //Ringalert.show('All files uploaded', 'success');
                            //}
                            safeDigest();
                        }
                    }, 2000);
                }

                function removeFailed(startFromZero) {
                    var start = startFromZero ? 0 : startIndex;
                    var removeCounter = 0;
                    for(var i = start, l = self[whichFiles].length; i < l; i++) {
                        if (self[whichFiles][i] && self[whichFiles][i].uploadFailed()) {
                            self[whichFiles].splice(i, 1);
                            removeCounter++;
                            i--;
                            l--;
                        }
                    }
                    if (removeCounter > 0) {
                        safeDigest();
                    }
                    return removeCounter;
                }

            };
                self.setScopeForDigest = function(scope){
                    SCOPES[scope.$id] = scope;
                };
                self.removeScope = function(scope){
                    if(SCOPES[scope.$id]){
                        SCOPES[scope.$id] = null;
                    }
                };
            function safeDigest(){
                var digestScope;
                for(var key in SCOPES){
                    if (SCOPES.hasOwnProperty(key)) {
                        digestScope = SCOPES[key];
                        if(digestScope && digestScope.$id && !digestScope.$$destroyed){
                            digestScope.$rgDigest();
                        }
                    }
                }

            }

        }

})();



/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* * Copyright : Ipvision
*
* * File Name : image-quality.service.js
*
* * Creation Date : 01-01-2015
*
* * Last Modified : Tue 03 Nov 2015 17:13:48 BDT
*
* _._._._._._._._._._._._._._._._._._._._._.*/

(function () {

    'use strict';

    angular
        .module('ringid.common.image_quality_service', ['ringid.common.file_upload_service', 'ringid.utils'])
        .service('imageQuality', imageQuality);

        imageQuality.$inject = [ '$$q', 'APP_CONSTANTS', 'Ringalert', 'utilsFactory'];
        function imageQuality( $q, APP_CONSTANTS, Ringalert, utilsFactory) { // jshint ignore:line
            var self = this, // jshint ignore:line
                coverMinW = APP_CONSTANTS.COVER_PIC_UPLOAD_MINIMUM_WIDTH,
                coverMinH = APP_CONSTANTS.COVER_PIC_UPLOAD_MINIMUM_HEIGHT,
                coverMaxW = APP_CONSTANTS.COVER_PIC_UPLOAD_MAXIMUM_WIDTH,
                coverMaxH = APP_CONSTANTS.COVER_PIC_UPLOAD_MAXIMUM_HEIGHT,
                profileMinW = APP_CONSTANTS.PROFILE_PIC_UPLOAD_MINIMUM_WIDTH,
                profileMinH = APP_CONSTANTS.PROFILE_PIC_UPLOAD_MINIMUM_HEIGHT,
                imageMinH = APP_CONSTANTS.IMAGE_UPLOAD_MIN_HEIGHT,
                imageMinW = APP_CONSTANTS.IMAGE_UPLOAD_MIN_WIDTH;



            self.resizeImage = function(imageFile, uploadType) {
                // imageFile can be image source path or imageMap object

                var image = new Image(),
                    limitCross = false,
                    defer = $q.defer(),
                    meta = {
                        ih: 0,
                        iw: 0,
                        previewUrl: '',
                        file: ''
                    },
                    URL = window.URL || window.webkitURL;


                function imageLoaded() {
                        var imgObj = this; // jshint ignore:line
                        var canvas,
                            scale = 1,
                            ctx,
                            imageWidth =  imgObj.width,
                            imageHeight = imgObj.height;


                        function resizeInCanvas(imgQuality) {

                            canvas = document.createElement('canvas');
                            canvas.width = meta.iw;
                            canvas.height = meta.ih;
                            ctx = canvas.getContext('2d');

                            ctx.drawImage(imgObj, 0, 0, meta.iw, meta.ih);

                            if(imgQuality) {
                                meta.imQ = imgQuality.qualityIM.quality;
                            }

                            meta.previewUrl = canvas.toDataURL('image/jpeg');
                            meta.file = utilsFactory.dataURLToBlob(meta.previewUrl);

                            meta.file.name = imageFile.name || uploadType + '.jpg';

                            defer.resolve(meta);


                            // queue in upload service for actual upload later
                            //fileUploadService.queueFile(uploadType, meta);

                            // only for chat images retain objectURL otherwise remoke it
                            //if (uploadType  && (uploadType === 'chatimage' || uploadType === 'tagchatimage')) {
                                //defer.resolve(image.src, meta.boxValue);
                            //} else {
                                //URL.revokeObjectURL(image.src);
                                //defer.resolve(meta.previewUrl, meta.boxValue);
                            //}

                        }

                        // meature actual resize dimensions
                        if(imageWidth > coverMaxW || imageHeight > coverMaxH) {
                            // set width = maximum allowed Width and adjust Height
                            if ( (imageWidth / coverMaxW) > (imageHeight / coverMaxH)) {
                                scale = coverMaxW / imageWidth;
                                meta.iw= coverMaxW;
                                meta.ih = Math.floor( scale * imageHeight);
                            } else { // set height = maximum allowed and adjust width
                                scale = coverMaxH / imageHeight;
                                meta.ih = coverMaxH;
                                meta.iw= Math.floor(scale * imageWidth);
                            }
                        } else {
                            // no need to resize
                            meta.iw = imageWidth;
                            meta.ih = imageHeight;
                        }

                        var minimumH = imageMinH,
                            minimumW = imageMinW;

                        switch(uploadType) {
                            case 'profilephoto':
                                if(meta.iw < profileMinW || meta.ih < profileMinH) {
                                    minimumH = profileMinH;
                                    minimumW = profileMinW;
                                    limitCross = true;
                                }
                                break;
                            case 'coverphoto':
                                if(meta.iw < coverMinW || meta.ih < coverMinH) {
                                    minimumH = coverMinH;
                                    minimumW = coverMinW;
                                    limitCross = true;
                                }
                                break;
                            case 'image':
                            case 'status':
                            case 'chatimage':
                            case 'tagchatimage':
                                if(meta.iw < imageMinW || meta.ih < imageMinH) {
                                    limitCross = true;
                                }
                                break;
                            default:
                        }



                        if(limitCross) {
                            defer.reject('Image Size below Minimum(' + minimumW + 'px by ' + minimumH  + 'px) :' + imageFile.name);
                        } else {
                            // get quality and then resize and queue for uploading
                            // ignore
                            //if(imageFile.type === 'image/jpeg') {
                                //// calculate quality only for jpeg
                                //self.calculate(imgObj, resizeInCanvas);
                            //} else {
                                resizeInCanvas(false);
                            //}

                        }


                    }

                    function imageError () {
                        defer.reject('Image invalid: ' + imageFile.name);
                    }

                    if(typeof imageFile === 'string' ) {
                        image.setAttribute('crossOrigin', 'anonymous');
                        image.src = imageFile;
                    } else {
                        image.src = URL.createObjectURL(imageFile); // new file upload
                    }

                    image.onload = imageLoaded;
                    image.onerror = imageError;

                return defer.promise;
            };

        }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.common.services', [
            'ringid.common.media_metadata_service',
            'ringid.common.file_upload_service',
            'ringid.common.image_quality_service',
			'ringid.config',
			'ngWebSocket'
			//'ngCookies'
			])
		.factory('countryListService', countryListService)
        // get list of countries with code from a json file
		countryListService.$inject = ['$ringhttp', 'settings'];
		function countryListService($ringhttp, settings) {
			return {
					getList: function(forSignup) {
						return $ringhttp.get( settings.baseUrl + '/resources/countries.json');
					}
			};
		}
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

     angular
        .module('ringid.common.services')
        .service('imageHttpService', imageHttpService);

        imageHttpService.$inject = ['$$q', 'settings', '$$connector', 'OPERATION_TYPES'];
        function imageHttpService($q, settings, $$connector, OPERATION_TYPES){ // jshint ignore:line
            var self = this, //jshint ignore:line
                REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE,
                OTYPES = OPERATION_TYPES.SYSTEM.IMAGE;


            self.fetchAlbumList = function(fndId) {
                var payload = {};
                if(fndId) {
                    payload.actn = OTYPES.FETCH_FRIEND_ALBUM_LIST;
                    payload.fndId = fndId;
                } else {
                        payload.actn = OTYPES.FETCH_ALBUM_LIST;
                }
                $$connector.send(payload, REQTYPE.REQUEST);
            };


            /**
            * @api {request} /APIREQUEST/97,109 Get Photos of Album
            * @apiVersion 0.1.0
            * @apiDescription Fetches photos of 3 predefined albums( profileImages, coverImages, feed Images/default)
            * @apiName GetAlbumImages
            * @apiGroup Image
            *
            * @apiParam {Number=97,109} actn TYPE_ALBUM_IMAGES / TYPE_FRIEND_ALBUM_IMAGES
            * @apiParam {Number} [fndId] Friend uId in case of friends photos
            * @apiParam {String='profileImages', 'coverImages', 'default'} albId Album id. predefined for three types of albums
            * @apiParam {Number} st=0 Pagination
            *
            *
            * @apiSuccess {Number} actn TYPE_FRIEND_ALBUM_IMAGES
            * @apiSuccess {String='default','coverImages','profileImages'} Album Id
            * @apiSuccess {Object[]{1..5}} imageList Image list
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} timg No of total Images in Album
            * @apiSuccess {Number} tr No of Image in response
            *
            * @apiSuccess (imageList) {String} cptn Caption
            * @apiSuccess (imageList) {Number=0,1} ic Image have User's comment or not
            * @apiSuccess (imageList) {Number} ih Image height
            * @apiSuccess (imageList) {Number=0,1} il Image have User's Like or not
            * @apiSuccess (imageList) {Number} imT Image Type
            * @apiSuccess (imageList) {Number} imgId Image Id
            * @apiSuccess (imageList) {Number} iw Image Width
            * @apiSuccess (imageList) {Number} nc No of Comments
            * @apiSuccess (imageList) {Number} nl No of Likes
            * @apiSuccess (imageList) {Number} tm Image upload time
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 97
            *       albId: "default"
            *       headerLength: 20
            *       imageList:  [
            *           0: {
            *               cptn: ""
            *               ic: 0
            *               ih: 183
            *               il: 0
            *               imT: 1
            *               imgId: 16343
            *               iurl: "2000001794/1435711880942.jpg"
            *               iw: 275
            *               nc: 0
            *               nl: 0
            *               tm: 1435732845444
            *           }
            *       ]
            *       pckId: "895751887743"
            *       seq: "2/2"
            *       sucs: true
            *       timg: 14
            *       tr: 10
            *     }
            *
            * @apiError Album has no Image
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 200 Not Found
            *     {
            *       "sucs": false
            *     }
            */

            self.getAlbumImages = function (obj) {
                var payload = {};
                if (obj.fndId) {
                    payload.actn = OTYPES.TYPE_FRIEND_ALBUM_IMAGES; // 109
                    payload.fndId  = obj.fndId;
                } else {
                    payload.actn = OTYPES.TYPE_ALBUM_IMAGES; // 97
                }
                payload.st = obj.st || 0;
                payload.albId = obj.albId;

                //return $$connector.pull(payload, REQTYPE.REQUEST, true);
                $$connector.send(payload, REQTYPE.REQUEST, true);
            };


            /**
            * @api {request} /APIREQUEST/89 Get Image Comments
            * @apiVersion 0.1.0
            * @apiDescription Fetches Comments for an Image
            * @apiName GetImageComments
            * @apiGroup Image
            *
            * @apiParam {Number=89} actn TYPE_COMMENTS_FOR_IMAGE
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number} st=0 Pagination
            *
            * @apiSuccess {Number=89} actn TYPE_COMMENTS_FOR_IMAGE
            * @apiSuccess {Object[]{1..5}} comments Comment list
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            *
            * @apiSuccess (comments) {String} cmn Comment Text
            * @apiSuccess (comments) {Number} cmnId Comment Id
            * @apiSuccess (comments) {String} fn User Name
            * @apiSuccess (comments) {il=1,0} il Image have User's Like or not
            * @apiSuccess (comments) {String} prIm Image Url
            * @apiSuccess (comments) {Number} sc Undefined
            * @apiSuccess (comments) {Number} tl Total Like
            * @apiSuccess (comments) {Number} tm Image upload time
            * @apiSuccess (comments) {Number} uId User uId
            *
            *
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 89
            *       comments: [
            *           0: {
            *               cmn: "more comments"
            *               cmnId: 2328
            *               fn: "Spirit Walker"
            *               il: 0
            *               prIm: "2000001794/1428886675955.jpg"
            *               sc: false
            *               tl: 0
            *               tm: 1435747371055
            *               uId: "2000001794"
            *           }
            *       ]
            *       headerLength: 60
            *       imgId: 16339
            *       pckFs: 1161342
            *       pckId: "574746651601"
            *       seq: "1/1"
            *       sucs: true
            *
            *     }
            *
            * @apiError Image has no Comments
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 404 Not Found
            *     {
            *       "sucs": false
            *     }
            */

            // self.getComments = function(obj) {
            //     var payload = {
            //             actn: OTYPES.TYPE_COMMENTS_FOR_IMAGE,
            //             imgId: obj.imgId,
            //             st: obj.st || 0
            //     };
            //     return $$connector.request(payload, REQTYPE.REQUEST);
            // };

            self.deleteImage = function(imgId) {
                return $$connector.request({
                    actn: OTYPES.DELETE_IMAGE,
                    imgIds: [imgId]
                }, REQTYPE.UPDATE);
            };


            // self.getCommentById = function(imgId, commentId) {
            //     $$connector.request({
            //         actn: OTYPES.ACTION_GET_FULL_COMMENT,
            //         imgId: imgId,
            //         cmnId: commentId,
            //         cmntT: 2 // 1=feed comment, 2= image comment

            //     },OTYPES.REQUEST_TYPE.REQUEST);
            // };



            /**
            * @api {request} /APIREQUEST/93 Get Image Likes (INCOMPLETE OR UNUSED)
            * @apiVersion 0.1.0
            * @apiDescription Fetches Likes for an Image
            * @apiName GetImageLikes
            * @apiGroup Image
            *
            * @apiParam {Number=93} actn TYPE_LIKES_FOR_IMAGE
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number} st=0 Pagination
            *
            * @apiSuccess {Number} actn TYPE_FRIEND_ALBUM_IMAGES
            * @apiSuccess {String='default','coverImages','profileImages'} Album Id
            * @apiSuccess {Object[]{1..5}} imageList Image list
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} timg No of total Images in Album
            * @apiSuccess {Number} tr No of Image in response
            *
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 97
            *       albId: "default"
            *       headerLength: 20
            *       pckId: "895751887743"
            *       seq: "2/2"
            *       sucs: true
            *       timg: 14
            *       tr: 10
            *     }
            *
            * @apiError Album has no Image
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 404 Not Found
            *     {
            *       "sucs": false
            *     }
            */

            // self.getLikes = function(obj) {
            //     var payload = {
            //         actn: OTYPES.TYPE_LIKES_FOR_IMAGE,
            //             imgId: obj.imgId,
            //             st: obj.st || 0
            //     };
            //     return $$connector.request(payload, REQTYPE.REQUEST);
            // };



            /**
            * @api {request} /APIREQUEST/121 Get Image Details
            * @apiVersion 0.1.0
            * @apiDescription Get Image Details, i.e who owns, album, no of likes, comments etc
            * @apiName GetImageDetails
            * @apiGroup Image
            *
            * @apiParam {Number=121} actn TYPE_IMAGE_DETAILS
            * @apiParam {Number} imgId Image Id
            *
            *
            * @apiSuccess {Number=121} actn TYPE_IMAGE_DETAILS
            * @apiSuccess {String='default','coverImages','profileImages'} Album Id
            * @apiSuccess {String} albn Album Name i.e. Feed Images, Profile Images, Cover images etc
            * @apiSuccess {String} cptn Caption
            * @apiSuccess {String} fn User Name
            * @apiSuccess {Number=0,1} ic Image have User's comment or not
            * @apiSuccess {Number} ih Image height
            * @apiSuccess {Number=0,1} il Image have User's Like or not
            * @apiSuccess {Number} imT Image Type
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {String} iurl Image Url
            * @apiSuccess {Number} iw Image Width
            * @apiSuccess {Number} nc No of Comments
            * @apiSuccess {Number} nl No of Likes
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} tm Image time
            * @apiSuccess {Number} uId User Id
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 121
            *       albId: "default"
            *       albn: "Feed Photos"
            *       cptn: ""
            *       fn: "Spirit Walker"
            *       headerLength: 53
            *       ic: 1
            *       ih: 153
            *       il: 0
            *       imT: 1
            *       imgId: 16339
            *       iurl: "2000001794/1435711441058.jpg"
            *       iw: 300
            *       nc: 2
            *       nl: 0
            *       pckId: "745902702948"
            *       sucs: true
            *       tm: 1435732409019
            *       uId: "2000001794"
            *     }
            *
            */

            self.getImageDetails = function(imgId){
             return  $$connector.request({
                    actn :OTYPES.TYPE_IMAGE_DETAILS,
                    imgId : imgId
                }, REQTYPE.REQUEST);

            };



            /**
            * @api {UPDATE} /APIREQUEST/185 Like/Unlike Image
            * @apiVersion 0.1.0
            * @apiDescription Request to Like or Unlike Image
            * @apiName ImageLikeUnlike
            * @apiGroup Image
            *
            * @apiParam {Number=185} actn TYPE_LIKE_IMAGE
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number=0,1} ikd I like(0)/unlike(1)
            *
            *
            * @apiSuccess {Number=185} actn TYPE_LIKE_IMAGE
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {String} mg Message
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 185
            *       headerLength: 53
            *       imgId: 16339
            *       nfId : 1511
            *       pckId: "770981966122"
            *       sucs: true
            *     }
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 404 Not Found
            *     {
            *       actn: 185
            *       headerLength: 53
            *       imgId: 16339
            *       mg: "Unable to post like/unlike."
            *       pckId: "770981966122"
            *       sucs: false
            *     }
            */


            // self.toggleLike = function(imgId, lkd,nfId) {
            //     var payload = {
            //         actn: OTYPES.TYPE_LIKE_IMAGE,
            //         imgId : imgId,
            //         lkd : lkd
            //     };
            //     if(nfId){
            //         payload.nfId = nfId;
            //     }
            //     return $$connector.request(payload,  REQTYPE.UPDATE );
            // };

            /**
            * @api {UPDATE} /APIREQUEST/180 Comment On Image
            * @apiVersion 0.1.0
            * @apiDescription Request to Add Comment to Image
            * @apiName ImageAddComment
            * @apiGroup Image
            *
            * @apiParam {Number=180} actn TYPE_ADD_IMAGE_COMMENT
            * @apiParam {Number} imgId Image Id
            * @apiParam {String} cmn Comment Text
            *
            *
            * @apiSuccess {Number=180} actn TYPE_ADD_IMAGE_COMMENT
            * @apiSuccess {String} cmn Comment Text
            * @apiSuccess {Number} cmnId Comment Id
            * @apiSuccess {String} fn User Name
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {Number} loc Undefined
            * @apiSuccess {Boolean} sc Undefined
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} tm Comment Time
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 180
            *       cmn: "test comment"
            *       cmnId: 2330
            *       fn: "Spirit Walker"
            *       headerLength: 53
            *       imgId: 16339
            *       loc: 3
            *       pckId: "794680017483"
            *       sc: false
            *       sucs: true
            *       tm: 1435752098339
            *     }
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 404 Not Found
            *     {
            *       sucs: false
            *     }
            */
            // self.addComment = function(imgId, comment) {
            //     return $$connector.request({
            //         actn : OTYPES.TYPE_ADD_IMAGE_COMMENT,
            //         imgId : imgId,
            //         cmn : comment.utf8Encode()
            //     }, REQTYPE.UPDATE);
            // };

            /**
            * @api {UPDATE} /APIREQUEST/194 Edit Comment
            * @apiVersion 0.1.0
            * @apiDescription Request to Edit Comment
            * @apiName ImageEditComment
            * @apiGroup Image
            *
            * @apiParam {Number=194} actn TYPE_EDIT_IMAGE_COMMENT
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number} cmnId Comment Id
            * @apiParam {String} cmn Comment Text
            *
            *
            * @apiSuccess {Number=194} actn TYPE_EDIT_IMAGE_COMMENT
            * @apiSuccess {String} cmn Comment Text
            * @apiSuccess {Number} cmnId Comment Id
            * @apiSuccess {String} fn User Name
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {Boolean} sc Undefined
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 194
            *       cmn: "comment again dsfasfas"
            *       cmnId: 2322
            *       fn: "Spirit Walker"
            *       headerLength: 54
            *       imgId: 16340
            *       pckId: "1083486106462"
            *       sc: false
            *       sucs: true
            *     }
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 200 Not Found
            *     {
            *       actn: 194
            *       sucs: false
            *     }
            */
            // self.updateComment = function(imgId, cmnId, cmn) {
            //     return $$connector.request({
            //             actn : OTYPES.TYPE_EDIT_IMAGE_COMMENT,
            //             imgId : imgId,
            //             cmnId :cmnId,
            //             cmn: cmn.utf8Encode()
            //         }, REQTYPE.UPDATE );
            // };

            /**
            * @api {UPDATE} /APIREQUEST/182 Delete Image Comment
            * @apiVersion 0.1.0
            * @apiDescription Request to Delete Image Comment
            * @apiName ImageDeleteComment
            * @apiGroup Image
            *
            * @apiParam {Number=182} actn TYPE_DELETE_IMAGE_COMMENT
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number} cmnId Comment Id
            *
            *
            * @apiSuccess {Number=182} actn TYPE_DELETE_IMAGE_COMMENT
            * @apiSuccess {Number} cmnId Comment Id
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {Number} loc Undefined
            * @apiSuccess {Boolean} sc Undefined
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 182
            *       cmnId: 2322
            *       headerLength: 53
            *       imgId: 16340
            *       loc: 1
            *       pckId: "234858749621"
            *       sc: false
            *       sucs: true
            *     }
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 200 Not Found
            *     {
            *       actn: 182
            *       sucs: false
            *     }
            */
            // self.deleteComment = function(imgId, cmnId) {
            //     return $$connector.request({
            //         actn : OTYPES.TYPE_DELETE_IMAGE_COMMENT,
            //         imgId : imgId,
            //         cmnId :cmnId
            //     }, REQTYPE.UPDATE);
            // };

            /**
            * @api {UPDATE} /APIREQUEST/197 Like/Unlike Image Comment
            * @apiVersion 0.1.0
            * @apiDescription Request to Like or Unlike Image Comment
            * @apiName ImageCommentLikeUnlike
            * @apiGroup Image
            *
            * @apiParam {Number=197} actn TYPE_LIKE_UNLIKE_IMAGE_COMMENT,
            * @apiParam {Number} imgId Image Id
            * @apiParam {Number} cmnId Comment Id
            * @apiParam {Number=0,1} lkd I like(0)/unlike(1) Comment
            *
            *
            * @apiSuccess {Number=185} actn TYPE_LIKE_UNLIKE_IMAGE_COMMENT,
            * @apiSuccess {Number} cmnId Comment Id
            * @apiSuccess {Number} id Undefined
            * @apiSuccess {Number} imgId Image Id
            * @apiSuccess {Number=0,1} lkd Like/Unlike value
            * @apiSuccess {Number} loc Undefined
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} tm Image time
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       actn: 197
            *       cmnId: 2321
            *       headerLength: 53
            *       id: 492
            *       imgId: 16340
            *       lkd: 1
            *       loc: 1
            *       pckId: "449485259142"
            *       sucs: true
            *       tm: 1435753240084
            *     }
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 200 Not Found
            *     {
            *       actn: 197
            *       sucs: false
            *     }
            */
            // self.toggleCommentLike = function(imgId, cmnId, lkd) {
            //     return $$connector.request({
            //         actn : OTYPES.TYPE_LIKE_UNLIKE_IMAGE_COMMENT,
            //         imgId : imgId,
            //         cmnId: cmnId,
            //         lkd : lkd
            //     }, REQTYPE.UPDATE );
            // };

            self.getProfilePicORCoverPicImageDetails = function(obj){
                var defer = $q.defer();
                 self.go({
                    actn :OTYPES.GET_CP_OR_PP_DETAIL,
                    type : obj.type
                }).then(function(data){
                        defer.resolve(data);
                 },function(reason){
                    defer.reject(reason);
                 });
                return defer.promise;
            };

             // self.fetchWhoLikes = function(imgId,ulength,nfId){
             //    var requestData = {
             //        actn: OTYPES.TYPE_LIKES_FOR_IMAGE,
             //        imgId: imgId
             //        //st: this parameter is required for load more.have to set.
             //    };
             //    if(nfId){
             //        requestData.nfId = nfId;
             //    }
             //     if ( ulength > 0 ) {
             //         requestData.st = ulength;
             //     }
             //   return $$connector.pull(requestData, REQTYPE.REQUEST);
             // };

            // self.peopleDetails = function ( utids ) {
            //     var payload = {
            //         actn: OTYPEFRIEND.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS,//OTYPES.FRIENDS.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS,
            //         idList: utids
            //     };
            //     $$connector.send(payload, REQTYPE.REQUEST);
            // };

             self.getFeedImages= function(nfId) {
                var payload = {
                    actn: OPERATION_TYPES.SYSTEM.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS,
                    nfId: nfId
                };
                return $$connector.request(payload, REQTYPE.REQUEST);
             };

        }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.common.imagepopup_controller', [
			'ringid.config',
            //'ringid.ringbox',
            'ringid.common.imagemap_factory'
        ])
        .controller('ImagePopupController',
        ['$routeParams', '$scope', 'Auth', '$$imageMap', '$$stackedMap', 'AlbumFactory','$$connector','OPERATION_TYPES',
    function ImagePopupController($routeParams, $scope, Auth, $$imageMap, $$stackedMap, AlbumFactory,$$connector,OPERATION_TYPES) { // jshint ignore:line

        /***
         *
         * Base Controller,
         * - Can't be used directly,
         * Need to Use With Wrapper Controller  (i.e, ringbox-image-popup.controller, single-image-controller
         *
         *
         */

        var imageList = $$stackedMap.createNew(),
            OTYPES  = OPERATION_TYPES.SYSTEM.IMAGE,
            imageSubscriptionKey,
            commentUpdateSubcriber;

        //$scope.currentUser = Auth.currentUser();
        //$scope.imageComments = [];
        //$scope.boxIsLoading = true;
        $scope.showCommentBox = true;
        $scope.nextImg = false;
        $scope.prevImg = false;

        $scope.changeImage = changeImage;
        $scope.openRingboxLike = openRingboxLike;
        $scope.actionImageDropdown = angular.noop;
        $scope.ddTemplate =
                '<div class="ng-cloak pad-204 action feed-drop_top">' +
                    '<i class="drop-sprite curve-a p-ab top11"></i>' +
                    '<div class="ac-top-line" ng-if="ddControl.showReportButton()">' +
                    '<a class="pad-8-14" rg-report spam-type="{{ddControl.getSpamType()}}" spam-id="ddControl.getSpamId()"><i class="report-ico"></i>Report</a>' +
                    '</div>',
                '</div>';


        function openRingboxLike() {
            return $scope.image && $scope.image.getLikes() > 0;
        }

        function changeImage(direction) {
            // create image from image list
            if (direction === 'next') {
                if($scope.params.popupFrom === 'profile') {
                    // check if reached end of imagelist then call for more images
                    if( !imageList.previous($scope.image.getKey())) {
                        AlbumFactory.loadMoreImage($scope.image.getAlbumId(), $routeParams.uId);
                        //.then(function() {
                            //imageList = AlbumFactory.getAlbums($routeParams.uId).get($scope.image.getAlbumId()).getImages();
                            //$scope.image = imageList.next($scope.image.getKey()) || imageList.bottom();
                            //$scope.$rgDigest();
                        //});
                    } else {
                        $scope.image = imageList.next($scope.image.getKey()) || imageList.bottom();
                    }
                } else {
                    $scope.image = imageList.next($scope.image.getKey()) || imageList.bottom();
                }
            } else {
                $scope.image = imageList.previous($scope.image.getKey()) || imageList.top(); //$$imageMap.create(imageList[changeTo]);
            }
            //_setRotation(); // rotation need to be checked only once upon receiving image list. because now it'll rotate circular if there are more than one image
            // request comments;
            //initImageDetails();
            _preloadImage(direction);
            $scope.$rgDigest();
        }



        // get image list
        function _getImages(nfId) {
            if (nfId) {
                AlbumFactory.getFeedImages(nfId).then(function(response) {
                    if (response.sucs === true) {
                        var imageArray = response.newsFeedList[0].imageList,
                            image;
                        for(var i = 0, lt = imageArray.length; i < lt; i++) {
                            imageArray[i].nfId = response.nfId;
                            if(imageArray[i].imgId === $scope.image.getKey()){
                                $scope.image.updateImage(imageArray[i]);
                                imageList.save($scope.image.getKey(), $scope.image);
                            }else{
                                image = $$imageMap(imageArray[i]);
                                imageList.save(image.getKey(), image);
                            }

                        }
                        _setRotation();
                    }

                });
            } else {
                var albums = AlbumFactory.getAlbums($routeParams.uId);
                imageList = albums.get($scope.image.getAlbumId()).getImages();
                _setRotation();
            }
        }

        function _setRotation() {
            if(imageList.length() > 1) {
                $scope.nextImg = !!imageList.next($scope.image.getKey()) || !!imageList.bottom();
                $scope.prevImg = !!imageList.previous($scope.image.getKey()) || !!imageList.top();
            }
            $scope.$rgDigest();
        }

        function _preloadImage(direction) {
            var img = new Image(),
                imgObj;

            if (direction === 'next') {
                imgObj = imageList.next($scope.image.getKey());
            } else {
                imgObj = imageList.previous($scope.image.getKey());
            }
            setTimeout(function() {
                img.src = imgObj ? imgObj.src() : '';
            }, 200);
        }









        function _activate() {
            commentUpdateSubcriber = $$connector.subscribe(function(message){
                if($scope.image && $scope.image.getKey() === message.imgId){
                    $scope.image.setTotalComment(message.loc);
                    $scope.$rgDigest();
                }

            },{
                action :[OTYPES.TYPE_UPDATE_ADD_IMAGE_COMMENT,OTYPES.TYPE_UPDATE_DELETE_IMAGE_COMMENT]
            });


            imageSubscriptionKey = $$connector.subscribe(function(json) {
                    if (json.sucs === true) {
                        imageList = AlbumFactory.getAlbums($routeParams.uId).get($scope.image.getAlbumId()).getImages();
                        $scope.image = imageList.next($scope.image.getKey()) || imageList.bottom();
                        $scope.$rgDigest();
                    }
                }, {
                action: [
                    OTYPES.TYPE_ALBUM_IMAGES,
                    OTYPES.TYPE_FRIEND_ALBUM_IMAGES
                ]
            });

            if (!!$scope.params.image) { // image popup from profile photos tab
                $scope.image = $scope.params.image;
            } else if (!!$scope.params.imgId) { // image popup from notification dropdown
                    if(!!$scope.remoteData){
                        $scope.image = $scope.remoteData; //imageMap;
                    }else{
                        AlbumFactory.getImageDetails($scope.params.imgId).then(function (imageMap) {
                            $scope.image = imageMap;
                            $scope.$rgDigest();
                        });
                    }
            }

            if ($scope.params.feed) {
                // get list of images for the feed
                $scope.feed = $scope.params.feed;
                _getImages($scope.feed.getKey());
            }

            if ($scope.params.popupFrom === 'profile') { //
                // get album images
                _getImages();
            }

            $scope.$rgDigest();
        }

        _activate();

        $scope.$on('$destroy', function() {
            if(commentUpdateSubcriber){
                $$connector.unsubscribe(commentUpdateSubcriber);
            }
            $$connector.unsubscribe(imageSubscriptionKey);

        });
    }]);


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
            .module('ringid.common.media_controller', [
                'ringid.config',
                //'ringid.ringbox'
            ])
            .controller('MediaController', MediaController);


    MediaController.$inject =
            ['APP_CONSTANTS', 'fileUploadService', '$routeParams', '$scope', 'Auth', 'rgDropdownService', 'Media', '$$connector', 'OPERATION_TYPES', 'Ringalert', 'feedFactory', '$ringbox'];
    function MediaController(APP_CONSTANTS, fileUploadService, $routeParams, $scope, Auth, rgDropdownService, Media, $$connector, OPERATION_TYPES, Ringalert, feedFactory, $ringbox) { // jshint ignore:line

        /***
         *
         * Base Controller,
         * - Can't be used directly,
         * Need to Use With Wrapper Controller  (i.e, ringbox-image-popup.controller, single-image-controller
         *
         */
        var OTYPES = OPERATION_TYPES.SYSTEM.MEDIA,
                AC = APP_CONSTANTS,
                commentUpdateSubcriber;

        $scope.currentUser = Auth.currentUser();
        $scope.showCommentBox = true;


        $scope.changeMedia = changeMedia;
        // $scope.fetchWhoLikes = fetchWhoLikes;
        $scope.actionImageDropdown = angular.noop;
        $scope.ddTemplate =
                '<div class="ng-cloak action pad-204 vp-position">' +
                    '<i class="drop-sprite curve-a p-ab curve-b-ico bottom11"></i>' +
                    '<div class="ac-top-line" ng-if="ddControl.showReportButton()">' +
                        '<a class="pad-8-14" rg-report spam-type="{{ddControl.getSpamType()}}" spam-id="ddControl.getSpamId()"><i class="report-ico"></i>Report</a>' +
                    '</div>'+
                    '<div class="ac-top-line" ng-if="ddControl.showAddToAlbum()">'+
                                '<a class="pad-8-14" rg-ringbox="true" ringbox-controller="RingBoxAlbumlistController" ringbox-animation="true"'+
                                    'ringbox-type="remote" ringbox-target="pages/dropdowns/popup-album-dropdown.html" ringbox-data="ddControl.getRingboxData()"><i class="share-ico"></i>Add to Album</a>'+
                    '</div> '+
                '</div>';

                

        if ($scope.params && $scope.params.popupFrom === 'notification') {
            $scope.media = $scope.remoteData;
            $scope.album = Media.getAlbum($scope.media.getAlbumId());
        } else {
            $scope.media = $scope.params.media;
            //$scope.album = $scope.params.album;
            $scope.playlist = $scope.params.playlist;
        }


        function initMedia() {
            $scope.media.increaseView().then(function() {
                $scope.$rgDigest();
            }, function() {
                $scope.$rgDigest();
            });
        }

        $scope.selectAlbum = selectAlbum;

        function selectAlbum(mediaMap) { // jshint ignore:line
            return {
                    data: function () {
                        return {
                            media: mediaMap,
                            //album: feed.getAlbum(),
                            //playlist: feed.getAlbum().getContents().all(),
                            //feedTime: feed.time()
                        };
                    },
                    //promise: media.fetchDetails() // Media.fetchContentDetails(media, true, media.user())
            };
        }



        function changeMedia(media) {
            $scope.media = media;
            $scope.media.fetchDetails();
            initMedia();
            $scope.$rgDigest();
        }



        // function fetchWhoLikes () {
        //     return {
        //         data: function () {
        //             return {
        //                 target: $scope.media
        //             };
        //         },
        //         promise:  Media.fetchLikeList($scope.media)
        //     };
        // }

        $scope.shareMedia = function() {
                var instance = $ringbox.open({
                    type: 'remote',
                    scope: false,
                    controller: 'feedMediaShareController',
                    scopeData: {
                        media: $scope.media
                    },
                    onBackDropClickClose: true,
                    templateUrl: 'pages/home/share-media.html',
                });
                instance.result.then(function() {
                    $scope.$rgDigest();
                });
        };


        commentUpdateSubcriber = $$connector.subscribe(function(message) {
            if ($scope.media && $scope.media.getKey() === message.cntntId) {
                $scope.media.setTotalComment(message.loc);
            }
        }, {
            action: [
                OTYPES.ACTION_UPDATE_ADD_MEDIA_COMMENT,
                OTYPES.ACTION_UPDATE_DELETE_MEDIA_COMMENT
            ]
        });

        $scope.$on('$destroy', function() {
            if (commentUpdateSubcriber) {
                $$connector.unsubscribe(commentUpdateSubcriber);
            }
        });
    }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
            .module('ringid.common.albumlist_controller', [
                'ringid.config',
                //'ringid.ringbox'
            ])
            .controller('AlbumlistController', AlbumlistController);


    AlbumlistController.$inject = ['APP_CONSTANTS',  '$scope', 'Media', 'Ringalert', 'OPERATION_TYPES', '$$connector', '$ringbox', 'fileUploadService'];
    function AlbumlistController(APP_CONSTANTS, $scope,  Media,  Ringalert, OPERATION_TYPES, $$connector, $ringbox, fileUploadService) { // jshint ignore:line

        var OTYPES = OPERATION_TYPES.SYSTEM.MEDIA,
            albumType,
            AC = APP_CONSTANTS,
            subscriptionKey;

        $scope.selectedAlbum = '';
        $scope.albumName = '';
        $scope.media = $scope.params.media;
        $scope.selectAlbum = selectAlbum;
        $scope.createAlbumPopup = createAlbumPopup;

        if ($scope.media) {
            albumType = ($scope.media.isAudio() ? 'audio' : 'video');
        } else {
            albumType = $scope.params.mediaType;
        }

        $scope.addToAlbum = function() {
            if ($scope.media) {
                $scope.selectedAlbum.addNewContent($scope.media);
            } else {
                fileUploadService.setUploadAlbum($scope.selectedAlbum.getId());
            }
            $scope.close();
        };

        $scope.getAlbums = function() {
            return Media.getAlbums(true, albumType);
        };

        function createAlbumPopup() {
           var boxInstance = $ringbox.open({
                    type : 'remote',
                    resolve : {
                        localData : {
                            mdaT : (albumType === 'audio') ? AC.NEWS_FEED_MEDIA_TYPE_AUDIO : AC.NEWS_FEED_MEDIA_TYPE_VIDEO
                        }
                    },
                    scope:false,
                    controller: 'AlbumCreateController',
                    templateUrl : "pages/popups/create-album-popup.html"
            });

           boxInstance.result.then(function(albumMap){
            if (albumMap) {
                $scope.selectedAlbum = albumMap;
                //$scope.selectedAlbum.addNewContent($scope.media);
                $scope.$rgDigest();
               }
           });
        }



        function selectAlbum(actionObj) { // jshint ignore:line
            switch (actionObj.action) {
                case 'select':
                    if ($scope.selectedAlbum && $scope.selectedAlbum.getKey() === actionObj.albumMap.getKey()) {
                        break;
                    } else {
                        $scope.selectedAlbum = actionObj.albumMap;
                        //$scope.selectedAlbum.addNewContent($scope.media);
                    }
                    break;
                //case 'toggleCreate':
                    //$scope.createAlbum = !$scope.createAlbum;
                    //break;
            }
            $scope.$rgDigest();
        }


        function activate() {
            Media.init();
            subscriptionKey = $$connector.subscribe(function() {
                setTimeout(function() {
                    $scope.$rgDigest();
                }, 500);

            }, {
                action:  [
                    OTYPES.ACTION_MEDIA_ALBUM_LIST
                ]
            });
        }

        activate();

        $scope.$on('$destroy', function() {
            $$connector.unsubscribe(subscriptionKey);
        });


    }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
            .module('ringid.common.albumcreate_controller', [
                'ringid.config',
                //'ringid.ringbox'
            ])
            .controller('AlbumCreateController', AlbumCreateController);


    AlbumCreateController.$inject = ['$scope', 'Media', 'APP_CONSTANTS', '$boxInstance', 'localData'];
    function AlbumCreateController($scope,  Media, APP_CONSTANTS, $boxInstance, localData) { // jshint ignore:line

        $scope.albumName = '';
        $scope.createAlbum = function() {
            if ($scope.albumName.length > 0) {
                Media.createAlbum({
                    albn: $scope.albumName,
                    mdaT: localData.mdaT
                }, true).then(function(albumMap) {
                    if (albumMap) {
                        $boxInstance.close(albumMap);
                    }
                });
            }
        };


    }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.common.ringbox_imagepopup_controller', [
            'ringid.common.imagepopup_controller'
        ])
        .controller('RingBoxImagePopupController', RingBoxImagePopupController);


    RingBoxImagePopupController.$inject = [ '$scope', '$boxInstance', '$controller', 'localData', 'remoteData', 'feedFactory'];
    function RingBoxImagePopupController($scope, $boxInstance, $controller, localData, remoteData, feedFactory) { // jshint ignore:line
        /****
         *
         * Extends Basic Image Popup controller to use in Ringbox
         *
         *
         */



        $scope.close = $boxInstance.close;

        if (localData && localData.imgId) {
            $scope.templateType = localData.templateType;
        }
        $scope.params = localData;
        $scope.remoteData = remoteData;
         if(localData.noti && localData.noti.getCommentId() > 0){
            $scope.activeCommentId = localData.noti.getCommentId();
        }

        $controller('ImagePopupController', {$scope: $scope} );

        //////////////////////////////////

        //----------- Public --------------

    }


})();



/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.common.ringbox_media_controller', [
            'ringid.common.media_controller'
        ])
        .controller('RingBoxMediaController', RingBoxMediaController);


    RingBoxMediaController.$inject = [ '$scope', '$boxInstance', '$controller', 'localData', 'remoteData', 'Media'];
    function RingBoxMediaController($scope, $boxInstance, $controller, localData, remoteData, Media) {
        /****
         *
         * Extends Basic Image Popup controller to use in Ringbox
         *
         *
         */

        $scope.close = close;
        if (localData && localData.mediaId) {
            $scope.templateType = localData.templateType;
        }
        //var noti = notificationFactory.getNotification(localData.notiKey||0);
        $scope.params = localData;
        $scope.remoteData = remoteData;



        $controller('MediaController', {$scope: $scope} );
        //////////////////////////////////

        //----------- Public --------------
        $scope.destroyPlayer = angular.noop;
        function close() {
            $scope.destroyPlayer();
            $boxInstance.close();
        }

    }


})();



/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.common.ringbox_albumlist_controller', [
            'ringid.common.albumlist_controller'
        ])
        .controller('RingBoxAlbumlistController', RingBoxAlbumlistController);


    RingBoxAlbumlistController.$inject = [ '$scope', '$boxInstance', '$controller', 'localData'];
    function RingBoxAlbumlistController($scope, $boxInstance, $controller, localData) {
        /****
         *
         * Extends Basic Album List controller to use in Ringbox
         *
         *
         */

        $scope.close = $boxInstance.close;

        $scope.params = localData;

        $controller('AlbumlistController', {$scope: $scope} );
        //////////////////////////////////


    }


})();



/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.common.ringbox_confirm_controller', [])
        .controller('RingBoxConfirmController', RingBoxConfirmController);


    RingBoxConfirmController.$inject = [ '$scope', '$boxInstance', 'localData'];
    function RingBoxConfirmController($scope, $boxInstance, localData) {

        $scope.close = close;
        $scope.params = localData;

        function close(confirmed) {
            $boxInstance.close(confirmed);
        }

    }


})();



/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.singleimage_controller', [
            'ringid.common.imagepopup_controller'
        ])
        .controller('SingleImageController', SingleImageController);


    SingleImageController.$inject = ['$scope', '$routeParams', '$controller', 'Auth' ];

    function SingleImageController($scope, $routeParams, $controller, Auth) {
        /****
         *
         * Extends Basic Image Popup controller to ReUse the functionality
         *
         *
         *
         */

        $scope.params  = {};
        $scope.params.imgId = $routeParams.imageId;

        $scope.isReady = false;

        $scope.currentUser = Auth.currentUser();

        $controller('ImagePopupController', {$scope: $scope});
        $scope.showCommentBox = true;

    }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.all_suggestions_controller', [])
        .controller('allSuggestionController', allSuggestionController);

    allSuggestionController.$inject = [ '$scope', '$boxInstance', 'localData', 'friendsFactory','InviteFactory','OPERATION_TYPES','$$connector','rgScrollbarService' ];
    function allSuggestionController( $scope, $boxInstance, localData, friendsFactory,InviteFactory,OPERATION_TYPES,$$connector,rgScrollbarService ) { // jshint ignore:line

        $scope.users = [];
        var OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS;
        $scope.state = InviteFactory.state;
        $boxInstance.opened.then(function () {

            $scope.users = localData.target.all();
            $scope.$rgDigest();

        });
        var totalFriend = localData.target.length();

        $scope.$watch('state.isRequestsLoading', function (n,o) {
            $scope.$rgDigest();
        });

        $scope.contactListAction = function(actionObj) {
            if (!actionObj.friend.isLoading()) {
                friendsFactory.friendAction(actionObj,true).then(function() {
                    $scope.$rgDigest();
                }, function() {
                    $scope.$rgDigest();
                });
                $scope.$rgDigest();
            }
        };

        $scope.loadmorefriend = function() {
            InviteFactory.getSuggestionContactsDetails(5);
            $scope.$rgDigest();
        };

        $scope.getMutualFriend = function(user) {

            return{
                data: function() {
                    return {
                        target: user
                    };
                },
                promise: InviteFactory.getMutualFriend(user)
            };
        };

        var subscriptionKey = $$connector.subscribe(processPeople, {action: [
                OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS
            ]
        });

        function processPeople(data){
            if(data){
                if(InviteFactory.noOfSuggestions() > totalFriend){
                    rgScrollbarService.recalculate($scope);
                    $scope.$rgDigest();
                }
                totalFriend = InviteFactory.noOfSuggestions();
            }
        }

        $scope.$on('$destroy', function() {
            $$connector.unsubscribe(subscriptionKey);
        });
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.mutualfriends_controller', [])
        .controller('mutualFriendsController', mutualFriendsController);

    mutualFriendsController.$inject = [ '$scope','remoteData', 'friendsFactory','userFactory','InviteFactory','rgScrollbarService' ];
    function mutualFriendsController( $scope,remoteData, friendsFactory,userFactory,InviteFactory,rgScrollbarService ) { // jshint ignore:line

        var mutualIds = remoteData.mfIDs;
        $scope.mutualfriends = [];
        $scope.state = InviteFactory.state;

        friendsFactory.getContactDetailsByUtIds(mutualIds).then(function(data){
            $scope.mutualfriends = [];
            if(data.sucs===true){
                for(var i=0; i<data.contacts.length; i++){
                    $scope.mutualfriends.push(userFactory.create(data.contacts[i]));
                }
                $scope.$rgDigest();
            }
            rgScrollbarService.recalculate($scope);
            $scope.$rgDigest();
        });

        $scope.getMutualFriend = function(user) {

            return{
                data: function() {
                    return {
                        target: user
                    };
                },
                promise: InviteFactory.getMutualFriend(user)
            };
        };

        // MUTUAL FRIENDS MEAN USER AND THEY ARE ALREADY FRIENDS NO NEED OF friendsAction
        //$scope.contactListAction = function(actionObj) {
             //if (!actionObj.friend.isLoading()) {
                 //friendsFactory.friendAction(actionObj, true).then(function() {
                     //$scope.$rgDigest();
                 //}, function() {
                     //$scope.$rgDigest();
                 //});
                //$scope.$rgDigest();
             //}
        //};

    }

})();

(function() {
  'use strict';
  angular
    .module('ringid.common.header_controller', [
        'ringid.auth',
        'ringid.media',
        'ringid.friend.friends_factory',
        //'ringid.common.rgscrollbar_directive',
        'ringid.notification',
        'ringid.profile',
        'ringid.config'
    ])
    .controller('HeaderController', HeaderController);

    HeaderController.$inject = ['$scope', '$rootScope', '$location','rgDropdownService', '$$connector', 'OPERATION_TYPES',
        'friendsFactory', 'NotificationFactory', 'Auth',   'rgScrollbarService', 'ChatFactory','utilsFactory','SystemEvents', 'chatHistoryFactory'];
    function HeaderController( $scope, $rootScope, $location, rgDropdownService,  $$connector, OPERATION_TYPES,  // jshint ignore:line
                              friendsFactory, NotificationFactory, Auth, rgScrollbarService, ChatFactory, utilsFactory,SystemEvents, chatHistoryFactory) {
      var vm = this,
          OTYPES = OPERATION_TYPES.SYSTEM,
        active_menu = setActiveMenu();
        vm.getActiveMenu = getActiveMenu;


      /****************************
        LOGOUT Dropdown section
       */
      vm.logout = {
        ddHtml: 'pages/dropdowns/logout-dropdown.html', //$templateCache.get('logout-dropdown.html'),
        ddControl: Auth,
        ddAction: function() {
            rgDropdownService.close();
            Auth.logout();
        },
        ddOpened: function() {
          setActiveMenu('logout');
        },
        ddBeforeClose: function(){
          setActiveMenu('');
        }
      };
      /*****************************
         END LOGOUT Dropdown section
       */



      /********************************
        FRIEND REQUEST Dropdown section
       */
      vm.freq = {
        //ddHtml:'pages/partials/requests-directive.html', // $templateCache.get('friend-request-dropdown.html'),
        ddTemplate:'<rg-requests load-on-scroll="true" load-count="10" ></rg-requests>',
        ddOpened: function() {
          setActiveMenu('friend_request');
        },
        ddBeforeClose: function(){
          setActiveMenu('');
        }
      };


      vm.requestCount = friendsFactory.getRequestCount;
      /*****************************
        END FRIEND REQUEST Dropdown section
       */


        /********************************
         Chat History  Dropdown section
         */
        vm.chatHistory = {
            ddHtml:'pages/partials/chat/chat-history-dropdown.html', // $templateCache.get('friend-request-dropdown.html'),
            ddOpened: function() {
                setActiveMenu('chat_history');
                chatHistoryFactory.resetConversationCount();
                $scope.$rgDigest();
            },
            ddBeforeClose: function(){
                setActiveMenu('');
            }
        };


        vm.unreadChatConversationCount = chatHistoryFactory.getUnreadConversationCount;

        utilsFactory.onCustomEvent(SystemEvents.CHAT.UNREAD_MESSAGE_INFO_UPDATED, function(){
            $scope.$rgDigest();
        });


        /*****************************
         Chat History REQUEST Dropdown section
         */



      /*****************************
         NOTIFICATION Dropdown section
       */

        vm.noti = {
            //ddHtml: 'pages/partials/notification-directive.html',
            ddTemplate: '<rg-notification load-count="10" template-url="pages/dropdowns/notification-dropdown.html"></rg-notification>',
            //ddTemplate: '<rg-notification ></rg-notification>',
            ddOpened: function() {
              setActiveMenu('notification');
              NotificationFactory.clearCounter();
            },
            ddBeforeClose: function(){
              setActiveMenu('');
            }
        };

        vm.notiCount = NotificationFactory.getNotiCount;
        var subscriptionKey = $$connector.subscribe(function() {
            setTimeout(function() {
                $scope.$rgDigest();
            }, 200);

        }, {
            action: [
                OTYPES.FRIENDS.TYPE_ACCEPT_FRIEND,
                OTYPES.FRIENDS.TYPE_UPDATE_ADD_FRIEND,
                OTYPES.FRIENDS.TYPE_UPDATE_DELETE_FRIEND,
                OTYPES.FRIENDS.TYPE_DELETE_FRIEND,
                OTYPES.NOTIFICATION.TYPE_MY_NOTIFICATIONS,
                OTYPES.NOTIFICATION.TYPE_SINGLE_NOTIFICATION
            ]
        });

      /*****************************
         END NOTIFICATION Dropdown section
       */
       $scope.hideColumn = false;

       function setHideColumn(){
          var loc = $location.path();
          if(loc === "/"){
            $scope.hideColumn = false;
          }/*else if(/\/circle\/\d+(\/post|$)/.test(loc)){
            $scope.hideColumn = true;
          }else if(/\/profile\/\d+(\/post|$)/.test(loc)){
            $scope.hideColumn = true;
          }*/else{
            $scope.hideColumn = true;
          }
       }

         $rootScope.$on('$routeChangeStart', function(e) {
               setHideColumn();
          });
      setHideColumn();
      function setActiveMenu(name){
        if( name && name !== ''){
          active_menu = name;
        }else if( $location.path() === '/'){
          active_menu = 'home';
        }else{
          active_menu = 'none';
        }
        $scope.$rgDigest();
      }


      function getActiveMenu(){
        return active_menu;
      }

      vm.defaultSpan = utilsFactory.getDefaultColumn;

      $rootScope.$on('$routeChangeStart', function() {
        setActiveMenu();
        $$connector.unsubscribe(subscriptionKey);
      });
      $scope.$on(SystemEvents.COMMON.WINDOW_RESIZED,function(){
          $scope.$rgDigest();
      });


    }

}(angular));

/**
 *
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.menu_controller', [
            'ringid.circle',
            //'ringid.ringbox',
            'ringid.friend.friends_factory',
            //'ringid.common.rgscrollbar_directive'
        ])
        .controller('MenuController', MenuController);

        MenuController.$inject = ['$scope','$location', 'circlesManager', 'rgScrollbarService', '$$connector','circleHttpService', 'OPERATION_TYPES', '$timeout'];
        function MenuController($scope,$location, circlesManager, rgScrollbarService, $$connector,circleHttpService, OPERATION_TYPES, $timeout) { // jshint ignore:line

            var OTYPES = OPERATION_TYPES.SYSTEM.CIRCLE;

            var vm = this,
                subkey,
                circleUpdateSubscribeKey;


            function gotCircleData() {
                //setTimeout(function() {
                    $scope.$rgDigest();
                //},200);
            }

            // initialize
            subkey = $$connector.subscribe( gotCircleData,
                { action:OTYPES.TYPE_GROUP_LIST }
            );

            circleUpdateSubscribeKey = $$connector.subscribe( gotCircleData,{
                filter : circlesManager.circleUpdateFilter
            });


            //vm.ddHtml = 'pages/dropdowns/circle-list-dropdown.html'; // IMPORTANT this template is preloaded
            //vm.ddControl = {
                //getCircles: getCircles
            //};
            //vm.ddAction = vm.toggleRingCircle;
            //vm.ddAction = getCircles;

            function getCircles(own) {
                if (own === 'true' || own === true) {
                    return circlesManager.getCircles(true);
                } else {
                    return circlesManager.getCircles(false);
                }
            }

            $scope.initCircles = function initCircles() {
                circlesManager.init();
                return {
                    data: function () {
                        return {};
                    }
                };
            }

            $scope.isCurrentPath = function (path,contain) {
                return contain ?$location.path().indexOf(path) > -1 : $location.path() == path;
            };

            var mycircles   = circlesManager.getCircles('true').all();
            var circlesofme = circlesManager.getCircles().all();

            //var totalCircles = mycircles.concat(circlesofme);
            //
            //console.log(mycircles);
            //console.log(circlesofme);
            //console.log(totalCircles);

            //$scope.getAllCircleList = function(){
                //return{
                    //data: function() {
                        //return {
                            //target: mycircles.concat(circlesofme)//circlesManager.getCircles('true')===>have to implement if param is 'true'
                        //};
                    //}
                //};
            //};

            $scope.$on('$destroy',function(){
                $$connector.unsubscribe(subkey);
                $$connector.unsubscribe(circleUpdateSubscribeKey);
            });

        }
})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.controllers', [
            'ringid.common.header_controller',
            'ringid.common.menu_controller',
            'ringid.common.mutualfriends_controller',
            'ringid.common.all_suggestions_controller',
           // 'ringid.common.fetch_like_controller',
            'ringid.common.imagepopup_controller',
            'ringid.common.media_controller',
            'ringid.common.albumlist_controller',
            'ringid.common.albumcreate_controller',
            'ringid.common.ringbox_confirm_controller',
            'ringid.common.ringbox_imagepopup_controller',
            'ringid.common.ringbox_media_controller',
            'ringid.common.ringbox_albumlist_controller',
            'ringid.common.singleimage_controller',
            //'ringid.common.incoming_request_controller',
            //'ringid.common.all_notification_controller'
        ]);
})();


/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.filters', ['ringid.config'])
		.filter('validProfileImage', validProfileImage)
		.filter('friendListFilter', friendListFilter) // filter by a regex
		.filter('mapListFilter', mapListFilter) // filter friend map list by another user map list
		.filter('stackMapFilter', stackMapFilter)
		.filter('ymdDateFilter', ymdDateFilter)
		.filter('mediaFilter', mediaFilter)
		.filter('mapFilter', mapFilter)
		.filter('objectFilter', objectFilter);

		validProfileImage.$inject = ['settings'];
		function validProfileImage (settings) {
			return function(item) {
				return item.indexOf('prof.png') > 0 ? item : settings.imBase + item;
			};
		}

		function stackMapFilter() {
			return function(items, filterItems) {
				if (items) {
					for (var i = 0; i < items.length; i++) {
						if (filterItems.get(items[i].key)) {
							console.log('got a matching item:' + items[i].key);
						}
					}
					return items;
				}
			};
		}

        friendListFilter.$inject = ['APP_CONSTANTS'];
		function friendListFilter(APP_CONSTANTS) {
			return function(items, obj) {
				if (items) {
					var filtered = [];
                    //var nameMatch = new RegExp(obj.name, 'ig');
                    var nameMatch = obj.name.toLowerCase();
					for (var i = 0; i < items.length; i++) {
                        if(obj.showMutual && items[i].value.friendshipStatus() !== APP_CONSTANTS.FRIEND) {
                            continue;
                        }
                        //if ( nameMatch.test(items[i].value.getName())) {
                        if (nameMatch.length === 0 || items[i].value.getName().toLowerCase().indexOf(nameMatch) > -1) {
                            filtered.push(items[i]);
                        }
					}
					return filtered;
				}
			};
		}


		function mapListFilter() {
			return function(items, filterList) {
				if (items) {
					var filtered = [];
					for(var i = 0; i < items.length; i++) {
						if( ! filterList.get( items[i].value.getKey() ) ) {
							filtered.push(items[i]);
						}
					}
					return filtered;
				}
			};

		}

		function ymdDateFilter() {
			return function(date) {
				var d = new Date(date),
					month = '' + (d.getMonth() + 1),
					day = '' + d.getDate(),
					year = d.getFullYear();

				if (month.length < 2) {
                    month = '0' + month;
                }
				if (day.length < 2) {
                    day = '0' + day;
                }

				return [year, month, day].join('-');
			};
		}


		function mediaFilter() {
			return function(items, mediaType) {
				if (items) {
					var filtered = [];
					for(var i = 0; i < items.length; i++) {
						if( items[i].value.getType() === mediaType ) {
							filtered.push(items[i]);
						}
					}
					return filtered;
				}
			};

		}

        // generic Map Filter
		function mapFilter() {
			return function(items, obj) {
				if (items) {
					var filtered = [],
						nameToMatch = obj.value ? obj.value.toLowerCase(): '';
						//regEx;
					for(var i = 0; i < items.length; i++) {

						//nameMatch = items[i].value[obj.mapApi]().toLowerCase();
						//if ( nameMatch.test(items[i].value.getName())) {
						if (items[i].value[obj.mapApi]().toLowerCase().indexOf(nameToMatch) > -1) {
							filtered.push(items[i]);
						}

						//if(obj.hasOwnProperty('compare') && obj.compare === 'regex') {
					     //   regEx = new RegExp(obj.value || '', 'ig');
                         //   if (regEx.test( items[i].value[obj.mapApi]() )) {
						//	    filtered.push(items[i]);
                         //   }
                        //
						//} else if (items[i].value[obj.mapApi]() === obj.value) { // default is just plain equal compare
						//	filtered.push(items[i]);
						//}
					}
					return filtered;
				}
			};

		}


        function objectFilter() {
            function compareString(compareTo, compareThis) {
                return compareTo.indexOf(compareThis) > -1;
            }

            function compareDefault(compareTo, compareThis) {
                return compareThis === compareTo;
            }

            return function(items, obj) {
                var compareFunc, filtered = [];
                if (items && items.length > 0) {
                    switch(obj.compare) {
                        case 'string':
                            compareFunc = compareString;
                            break;
                        default:
                            compareFunc = compareDefault;
                    }

                    for(var i = 0; i < items.length; i++) {
                        if (compareFunc(items[i][obj.prop], obj.value)) {
                            filtered.push(items[i]);
                        }
                    }
                    return filtered;
                }
            };
        }
})();

(function () {
    "use strict";
    angular
            .module('ringid.common.contacts_factory', [
                'ringid.config',
                //'ringid.common.stacked_map'
            ])
            .factory('Contacts', ContactsFactory);

            ContactsFactory.$inject = ['settings','$$stackedMap', 'utilsFactory', 'Storage'];
            function ContactsFactory(settings, $$stackedMap,  utilsFactory, Storage) {
                var utIdMap = {
                        utIds:  $$stackedMap.createNew(),
                        incomingUtIds: $$stackedMap.createNew(),
                        outgoingUtIds: $$stackedMap.createNew()
                    },
                    removedUtIds = $$stackedMap.createNew();
                    //tempUtIds = $$stackedMap.createNew();

                //function syncStorage(utidType, utid, frnsObj, addNew) {
                        //tempUtIds.setStack(Storage.getData(utidType)); // set from localStorage
                        //if(addNew) {
                            //tempUtIds.save(utid, frnsObj); // modify data
                        //} else {
                            //tempUtIds.remove(utid); // modify data
                        //}

                        //Storage.setData(utidType, tempUtIds.all()); // save changes to localstorage
                        //tempUtIds.reset(); // reset temp variable
                //}

                return {
                    init: function() {
                        //tempUtIds.setStack([]);
                        // all time fresh utid list is taken from server and shown to user
                        //utIdMap.utIds.setStack(Storage.getData('utIds') || []);
                        //utIdMap.incomingUtIds.setStack(Storage.getData('incomingUtIds') || []);
                        //utIdMap.outgoingUtIds.setStack(Storage.getData('outgoingUtIds') || []);
                    },
                    initStorage: function() {
                        //Storage.setData('utIds', utIdMap.utIds.all() );
                        //Storage.setData('incomingUtIds', utIdMap.incomingUtIds.all() );
                        //Storage.setData('outgoingUtIds', utIdMap.outgoingUtIds.all() );
                    },
                    utIds : function() {
                        return utIdMap.utIds; // all friends
                    },
                    outgoingUtIds : function() {
                        return utIdMap.outgoingUtIds; // all friends
                    },
                    incomingUtIds :function() {
                        return utIdMap.incomingUtIds; // all friends
                    },
                    remove: function(utidType, utid) {
                        //syncStorage(utidType, utid);
                        removedUtIds.save(utid, utIdMap[utidType].get(utid));
                        return utIdMap[utidType].remove(utid);
                    },
                    add: function(utidType, utid, frnsObj) {
                        //syncStorage(utidType, utid, frnsObj, true);
                        utIdMap[utidType].save(utid, frnsObj);
                    },
                    getFrns: function(utId) {
                        return utIdMap.utIds.get(utId) ||
                               utIdMap.incomingUtIds.get(utId) ||
                               utIdMap.outgoingUtIds.get(utId) ||
                               removedUtIds.get(utId) ||
                               {frnS: 0};
                    }
                };
            }

})();

(function () {
    "use strict";
    angular
            .module('ringid.common.user_factory', [
                'ringid.config',
                //'ringid.common.stacked_map',
                'ringid.common.contacts_factory'
            ]).factory('$$userMap', ['profileHttpService', 'settings','$$stackedMap','$filter',  'utilsFactory', 'Storage', 'Contacts','$$q',
                function (profileHttpService, settings, $$stackedMap,$filter,   utilsFactory, Storage, Contacts,$q) {
                    var DEVICES = {
                        0 : 'p',
                        1 : 'desktop',
                        2 : 'android',
                        3 : 'iphone',
                        4 : 'windows',
                        5 :  'web'
                    };
                    var user_defaults = {
                                fn: "",
                                uId: 0,
                                cnty: "",
                                el: "",
                                gr: "",
                                am: "",
                                mblDc: "",
                                mbl:"",
                                prIm: "images/prof.png",
                                cIm : "images/default_cover.jpg",
                                prImId: 0,
                                cImId: 0,
                                cimX: 0,
                                cimY: 0,
                                bDay: "",
                                blc: 0, // block maybe
                                re: '',
                                utId: 0,
                                tf: 0,
                                nmf: 0, // no of common friends
                                // access parameters
                                chta: 0,
                                cla: 0,
                                fda: 0,
                                cc:"",
                                hc:"",
                                adt: 0, // added time

                                iev:0,//is email verified
                                imnv:0,//is mobile num verified

                                // presence detail
                                psnc: 0, // 1=online, 2=offline, 3=away, 4=do not disturb
                                lot: 0,
                                mood: 0, // 1=alive, 2=do not disturb, 3=busy, 4=invisible
                                apt : 0,
                                dt : "",

                             //   groups: {}, // groups memberships info
                                frnS: 0,
                                ct: 0,
                                nct: 0,
                                pimX: 0,
                                pimY: 0,
                                bv: 0,
                                owner: 0,
                                basicInfo: false,
                                privacyInfo: {}
                            };

                    function RingUser(obj, isProfile, isCurrent,withMfc){
                            this.groups = {};
                            this.updateUserObj(obj);
                            this.isCurrent = isCurrent;
                            this.isProfile = isProfile;
                            this.requestedMutualFriend = false;
                            this.loading = false;
                            this.user.psnc = this.isCurrent ? 2 : this.user.psnc;
                            this.user.dvc =  this.isCurrent ? 5 : this.user.dvc;
                            //if group information present store it
                            if ( obj.hasOwnProperty('grpId') ) {
                                this.groups[obj.grpId] = obj.admin;
                            }
                            obj = null;
                            if(!this.user.prIm || !this.user.uId || !this.user.utId || (!this.user.nmf && withMfc)){
                                this.requestUserDetails(!!withMfc);
                            }
                    }

                    RingUser.prototype = {
                                updateUserObj : function(userObj) {
                                    var userObj = userObj || {};

                                    if(this.user){
                                        angular.extend(this.user, userObj);
                                    }else{
                                        this.user = angular.extend({},user_defaults, userObj);
                                    }
                                    //console.log('info: '+user.gr);
                                    // update group info
                                    if(userObj.grpId) {
                                        this.groups[userObj.grpId] = userObj.admin;
                                    }

                                    // if prIm and cIm is empty string set them to default
                                    if (this.user.prIm === '') {
                                        this.user.prIm =   "images/prof.png";
                                    }
                                    if (this.user.cIm ===  '') {
                                        this.user.cIm = "images/default_cover.jpg";
                                    }

                                    if( this.user.frnS === 0) {
                                        this.user.frnS = Contacts.getFrns(this.user.utId).frnS || this.user.frnS;
                                    }
                                    if(userObj.mfc){
                                        this.user.nmf = userObj.mfc;
                                    }
                                    if(userObj.mutualFriends){
                                        this.user.nmf = userObj.mutualFriends;
                                    }
                                    userObj = null;
                                },
                                requestUserDetails : function (mfc){//mutual Friend count
                                        var reqData = {},that=this,promise;
                                        if(this.user.utId){
                                            reqData.utId = this.user.utId;
                                        }
                                        else if(this.user.uId){
                                            reqData.uId = this.user.uId;
                                        }
                                        if(reqData.utId || reqData.uId){
                                            if(mfc){
                                                this.requestedMutualFriend = true;
                                            }
                                            promise = profileHttpService.getUserDetails(reqData,!!mfc);
                                            promise.then(function(json){
                                                if(json.sucs){
                                                    that.updateUserObj(json.userDetails);
                                                }

                                            });
                                            return promise;
                                        }
                                    },
                                getName: function () {
                                    return this.user.fn;
                                },
                                avatar:  function (size){
                                        var imageLink = this.user.prIm || "";
                                        if (size === 'iurl') {
                                            return imageLink;
                                        }

                                        if (size === 'original') {
                                            return settings.imBase + imageLink;
                                        }

                                        // default image
                                        if (imageLink.indexOf('prof.png') > 0) {
                                            return imageLink;
                                        }

                                        imageLink =  imageLink.replace('profileimages/','');
                                        if(size === 'original') {
                                            size = '';
                                        } else if(!size){
                                          size = 'crp';
                                        }
                                        // add progressive prefix
                                        size = (/\/uploaded\//.test(imageLink) ? '': 'p') + size;

                                        var position = imageLink.lastIndexOf('/') + 1;
                                        imageLink = [settings.imBase, imageLink.slice(0, position), size,  imageLink.slice(position)].join('');

                                        return imageLink.indexOf('prof.png') > 0 ? this.user.prIm : imageLink ;
                                },
                                getKey: function () {
                                    return this.user.uId || this.user.utId;
                                },
                                getUId : function(){
                                    return this.user.uId;
                                },
                                setUid : function(uid){
                                    this.user.uId = uid;
                                },
                                getUtId: function () {
                                    return +this.user.utId;
                                },
                                equals: function(u,check){// id or instance of
                                    // for match utId sent utId else sent uId or sent nothing
                                    if (!check){
                                        check = 'uId';
                                    }
                                    if(angular.isObject(u)){
                                        u = (check === 'uId') ? u.getKey() : u.getUtId();
                                    }
                                    return this.user[check] === u;
                                },
                                link: function () {

                                    //if( !!this.user.uId || !!this.user.utId ){
                                    if (!!this.user.uId || this.user.ct !== 3) {
                                        //return settings.baseUrl + utilsFactory.getRingRoute('USER_PROFILE', { uId : user.uId, utId : user.utId }) + (user.frnS !== 1 && !user.isCurrent) ? '/about' : '';
                                        return settings.baseUrl + utilsFactory.getRingRoute('USER_PROFILE', { uId : this.user.uId, utId : this.user.utId }) + ((this.user.frnS !== 1 && !this.isCurrent) ? '/about' : '');
                                    }else{
                                        return '';
                                    }
                                },
                                getRingNumber: function () {
                                   return  (this.user.uId.replace(/(\d{2})(\d{4})(\d+?)/,"$2 $3"));
                                   //return user.uId.substring(2);
                                },
                               navActiveLink: function () {

                                   if( !!this.user.uId || !!this.user.utId ){
                                       var url = '/profile/'+this.user.uId+'/post';
                                       return  url;
                                   }else{
                                       return '';
                                   }
                               },
                                toString : function(){
                                    return this.user.uId;
                                },

                                friendshipStatus: function () {
                                    if (this.user.frnS === 0) {
                                        return Contacts.getFrns(this.user.utId).frnS || this.user.frnS;
                                    } else {
                                        return this.user.frnS; // 0=not friend, 1=accepted friend, 2=incoming friend request, 3=outgoing friend request
                                    }
                                },
                                isLoading: function(bool) {
                                    if (typeof bool === 'undefined') {
                                        return this.user.loading;
                                    } else {
                                        this.user.loading = bool;
                                        return this.user.loading;
                                    }
                                },
                                commonFriends: function (force,returnPromise) {
                                    var promise;
                                    if((!this.user.nmf && !this.requestedMutualFriend) || force){
                                        promise = this.requestUserDetails(true);
                                    }
                                    return returnPromise ? (promise || $q.when(this.user.nmf)) : this.user.nmf;
                                },
                                isCurrentUser: function () {
                                   return this.isCurrent;
                                },
                                sortBy: function() {
                                    //return user.fn.toLowerCase();
                                    return this.user.adt;
                                },
                                getLiteUser : function(){
                                    return this;
                                },
                                isAdmin: function(grpId) { // check if user admin of a group
                                    if(this.groups.hasOwnProperty(grpId)) {
                                        return this.groups[grpId];
                                    } else {
                                        return false;
                                    }
                                },
                                setGroupAdmin : function(groupId){
                                    this.groups[groupId]=true;
                                },
                                removeGroupAdmin : function(groupId){
                                    delete this.groups[groupId];
                                },
                                overwriteInfo : function(ob){
                                    this.user.prIm = ob.prIm || this.user.prIm;
                                },
                                haveProfileData: function() {
                                    return this.isProfile;
                                },
                                getBasicInfo: function() {

                                    var frTime = utilsFactory.profileVerbalDate(this.user.bDay);
                                    var mTime = utilsFactory.profileVerbalDate(this.user.mDay);

                                    return {
                                        fn: this.user.fn || '',
                                        birthDay: this.user.bDay || '',
                                        mDay: this.user.mDay || '',
                                        birthday: frTime,
                                        marriageDay: mTime,
                                        el: this.user.el || '',
                                        hc: this.user.hc.trim() || '',
                                        cc: this.user.cc.trim() || '',
                                        gr: this.user.gr || '',
                                        am: this.user.am.trim() || '',
                                        uId: this.user.uId.toString().substring(2) || ''
                                    };
                                },
                                setBasicInfo: function(basicInfoObj) {
                                   // console.log(basicInfoObj);
                                   //return setProfileInfo(basicInfoObj);
                                },
                                resetCover: function() {
                                    this.user.cIm = "images/default_cover.jpg";
                                },
                                getCover: function(size) {
                                    var cIm = this.user.cIm,
                                        prefix,
                                        position;

                                    if (size === 'iurl') {
                                        return cIm;
                                    }

                                    if (size && size === 'original') {
                                        return settings.imBase + cIm;
                                            //prefix = (/\/uploaded\//.test(cIm) ? '': 'p');
                                            //position = cIm.lastIndexOf('/') + 1;
                                            //cIm = [settings.imBase, cIm.slice(0, position), prefix,  cIm.slice(position)].join('');
                                        //return cIm;
                                    }

                                    if (cIm) {
                                        if(cIm.indexOf('default') > 0){
                                            return cIm;
                                        }
                                        else if (cIm.indexOf('web') > 0) {
                                            return settings.imBase + cIm;
                                        } else {

                                            prefix = (/\/uploaded\//.test(cIm) ? '': 'p') + (size || 'crp') ;
                                            position = cIm.lastIndexOf('/') + 1;
                                            cIm = [settings.imBase, cIm.slice(0, position), prefix,  cIm.slice(position)].join('');
                                            return cIm;
                                        }
                                    } else {
                                        return "images/default_cover.jpg";
                                    }
                                },
                                getCoverXY: function() {
                                    return {x:this.user.cimX, y:this.user.cimY};
                                },
                                setCover: function(obj) {
                                    this.user.cIm = obj.iurl;
                                    this.user.cimX = obj.cimX;
                                    this.user.cimY = obj.cimY;
                                    this.user.cImId = obj.cImId;
                                },
                                getAvatarXY: function() {
                                    return {x:this.user.pimX, y:this.user.pimY};
                                },
                                setProfileImage: function (prImg, prImId) {
                                    this.user.prIm = prImg;
                                    this.user.prImId = prImId;
                                },
                                setName: function (fn) {
                                    this.user.fn = fn;
                                },
                                setAboutMe: function (am) {
                                    this.user.am = am;
                                },
                                setHomeCity: function (hc) {
                                    this.user.hc = hc;
                                },
                                setCurrentCity: function (cc) {
                                    this.user.cc = cc;
                                },
                                setGender: function (gr) {
                                    this.user.gr=gr;
                                },
                                setBirthday: function(bd) {
                                   this.user.bDay=bd;
                                },
                                setMarriageday: function(md) {
                                   this.user.mDay=md;
                                },
                                getEmail: function(){
                                  return this.user.el;
                                },
                                getMobileDc:function(){
                                    return this.user.mblDc;
                                },
                                getMobileNumber: function() {
                                    return this.user.mbl;
                                },
                                getCountry: function () {
                                    return this.user.cnty;
                                },
                                friendType: function () {
                                    return this.user.ct; // 0=not friend, 1=call&chat, 2=fullprofile, 3= special friend
                                },
                                setFriendType: function(ct) {
                                    this.user.ct = ct;
                                },
                                newFriendType: function () {
                                    return this.user.nct; // 0=not friend, 1=call&chat, 2=fullprofile
                                },

                                getLink : function(attrs){
                                    var attrsStr ="";
                                    if(!!attrs){
                                        for(var key in attrs){
                                            if (attrs.hasOwnProperty(key)){
                                                attrsStr += key + '="'+attrs[key]+'" ';
                                            }
                                        }
                                    }

                                  return '<a '+attrsStr+' href="'+ this.link() +'">' + this.user.fn +'</a>';

                                },

                                resetAvatar: function() {
                                    this.user.prIm =  "images/prof.png";
                                },

                                avatarXY: function() {
                                    return {x:this.user.pimX, y:this.user.pimY};
                                },
                                getBday: function() {
                                    return this.user.bDay;
                                },
                                getUserMood: function() {
                                    //switch(user.mood) {
                                        //case 1:
                                            //return 'Available';
                                            //break;
                                        //case 2:
                                            //return 'Do not disturb';
                                            //break;
                                        //case 3:
                                            //return 'Busy';
                                            //break;
                                        //case 4:
                                            //return 'Invisible';
                                            //break;
                                        //default:
                                            return this.user.mood;
                                    //}
                                },
                                setUserMood : function(mood){
                                    this.user.mood = mood;
                                },
                                getAppType : function(){
                                    return this.user.apt;
                                },
                                setAppType : function(appType){
                                    this.user.apt = appType;
                                },
                                getDeviceToken : function(){
                                    return this.user.dt;
                                },
                                setDeviceToken : function(deviceToken){
                                    this.user.dt = deviceToken;
                                },
                                isBlocked: function() {
                                    if(this.user.cla===0 && this.user.chta===0 && this.user.fda===0){
                                        this.user.bv = 1;
                                    }else{
                                        this.user.bv = 0;
                                    }
                                    return this.user.bv;
                                },
                                setBlock: function(block) {
                                    if( block === 1 ) {
                                        var accessVal = 0;
                                    }else{
                                        var accessVal = 1
                                    }
                                    this.user.cla = accessVal;
                                    this.user.chta = accessVal;
                                    this.user.fda = accessVal;
                                    this.user.bv = block;
                                },
                                isFriend: function() {
                                    return this.user.frnS === 1;
                                },
                                unFriend: function() {
                                    this.user.frnS = 0;
                                },
                                getAccess: function() {
                                    return {
                                        chta: this.user.chta,
                                        cla: this.user.cla,
                                        fda: this.user.fda
                                    };
                                },
                                canChat: function() {
                                    if(this.user.chta === 1) {
                                        return true;
                                    } else {
                                        return false;
                                    }
                                },
                                canSeeFeed: function() {
                                    if(this.user.fda === 1) {
                                        return true;
                                    } else {
                                        return false;
                                    }
                                },
                                setOnlineStatus: function(status){
                                    this.user.psnc = status;
                                },
                                getOnlineStatus : function(){
                                    return this.user.psnc;
                                },
                                isOnline: function() {
                                    return (this.user.psnc === 2 && this.user.mood === 1);
                                },
                                onlineDevice: function() {
                                    return DEVICES[this.user.dvc];
                                },
                                getPlatform : function(){
                                  return this.user.dvc;
                                },
                                setPlatform : function(platfrom){
                                    this.user.dvc = platfrom;
                                },
                                lastOnline: function() {
                                    if(this.user.lot === 0) {
                                        return false;
                                        //return user.lot;
                                    } else {

                                        return utilsFactory.verbalDate(this.user.lot);
                                    }
                                },
                                getProfileImageId : function () {
                                    return this.user.prImId;
                                },
                                getCoverImageId : function () {
                                    return this.user.cImId;
                                },
                                isEmailVerified:function(){
                                    return this.user.iev;
                                },
                                isMobileVerified:function(){
                                    return this.user.iev;
                                },
                                // api methods
                                toggleMood: function(mood) {
                                    //console.log('mood: ' + mood);
                                    this.user.mood = mood ? 1 : 2;
                                    profileHttpService.changeMood(this.user.mood).then(function(json) {
                                        //console.log('%c' + angular.toJson(json), 'color:green');
                                        if(json.sucs !== true) {
                                            this.user.mood = json.mood;
                                        }
                                    });
                                }
                           };

                    return function (obj, isProfile, isCurrent,usersByUtId,withMfc) {
                            return new RingUser(obj,isProfile,isCurrent,usersByUtId,withMfc);
                          };

                }])
            .factory("userFactory", ['$$userMap', '$$stackedMap', function ($$userMap, $$stackedMap) {
                    var users = $$stackedMap.createNew();

                    var usersByUtId = {};

                    var prefix = "ru_";

                    var ObjectToReturn = {
                        getSortIndex: function() {
                            return 'adt';
                            //return 'fn';
                        },
                        create: function (ob, isProfile, isCurrent) {
                           //console.log(ob);
                             isProfile = !!isProfile;
                             isCurrent = !!isCurrent;

                            //console.log('user:');
                            //console.dir(ob);
                            var key, user;
                            if(angular.isObject(ob)){
                                if (ob.uId) {
                                   key = ob.uId;
                                   key = prefix + key;
                                   user = users.get(key);
                                } else if(ob.utId) {
                                    user = usersByUtId[ob.utId];
                                    if(!user)user=false;
                                }else{
                                    user = false;
                                }
                            }else{
                                   key = prefix + ob;
                                   user = users.get(key);
                            }




                            // existing user in the map?
                            if (user === false ) {
                                if (ob.utId && usersByUtId[ob.utId]){
                                    user = usersByUtId[ob.utId];
                                    key = prefix + ob.uId;
                                    users.save(key, user);
                                    user.updateUserObj(ob);
                                } else {
                                    user = $$userMap(ob, isProfile, isCurrent);
                                    if(user.getUtId()){
                                        usersByUtId[user.getUtId()] = user;
                                    }

                                }
                            } else {
                                user.updateUserObj(ob);
                            }

                          users.save(key, user);
                          return user;
                        },
                        createByUtId : function(ob,returnLite,withMfc){
                            if(!usersByUtId[ob.utId]){
                               usersByUtId[ob.utId]=$$userMap(ob,false,false,withMfc);
                            }
                            return !returnLite ? usersByUtId[ob.utId] : usersByUtId[ob.utId].getLiteUser();
                        },
                        getUser : function(key){
                            key = prefix + key;
                          return users.get(key);
                        },

                        /* get by utId */
                        getByUtId : function(utId){
                           return (utId && usersByUtId[utId]) || false;
                        },
                        getAllUtIds : function(){
                            return Object.keys(usersByUtId);
                        },
                        getUIdByUtId : function(utId){
                            return usersByUtId[utId] && usersByUtId[utId].getUId();
                        },
                        getUtIdByUId : function(uId){
                            var user;
                            try{
                                user = ObjectToReturn.getUser(uId);
                            }catch(e){
                            }
                            return user && user.getUtId();
                        }

                    };


                    return ObjectToReturn;

                }]);

})();

"use strict";
(function(){

    angular
        .module('ringid.common.comment_factory',[
                'ringid.config',
                //'ringid.common.stacked_map'
        ])
        .factory("$$commentMap", ['$$stackedMap','settings','$filter',"DATE_FORMAT",'userFactory','utilsFactory','$$stickerMap','$sce',
            function ($$stackedMap,settings,$filter,DATE_FORMAT,userFactory,utilsFactory,$$stickerMap,$sce) {

                var comment_defaults = {
                            cmn: "",
                            cmnId: 0,
                            deleted: false,
                            edited: false,
                            fn: "",
                            il: 0,
                            isNew:1,
                            ln: "",
                            nfId: 0,
                            imageId : 0,
                            tl: 0,
                            tm: "",
                            uId: "",
                            prIm : "",
                            pending : false // for showing half opacity when add comment
                        };

                function RingComment(ob,user){
                    if(user){
                        this._u = user;
                    }
                    this.updateComment(ob);
                }

                RingComment.prototype = {
                            updateComment : function(json){
                                if(this.comment){
                                    angular.extend(this.comment, json);
                                }else{
                                    this.comment = angular.extend({},comment_defaults, json);
                                }

                                this.updateTime();
                                this.setHtml();
                                if(!this._u){
                                    this._u = userFactory.create({
                                                fn : this.comment.fn,
                                                ln : this.comment.ln,
                                                uId : this.comment.uId,
                                                prIm : this.comment.prIm
                                            });
                                }
                            },
                            updateTime : function(){
                                if(!this.comment.tm){
                                    this.comment.tm =  Date.now();
                                }
                                this.vtime = utilsFactory.verbalDate(this.comment.tm);
                            },
                            setHtml : function(){
                                this.html = $sce.trustAsHtml(utilsFactory.parseForLE(this.comment.cmn));
                            },
                            user: function () {
                                return this._u;// instance of $$userMap
                            },
                            isOwner: function(userKey) {
                                return userKey === this._u.getKey() ? true : false;
                            },
                            text : function(){
                               return this.comment.cmn;// here should goes a emoticon filter
                            },
                            setComment: function (commentText) {
                                this.comment.cmn = commentText;
                                this.setHtml();
                            },
                            setText: function (txt) {
                                comment.cmn = txt;
                                this.setHtml();
                            },
                            getDynamicText : function(){
                                return this.html;
                            },
                            getByProperty : function(property_name,return_default){
                                return_default = return_default || false;
                                return this.comment.hasOwnProperty(property_name)?this.comment[property_name]:return_default;
                            },
                            sortBy : function(){
                                return this.comment.cmnId;
                            },
                            getKey: function () {
                                return this.comment.cmnId;
                            },
                            setKey : function(key){
                              this.comment.cmnId = key;
                            },
                            getFeedKey: function(){ // when comment belongs to feed
                                return this.comment.nfId;
                            },
                            setFeedKey:function(key){ // when comment belongs to feed
                                this.comment.nfId = key;
                            },
                            getImageKey: function(){ // when comment belongs to image
                                return this.comment.imageId;
                            },
                            setImageKey:function(key){ // when comment belongs to image
                                this.comment.imageId = key;
                            },
                            getTimestamp: function(){
                                return this.comment.tm;
                            },
                            setTime : function(tm){
                                this.comment.tm = tm;
                                this.updateTime();
                            },
                            getTimeUpdate : function(){
                                this.updateTime();
                                return this.vtime;
                            },
                            time : function(){
                                return this.vtime;
                            },
                            like : function(dolike,totalLike){
                                if(!dolike)return this.comment.il;
                                this.comment.il = this.comment.il ^ 1;
                                if(totalLike){
                                    this.comment.tl = totalLike;
                                }else{
                                    this.comment.tl = (this.comment.il == 0)?this.comment.tl-1:this.comment.tl+1;
                                }
                                return this.comment.il;

                            },
                            getTotalLikes : function(){
                                return this.comment.tl;
                            },
                            incomingLike: function (tl) {
                                    this.comment.tl = tl;
                            },
                            isPending : function(val){
                                if(val !== undefined){
                                    this.comment.pending = !!val;
                                }
                                return this.comment.pending;
                            },
                            isEditable : function(){
                                return this._u.isCurrentUser() && this.like() === 0;
                            }
                };



                return {
                    getSortIndex : function(){
                        return 'tm';
                    },
                    create: function (ob,user) { // while user adding comment // user is the second paramter of $$userMap Instance
                        return new RingComment(ob,user);
                    }
                };
            }]);



})();


/*
 * Ipvision
 */


(function(){
    "use strict";




    angular
        .module('ringid.common.imagemap_factory',[
            'ringid.config',
            'ringid.utils',
            //'ringid.common.stacked_map',
            'ringid.common.comment_factory',
            'ringid.common.user_factory'
        ])
        .factory('$$imageMap', $$imageMap);

    $$imageMap.$inject = ['settings', '$$stackedMap', 'userFactory', 'utilsFactory'];
    function $$imageMap (settings, $$stackedMap, userFactory, utilsFactory) {
        var image_defaults = {
                    albId: "",
                    albn: "",
                    cptn: "",
                    nfId : 0,
                    ic: 0,
                    ih: 0,
                    il: 0,
                    imT: 0,
                    imgId: 0,
                    iurl: "",
                    iw: 0,
                    nc: 0,
                    nl: 0,
                    tm: 0,
                    user: null
                };
        function RingImage(image,user){
            var that = this;
            image = image || {};
            if(user){
                that._u = user;
            }
            that.updateImage(image);

             Object.defineProperty(that, 'ddControl', {
                                  enumerable: false,
                                  configurable: false,
                                  writable: false,
                                  value: {
                                        key: that.image.imgId,
                                        showReportButton : function(){
                                            return !that._u.isCurrentUser();
                                        },
                                        getSpamId : function(){
                                            return that.getKey();
                                        },
                                        getSpamType : function(){
                                            return "image";
                                        }
                                    }
                                });

        }

        RingImage.prototype = {
                    updateImage: function(image,user) {
                        if(this.image){
                            angular.extend(this.image,image);
                        }else{
                            this.image = angular.extend({},image_defaults,image);
                        }

                        image = null;
                        this.key = 'im'+this.image.imgId;
                        if(this.image.tm){
                            this._time = utilsFactory.verbalDate(this.image.tm);;
                        }else{
                            this._time = {};// preventing from throwing error
                        }
                        if (!this._u && this.image.hasOwnProperty('uId')) {
                            this._u = userFactory.create({
                                uId: this.image.uId,
                                fn: this.image.fn || ''
                            });
                        }
                    },
                    user: function() {
                        return this._u;
                    },
                    src: function (size) {
                        if (size === 'iurl') {
                            return this.image.iurl;
                        }

                        var position = this.image.iurl.lastIndexOf('/') + 1;
                        var progressive = /\/uploaded\//.test(this.image.iurl) ? '': 'p';
                        if(size !== undefined){
                            return [settings.imBase, this.image.iurl.slice(0, position), progressive , size,  this.image.iurl.slice(position)].join('');
                            //return [settings.imBase, image.iurl.slice(0, position), size,  image.iurl.slice(position)].join('');
                        } else {
                            return [settings.imBase, this.image.iurl.slice(0, position), progressive,  this.image.iurl.slice(position)].join('');
                            //return [settings.imBase, image.iurl.slice(0, position), image.iurl.slice(position)].join('');
                        }
                    },
                    getByProperty : function(property_name,returndefault){
                        returndefault = returndefault || false;
                        return this.image.hasOwnProperty(property_name)?user[property_name]:returndefault;
                    },

                    sortBy : function(){
                        return this.image.imgId;
                    },
                    getIh: function() {
                        return this.image.ih;
                    },
                    getIw: function() {
                        return this.image.iw;
                    },
                    sortByTime : function(){
                        return this.image.tm;
                    },
                    getAlbumName : function(){
                        return this.image.albn;
                    },
                    getAlbumId: function() {
                        return this.image.albId;
                    },
                    getCaption : function(){
                        return this.image.cptn;
                    },
                    getKey: function () {
                        return this.image.imgId;
                    },
                    getMapKey : function(){
                        return this.key;
                    },
                    getFeedKey: function(){
                        return this.image.nfId;
                    },
                    setFeedKey:function(key){
                        this.image.nfId = key;
                    },
                    time : function(){
                        return this._time;
                    },
                    like : function(dolike,totalLike){
                        if(!dolike)return this.image.il;

                        this.image.il = this.image.il ^ 1;
                        if(totalLike){
                            this.image.nl  = totalLike;
                        }else{
                            this.image.nl = (this.image.il == 0) ? this.image.nl-1 : this.image.nl+1;
                        }
                        return this.image.il;
                    },
                    getLikes : function(){
                        return this.image.nl;//todo remove the getLikes from templates use getTotalLikes
                    },
                    getTotalLikes : function(){
                        return this.image.nl;
                    },
                    getImageType : function(){
                        return this.image.imT;
                    },
                    // getWhoLikes : function() {
                    //     return image.whoLikes.all();
                    // },
                    incomingLike: function (type) {
                        return (type && ++this.image.nl) || --this.image.nl;
                    },
                    // incomingWhoLikes: function (userJson) {

                    //         var user = userFactory.create(userJson);
                    //         image.whoLikes.save(user.getKey(), user);


                    // },

                    offset : function(){
                        return {width:this.image.iw,height:this.image.ih};
                    },
                    selfComment: function() {
                        return this.image.ic;
                    },
                    getTotalComment: function() {
                        return this.image.nc;
                    },
                    setTotalComment: function(total,ic) {
                        this.image.nc = total;
                        if(angular.isDefined(ic)){
                                this.image.ic = ic;
                            }
                    },
                    getUrl : function(){
                        /** Not an ideal place, will be refactored */
                        return '/image/' + this.getKey();
                    },
                    getRelativeHeight : function(width){
                        //if(width > image.iw) return image.ih;
                        try {
                            return (this.image.ih/this.image.iw) * width;
                        }catch(e){
                            return this.image.ih;
                        }

                    }
                };

        return function (obj, user) {
                return new RingImage(obj,user);
            }

    }




})();

/*
 * Ipvision
 */


(function(){
    'use strict';
    angular
        .module('ringid.common.album_factory',[
            'ringid.config',
            'ringid.common.imagemap_factory',
            //'ringid.common.stacked_map',
            'ringid.utils','ringid.connector',
            'ringid.common.services',
            'ringid.profile'
        ])
        .factory('$$albumMap', $$albumMap)
        .factory('AlbumFactory', AlbumFactory);


        $$albumMap.$inject = [ 'settings', '$$imageMap', '$$stackedMap', 'profileFactory'];
        function $$albumMap( settings, $$imageMap, $$stackedMap, profileFactory) { // jshint ignore:line

            // constructor
            function Album (obj, albumOwnerUid) {
                var image,
                    albumOwner,
                    album = {
                        albId: obj.albId,
                        timg: obj.timg,
                        images: $$stackedMap.createNew(),
                        ut: 0
                    };

                albumOwner = profileFactory.getProfile(albumOwnerUid);
                album = angular.extend({}, album, obj);

                function pushImages(obj) {
                    var imageObj;
                    for( var i = 0, lt = obj.imageList.length; i < lt; i++) {
                        imageObj =  angular.extend({}, obj.imageList[i], {albId: album.albId});
                        image = $$imageMap(imageObj, albumOwner);
                        album.images.save(image.getKey(), image);

                        if (album.ut < obj.imageList[i].tm) {
                            album.ut = obj.imageList[i].tm;
                        }
                    }
                }
                if(obj.imageList && obj.imageList.length > 0) {
                    pushImages(obj);
                }

                return {
                    getKey: function() {
                        return album.albId;
                    },
                    pushImages: function(obj) {
                        pushImages(obj);
                    },
                    removeImage: function(imageKey) {
                        if( album.images.remove(imageKey)) {
                            // do other stuff
                            album.tn = album.tn - 1; // decrease total no of image
                        }
                    },
                    getName: function() {
                        return album.albn;
                    },
                    getCoverImage: function(size) {
                        var position = album.cvImg.lastIndexOf('/') + 1;
                        size = 'p' + size;
                        return [settings.imBase, album.cvImg.slice(0, position), size,  album.cvImg.slice(position)].join('');
                        //return album.images.top().src(size);
                    },
                    getTotalImageCount: function() {
                        return album.tn;
                    },
                    getUpdateTime: function() {
                        return album.tm;
                    },
                    getImages: function() {
                        return album.images;
                    }

                };
            }

            return function(obj, albumOwnerUid) {
                return new Album(obj, albumOwnerUid);
            };
        }

        AlbumFactory.$inject = ['$$q', 'settings', 'Auth', '$$albumMap', '$$imageMap', '$$stackedMap', '$$connector', 'OPERATION_TYPES', 'imageHttpService', 'profileFactory', 'Ringalert'];
        function AlbumFactory($q, settings, Auth, $$albumMap, $$imageMap, $$stackedMap, $$connector, OPERATION_TYPES, imageHttpService, profileFactory, Ringalert) { // jshint ignore:line

            var _state = {
                    imagesLoading : false,
                    albumsLoading : false
                };

            var albumRequestCount = 0,
                imageRequestCount = 0,
                OTYPES = OPERATION_TYPES.SYSTEM.IMAGE,
                ownAlbums = $$stackedMap.createNew(),
                userAlbums = $$stackedMap.createNew();


            function _processResponse (json, uId) {
                var album, i, len;
                switch(json.actn) {
                    case OTYPES.TYPE_ALBUM_IMAGES:
                        if (json.sucs === true) {
                            if (ownAlbums.get(json.albId)) {
                                ownAlbums.get(json.albId).pushImages(json);
                            } else {
                                album = new $$albumMap(json);
                                ownAlbums.save(album.getKey(), album);
                            }
                        } else if (json.sucs === false && json.rc === 1111){
                        }

                        break;
                    case OTYPES.TYPE_FRIEND_ALBUM_IMAGES:
                        if (json.sucs === true) {
                            if (userAlbums.get(json.albId)) {
                                userAlbums.get(json.albId).pushImages(json);
                            } else {
                                album = new $$albumMap(json);
                                userAlbums.save(album.getKey(), album);
                            }
                        } else {
                        }
                        break;
                    case OTYPES.FETCH_FRIEND_ALBUM_LIST:
                        if(json.sucs === true) {
                            for(i=0, len=json.albumList.length; i<len; i++) {
                                album = new $$albumMap(json.albumList[i], uId);
                                userAlbums.save(album.getKey(), album);
                            }
                        }
                        break;
                    case OTYPES.FETCH_ALBUM_LIST:
                        if(json.sucs === true) {
                            for(i=0, len=json.albumList.length; i<len; i++) {
                                album = new $$albumMap(json.albumList[i], uId);
                                ownAlbums.save(album.getKey(), album);
                            }
                        }
                        break;
                    default:
                }
            }

            function _fetchMoreImage(albId, uId) {
                var fndId = false,
                    st = 0;

                if (Auth.currentUser().getKey() === uId) {
                    st = ownAlbums.get(albId) ? ownAlbums.get(albId).getImages().length() : 0;
                    if (st !== 0 && st >= ownAlbums.get(albId).getTotalImageCount()) { // all images already fetched.
                        return;
                    }
                } else {
                    fndId = uId;
                    st = userAlbums.get(albId) ? userAlbums.get(albId).getImages().length() : 0;
                    if (st !== 0 && st >= userAlbums.get(albId).getTotalImageCount()) { // all images already fetched. no need to request more
                        return;
                    }
                }

                imageHttpService.getAlbumImages({
                    fndId : fndId,
                    albId: albId,
                    st: st
                });
            }

            function _fetchAllAlbums(uId) {
                var fndId = false;

                if (Auth.currentUser().getKey() !== uId) {
                    fndId = uId;
                }

                imageHttpService.fetchAlbumList(fndId);
            }



            return {
                processResponse: _processResponse,
                state: _state,
                resetAlbums: function(own) {
                    if (own) {
                         ownAlbums.reset();
                    } else {
                        userAlbums.reset();
                    }
                },
                deleteImage: function(imageMap) {
                    return imageHttpService.deleteImage(imageMap.getKey());
                },
                getAlbums: function(uId) {
                    if (Auth.currentUser().getKey() === uId) {
                        return ownAlbums;
                    }else {
                        return userAlbums;
                    }
                },
                loadMoreImage: _fetchMoreImage,
                fetchAllAlbums: _fetchAllAlbums,
                getFeedImages : imageHttpService.getFeedImages ,
                getImageDetails: function(imgId,nfId) {
                    var defer = $q.defer(); // this promise is used for popup only
                    imageHttpService.getImageDetails(imgId).then(function(response) {
                        if (response.sucs === true) {
                            //if (imgId) { // no image provided only imgId. so resolve with image obj
                                if(nfId && !response.nfId){
                                    response.nfId = nfId;
                                }
                                defer.resolve($$imageMap(response));
                            //} else {
                                //image.updateImage(response);
                                //defer.resolve();
                            //}
                        } else {
                            Ringalert.show(response,'error');
                        }
                    }, function(errData) {
                        defer.reject();
                    });
                    return defer.promise;
                }
            };
        }
})();

(function () {
    'use strict';

    angular
        .module('ringid.common.emotion_factory', [])
        .factory('EmotionFactory', ['$$connector', 'settings', 'OPERATION_TYPES', function ($$connector, settings, OPERATION_TYPES) {
            var emotions = {}, OTYPES = OPERATION_TYPES.SYSTEM,count=0,SCOPES={};

            function createEmotion(ob) {
                return {
                    id: ob.id,
                    title: ob.nm,
                    nm: ob.nm,
                    url: settings.emotionServer + ob.url,
                    cat: ob.cat
                };
            }

            function process(message) {
                var i;
                if (message.sucs && message.mdLst.length) {
                    for (i = 0; i < message.mdLst.length; i++) {
                        emotions[message.mdLst[i].id] = createEmotion(message.mdLst[i]);
                        count++;
                    }
                }

                safeDigest();
                
            }

            var subKey = $$connector.subscribe(process, {
                action: OTYPES.FETCH_EMOTION_LIST
            });

            function getEmotions() {
                var arr = [];
                for(var key in emotions){
                    if(emotions.hasOwnProperty(key)){
                        arr.push(emotions[key]);
                    }
                }
                return arr;
            }
            function safeDigest(){
                var digestScope;
                for(var key in SCOPES){
                    digestScope = SCOPES[key];
                    if(digestScope && digestScope.$id && !digestScope.$$destroyed){
                        digestScope.setEmotion.call(digestScope,getEmotions());
                    }
                }
                
            }
            function init() {
                if (!count) {
                    $$connector.send({
                        actn: OTYPES.FETCH_EMOTION_LIST
                    }, OTYPES.REQUEST_TYPE.REQUEST);
                }else{
                    safeDigest();
                }

            }

           // init();
            return {
                init: init,
                getEmotions: getEmotions,
                getLength: function () {
                    return count;
                },
                getEmotion: function (ob, createIfNotExist) {
                    var id = angular.isObject(ob) ? ob.id : ob;
                    if (!createIfNotExist)return emotions[id] || false;
                    if (!!emotions[id])return emotions[id];
                    if (angular.isObject(ob))return createEmotion(ob);
                    return false;
                },
                setScopeForDigest : function(scope){
                    SCOPES[scope.$id] = scope;
                },
                removeScope : function(scope){
                    if(SCOPES[scope.$id]){
                        SCOPES[scope.$id] = null;
                    }
                }
            }
        }])


})();

/*
 * Ipvision
 */


(function(){
    "use strict";
    angular
        .module('ringid.common.invite_factory',[
            'ringid.config',
            //'ringid.common.stacked_map',
            'ringid.common.user_factory',
            'ringid.utils',
            'ringid.connector'
        ])
        .factory('InviteFactory', InviteFactory);

    InviteFactory.$inject = ['$timeout', '$$connector', 'OPERATION_TYPES', 'userFactory', 'Storage', 'friendsFactory', '$$stackedMap', '$$q', 'Auth', '$rootScope'];
    function InviteFactory($timeout, $$connector, OPERATION_TYPES, userFactory, Storage, friendsFactory, $$stackedMap, $q, Auth, $rootScope) {
        var _utIds = [], //Storage.getData('suggestionUtIds') || [],
            initialized = false,
            OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS,
            REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE,
            REQPRF = OPERATION_TYPES.SYSTEM.PROFILE,
            user;

        var Factory = {
            init: init,
            state : {
                isRequestsLoading: false
            },
            suggestionFriends: $$stackedMap.createNew(),
            getSuggestionContactsDetails: getSuggestionContactsDetails,
            removeSuggestion: removeSuggestion,
            getMutualFriend : getMutualFriend,
            allSuggestionFriends: $$stackedMap.createNew(),
            noOfSuggestions: function() { // should be removed after refactor done
                return Factory.suggestionFriends.length();
            }
            //getAllsuggestionContactDetails:getAllsuggestionContactDetails
        };

        function _processResponse (json) {
            var i;
            switch(json.actn) {
                case OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW:
                    if (json.sucs===true) {
                        for(i=0; i<json.contactIds.length;i++){
                            _utIds.push(json.contactIds[i]);
                        }
                        getSuggestionContactsDetails();
                    } else if (json.sucs === false && json.rc === 1111) {
                        _getSuggestionUtids();
                    } else {
                    }
                    break;
                case OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS:
                    Factory.state.isRequestsLoading = false;
                    if(json.sucs === true){
                        for(i=0; i<json.contactList.length; i++){
                            //if(json.contactList[i].frnS === undefined){
                                _utIds.splice( _utIds.indexOf(json.contactList[i].utId), 1);
                                user = userFactory.create(json.contactList[i]);
                                if (user.isFriend()) {
                                    continue;
                                } else {
                                    Factory.suggestionFriends.save(user.getUtId(), user);
                                }
                            //}
                        }
                    } else if (json.sucs === false && json.rc === 1111) {
                        getSuggestionContactsDetails();
                    } else{
                    }
                    break;
            }
        }



        function _getSuggestionUtids() {
            //_utIds = [];
            return $$connector.send({
                actn: OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW
            }, REQTYPE.REQUEST);
        }


        function getSuggestionContactsDetails (count){//user details
            count = count || 10;
            if(!Factory.state.isRequestsLoading){
                Factory.state.isRequestsLoading = true;
                return $$connector.send({
                    actn: OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS,
                    idList: _utIds.slice(0, count)
                }, REQTYPE.REQUEST);
            }


        }

        //function getAllsuggestionContactDetails() {
        //    var suggUtIds = Storage.getData('suggestionUtIds');
        //}
        function getMutualFriend(user) {
            var params = {
                actn: REQPRF.FETCH_FRIEND_MUTUAL_FRIEND_LIST,
                uId: user.getUId()
            };
            return $$connector.pull(params, REQTYPE.REQUEST);
        }

        function removeSuggestion(utid,action){
            var defer = $q.defer();
            var payload = {
                actn:33,
                utId:utid
            };

            $$connector.request(payload, REQTYPE.REQUEST).then(function(json){
                if(json.sucs===true){
                    //Factory.suggestionFriends.remove(json.utId);
                    if(action !=='remove'){
                        friendsFactory.addToUtIdList('outgoingUtIds', json.utId);
                    }

                    Factory.suggestionFriends.remove(utid);

                    if(Factory.suggestionFriends.length() < 5){
                        getSuggestionContactsDetails();
                    }
                    defer.resolve(json);
                }

            }, function(errData) {
                defer.reject(errData);
            });
            return defer.promise;
        }


        function init(force) {

            if (!initialized) {
                $$connector.subscribe(_processResponse, {action: [
                        OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW,
                        OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS
                    ]
                });
            }

            if (!initialized || force) {
                initialized = true;
                _getSuggestionUtids();
            }
        }


        return Factory;

    }


})();

/*
* © Ipvision
*/

(function() {
    'use strict';
    angular
        .module('ringid.common.factories', [
            //'ringid.common.global_events_factory',
            //'ringid.common.storage_factory',
            'ringid.common.user_factory',
            //'ringid.common.stacked_map',
		    'ringid.common.imagemap_factory',
            'ringid.common.album_factory',
		    'ringid.common.comment_factory',
            'ringid.common.emotion_factory',
            'ringid.common.invite_factory',
            //'ringid.common.ringalert',
            //'ringid.common.auth_factory'
        ]);
})();

/*!
 * AngularJS Round Progress Directive
 *
 * Copyright 2013 Stephane Begaudeau
 * Released under the MIT license
 */
"use strict";
angular.module('ringid.common.rground_progress_directive', [])
        .directive('rgRoundProgress', [function () {
                var compilationFunction = function (templateElement, templateAttributes, transclude) {
                    if (templateElement.length === 1) {
                        var node = templateElement[0];
                        var width;// = node.getAttribute('data-round-progress-width') || '400';
                        var height;// = node.getAttribute('data-round-progress-height') || '400';

                        var canvas = document.createElement('canvas');
//                        canvas.setAttribute('width', width);
//                        canvas.setAttribute('height', height);
//                        canvas.setAttribute('data-round-progress-model', node.getAttribute('data-round-progress-model'));

//                        node.parentNode.replaceChild(canvas, node);

                        var outerCircleWidth;// = node.getAttribute('data-round-progress-outer-circle-width') || '20';
                        var innerCircleWidth;// = node.getAttribute('data-round-progress-inner-circle-width') || '5';

                        var outerCircleBackgroundColor;// = node.getAttribute('data-round-progress-outer-circle-background-color') || '#505769';
                        var outerCircleForegroundColor;// = node.getAttribute('data-round-progress-outer-circle-foreground-color') || '#12eeb9';
                        var innerCircleColor;// = node.getAttribute('data-round-progress-inner-circle-color') || '#505769';
                        var labelColor;// = node.getAttribute('data-round-progress-label-color') || '#12eeb9';

                        var outerCircleRadius;// = node.getAttribute('data-round-progress-outer-circle-radius') || '100';
                        var innerCircleRadius;// = node.getAttribute('data-round-progress-inner-circle-radius') || '70';

                        var labelFont;// = node.getAttribute('data-round-progress-label-font') || '50pt Calibri';

                        return {
                            pre: function preLink(scope, instanceElement, instanceAttributes, controller) {
                                var scale = (window.outerWidth - 20) / 1920;
                                width = +(scope.roundProgressBarStyle.dataRoundProgressWidth || '200') * scale;
                                height = +(scope.roundProgressBarStyle.dataRoundProgressHeight || '200') * scale;

                                canvas.setAttribute('width', width);
                                canvas.setAttribute('height', height);
                                canvas.setAttribute('data-round-progress-model', node.getAttribute('data-round-progress-model'));

                                node.parentNode.replaceChild(canvas, node);


                                outerCircleWidth = +(scope.roundProgressBarStyle.dataRoundProgressOuterCircleWidth || '4') * scale;
                                innerCircleWidth = +(scope.roundProgressBarStyle.dataRoundProgressInnerCircleWidth || '8') * scale;


                                outerCircleRadius = +(scope.roundProgressBarStyle.dataRoundProgressOuterCircleRadius || '85') * scale;
                                innerCircleRadius = +(scope.roundProgressBarStyle.dataRoundProgressInnerCircleRadius || '85') * scale;

                                labelFont = (+(scope.roundProgressBarStyle.dataRoundProgressLabelFont || '24') * scale) + 'px Arial';



                                outerCircleBackgroundColor = scope.roundProgressBarStyle.dataRoundProgressOuterCircleBackgroundColor || '#505769';
                                outerCircleForegroundColor = scope.roundProgressBarStyle.dataRoundProgressOuterCircleForegroundColor || '#13A8E8';
                                innerCircleColor = scope.roundProgressBarStyle.dataRoundProgressInnerCircleColor || '#505769';
                                labelColor = scope.roundProgressBarStyle.dataRoundProgressLabelColor || '#fff';

                            },
                            post: function postLink(scope, instanceElement, instanceAttributes, controller) {

                                var expression = canvas.getAttribute('data-round-progress-model');

                                scope.$watch(expression, function (newValue, oldValue) {
                                    console.log(expression, newValue, oldValue);
                                    // Create the content of the canvas
                                    var ctx = canvas.getContext('2d');
                                    ctx.clearRect(0, 0, width, height);

                                    // The "background" circle
                                    var x = width / 2;
                                    var y = height / 2;
//                                    ctx.beginPath();
//                                    ctx.arc(x, y, parseInt(outerCircleRadius), 0, Math.PI * 2, false);
//                                    ctx.lineWidth = parseInt(outerCircleWidth);
//                                    ctx.strokeStyle = outerCircleBackgroundColor;
//                                    ctx.stroke();

                                    // The inner circle
                                    ctx.beginPath();
                                    ctx.arc(x, y, parseInt(innerCircleRadius), 0, Math.PI * 2, false);
                                    ctx.lineWidth = parseInt(innerCircleWidth);
//                                    ctx.shadowColor = innerCircleColor;
                                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                                    ctx.globalCompositeOperation = 'source-over';
                                    ctx.stroke();

                                    // The inner number
                                    ctx.font = labelFont;
                                    ctx.textAlign = 'center';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillStyle = labelColor;
//                                    ctx.shadowColor = "black";
//                                    ctx.shadowOffsetY = 3;
//                                    ctx.shadowOffsetX = 3;
                                    ctx.fillText(newValue.label + '%', x, y);

                                    // The "foreground" circle
                                    var startAngle = -(Math.PI / 2);
                                    var endAngle = ((Math.PI * 2) * newValue.percentage) - (Math.PI / 2);
                                    var anticlockwise = false;
                                    ctx.beginPath();
                                    ctx.arc(x, y, parseInt(outerCircleRadius), startAngle, endAngle, anticlockwise);
                                    ctx.lineWidth = parseInt(outerCircleWidth);
                                    ctx.strokeStyle = outerCircleForegroundColor;
                                    ctx.stroke();
                                }, true);
                            }
                        };
                    }
                };

                var roundProgress = {
                    compile: compilationFunction,
                    replace: true
                };
                return roundProgress;
            }]);

(function () {
    'use strict';
    var ringUtilsModule;

    try {
        ringUtilsModule = angular.module('ringid.utils');
    } catch (e) {
        console.warn("Utils Module Not Found");
        return;
    }

    ringUtilsModule.directive('ogImageSrc', ogImageSrc );
    ringUtilsModule.directive('rgUrlOgPreview', rgUrlOgPreview );

    ogImageSrc.$inject = ['SystemEvents'];
    function ogImageSrc(SystemEvents){

        return {
            restrict : 'A',
            link : function(scope,element,attr){
                element[0].onload = function(){
                    scope.$emit(SystemEvents.FEED.HEIGHT,scope.feedKey);
                }

                element[0].src = attr['ogImageSrc'];

                
            }
        }
    }

    rgUrlOgPreview.$inject = [ '$ringhttp', '$templateCache', '$compile', 'utilsFactory' ];
    function rgUrlOgPreview($ringhttp, $templateCache, $compile, utilsFactory ){
        return {
            restrict : 'E',
            replace : true,
            scope : {
              onClick : '&',
              ogData : '=',
              showPreview : '=',
              loadingData: '=',
             // filterOnProgress : '=',
              editMode : '@',
              feedKey : '@'
            },
            templateUrl: '',
            link : function(scope, element, attr){

                var templateUrl = "pages/partials/url-og-preview.html";

                if( !!attr.template) {
                    templateUrl = attr.template;
                }

                //$http.get(templateUrl, {cache: $templateCache}).success(function(tplContent){
                $ringhttp.get(templateUrl).success(function(tplContent){
                    element.append($compile(tplContent)(scope));
                    scope.$rgDigest();
                });


                //element.on('click', function(e){
                //    if(angular.isFunction(scope.onClick)){
                //        scope.onClick();
                //    }
                //});

            },
            controller : ['$scope' ,'$sce','settings', function($scope, $sce,settings){

                $scope.selectedOgImageIndex = 0;

                $scope.onClick = onClick;
                $scope.onImageCloseClick = onImageCloseClick;
                $scope.onDetailCloseClick = onDetailCloseClick;
                $scope.selectPreviousImage = selectPreviousImage;
                $scope.selectNextImage = selectNextImage;
                $scope.shouldShowNextButton = shouldShowNextButton;
                $scope.shouldShowPreviousButton = shouldShowPreviousButton;

                $scope.isYoutubeUrl = isYoutubeUrl;
                $scope.getYoutubeUrl = getYoutubeUrl;
                $scope.filterOnProgress = false;
                $scope.ogData.title = decodeEntities($scope.ogData.title);
                $scope.ogData.description = decodeEntities($scope.ogData.description);

                $scope.shouldShowNextPreviousButtonContainer = shouldShowNextPreviousButtonContainer;
                $scope.shouldShowImageCloseButton = shouldShowImageCloseButton;

                $scope.init = function(){

                    if( !!$scope.ogData && !!$scope.ogData.url ){

                        initUrlMetaData();
                        processUrl($scope.ogData.url);    

                        /**
                         *
                         * while add ssl unblock this code
                         */
                        if(!!$scope.ogData.url){
                            if(!/^https?:\/\//.test($scope.ogData.url)){
                            $scope.ogData.url = "http://" + $scope.ogData.url;
                            }   
                        }
                        
                        if(!!$scope.ogData.image){
                            if(!/^https?:\/\//.test($scope.ogData.image)){
                               $scope.ogData.image = "http://" + $scope.ogData.image;
                             }
                             if(settings.secure && /^http:/.test($scope.ogData.image)){
                                $scope.ogData.image = settings.httpsUrl + '/ImageProxy.png?url=' + $scope.ogData.image.replace(/http:\/\//,'');
                             }
                        }

                        if(!!$scope.ogData.images && $scope.ogData.images.length > 0){
                            filterImages();
                        }


                    }

                };

                $scope.$watch('ogData', function(){
                    $scope.init();                    
                });


                // $scope.init();                    

                    
                /////////////////////////////

                function doDigest(){
                    try{
                        if( !$scope.$parent.$parent ){
                            $scope.$parent.$rgDigest();        
                        }else{
                            $scope.$parent.$parent.$rgDigest();        
                        }
                        
                    }catch(e){
                        utilsFactory.safeDigest($scope);                        
                    }
                }

                function onClick(){
                    if(!!$scope.ogData && !$scope.ogData.images){
                        var url = $scope.ogData.url;
                        if(!!url){
                            window.open(url, '_blank');
                        }
                    }
                }

                function setImageInOgInfo(){
                    if( !!$scope.ogData.images){
                        $scope.ogData.image = $scope.ogData.images[$scope.selectedOgImageIndex];
                    }
                }
                function resetImageInOgInfo(){ $scope.ogData.image = ""; }
                function resetTitleInOgInfo(){ $scope.ogData.title = ""; }
                function resetDescriptionInOgInfo(){ $scope.ogData.description = ""; }
                function resetUrlInOgInfo(){ $scope.ogData.url = ""; }
                function resetLnkDmnInOgInfo(){ $scope.ogData.lnkDmn = ""; }

                function setUrlMetaData(key, value){
                     $scope.ogData.meta[key] = value;
                 }

                function initUrlMetaData(key, value){

                    $scope.ogData.meta = {
                        youtube : false,
                        youtube_id : ''
                    };
                }

                function selectNextImage(){
                    if( $scope.selectedOgImageIndex < $scope.ogData.images.length -1 ){
                        $scope.selectedOgImageIndex += 1;
                    }
                    setImageInOgInfo();

                    doDigest();
                }
                function selectPreviousImage(){
                    if( $scope.selectedOgImageIndex > 0){
                        $scope.selectedOgImageIndex -= 1;
                    }
                    setImageInOgInfo();

                    doDigest();
                }

                function onImageCloseClick($event){
                    $event.preventDefault();
                    $event.stopPropagation();
                    resetImageInOgInfo();

                    doDigest();
                }

                function onDetailCloseClick($event){
                    $event.preventDefault();
                    $event.stopPropagation();
                    resetTitleInOgInfo();
                    resetDescriptionInOgInfo();
                    resetUrlInOgInfo();
                    resetLnkDmnInOgInfo();

                    doDigest();

                    
                }

                function shouldShowNextButton(){ return !!$scope.ogData.images && $scope.selectedOgImageIndex < $scope.ogData.images.length - 1 }
                function shouldShowPreviousButton(){ return $scope.selectedOgImageIndex > 0 }

                function shouldShowNextPreviousButtonContainer(){
                    return ( !!$scope.editMode 
                        && !!$scope.ogData.image 
                        && ($scope.ogData.filteredImages.length > 1)
                    );                    
                }

                function shouldShowImageCloseButton(){
                    return !!$scope.editMode && !$scope.filterOnProgress && !!$scope.ogData.image
                }

                function setFilterOnProgress(){ $scope.filterOnProgress = true; }
                function resetFilterOnProgress(){ $scope.filterOnProgress = false;  }
                function setImagesInOgInfo(images){
                    $scope.ogData.images = images;
                }

                function addFilteredImageInOgInfo(image){

                    $scope.ogData.filteredImages.push(image);
                }

                function resetFilteredImagesInOgInfo(image){

                    $scope.ogData.filteredImages = [];
                }

                function setActiveImageInOgInfo(image){                    
                    $scope.ogData.image = image;                    
                }


                function isYoutubeUrl(){
                    if(!$scope.ogData.meta && $scope.ogData.url){
                        initUrlMetaData();
                        processUrl($scope.ogData.url);
                    }

                    return !!$scope.ogData.meta && $scope.ogData.meta.youtube
                }
                function getYoutubeId(){ return $scope.ogData.meta.youtube_id }

                function getYoutubeUrl(){
                    return $sce.trustAsResourceUrl("https://www.youtube.com/embed/" + getYoutubeId() + "?autoplay=0&autohide=1&border=0&wmode=opaque&enablejsapi=1");
                }

                function processUrl(url){
                    /*
                        Regx Explaination

                    var REGX_HTTP_HTTPS = "((http|https):\/{2})+";
                    var REGX_NAME_DOMAIN = "((www\.)?youtube.com)";
                    var REGX_PATH = "((\/([~0-9a-zA-Z\#\+\%@\.\/_-]+))?(?:\/|(?<=±@))(.*?=([^?=&]+)(=([^&]*))?(.*?))(?:±@|$|\/(?!.*±@))?)?";
                    var YOUTUBE_URL_REGX_STRING = REGX_HTTP_HTTPS + REGX_NAME_DOMAIN + REGX_PATH;
                    var YOUTUBE_URL_REGX = new RegExp(YOUTUBE_URL_REGX_STRING, "im");

                    */

                    var FULL_YOUTUBE_URL_REGX = /((http|https):\/{2})+((www\.)?youtube\.com)([?&]?([^=]+)=([^&]*))?/im;

                    if(url){
                        var matches = url.match(FULL_YOUTUBE_URL_REGX);
                        if( !!matches && !!matches[3] && !!matches[7] ){
                            setUrlMetaData('youtube', true);
                            setUrlMetaData('youtube_id', matches[7]);
                        }else{
                            setUrlMetaData('youtube', false);
                        }
                    }

                }

                function filterImages(){
                    resetFilteredImagesInOgInfo();
                    setFilterOnProgress();

                    var imageUrls = $scope.ogData.images;
                    
                    utilsFactory.filterImagesByDimentions(imageUrls, {width: 200})
                    .then(function(anImageUrl ){
                        console.log(anImageUrl);
                        console.log(imageUrls);
                        
                        if( !$scope.ogData.image ){
                            setActiveImageInOgInfo(anImageUrl);                                
                        }
                        
                        addFilteredImageInOgInfo(anImageUrl);                                                                                    

                        if(!!$scope.filterOnProgress){
                            resetFilterOnProgress();
                        }

                        doDigest();                           

                    }, function(){

                    }, function(anImageUrl){
                        console.log(anImageUrl);
                        addFilteredImageInOgInfo(anImageUrl);

                        if( !$scope.ogData.image ){
                            setActiveImageInOgInfo(anImageUrl);                                
                        }
                        console.log($scope.ogData.image);
                        doDigest();

                    });
                }

                // function getSelectedImage(){
                //     if(!ogData.image){
                //         if(!!$scope.ogData.images){
                //             ogData.image = $scope.ogData.images[$scope.selectedOgImageIndex];
                //         }
                //     }
                //
                // }



            }]
        }
    }

})();

(function () {
    'use strict';
    var ringUtilsModule;

    try {
        ringUtilsModule = angular.module('ringid.utils');
    } catch (e) {
        console.warn("Utils Module Not Found");
        return;
    }
    ringUtilsModule.directive('rgUrlOgFetcher', rgUrlOgFetcher );

    rgUrlOgFetcher.$inject = ['$compile'];
    function rgUrlOgFetcher($compile) {
        return {
            restrict : 'E',
            scope : {
                fetchedOgInfo : '=',
                editorContent : '=',
                showPreview : '=',
                filterOnProgress : '=',
                loadingData : '='
            },
            link : function(scope, element, attr){

                var previewDom;

                scope.fetchedOgInfo = scope.fetchedOgInfo || {};

                if(!!scope.filterOnProgress)
                    scope.filterOnProgress = false;

            },
            controller : ['$scope', '$rootScope', '$timeout', 'utilsFactory', 'settings', function($scope, $rootScope, $timeout, utilsFactory, settings){
                // var ORIG_URL_DETECTION_REGEX = /(((http|https):\/{2})+(([0-9a-z_-]+\.)+(aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mn|mn|mo|mp|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|nom|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ra|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw|arpa)(:[0-9]+)?((\/([~0-9a-zA-Z\#\+\%@\.\/_-]+))?(\?[0-9a-zA-Z\+\%@\/&\[\];=_-]+)?)?))\b/im;

                var REGX_TOP_LEVEL_DOMAINS = "(aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mn|mn|mo|mp|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|nom|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ra|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw|arpa)";
                var REGX_HTTP_HTTPS = "((http|https):\/{2})+";
                var REGX_NAME_DOMAIN = "([0-9a-z_-]+\.)+";
                var REGX_PORT = "(:[0-9]+)?";
                var REGX_PATH = "((\/([~0-9a-zA-Z\#\+\%@\.\/_-]+))?(\\?[0-9a-zA-Z\+\%@\/&\[\];=_-]+)?)?";

                var REGX_IP_ADDRESS = "0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])"

                var REGEX_URL_DETECTION_STRING = "(" +  REGX_HTTP_HTTPS +
                                                        "(" + "((" + REGX_NAME_DOMAIN + REGX_TOP_LEVEL_DOMAINS + ")"  + "|" + "(" + REGX_IP_ADDRESS + "))"
                                                        + REGX_PORT + REGX_PATH + ")" + ")\\b";


                var URL_DETECTION_REGEX = /(((http|https):\/{2})?((([0-9a-z_-]+\.)+(aero|asia|biz|cat|com|coop|edu|gov|info|int|jobs|mil|mobi|museum|name|net|org|pro|tel|travel|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mn|mn|mo|mp|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|nom|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ra|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sj|sk|sl|sm|sn|so|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw|arpa)|(0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])\.0*([1-9]?\d|1\d\d|2[0-4]\d|25[0-5])))(:[0-9]+)?((\/([~0-9a-zA-Z\#\+\%@\.\/_-]+))?(\?[0-9a-zA-Z\.\+\%@\/&\[\];=_-]+)?(\?[\w|\W]+)?)?))\b/im;

                var previewDom = '';

                var urlCache = {};

                var debounceLimit = 4000;
                var lastProcessTime = 0;
                var lastSkipTime = 0;
                var lastDetectedUrl = "";
                var idleInterval = null;

                function doDigest(){
                    try{

                        if( !$scope.$parent.$parent ){
                            $scope.$parent.$rgDigest();        
                        }else{
                            $scope.$parent.$parent.$rgDigest();        
                        }
                        
                        
                    }catch(e){
                        utilsFactory.safeDigest($scope);                        
                    }
                }

                $scope.$watch('editorContent', utilsFactory.debounce(function(newValue, oldValue){

                    processModelUpdate(newValue, oldValue);
            
                    doDigest();


                }, 500) );

                //console.log($scope.editorContent);



                function processModelUpdate(newValue, oldValue){

                    if( !shouldProcessModelChange(newValue, oldValue)){
                        return;
                    }

                    if(!!newValue && URL_DETECTION_REGEX.test(newValue)) {
                        console.log('Updated Value ', newValue);
                        var matches = newValue.match(URL_DETECTION_REGEX);
                        var firstUrl = matches[1];
                        if (firstUrl) {
                            var firstUrlDomain = !matches[5] ? '' : matches[5];

                            if(!/^https?:\/\//.test(firstUrl)){
                                firstUrl = 'http://' + firstUrl;
                            }

                                console.log('Detected Url', firstUrl);
                            if( !shouldProcessChange(firstUrl) ) return;

                            console.log('Starting to Fetch Url', firstUrl);
                            // firstUrl = firstUrl.replace('/https/g', function(){ return ''});
                            // console.log(firstUrl);

                            var cachedValue = getFromUrlCache(firstUrl);
                            if(!!cachedValue){

                                setFetchedOgInfo( cachedValue );
                                showUrlOgInfoPreview();
                                emitFeedBoxHeightChange();

                            }else{

                                showLoading();
                                emitFeedBoxHeightChange();

                                doDigest();                    

                                utilsFactory.getOGDetails(firstUrl).success(function (data) {
                                    hideLoading();
                                    console.log('Server Response :', data);
                                    if (!!data && !!data.sucs) {
                                        setToUrlCache(firstUrl, data);
                                        data['lnkDmn'] = firstUrlDomain;
                                        data['url'] = firstUrl;

                                        data = fixFetchedOgInfo(data, firstUrl);

                                        setFetchedOgInfo(data);
                                        // filterImages();
                                        showUrlOgInfoPreview();

                                    }else{
                                        resetFetchedOgInfo();
                                        // resetFilterOnProgress();
                                        hideUrlOgInfoPreview();
                                    }


                                    emitFeedBoxHeightChange();
                                    
                                    doDigest();


                                }).error(function (data) {
                                    resetFetchedOgInfo();
                                    // resetFilterOnProgress();
                                    resetLastDetectedUrl();
                                    hideUrlOgInfoPreview();
                                    hideLoading();
                                    emitFeedBoxHeightChange();

                                    doDigest();
                                });
                            }

                        }



                    }else{
                        resetFetchedOgInfo();
                        hideUrlOgInfoPreview();

                    }
                    $scope.$parent.$rgDigest();
                }

                function fixUrl(url){
                    if(!url) return '';

                    if( url[url.length -1] != '/')
                        return url + '/';
                    return url;
                }
                function shouldProcessChange(url){

                    if(!$scope.fetchedOgInfo || lastDetectedUrl != url){
                        lastDetectedUrl = url;
                        return true;
                    }
                    console.log('Same Url Will Not Fetch');
                    return false;
                }

                function setToUrlCache(url, data){ urlCache[url] = data; }
                function getFromUrlCache(url){ urlCache[url]; }

                function setFetchedOgInfo(fetchedOgInfo) { $scope.fetchedOgInfo = fetchedOgInfo;  }
                function resetFetchedOgInfo() { $scope.fetchedOgInfo = {};  }

                function showLoading(){ $scope.loadingData = true; }
                function hideLoading(){ $scope.loadingData = false; }
                function isLoading(){ return $scope.loadingData; }

                function showUrlOgInfoPreview(){ $scope.showPreview = true; }
                function hideUrlOgInfoPreview(){ $scope.showPreview = false; }

                // function setFilterOnProgress(){ $scope.filterOnProgress = true; }
                // function resetFilterOnProgress(){ $scope.filterOnProgress = false;  }

                function resetLastDetectedUrl(){ lastDetectedUrl = '' }

                function startIdleDetectInterval(){
                    if(!idleInterval){
                        idleInterval = setInterval(function(){
                            if(detectIdleState()){
                                processModelUpdate($scope.editorContent);
                                clearIdleIteterval();
                            }
                        }, 2 * debounceLimit);
                    }

                }

                function clearIdleIteterval(){
                    clearInterval(idleInterval);
                }

                function fixFetchedOgInfo(fetchedOgInfo, requestedUrl) {
                    var fixedOgInfo = angular.extend({}, fetchedOgInfo);
                    if(!fixedOgInfo.url){
                        fixedOgInfo.url = requestedUrl;
                    }
                    if(!fixedOgInfo.title){
                        fixedOgInfo.title = fixedOgInfo.lnkDmn;
                    }

                    if( !!fetchedOgInfo.images ){
                        var len = fetchedOgInfo.images.length;
                        for(var index = 0; index < len; index++){
                            
                            if(settings.secure && /^http:/.test(fetchedOgInfo.images[index])){
                                fetchedOgInfo.images[index] = settings.httpsUrl + '/ImageProxy.png?url=' + fetchedOgInfo.images[index].replace(/http:\/\//,'');
                             }
                        }

                    }
                    fixedOgInfo.title = decodeEntities(fixedOgInfo.title);
                    fixedOgInfo.description = decodeEntities(fixedOgInfo.description);

                    return fixedOgInfo;
                }

                function emitFeedBoxHeightChange(){
                    $timeout(function(){
                        $rootScope.$broadcast('statusHeightChange');
                    });
                }

                // function setActiveImageInOgInfo(images){
                //     if(images.length > 0){
                //         $scope.fetchedOgInfo.image = images[0];
                //     }
                // }

                // function setImagesInOgInfo(images){
                //     $scope.fetchedOgInfo.images = images;
                // }

                

                function shouldProcessModelChange(newValue, oldValue){
                    // console.log($scope.fetchedOgInfo);

                    if( isLoading() ) return false;

                    if( !$scope.fetchedOgInfo ||
                        ( !$scope.fetchedOgInfo.image && !$scope.fetchedOgInfo.title && !$scope.fetchedOgInfo.description ) ){
                            resetLastDetectedUrl();
                            return true;
                    }

                    return false;

                }

                function detectIdleState(){
                    if( (Date.now() - lastSkipTime) > 1.5 * debounceLimit ){
                        return true;
                    }
                    return false;
                }


            }]
        };
    }

})();
(function () {
    'use strict';
    var ringUtilsModule;

    try {
        ringUtilsModule = angular.module('ringid.utils');
    } catch (e) {
        console.warn("Utils Module Not Found");
        return;
    }

    ringUtilsModule
        .directive('rgLoaderView', rgLoaderView);

    ringUtilsModule
        .directive('rgLoaderView1', rgLoaderView1);

    ringUtilsModule
        .directive('rgLoaderView2', rgLoaderView2);

    function rgLoaderView(){
        return {
            restrict: 'E',
            replace: true,
            scope : {
                isLoading : '='
            },
            templateUrl: 'pages/partials/loading_view.html'
        };
    }

    function rgLoaderView1(){
        return {
            restrict: 'E',
            replace: true,
            scope : {
                isLoading : '='
            },
            templateUrl: 'pages/partials/loading_view1.html'
        };
    }

    function rgLoaderView2(){
        return {
            restrict: 'E',
            replace: true,
            scope : {
                isLoading : '='
            },
            templateUrl: 'pages/partials/loading_view2.html'
        };
    }


})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
            .module('ringid.common.rgplayer_directive', [])
            .provider('$player', Player)
            .directive('rgPlayer', rgPlayer);

    function Player() {
        this.dicts = {
            'maximize': 'Back to normal view',
            'minimize': 'Go to small view',
            'fullScreen': 'Full Screen',
            'playlist': 'Playlist',
            'auto': 'Auto Play',
        };
        this.instances = [];
        this.template = '<div class="rg-player">'
                + '<div class="container">'
                + '<div class="play-info"></div>'
                + '<div class="play-error"></div>'
                + ' <div class="music-bars"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></div>'
                + '<div class="big-play"><span class="icon-player"></span></div>'
                + '<div class="loader">'
                + '<div class="circle1"></div>'
                + '<div class="circle2"></div>'
                + '<div class="circle3"></div>'
                + '</div>'
                + '<div class="player-poster">'
                + '<img class="poster" />'
                + '</div>'
                + '</div>'
                + '<div class="playlist-wrapper"></div>'
                + '<div class="media-control">'
                + '<div class="media-tip"></div>'
                + '<div class="media-control-bg"></div>'
                + '<div class="media-control-layer">'
                + '<div class="bar-panel">'
                + '<div class="bar-container">'
                + '<div class="bar-background">'
                + '<div class="bar-fill-1"></div>'
                + '<div class="bar-fill-2"></div>'
                + '<div class="bar-hover"></div>'
                + '</div>'
                + '<div class="bar-scrubber">'
                + '<div class="bar-scrubber-icon"></div>'
                + '</div>'
                + '<div class="seek-time">'
                + '<div class="timer"></div>'
                + '</div>'
                + '</div>'
                + '</div>'
                + '<div class="control-left">'
                + '<div class="play-btns">'
                + '<button class="icon-previous-p control-btn prev-btn"></button>'
                + '<button class="icon-play-p control-btn start-btn"></button>'
                + '<button class="icon-next-p control-btn next-btn"></button>'
                + '</div>'
                + '<div class="volume-bar">'
                + '<div class="icon-speaker-fill volume-icon unmute"></div>'
                + '<div class="volume-bar-container volume-bar-hide">'
                + '<div data-rel="0" class="bar fill"></div>'
                + '<div data-rel="1" class="bar fill"></div>'
                + '<div data-rel="2" class="bar fill"></div>'
                + '<div data-rel="3" class="bar fill"></div>'
                + '<div data-rel="4" class="bar"></div>'
                + '<div data-rel="5" class="bar"></div>'
                + '<div data-rel="6" class="bar"></div>'
                + '<div data-rel="7" class="bar"></div>'
                + '<div data-rel="8" class="bar"></div>'
                + '<div data-rel="9" class="bar"></div>'
                + '</div>'
                + '</div>'
                + '<div class="time-indicator time-running"></div>'
                + '<div class="time-indicator time-total"></div>'
                + '</div>'
                + '<div class="control-right">'
                + '<button class="control-btn hd">HD</button>'
                + '<button class="icon-minimize control-btn minimize" tooltip="' + this.dicts['minimize'] + '"></button>'
                + '<button class="icon-screen-f control-btn full-screen" tooltip="' + this.dicts['fullScreen'] + '"></button>'
                + '<button class="icon-play-list control-btn playlist-btn" tooltip="' + this.dicts['playlist'] + '"></button>'
                + '<button class="control-btn auto" tooltip="' + this.dicts['auto'] + '">AUTO</button>'
                + '</div>'
                + '</div>'
                + '</div>'
                + '</div>';

        this.trackTemplate = '<a rel="data-rel" href="#">'
                + '<span class="list-thumb"><img src="data-thumb" /></span>'
                + '<span class="list-title">data-caption<b>data-duration</b></span>'
                + '</a>';

        this.secToTime = function (seconds) {
            seconds = Math.floor(seconds);
            var hours = parseInt(seconds / 3600) % 24;
            var minutes = parseInt(seconds / 60) % 60;
            var seconds = (seconds < 0) ? 0 : seconds % 60;
            var result = '';
            if (hours > 0)
                result += (hours < 10 ? "0" + hours : hours);
            result += (minutes < 10 ? "0" + minutes : minutes) + ":" + (seconds < 10 ? "0" + seconds : seconds);
            return result;
        };

        this.findPos = function (el) {
            var x = 0, y = 0;
            if (el.offsetParent) {
                do {
                    x += el.offsetLeft;
                    y += el.offsetTop;
                } while (el = el.offsetParent);
            }
            return {x: x, y: y};
        };

        this.destroy = function (instance) {

            try {
                instance.removeEvent();
                instance.provider.pause();
                instance.provider.src = '';
                instance.dom = null;
                delete instance.provider;
                //delete instance;
            } catch (e) {
            }

        };

        this.addRemoveClass = function (el, add, remove) {
            var i;
            for (i = 0; i < remove.length; i++) {
                el.className = el.className.replace(remove[i], '').trim();
            }

            for (i = 0; i < add.length; i++) {
                el.className += ' ' + add[i];
            }
        };

        this.createMediaObject = function (type) {
            return  (type == 'audio') ? document.createElement('audio') : document.createElement('video');
        };

        this.getDefaultThumb = function(thumb) {
            
            if (!thumb || thumb == 'images/default_audio_image.jpg') {
              thumb = 'images/player-audio.png';  
            }

            return thumb;
        }

        this.$get = ['$compile', '$document',
            function ($compile, $document) {

                var $this = this, $playerProvider = {};

                $playerProvider.escapeKey = false;
                $playerProvider.miniPlayer = {dom: {container:null,move:null, resize: null, maximize : null, close : null}, parent: null, player: null};
                $playerProvider.wh = window.innerHeight;

                $playerProvider.destroy = function () {
                    if ($this.instances.length > 0)
                    {
                        $this.destroy($this.instances.pop());
                    }
                };

                $playerProvider.destroyAll = function () {
                    for (var i = $this.instances.length - 1; i >= 0; i--) {
                        $this.destroy($this.instances.pop());
                    }
                };

                $playerProvider.toggleMinMax = function () {
                    var player;
                    for (var i = $this.instances.length - 1; i >= 0; i--) {
                        if (!$this.instances[i].chat) {
                            player = $this.instances[i];
                            break;
                        }
                    }

                   player.minimize(); 
                }

                $playerProvider.showMiniPlayer = function () {
                    if ($playerProvider.miniPlayer.player) {
                        $playerProvider.miniPlayer.dom.container.appendChild($playerProvider.miniPlayer.player.parent)
                        $playerProvider.miniPlayer.dom.container.style.display = 'block';

                        if ($playerProvider.miniPlayer.player.playingState == 'PLAYING') {
                            setTimeout(function(){
                               $playerProvider.miniPlayer.player.provider.play(); 
                            });
                        }
                    }
                }

                $playerProvider.closeMiniPlayer = function () {
                    if ($playerProvider.miniPlayer.player) {
                        $playerProvider.ringboxRemove();
                        $playerProvider.destroy();
                        $playerProvider.miniPlayer.dom.container.parentNode.removeChild($playerProvider.miniPlayer.dom.container);
                        $playerProvider.miniPlayer.dom = {container:null,move:null, resize: null, maximize : null, close : null};
                        $playerProvider.miniPlayer.player = null;
                    }
                }


                $playerProvider.addToPlaylist = function (playlist) {

                    for (var i = $this.instances.length - 1; i >= 0; i--) {
                        if (!$this.instances[i].chat) {
                            $this.instances[i].AddToPlaylist(playlist);
                            break;
                        }
                    }
                }

                $playerProvider.player = function (option) {


                    $playerProvider.ringboxRemove = (option.ringboxRemove) ? option.ringboxRemove : function () {};

                    if (!option.chatVersion) {
                        $playerProvider.closeMiniPlayer();
                    }

                    var $player = {};
                    $player.source = option.source || '';
                    $player.autoPlay = option.autoPlay || false;
                    $player.showMinMax = option.showMinMax || false;
                    $player.auto = option.auto || false;
                    $player.parent = document.getElementById(option.parentId);
                    $player.poster = option.poster || '';
                    $player.mediaType = option.type || 'video';
                    $player.dom = {};
                    $player.playingState = (this.autoPlay) ? 'INIT' : 'STOPPED';
                    $player.screenState = 'NORMAL';
                    $player.volumeState = 'UNMUTE';
                    $player.volume = 5;
                    $player.duration = 0;
                    $player.currentTrack = 0;
                    $player.playlist = option.playlist || [];
                    $player.title = option.title || '';
                    $player.playlistState = false;
                    $player.hd = false;
                    $player.isMouseDown = false;
                    $player.isLoading = $player.autoPlay;
                    $player.isFirefox = !!(navigator.userAgent.match(/firefox/i));
                    $player.canPlay = true;
                    $player.chat = !!option.chatVersion;

                    $player.provider = $this.createMediaObject($player.mediaType);

                    $player.parent.innerHTML = $this.template;

                    $player.dom.player = $player.parent.querySelector('.rg-player');
                    $player.dom.container = $player.parent.querySelector('.container');
                    $player.dom.playlistWrap = $player.parent.querySelector('.playlist-wrapper');
                    $player.dom.control = $player.parent.querySelector('.media-control');
                    $player.dom.bigBlay = $player.dom.container.querySelector('.big-play');
                    $player.dom.bigBlayIcon = $player.dom.bigBlay.querySelector('span');
                    $player.dom.playError = $player.dom.container.querySelector('.play-error');
                    $player.dom.playInfo = $player.dom.container.querySelector('.play-info');
                    $player.dom.musicBar = $player.dom.container.querySelector('.music-bars');
                    $player.dom.loader = $player.dom.container.querySelector('.loader');
                    $player.dom.poster = $player.dom.container.querySelector('.player-poster');
                    $player.dom.posterImg = $player.dom.poster.querySelector('.poster');
                    $player.dom.barContainer = $player.dom.control.querySelector('.bar-container');
                    $player.dom.barScrubber = $player.dom.control.querySelector('.bar-scrubber');
                    $player.dom.barLoaded = $player.dom.control.querySelector('.bar-fill-1');
                    $player.dom.barPosition = $player.dom.control.querySelector('.bar-fill-2');
                    $player.dom.barHover = $player.dom.control.querySelector('.bar-hover');
                    $player.dom.controlLayer = $player.dom.control.querySelector('.media-control-layer');
                    $player.dom.controlBG = $player.dom.control.querySelector('.media-control-bg');
                    $player.dom.controlTip = $player.dom.control.querySelector('.media-tip');
                    $player.dom.playBtn = $player.dom.control.querySelector('.start-btn');
                    $player.dom.nextBtn = $player.dom.control.querySelector('.next-btn');
                    $player.dom.prevBtn = $player.dom.control.querySelector('.prev-btn');
                    $player.dom.timeRunning = $player.dom.control.querySelector('.time-running');
                    $player.dom.timeTotal = $player.dom.control.querySelector('.time-total');
                    $player.dom.hd = $player.dom.control.querySelector('.hd');
                    $player.dom.playlistBtn = $player.dom.control.querySelector('.playlist-btn');
                    $player.dom.minimize = $player.dom.control.querySelector('.minimize');
                    $player.dom.auto = $player.dom.control.querySelector('.auto');
                    $player.dom.volumeIcon = $player.dom.control.querySelector('.volume-icon');
                    $player.dom.volumeBarContainer = $player.dom.control.querySelector('.volume-bar-container');
                    $player.dom.volumeBars = $player.dom.volumeBarContainer.querySelectorAll('.bar');
                    $player.dom.fullScreenBtn = $player.dom.control.querySelector('.full-screen');
                    $player.dom.seekTimer = $player.dom.control.querySelector('.seek-time');
                    $player.dom.timer = $player.dom.control.querySelector('.timer');
                    $player.dom.playlist = null;


                    $player.dom.player.style.width = (option.width) ? option.width + 'px' : '100%';
                    $player.dom.player.style.height = (option.height) ? option.height + 'px' : '100%';
                    $player.dom.timeRunning.innerHTML = '00:00';
                    $player.dom.timeTotal.innerHTML = '00:00';

                    if (option.chatVersion || !$player.showMinMax) {
                       $player.dom.minimize.style.display = 'none';
                    }
                        
                    $player.dom.poster.appendChild($player.provider);

                    $playerProvider.miniPlayer.parent = $player.parent.parentNode;


                    /* DOM event methods */
                    function playerFullScreen() {
                        var isFullScreen = document.mozFullScreen || document.webkitIsFullScreen;
                        if (!isFullScreen && $player.screenState == 'FULL') {
                            $player.fullScreen();
                        }
                    };
                    function playerKeyEvt(evt) {
                        var keyCode = evt.which || evt.keyCode || evt.key;
                        if ($playerProvider.miniPlayer.player) return; 
                        if (keyCode === 32) {
                            $player.playPause();
                        }
                    };


                    function clickPlayBtnCallback(e) {
                        e.stopPropagation();
                        $player.playPause();
                    }

                    function clickNextBtnCallback(e) {
                        e.stopPropagation();
                        $player.playNext();
                    }

                    function clickPrevBtnCallback(e) {
                       e.stopPropagation();
                       $player.playPrev();
                    }

                    function clickVolumeCallback(e) {
                        e.stopPropagation();
                        $player.muteUnmute();
                    }

                    function clickFullScreenCallback(e) {
                        e.stopPropagation();
                        $player.fullScreen();
                    }

                    function clickMinimizeCallback(e) {
                       e.stopPropagation();
                       $player.minimize();
                    }

                    function mousemoveBarCallback(e) {
                       $player.timeInfo(e);
                       if ($player.isMouseDown) {
                         $player.setPosition(e, false); 
                       }
                    }

                    function mousedownBarCallback(e) {
                       $player.isMouseDown = true;
                       $this.addRemoveClass($player.dom.barContainer, ['down'], []);
                    }

                    function mouseupBarCallback(e) {
                       $player.isMouseDown = false;
                       $player.setPosition(e, true);
                       $this.addRemoveClass($player.dom.barContainer, [], ['down']);
                    }

                    function mouseleaveBarCallback(e) {
                        $player.isMouseDown = false;
                        $this.addRemoveClass($player.dom.barContainer, [], ['down']);
                    }

                    function clickContainerCallback(e) {
                        e.stopPropagation();
                        if ($player.playlistState) {
                            $player.showPlaylist(false);
                            return;
                        }
                        $player.playPause();
                    }

                    function mouseoverPlayerCallback(e) {
                         e.stopPropagation();
                         $player.showControl(true);
                    }

                    function mouseleavePlayerCallback(e) {
                        e.stopPropagation();
                        $player.showControl(false);
                    }

                    function clickPlaylistCallback(e) {
                        e.stopPropagation();

                        if ($playerProvider.miniPlayer.player) {
                            $player.maximize();
                        }

                        $player.showPlaylist();
                     }

                     function clickAutoCallback(e) {
                        e.stopPropagation();
                        $player.setAuto();
                     }

                    function mouseoverAutoCallback(e) {
                        e.stopPropagation();
                        $player.showTootip(e,this.getAttribute('tooltip'));
                     }

                    function mouseleaveAutoCallback(e) {
                        e.stopPropagation();
                        $player.dom.controlTip.style.display = 'none';
                     }

                     function mouseoverMinimizeCallback(e) {
                       e.stopPropagation();
                       $player.showTootip(e,this.getAttribute('tooltip'));
                     }

                     function mouseleaveMinimizeCallback(e) {
                        e.stopPropagation();
                        $player.dom.controlTip.style.display = 'none';
                     }

                     function mouseoverFullCallback(e) {
                         e.stopPropagation();
                         $player.showTootip(e,this.getAttribute('tooltip'));
                     }

                     function mouseleaveFullCallback(e) {
                        e.stopPropagation();
                        $player.dom.controlTip.style.display = 'none';
                     }

                     function mouseoverPlaylistCallback(e) {
                        e.stopPropagation();
                        $player.showTootip(e,this.getAttribute('tooltip'));
                     }

                     function mouseleavePlaylistCallback(e) {
                        e.stopPropagation();
                        $player.dom.controlTip.style.display = 'none';
                     }

                     function clickVolumeBarCallback(e) {
                        e.stopPropagation();
                        var volume = parseInt(this.getAttribute('data-rel'));
                        $player.changeVolume(volume);
                      }

                     /* Callback for minimize version*/
                      
                     var mouseMove = false, fromMouseMove=false, mouseResize = false, pw = 350, ph = 120,
                         wh = window.innerHeight, ww = window.innerWidth, ol, ot, py;

                     function moveDOCCallbackMoving(event) {
                            fromMouseMove = true;
                            if (mouseMove) {

                                fastdom.read(function () {
                                    if(!$playerProvider.miniPlayer.dom.resize) return;
                                    document.body.style.cursor = 'move';
                                    $playerProvider.miniPlayer.dom.resize.style.cursor = 'move';
                                    $player.dom.container.style.cursor = 'move';
                                    fastdom.write(function () {
                                        if ((event.clientX + ol) >= 200 && (event.clientX + ol) <= (ww - pw - 210)) {
                                            $playerProvider.miniPlayer.dom.container.style.left = (event.clientX + ol) + 'px';
                                        }

                                        if ((event.clientY + ot) >= 50 && (event.clientY + ot) <= (wh - ph)) {
                                            $playerProvider.miniPlayer.dom.container.style.top = (event.clientY + ot) + 'px';
                                        }
                                    });
                                });
                            }
                     }

                     function upDOCCallbackMoving(event) {
                        event.stopPropagation();
                        mouseMove = false;
                        document.body.style.cursor = 'default';
                        $playerProvider.miniPlayer.dom.resize.style.cursor = 'ns-resize';
                        $player.dom.container.style.cursor = 'pointer';
                        document.removeEventListener('mousemove', moveDOCCallbackMoving);
                        document.removeEventListener('mouseup', upDOCCallbackMoving);
                     }    

                     function mousedownMoveCallback(e) {
                            e.preventDefault();
                            e.stopPropagation();

                            mouseMove = true;
                            ww = window.innerWidth,
                            wh = window.innerHeight,
                            ol = $playerProvider.miniPlayer.dom.container.offsetLeft - e.clientX,
                            ot = $playerProvider.miniPlayer.dom.container.offsetTop - e.clientY;

                            document.addEventListener('mousemove', moveDOCCallbackMoving, false);
                            document.addEventListener('mouseup', upDOCCallbackMoving, false);
                     }

                     function clickMoveCallback(e) {

                        if(fromMouseMove) {
                           fromMouseMove = false;
                           return; 
                        } 
                        $player.playPause();
                     }

                    function moveDOCCallbackResizing(event) {
                                
                         if (mouseResize) {

                            fastdom.read(function () {

                                if(!$playerProvider.miniPlayer.dom.container) return;
                                
                                var height = $playerProvider.miniPlayer.dom.container.offsetHeight;
                                var top = parseInt($playerProvider.miniPlayer.dom.container.style.top.replace('px', ''));

                                fastdom.write(function () {
                                    document.body.style.cursor = 'ns-resize';
                                    $playerProvider.miniPlayer.dom.move.style.cursor = 'ns-resize';
                                    $player.dom.container.style.cursor = 'ns-resize';

                                    if (py >= event.clientY && height < 250) {
                                        height = height + 3;
                                        top = top - 3;
                                        $playerProvider.miniPlayer.dom.container.style.height = height + 'px';
                                        $playerProvider.miniPlayer.dom.container.style.top = top + 'px';
                                        py = event.clientY;
                                    }

                                    if (py < event.clientY && height > 120) {
                                        height = height - 3;
                                        top = top + 3;
                                        $playerProvider.miniPlayer.dom.container.style.height = height + 'px';
                                        $playerProvider.miniPlayer.dom.container.style.top = top + 'px';
                                        py = event.clientY;
                                    }

                                });
                            });
                         }
                     }

                     function upDOCCallbackResizing(event) {
                        event.stopPropagation();
                        mouseResize = false;
                        document.body.style.cursor = 'default';
                        $playerProvider.miniPlayer.dom.move.style.cursor = 'move';
                        $player.dom.container.style.cursor = 'pointer';
                        document.removeEventListener('mousemove', moveDOCCallbackResizing);
                        document.removeEventListener('mouseup', upDOCCallbackResizing);
                    }

                     function mousedownResizeCallback(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            mouseResize = true;
                            ww = window.innerWidth,
                            wh = window.innerHeight,
                            py = e.clientY;

                            document.addEventListener('mousemove', moveDOCCallbackResizing, false);
                            document.addEventListener('mouseup', upDOCCallbackResizing, false);
                     }

                     function clickMiniMaxBtnCallback(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $player.maximize();
                     }

                     function clickMiniCloseBtnCallback(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        $playerProvider.closeMiniPlayer();
                     }  

                    /* End of dom events */

                    $player.initEvent = function () {

                        $player.dom.playBtn.addEventListener('click', clickPlayBtnCallback, false);
                        $player.dom.nextBtn.addEventListener('click', clickNextBtnCallback , false);
                        $player.dom.prevBtn.addEventListener('click', clickPrevBtnCallback, false);
                        $player.dom.volumeIcon.addEventListener('click', clickVolumeCallback , false);
                        $player.dom.fullScreenBtn.addEventListener('click', clickFullScreenCallback, false);
                        $player.dom.minimize.addEventListener('click', clickMinimizeCallback , false);
                        $player.dom.barContainer.addEventListener('mousemove', mousemoveBarCallback , false);
                        $player.dom.barContainer.addEventListener('mousedown', mousedownBarCallback , false);
                        $player.dom.barContainer.addEventListener('mouseup', mouseupBarCallback , false);
                        $player.dom.barContainer.addEventListener('mouseleave', mouseleaveBarCallback, false);
                        $player.dom.container.addEventListener('click', clickContainerCallback , false);
                        $player.dom.player.addEventListener('mouseover', mouseoverPlayerCallback , false);
                        $player.dom.player.addEventListener('mouseleave', mouseleavePlayerCallback , false);
                        $player.dom.playlistBtn.addEventListener('click', clickPlaylistCallback , false);
                        $player.dom.auto.addEventListener('click', clickAutoCallback , false);

                        for (var i = 0; i < $player.dom.volumeBars.length; i++) {
                            $player.dom.volumeBars[i].addEventListener('click', clickVolumeBarCallback);
                        }

                        /* tooptip event */
                        $player.dom.auto.addEventListener('mouseover', mouseoverAutoCallback , false);
                        $player.dom.auto.addEventListener('mouseleave', mouseleaveAutoCallback , false);
                        /* tooptip event */
                        $player.dom.minimize.addEventListener('mouseover', mouseoverMinimizeCallback , false);
                        $player.dom.minimize.addEventListener('mouseleave', mouseleaveMinimizeCallback , false);
                        /* tooptip event */
                        $player.dom.fullScreenBtn.addEventListener('mouseover', mouseoverFullCallback , false);
                        $player.dom.fullScreenBtn.addEventListener('mouseleave', mouseleaveFullCallback , false);
                        /* tooptip event */
                        $player.dom.playlistBtn.addEventListener('mouseover', mouseoverPlaylistCallback , false);
                        $player.dom.playlistBtn.addEventListener('mouseleave', mouseleavePlaylistCallback , false);

                        

                        // document events
                        document.addEventListener("mozfullscreenchange", playerFullScreen, false);
                        document.addEventListener("webkitfullscreenchange", playerFullScreen, false);
                        document.addEventListener("fullscreenchange", playerFullScreen, false);
                        document.addEventListener("keyup", playerKeyEvt, false);

                        $player.setMediaEvent();
                        $player.createPlaylist();
                        $player.showPoster(true);

                        if ($player.auto) {
                            $player.setAuto(true);
                        }

                    };


                    $player.setMediaEvent = function () {

                        $player.provider.addEventListener('loadedmetadata', function (event, data) {
                            $player.initTime($player.provider.duration);

                            if ($player.autoPlay)
                                $player.play();
                        });

                        $player.provider.addEventListener('progress', function () {

                            var buffered = $player.provider.buffered.length > 0 ? $player.provider.buffered.end($player.provider.buffered.length - 1) : 0;
                            var bufferState = ($player.provider.currentTime + 0.05) >= buffered ? 'BUFFERING' : 'PLAYING_BUFFERING';

                            $player.showBuffered(buffered, $player.provider.duration);
                            $player.stateChanged(bufferState);

                        });

                        $player.provider.addEventListener('timeupdate', function () {
                            if (!$player.provider || $player.isMouseDown)
                                return;
                            $player.showPosition($player.provider.currentTime, $player.provider.duration);
                        });

                        $player.provider.addEventListener('play', function () {
                            $player.stateChanged('PLAYING');

                            if ($player.mediaType == 'video') {
                                $player.showPoster(false);
                            }

                            if (angular.isFunction(option.scope.onStart())) {
                                option.scope.onStart()();
                            }
                        });

                        $player.provider.addEventListener('pause', function () {
                            $player.stateChanged('PAUSED');

                            if ($player.mediaType == 'video') {
                                $player.showPoster(false);
                            }
                        });

                        $player.provider.addEventListener('ended', function () {
                            $player.stateChanged('ENDED');

                            if ($player.mediaType == 'video') {
                                $player.showPoster(false);
                            }

                            if (angular.isFunction(option.scope.onEnded())) {
                                option.scope.onEnded()();
                            }
                        });

                        $player.provider.addEventListener('stalled', function () {
                            if (!$player.provider)
                                return;
                            // $player.error = 'Media not availble';
                            //$player.canPlay = false;
                            // $player.showError();
                        });

                        $player.provider.addEventListener('error', function () {
                            if (!$player.provider)
                                return;
                            $player.error = $player.provider.error.code;
                            $player.canPlay = false;
                            $player.showError();
                        });

                    };

                    $player.removeEvent = function () {

                        $player.dom.playBtn.removeEventListener('click', clickPlayBtnCallback);
                        $player.dom.nextBtn.removeEventListener('click', clickNextBtnCallback);
                        $player.dom.prevBtn.removeEventListener('click', clickPrevBtnCallback);
                        $player.dom.volumeIcon.removeEventListener('click', clickVolumeCallback);
                        $player.dom.fullScreenBtn.removeEventListener('click', clickFullScreenCallback);
                        $player.dom.minimize.removeEventListener('click', clickMinimizeCallback);
                        $player.dom.barContainer.removeEventListener('mousemove', mousemoveBarCallback);
                        $player.dom.barContainer.removeEventListener('mousedown', mousedownBarCallback);
                        $player.dom.barContainer.removeEventListener('mouseup', mouseupBarCallback);
                        $player.dom.barContainer.removeEventListener('mouseleave', mouseleaveBarCallback);
                        $player.dom.container.removeEventListener('click', clickContainerCallback);
                        $player.dom.player.removeEventListener('mouseover', mouseoverPlayerCallback);
                        $player.dom.player.removeEventListener('mouseleave', mouseleavePlayerCallback);
                        $player.dom.playlistBtn.removeEventListener('click', clickPlaylistCallback);
                        $player.dom.auto.removeEventListener('click', clickAutoCallback);

                        for (var i = 0; i < $player.dom.volumeBars.length; i++) {
                          $player.dom.volumeBars[i].removeEventListener('click', clickVolumeBarCallback);
                        }

                        $player.dom.auto.removeEventListener('mouseover', mouseoverAutoCallback);
                        $player.dom.auto.removeEventListener('mouseleave', mouseleaveAutoCallback);
                        $player.dom.minimize.removeEventListener('mouseover', mouseoverMinimizeCallback);
                        $player.dom.minimize.removeEventListener('mouseleave', mouseleaveMinimizeCallback);
                        $player.dom.fullScreenBtn.removeEventListener('mouseover', mouseoverFullCallback);
                        $player.dom.fullScreenBtn.removeEventListener('mouseleave', mouseleaveFullCallback);
                        $player.dom.playlistBtn.removeEventListener('mouseover', mouseoverPlaylistCallback);
                        $player.dom.playlistBtn.removeEventListener('mouseleave', mouseleavePlaylistCallback);

                        document.removeEventListener("mozfullscreenchange", playerFullScreen);
                        document.removeEventListener("webkitfullscreenchange", playerFullScreen);
                        document.removeEventListener("fullscreenchange", playerFullScreen);
                        document.removeEventListener("keyup", playerKeyEvt);
                    };

                    $player.maximize = function () {

                        if ($playerProvider.miniPlayer.player) {
                            option.ringboxMaximize($playerProvider.miniPlayer.parent, $player.parent);

                            if ($player.playingState == 'PLAYING') {
                                setTimeout(function(){
                                   $player.provider.play();  
                                });
                            }

                            $playerProvider.miniPlayer.dom.move.removeEventListener('mousedown', mousedownMoveCallback);
                            $playerProvider.miniPlayer.dom.move.removeEventListener('click', clickMoveCallback);
                            $playerProvider.miniPlayer.dom.resize.removeEventListener('mousedown', mousedownResizeCallback);
                            $playerProvider.miniPlayer.dom.close.removeEventListener('click', clickMiniCloseBtnCallback);
                            $playerProvider.miniPlayer.dom.maximize.removeEventListener('click', clickMiniMaxBtnCallback);

                            $playerProvider.miniPlayer.dom.container.parentNode.removeChild($playerProvider.miniPlayer.dom.container);
                            $playerProvider.miniPlayer.dom = {container:null,move:null, resize: null, maximize : null, close : null};
                            $playerProvider.miniPlayer.player = null;
                            $this.addRemoveClass($player.dom.minimize, ['icon-minimize'], ['icon-maximize']);
                            $player.dom.fullScreenBtn.style.display = 'block';
                            $player.dom.minimize.setAttribute('tooltip', $this.dicts['minimize']);
                            return;
                        }
                    };


                    $player.minimize = function () {


                        if ($playerProvider.miniPlayer.player) {
                            $player.maximize();
                            return;
                        }

                        var mini = document.createElement('div'),
                            maxBtn = document.createElement('a'),
                            moveDiv = document.createElement('div'),
                            resizeDiv = document.createElement('div'),
                            closeBtn = document.createElement('a');

                        closeBtn.setAttribute('class', 'mini-close');
                        closeBtn.innerHTML = '<div class="icon-close pop-close"></div>';

                        maxBtn.setAttribute('class', 'maximize icon-maximize');
                        maxBtn.setAttribute('style', 'position: absolute;right: 22px;top: 5px;color: #fff;');
                        
                        moveDiv.setAttribute('class', 'move-player');
                        moveDiv.appendChild(maxBtn);
                        moveDiv.appendChild(closeBtn);

                        mini.setAttribute('id', 'mini-player');
                        mini.setAttribute('class', 'mini-player');

                        resizeDiv.setAttribute('class', 'resize-player');

                        mini.style.display = 'none';
                        mini.appendChild(moveDiv);
                        mini.appendChild(resizeDiv);
                        document.body.appendChild(mini);

                        $player.showPlaylist(true);
                        $player.showControl(true);

                        $playerProvider.miniPlayer.dom.container = mini;
                        $playerProvider.miniPlayer.dom.resize = resizeDiv;
                        $playerProvider.miniPlayer.dom.move = moveDiv;
                        $playerProvider.miniPlayer.dom.close = closeBtn;
                        $playerProvider.miniPlayer.dom.maximize = maxBtn;
                        $playerProvider.miniPlayer.player = $player;
                        $player.dom.minimize.setAttribute('tooltip', $this.dicts['maximize']);

                        option.ringboxMinimize();

                        wh = ($player.screenState == 'FULL') ? $playerProvider.wh : window.innerHeight;

                        mini.style.top = (wh - ph) + 'px';
                        $this.addRemoveClass($player.dom.minimize, ['icon-maximize'], ['icon-minimize']);
                        $player.dom.fullScreenBtn.style.display = 'none';


                        closeBtn.addEventListener('click', clickMiniCloseBtnCallback, false);
                        maxBtn.addEventListener('click', clickMiniMaxBtnCallback, false);

                        /*Move player*/
                        moveDiv.addEventListener('mousedown', mousedownMoveCallback, false);
                        moveDiv.addEventListener('click', clickMoveCallback, false);
                        /*resize player*/
                        resizeDiv.addEventListener('mousedown', mousedownResizeCallback, false);
                        
                        /*remove reference*/
                        closeBtn = maxBtn = resizeDiv = moveDiv= mini= null;   
                    };

                    $player.playPause = function () {

                        if (!$player.canPlay)
                            return;

                        if ($player.playingState == 'PLAYING') {
                            $player.pause();
                            $player.showLoader();
                            $player.showBigPlay();
                            $player.showControl(false);
                            $player.showPlaylist(true);
                            $player.showInfo(true);
                            return;
                        }

                        if ($player.playingState == 'PAUSED') {
                            $player.resume();
                            $player.showLoader();
                            $player.showBigPlay();
                            $player.showInfo();
                            return;
                        }

                        if ($player.playingState == 'STOPPED') {
                            $player.play();
                            $player.showLoader();
                            $player.showBigPlay();
                            $player.showPlaylist(true);
                            $player.showInfo();
                            return;
                        }

                    };

                    $player.muteUnmute = function () {

                        if ($player.volumeState == 'UNMUTE') {
                            $player.setVolume(0);
                            $this.addRemoveClass($player.dom.volumeIcon, ['icon-speaker-m'], ['icon-speaker-fill']);
                            $player.volumeState = 'MUTE';
                            return;
                        }

                        if ($player.volumeState == 'MUTE') {
                            $player.setVolume($player.volume);
                            $this.addRemoveClass($player.dom.volumeIcon, ['icon-speaker-fill'], ['icon-speaker-m']);
                            $player.volumeState = 'UNMUTE';
                            return;
                        }
                    };

                    $player.initTime = function (duration) {
                        $player.dom.timeTotal.innerHTML = $this.secToTime(duration);
                        $player.duration = duration;
                    };

                    $player.showPosition = function (position, duration) {

                        if ($player.duration == 0 && duration > 0) {
                            $player.initTime(duration);
                        }

                        if (position > duration) {
                            $player.initTime(position);
                        }

                        $player.dom.timeRunning.innerHTML = $this.secToTime(position);
                        $player.dom.barScrubber.style.left = ($player.duration == 0) ? '-' + ($player.dom.barScrubber.offsetWidth / 2) + 'px' : 'calc(' + ((position / $player.duration) * 100) + '% - ' + ($player.dom.barScrubber.offsetWidth / 2) + 'px)';
                        $player.dom.barPosition.style.width = ($player.duration == 0) ? '0%' : ((position / $player.duration) * 100) + '%';
                    };

                    $player.showBuffered = function (buffered, duration) {

                        if ($player.duration == 0 && duration > 0) {
                            $player.initTime(duration);
                        }
                        $player.dom.barLoaded.style.width = ($player.duration == 0) ? '0%' : ((buffered / $player.duration) * 100) + '%';
                    };

                    $player.timeInfo = function (event) {

                        var pos = ($player.screenState == 'FULL') ? {'x':0, 'y':0 } : $this.findPos($player.dom.barContainer);
                        var diff = event.pageX - pos.x;
                        var curTime = Math.round((diff * $player.duration) / $player.dom.barContainer.offsetWidth);
                        if (curTime < 0)
                            curTime = 0;
                        $player.dom.timer.innerHTML = $this.secToTime(curTime);
                        $player.dom.seekTimer.style.left = (diff - $player.dom.seekTimer.offsetWidth / 2) + 'px';
                        $player.dom.barHover.style.left = (diff - $player.dom.barHover.offsetWidth / 2) + 'px';
                    };

                     $player.showTootip = function (event, text) {
                        var pos = ($player.screenState == 'FULL') ? {'x':0, 'y':0 } : $this.findPos($player.dom.barContainer);
                        var diff = event.pageX - pos.x;
                        $player.dom.controlTip.innerHTML = text;

                        $player.dom.controlTip.style.display = 'block';
                        var pw = $player.dom.barContainer.offsetWidth, tw = $player.dom.controlTip.offsetWidth;
                        diff =  pw <= (tw/2 + diff) ? (pw - tw/2) : diff;
                        $player.dom.controlTip.style.left = (diff - tw/2) + 'px';
                    };

                    $player.setPosition = function (event, seek) {

                        if ($player.playingState == 'STOPPED' || !$player.canPlay)
                            return;

                        var pos = ($player.screenState == 'FULL') ? {'x':0, 'y':0 } : $this.findPos($player.dom.barContainer);
                        var diff = event.pageX - pos.x;
                        var curTime = Math.round((diff * $player.duration) / $player.dom.barContainer.offsetWidth);
                        if (seek)
                            $player.seek(curTime);
                        $player.showPosition(curTime);
                    };

                    $player.changeVolume = function (volume) {

                        var i;
                        for (i = 0; i < $player.dom.volumeBars.length; i++) {
                            $this.addRemoveClass($player.dom.volumeBars[i], [], ['fill']);
                        }
                        for (i = 0; i <= volume; i++) {
                            $this.addRemoveClass($player.dom.volumeBars[i], ['fill'], []);
                        }

                        $player.volume = volume + 1;

                        /* if mute and try to change volume, then unmute*/
                        if ($player.volumeState == 'MUTE') {
                            $player.muteUnmute();
                            return;
                        }

                        $player.setVolume($player.volume);
                    };

                    $player.showHD = function () {

                        /* keeping it for future
                         var currentLevel = $player.levels[level]
                         if (currentLevel) {
                         $player.hd = (currentLevel.height >= 720 || (currentLevel.bitrate / 1000) >= 2000);
                         }*/

                        if ($player.hd) {
                            $player.dom.hd.style.display = 'inline-block';
                        } else {
                            $player.dom.hd.style.display = 'none';
                        }
                    };


                    $player.showPoster = function (show) {

                        if ($player.poster == '')
                            return;

                        if (show) {
                            $player.dom.posterImg.src = $player.poster;
                            $player.dom.posterImg.style.display = 'inline-block';
                        }
                        else {
                            $player.dom.posterImg.style.display = 'none';
                        }
                    };

                    $player.showInfo = function (force) {

                        if ($player.title == '' || $player.mediaType != 'audio' || force) {
                            $player.dom.playInfo.style.display = 'none';
                        }
                        else {
                            $player.dom.playInfo.innerHTML = $player.title;
                            $player.dom.playInfo.style.display = 'block';
                        }

                        if($player.playlist.length > 0) {

                            var thumb = $player.playlist[$player.currentTrack].value.getThumb();
                            thumb = $this.getDefaultThumb(thumb);

                            $player.poster = thumb;

                            if($player.mediaType == 'audio') {
                              $player.showPoster(true);   
                            }
                        }

                    };


                    $player.showLoader = function () {
                        if ($player.isLoading && $player.canPlay)
                            $player.dom.loader.style.display = 'block';
                        else
                            $player.dom.loader.style.display = 'none';

                        $player.showMusicBar();
                        $player.showBigPlay();
                    };

                    $player.showError = function () {

                        $player.dom.playError.innerHTML = 'Sorry, your browser does not support this media format.';
                        $player.showLoader();

                        if (!$player.canPlay) {
                            $player.showPoster(false);
                            $player.dom.playError.style.display = 'block';
                        }
                        else {
                            $player.dom.playError.style.display = 'none';
                        }
                    };

                    $player.showBigPlay = function (replay) {

                        if (!$player.canPlay) {
                            $player.dom.bigBlay.style.display = 'none';
                            return;
                        }

                        if (replay) {
                            $this.addRemoveClass($player.dom.bigBlayIcon, ['icon-reload-p'], []);
                        }
                        else {
                            $this.addRemoveClass($player.dom.bigBlayIcon, [], ['icon-reload-p']);
                        }

                        if (($player.playingState == 'PAUSED' || $player.playingState == 'STOPPED') && !$player.isLoading) {
                            $player.dom.bigBlay.style.display = 'block';
                        }
                        else {
                            $player.dom.bigBlay.style.display = 'none';
                        }

                        $player.showMusicBar();
                    };

                    $player.initPlaylist = function () {

                        if (($player.playlist.length > 1)) {
                            $player.dom.playlistBtn.style.display = 'inline-block';
                            $player.dom.prevBtn.style.display = 'inline-block';
                            $player.dom.nextBtn.style.display = 'inline-block';
                            $player.dom.auto.style.display = 'inline-block';
                        }
                        else {
                            $player.dom.playlistBtn.style.display = 'none';
                            $player.dom.prevBtn.style.display = 'none';
                            $player.dom.nextBtn.style.display = 'none';
                            $player.dom.auto.style.display = 'none';
                        }

                        $player.dom.playlistWrap.style.right = '-250px';
                    };

                    $player.showPlaylist = function (forceHide) {


                        if ($player.playlistState || forceHide) {
                            $player.dom.playlistWrap.style.right = '-250px';
                            $player.dom.playlistWrap.style.zIndex = 999;
                            $player.playlistState = false;
                            return;
                        }

                        if (!$player.playlistState) {
                            $player.dom.playlistWrap.style.right = '0';
                            $player.dom.playlistWrap.style.zIndex = 10000;
                            $player.playlistState = true;
                            return;
                        }

                    };



                    $player.createPlaylist = function () {

                        if ($player.playlist.length < 2)
                            return;

                        var thumb, track,
                                playlist = '<div class="playlist-scrollbar-wrapper">'
                                + '<div rg-scrollbar="true" class="playlist-scrollbar">'
                                + '<ul class="playlist">';

                        for (var i = 0; i < $player.playlist.length; i++) {
                            thumb = $player.playlist[i].value.getThumb();
                            thumb = $this.getDefaultThumb(thumb);
                           
                            track = $this.trackTemplate.replace(/data-rel/g, i);
                            track = track.replace(/data-thumb/g, thumb);
                            track = track.replace(/data-caption/g, $player.playlist[i].value.getCaption());
                            track = track.replace(/data-duration/g, $this.secToTime($player.playlist[i].value.getDuration()));

                            if ($player.source == $player.playlist[i].value.getStreamUrl()) {
                                $player.currentTrack = i;
                            }

                            playlist += '<li>' + track + '</li>';
                        }

                        playlist += '</ul></div></div>';

                        $player.dom.playlistWrap.innerHTML = '';
                        $player.dom.playlistWrap.appendChild($compile(playlist)(option.scope)[0]);
                        $player.dom.playlistUL = $player.dom.playlistWrap.querySelector('.playlist');

                        $player.dom.playlist = $player.dom.playlistWrap.querySelectorAll('ul.playlist > li > a');

                        option.scope.$parent.$rgDigest();

                        for (var i = 0; i < $player.dom.playlist.length; i++) {
                            $player.dom.playlist[i].addEventListener('click', function (e) {
                                e.preventDefault();
                                $player.currentTrack = this.getAttribute('rel');
                                $player.title = $player.playlist[$player.currentTrack].value.getCaption();
                                $player.load($player.playlist[$player.currentTrack].value.getStreamUrl());
                            });
                        }

                    };

                    $player.updatePlaylist = function (playlist) {

                        if (!playlist)
                            return;

                        $player.playlist = playlist;
                        $player.createPlaylist();
                    };

                    $player.AddToPlaylist = function (playlist) {

                        var thumb, track;

                        if (!$player.dom.playlistUL) {
                            $player.updatePlaylist(playlist);
                            return;
                        }

                        if (playlist && $player.dom.playlistUL) {

                            for (var i = 0; i < playlist.length; i++) {

                                var li = document.createElement('li');
                                thumb = playlist[i].value.getThumb();
                                thumb = $this.getDefaultThumb(thumb);
                               
                                track = $this.trackTemplate.replace(/data-rel/g, i);
                                track = track.replace(/data-thumb/g, thumb);
                                track = track.replace(/data-caption/g, playlist[i].value.getCaption());
                                track = track.replace(/data-duration/g, $this.secToTime(playlist[i].value.getDuration()));
                                li.innerHTML = track;
                                $player.dom.playlistUL.appendChild(li);
                            }
                        }
                    };

                    $player.setTrack = function () {

                        if ($player.playlist.length < 2)
                            return;

                        if ($player.currentTrack == 0)
                            $this.addRemoveClass($player.dom.prevBtn, ['disabled'], []);
                        else
                            $this.addRemoveClass($player.dom.prevBtn, [], ['disabled']);

                        if ($player.currentTrack == ($player.playlist.length - 1))
                            $this.addRemoveClass($player.dom.nextBtn, ['disabled'], []);
                        else
                            $this.addRemoveClass($player.dom.nextBtn, [], ['disabled']);

                        for (var i = 0; i < $player.dom.playlist.length; i++) {
                            if (i == $player.currentTrack) {
                                $this.addRemoveClass($player.dom.playlist[i], ['active'], ['active']);
                            }
                            else {
                                $this.addRemoveClass($player.dom.playlist[i], [], ['active']);
                            }
                        }

                        $player.showInfo();

                    };

                    $player.setAuto = function (force) {

                        if (force) {
                            $this.addRemoveClass($player.dom.auto, ['enbled'], []);
                            return;
                        }

                        if ($player.auto) {
                            $player.auto = false;
                            $this.addRemoveClass($player.dom.auto, [], ['enbled']);
                            return;
                        }

                        if (!$player.auto) {
                            $player.auto = true;
                            $this.addRemoveClass($player.dom.auto, ['enbled'], []);
                            return;
                        }

                    };

                    $player.showMusicBar = function () {

                        if ($player.mediaType == 'audio' && $player.playingState == 'PLAYING' && !$player.isLoading) {
                            $player.dom.musicBar.style.display = 'block';
                        }
                        else {
                            $player.dom.musicBar.style.display = 'none';
                        }

                    };

                    $player.showControl = function (show) {

                        if ($playerProvider.miniPlayer.player) {
                           $player.dom.controlLayer.style.bottom = '0px';  
                           return;    
                        }
                            

                        if ($player.playingState == 'PLAYING' && show) {
                            $player.dom.controlLayer.style.bottom = '0px';
                            $player.dom.controlBG.style.opacity = 1;
                        }
                        else {
                            $player.dom.controlLayer.style.bottom = '-60px';
                            $player.dom.controlBG.style.opacity = 0;
                        }
                    };

                    $player.stateChanged = function (state) {

                        if (state == 'BUFFERING') {
                            $player.isLoading = true;
                        }
                        else {
                            $player.isLoading = false;
                        }
                        $player.showLoader();

                        if (state == 'PLAYING') {
                            $player.playingState = 'PLAYING';
                            $player.showBigPlay();
                            $this.addRemoveClass($player.dom.playBtn, ['icon-pause-p'], ['icon-play-p']);
                        }
                        if (state == 'ENDED' || state == 'IDLE') {
                            $player.playingState = 'STOPPED';
                            $player.showBigPlay(true);
                            $player.showPlaylist(true);

                            $this.addRemoveClass($player.dom.playBtn, ['icon-play-p'], ['icon-pause-p']);
                            $player.initTime(0);
                            $player.showPosition(0);
                            $player.showInfo(true);

                            if ($player.auto && $player.playlist.length > 0) {
                                $player.playNext();
                            }
                        }
                    };

                    $player.reset = function () {
                        $player.isLoading = true;
                        $player.initTime(0);
                        $player.showPosition(0);
                        $player.showBuffered(0);
                        $player.showLoader();
                        $player.showInfo();
                    };

                    $player.fullScreen = function () {

                        if ($player.screenState == 'NORMAL') {

                            if ($player.dom.player.requestFullscreen) {

                                $player.dom.player.requestFullscreen();
                            }
                            else if ($player.dom.player.mozRequestFullScreen) {
                                $player.dom.player.mozRequestFullScreen();
                            }
                            else if ($player.dom.player.webkitRequestFullScreen) {
                                $player.dom.player.webkitRequestFullScreen();
                            } else {
                                return false;
                            }
                            
                            $player.screenState = 'FULL';
                            $player.showControl(true);
                        
                            $this.addRemoveClass($player.dom.player, ['full'], []);
                            $this.addRemoveClass($player.dom.fullScreenBtn, ['icon-screen-fe'], ['icon-screen-f']);

                            if ($playerProvider.miniPlayer.dom.container) {
                                $this.addRemoveClass($playerProvider.miniPlayer.dom.container, ['full'], []);
                            }

                            $player.dom.fullScreenBtn.setAttribute('tooltip', $this.dicts['maximize']); 
                            return true;
                        }

                        if ($player.screenState == 'FULL') {

                            if (document.cancelFullscreen) {
                                document.cancelFullscreen();
                            }
                            else if (document.exitFullscreen) {
                                document.exitFullscreen();
                            }
                            else if (document.mozCancelFullScreen) {
                                document.mozCancelFullScreen();
                            }
                            else if (document.webkitCancelFullScreen) {
                                document.webkitCancelFullScreen();
                            }
                            $this.addRemoveClass($player.dom.player, [], ['full']);
                            $this.addRemoveClass($player.dom.fullScreenBtn, ['icon-screen-f'], ['icon-screen-fe']);
                            if ($playerProvider.miniPlayer.dom.container) {
                                $this.addRemoveClass($playerProvider.miniPlayer.dom.container, [], ['full']);
                            }

                            $player.showControl(false);
                            $player.screenState = 'NORMAL';
                            $playerProvider.escapeKey = true;
                            $player.dom.fullScreenBtn.setAttribute('tooltip', $this.dicts['fullScreen']);
                            return true;
                        }

                    };

                    $player.playNext = function () {

                        if ($player.currentTrack == $player.playlist.length - 1) {
                            return;
                        }

                        $player.currentTrack++;
                        $player.title = $player.playlist[$player.currentTrack].value.getCaption();
                        $player.load($player.playlist[$player.currentTrack].value.getStreamUrl());

                        if (option.onNext)
                            option.onNext.apply(option.scope);

                    };

                    $player.playPrev = function () {

                        if ($player.currentTrack == 0) {
                            return;
                        }

                        $player.currentTrack--;
                        $player.title = $player.playlist[$player.currentTrack].value.getCaption();
                        $player.load($player.playlist[$player.currentTrack].value.getStreamUrl());

                        if (option.onNext)
                            option.onNext.apply(option.scope);
                    };

                    /* ui related api*/
                    $player.getPlaylistUI = function () {
                        return $player.dom.playlistWrap;
                    }

                    $player.getNextUI = function () {
                        return $player.dom.nextBtn;
                    };

                    $player.getPrevUI = function () {
                        return $player.dom.prevBtn;
                    };

                    /*  media object related*/
                    $player.load = function (url) {
                        $player.reset();
                        $player.setTrack();

                        $player.provider.pause();
                        $player.seek(0);
                        $player.provider.src = url;

                        $player.source = url;

                        /* fire event on change*/
                        if (angular.isFunction(option.scope.onChange()) && $player.playlist.length > 0) {
                            option.scope.onChange()($player.playlist[$player.currentTrack].value);
                        }
                    };

                    $player.play = function () {
                        $player.provider.play();

                        $player.playingState = 'PLAYING';
                        $this.addRemoveClass($player.dom.playBtn, ['icon-pause-p'], ['icon-play-p']);
                    };

                    $player.pause = function () {
                        $player.provider.pause();

                        $player.playingState = 'PAUSED';
                        $this.addRemoveClass($player.dom.playBtn, ['icon-play-p'], ['icon-pause-p']);
                    };

                    $player.resume = function () {
                        $player.provider.play();

                        $player.playingState = 'PLAYING';
                        $this.addRemoveClass($player.dom.playBtn, ['icon-pause-p'], ['icon-play-p']);
                    };

                    $player.seek = function (offset) {

                        try {
                            $player.provider.currentTime = offset;
                        }
                        catch (e) {
                        }

                    };

                    $player.stop = function () {
                        $player.provider.pause();
                        $player.seek(0);
                        $player.playingState = 'STOPPED';
                        $this.addRemoveClass($player.dom.playBtn, ['icon-play-p'], ['icon-pause-p']);

                    };

                    $player.setVolume = function (volume) {
                        $player.provider.volume = volume / 10;
                    };

                    $player.initEvent();
                    $player.showControl();
                    $player.showLoader();
                    $player.showBigPlay();
                    $player.showError();
                    $player.showInfo();
                    $player.showMusicBar();
                    $player.initPlaylist();
                    $player.showHD();
                    $player.playingState = 'STOPPED';

                    $player.provider.autoPlay = false;
                    $player.load(option.source);
                    $player.setVolume($player.volume);

                    $this.instances.push($player);

                    return $player;
                };
                return $playerProvider;
            }];
    }

    rgPlayer.$inject = ['$compile', '$player', '$ringbox'];
    function rgPlayer($compile, $player, $ringbox) {

        function link(scope, element, attrs) {

            var id = (attrs.id) ? attrs.id : 'player_1',
                    width = (attrs.width) ? attrs.width : '100%',
                    height = (attrs.height) ? attrs.height : '100%',
                    auto = (attrs.auto == 'false' || attrs.auto == false) ? false : true,
                    src = (attrs.url) ? attrs.url : '',
                    title = (attrs.title) ? attrs.title : '',
                    type = (attrs.isVideo == 'true' || attrs.isVideo == false) ? 'video' : 'audio',
                    poster = (attrs.poster) ? attrs.poster : (type == 'audio' ? 'images/player-audio.png' : ''),
                    autoPlay = (attrs.autoPlay == 'false' || attrs.autoPlay == false) ? false : true,
                    chat = (attrs.chat == 'true' || attrs.chat == true) ? true : false,
                    current = 0,
                    player = null,
                    playerUI = null,
                    nextBtn = null,
                    prevBtn = null,
                    minMaxDom =  null,
                    fromPlaylist = false;

            if (!poster || poster == 'default_audio_image.jpg')
                poster = 'images/player-audio.png';

            var tpl = '<div id="player_' + id + '" class="player ' + type + '"></div>';
            element.append(tpl);

            setTimeout(function () {
                player = $player.player({
                    source: src,
                    title: title,
                    playlist: scope.playlist,
                    auto: auto,
                    type: type,
                    parentId: "player_" + id,
                    autoPlay: autoPlay,
                    chatVersion: chat,
                    width: width,
                    height: height,
                    poster: poster,
                    ringboxMinimize: $ringbox.minimize,
                    ringboxMaximize: $ringbox.maximize,
                    ringboxRemove: $ringbox.removeMinimize,
                    scope: scope
                });

               /* Min / max option*/
               minMaxDom = element[0].closest('.ringbox-inner').querySelector('.player-size');
               minMaxDom.addEventListener('click', function(e) {
                   e.preventDefault();
                   e.stopPropagation();
                   player.minimize();
                }, false);

            });

          scope.$on('$destroy', function(){
             minMaxDom = null;    
          });

        }

        return {
            restrict: 'E',
            scope: {
                onChange: '&',
                onStart: '&',
                onEnded: '&',
                playlist: '='
            },
            link: link
        }
    }
})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.rgloading_directive', [])
        .directive('rgLoading', rgLoading);

    rgLoading.$inject = ['$rootScope', 'SystemEvents'];
    function rgLoading($rootScope, SystemEvents) { //jshint ignore:line

        return {
            restrict: 'E',
            template:
                    '<a class="glo-l ng-cloak"> ' +
                        '<span class="load-circle">' +
                            '<span class="ld-cir1 glo-cir"></span>' +
                            '<span class="ld-cir2 glo-cir"></span>' +
                            '<span class="ld-cir3 glo-cir"></span>' +
                            '<span class="ld-cir4 glo-cir"></span>' +
                            '<span class="ld-cir5 glo-cir"></span>' +
                            '<span class="ld-cir6 glo-cir"></span>' +
                            '<span class="ld-cir7 glo-cir"></span>' +
                            '<span class="ld-cir8 glo-cir"></span>' +
                            '<span class="ld-cir9 glo-cir"></span>' +
                            '<span class="ld-cir10 glo-cir"></span>' +
                            '<span class="ld-cir11 glo-cir"></span>' +
                            '<span class="ld-cir12 glo-cir"></span>' +
                        '</span>' +
                        '<span class="glo-type">Processing...</span>' +
                        '</a>' ,
            scope: {
                rgLoadingObj: '='
            },
            link: function(scope, element) {
                $rootScope.$on(SystemEvents.AUTH.LOGIN, function() {
                    element[0].style.display = 'none';
                    scope.$rgDigest();
                });
                $rootScope.$on(SystemEvents.LOADING, function(event, bool) {
                    if (bool) {
                        element[0].style.display = 'block';
                    } else {
                        element[0].style.display = 'none';
                    }
                });

                element[0].style.display = 'none';
            }
        };
    }
})();


(function() {
    'use strict';
    angular.module('ringid.common.rgRecorder', [])
        .directive('rgImageCapture', rgImageCapture)
        .service('rgRecorderService', rgRecorderService);

        //.directive('rgAudioCapture', rgAudioCapture)
        //.directive('rgVideoCapture', rgVideoCapture);


    function __getUserMedia(){

        var _gum, _gumVersion;
        if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
            _gumVersion = 'old';
            _gum = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);
        }else{
            _gumVersion = 'new';
            _gum = navigator.mediaDevices.getUserMedia
        }

        return {gum : _gum, version : _gumVersion};
    }

    function rgRecorder(user_props){

        var self = this;

        var _gumVersion = 'old';
        var _gum = null;

        var _props = {
            recordedImage : {
                width : 0,
                height : 0,
                image : ''
            },
            recordedVideo : {
                width : 0,
                height: 0,
                video : ''
            },
            mediaPreview : {
                width : 400,
                height : 400
            },
            mediaStream : '',
            mediaObject : '',
            isStreaming : false,
            text : {
                PERMISSION_DENINED : 'Please enable webcam permission',
                WEBCAM_DISCONNECTED : 'Please connect webcam.',
                GUM_NOT_SUPPORTED : 'Webcam capture not supported in your browser'
            }
        };

        angular.extend(_props, user_props);

        var _streamReady = function(){};
        var _onError = function(){};

        this._callbacks = {
            streamReady : _streamReady,
            error : _onError
        };

        var initNavigatorMedia = function(){
            var userMedia = __getUserMedia();
            _gum = userMedia.gum;
            _gumVersion = userMedia.version;
        };

        var initMediaEvents = function(){
            if( self.getMediaObject().readyState > 3){
                self.onCanPlay();
            }else{
                self.getMediaObject().addEventListener('canplay', self.onCanPlay, false);
            }
        };

        //var setCanvas = function(){
        //    var canvas = self.getCanvas();
        //    canvas.setAttribute('width', self.getMediaPreview().width);
        //    canvas.setAttribute('height', self.getMediaPreview().height);
        //};

        var getVideoObjectFromStream = function(stream){
            var video = document.createElement('video');

            var vendorURL = window.URL || window.webkitURL;
            video.src = vendorURL.createObjectURL(stream);
            video.autoplay = true;
            //video.onloadedmetadata = function(e) {
            //    video.play();
            //    self.onCanPlay();
            //};
            return video;
        };

        var processMediaStream = function(stream){
            _props.mediaStream = stream;
            _props.mediaObject = getVideoObjectFromStream(stream);
            initMediaEvents();
        };

        var onFailure = function(e){
            var errorText;
            if(e.name == "DevicesNotFoundError" || e.name == "OverconstrainedError"){
                errorText = _props.text.WEBCAM_DISCONNECTED;
            }else if(e.name == 'PermissionDeniedError'){
                errorText = _props.text.PERMISSION_DENINED;
            }else{
                errorText = _props.text.GUM_NOT_SUPPORTED;
            }

            self.triggerEvent('error', { text : errorText });
        };

        self.on = function(eventName, func){
            self._callbacks[eventName] = func;
        };

        self.triggerEvent = function(eventName, data){
            if(!!self._callbacks[eventName]){
                self._callbacks[eventName].call(self, data);
            }
        };

        self.getProps = function(){
            return _props;
        };

        self.getMediaPreview = function(){
            return _props.mediaPreview;
        };

        self.getMediaObject = function(){
            return _props.mediaObject;
        };

        self.getStream = function(){
            return _props.mediaStream;
        };

        self.setStream = function(stream){
            _props.mediaStream = stream;
        };

        self.isStreaming = function(isStreaming){
            if( !isStreaming ){

                return _props.isStreaming;
            }else{
                _props.isStreaming = isStreaming;
            }
        };

        self.startRecording = function(){
            self.getStream().record();
        };

        self.stopRecording = function(){
            var stream = self.getStream();
            if( !stream.getTracks ){
                stream.stop();
            }else{
                var tracks = stream.getTracks();  // if only one media track
                tracks.forEach(function(aTrack){
                    aTrack.stop();
                });
            }
        };

        self.getRecordedMedia = function(callback){
            self.getStream().getRecordedData(callback);
        };

        //self.getRecordedMedia = function(){
        //
        //};

        self.captureImage = function(){
            var mediaObject = self.getMediaObject();
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            if ( mediaObject.width && mediaObject.height) {
                canvas.width = mediaObject.width;
                canvas.height = mediaObject.height;
                context.drawImage(mediaObject, 0, 0, mediaObject.width, mediaObject.height);
                return  canvas.toDataURL('image/jpeg');

            }else{

                return false;
            }
        };

        self.onCanPlay = function(ev){
            var mediaObject = self.getMediaObject();
            var mediaPreview = self.getMediaPreview();

            if (!self.isStreaming()) {
                var height = mediaObject.videoHeight / (mediaObject.videoWidth/mediaPreview.width);

                // Firefox currently has a bug where the height can't be read from
                // the video, so we will make assumptions if this happens.

                if (isNaN(height)) {
                    height = width / (4/3);
                }

                mediaObject.setAttribute('width', mediaPreview.width);
                mediaObject.setAttribute('height', height);

                self.isStreaming(true);
                self.triggerEvent('streamReady', { stream : self.getStream(), media : mediaObject });
            }

        };

        self.openMedia = function(props){

            if( !_gum ){

                self.triggerEvent('error', { text : _props.text.GUM_NOT_SUPPORTED });

            }else{

                try{

                    if( _gumVersion == 'old'){
                        _gum.call(navigator, props, processMediaStream, onFailure);
                        //_gum(props, processMediaStream, onFailure);
                    }else{
                        //var constraints = { audio: false, video: { width: 1280, height: 720 } };
                        _gum.call(navigator.mediaDevices, props).then(processMediaStream).catch(onFailure);
                    }

                }catch(e){

                }

            }

        };


        self.destroy = function(){
            var mediaObject = self.getMediaObject();
            if( !!mediaObject){
                mediaObject.removeEventListener('canplay', self.onCanPlay);
            }

            if(  self.getStream() ){
                self.stopRecording();
                self.setStream(null);
            }

        };

        var init = function(){
            initNavigatorMedia();
        };

        init();

    }

    function rgRecorderService(){

        var supportChecked = false;
        var _hasUserMediaSupport = false;

        this.getRecorderInstance = function(user_props){
            return new rgRecorder(user_props);
        };

        this.hasUserMediaSupport = function(){
            if( !supportChecked ){
                _hasUserMediaSupport = !!__getUserMedia().gum
                supportChecked = true;
            }

            return _hasUserMediaSupport;
        };
    }



    rgImageCapture.$inject = ['utilsFactory', 'rgRecorderService'];
    function rgImageCapture(utilsFactory, rgRecorderService){
        return {
            link : function(scope, elem, attr){

                var _TEXT = {
                    CAPTURE : 'Capture',
                    RETAKE : 'ReTake'
                };

                scope.videoId = utilsFactory.getUniqueID('rgRec');
                scope.showLoader = true;
                scope.media = null;
                scope.errorText = "";
                scope.connected = false;
                scope.captureText = _TEXT.CAPTURE;


                var getVideoContainerElement = function(){
                    return document.querySelector('#' + scope.videoId);
                };

                var props = {
                    text : {
                        PERMISSION_DENINED : 'Please enable webcam permission',
                        WEBCAM_DISCONNECTED : 'Please connect webcam.',
                        GUM_NOT_SUPPORTED : 'Webcam capture not supported in your browser. Please use upgraded browser.'
                    }
                };

                var recorder = rgRecorderService.getRecorderInstance(props);

                recorder.on('streamReady', function(data){

                    scope.showLoader = false;
                    scope.connected = true;

                    scope.$rgDigest();

                    try{

                        getVideoContainerElement().appendChild(data.media);
                        scope.media = data.media;

                        data.media.play();

                    }catch(e){
                    }


                });

                recorder.on('error', function(e){
                    scope.errorText = e.text;
                    scope.showLoader = false;
                    scope.connected = false;
                    scope.$rgDigest();
                });

                scope.connect = function(){
                    scope.showLoader = true;
                    scope.connected = false;
                    recorder.openMedia({video: true, audio : false});
                };

                setTimeout(function(){
                    scope.connect();
                },500);


                scope.doCapture = function(){

                    if( scope.captureText == _TEXT.CAPTURE){

                        var image = recorder.captureImage();
                        if( !!image ){
                            scope.capturedMedia = image;
                            scope.captureText = _TEXT.RETAKE;
                        }

                        if(!!scope.media){
                            scope.media.pause();
                        }

                    }else{
                        scope.capturedMedia = null;
                        scope.captureText = _TEXT.CAPTURE;

                        scope.media.play();

                    }

                    scope.$rgDigest();

                };

                scope.$on('$destroy', function(){

                    recorder.destroy();


                });
            },
            templateUrl : 'pages/partials/recorder/image.html'
        }

    }

    //rgAudioCapture.$inject = ['utilsFactory'];
    //function rgAudioCapture(utilsFactory){
    //    return{
    //        link : function(scope, elem, attr){
    //
    //        },
    //        templateUrl : 'pages/partials/recorder/audio.html'
    //
    //    }
    //
    //
    //}
    //
    //rgVideoCapture.$inject = ['utilsFactory'];
    //function rgVideoCapture(utilsFactory){
    //    return {
    //        link : function(scope, elem, attr){
    //
    //            var _TEXT = {
    //                CAPTURE : 'Record',
    //                STOP : 'STOP',
    //                RETAKE : 'Restart'
    //            };
    //
    //            var _VIDEO_STATES = {
    //                PLAYING : 0,
    //                PAUSED : 1
    //            };
    //
    //            scope.videoId = utilsFactory.getUniqueID('rgRec');
    //            scope.previewVideoId = utilsFactory.getUniqueID('rgRec');
    //            scope.showLoader = true;
    //            scope.errorText = "";
    //            scope.media = null;
    //            scope.videoState = _VIDEO_STATES.PAUSED;
    //            scope.captureText = _TEXT.CAPTURE;
    //
    //            var getVideoContainerElement = function(){
    //                return document.querySelector('#' + scope.videoId);
    //            };
    //
    //            var getPreviewVideoContainerElement = function(){
    //                return document.querySelector('#' + scope.previewVideoId);
    //            };
    //
    //            var pauseMedia = function(){
    //                if( !!scope.media){
    //                    scope.media.pause();
    //                    scope.videoState = _VIDEO_STATES.PAUSED;
    //                }
    //            };
    //
    //            var playMedia = function(){
    //                if( !!scope.media){
    //                    scope.media.play();
    //                    scope.videoState = _VIDEO_STATES.PLAYING;
    //                }
    //            };
    //
    //            var toggleMedia = function(){
    //                if( scope.videoState == _VIDEO_STATES.PAUSED ){
    //                    playMedia();
    //                }else{
    //                    pauseMedia();
    //                }
    //            };
    //
    //            var getMediaProps = function(){
    //                return {video: true, audio : true}
    //            };
    //
    //            var recorder = new rgRecorder();
    //            recorder.openMedia(getMediaProps());
    //
    //            recorder.on('error', function(e){
    //                scope.errorText = e.text;
    //                scope.showLoader = false;
    //            });
    //
    //
    //            recorder.on('streamReady', function(data){
    //
    //                scope.showLoader = false;
    //                scope.$rgDigest();
    //
    //                getVideoContainerElement().appendChild(data.media);
    //                scope.media = data.media;
    //
    //                playMedia();
    //
    //            });
    //
    //            scope.doCapture = function(){
    //
    //                if( scope.captureText == _TEXT.CAPTURE){
    //
    //                    recorder.startRecording();
    //                    scope.captureText = _TEXT.STOP;
    //
    //
    //                }else{
    //                    recorder.stopRecording();
    //
    //                    recorder.getMediaPreview(function(data){
    //                        var aPreviewVideo = document.createElement('video');
    //                        aPreviewVideo.src = data;
    //                        aPreviewVideo.width = "400";
    //                        aPreviewVideo.height = "400";
    //                        aPreviewVideo.autoPlay = true;
    //                        getPreviewVideoContainerElement().appendChild(aPreviewVideo);
    //
    //                    });
    //
    //
    //                    scope.captureText = _TEXT.CAPTURE;
    //
    //                    playMedia();
    //
    //                }
    //
    //                scope.$rgDigest();
    //
    //            };
    //
    //            scope.$on('togglePlayPause', function(){
    //                toggleMedia();
    //            });
    //
    //            scope.$on('$destroy', function(){
    //
    //                var element = getVideoContainerElement();
    //                recorder.destroy();
    //            });
    //        },
    //        templateUrl : 'pages/partials/recorder/video.html'
    //    }
    //
    //}


})();

(function () {
    'use strict';
    // THIS DIRECTIVE IS NO LONGER USED MAYBE TODO

    angular
        .module('ringid.common.rg_global_loader_directive', [])
        .directive('rgGlobalLoader', rgGlobalLoader);

        //rgGlobalLoader.$inject = ['Auth', '$rootScope'];
        function rgGlobalLoader(){

            //function linkFunc(scope, element) {
                //if (scope.loading) {
                    //element[0].style.display = false;
                //} else {
                    //element[0].style.display = true;
                //}
            //}

            return {
                restrict: 'E',
                //link: linkFunc,
                //replace: true,
                //scope: {
                    //isLoggedIn: '='
                //},
                template:
                        '<div id="global-loader" class="rgbubbling">' +
                            '<span id="rgbubbling_1">' +
                            '</span>' +
                            '<span id="rgbubbling_2">' +
                            '</span>' +
                            '<span id="rgbubbling_3">' +
                            '</span>' +
                        '</div>'
            };
        }


})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.media', [
            'ringid.filters',
            'ringid.profile',
            'ringid.config',
            //'ringid.common.stacked_map',
            //'ringid.ringbox',
            'ringid.common.controllers'
        ]);

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.media')
        .service('mediaHttpService', mediaHttpService);

        mediaHttpService.$inject = [ 'OPERATION_TYPES', '$$connector'];
        function mediaHttpService( OPERATION_TYPES, $$connector) {
			var self = this,
				OTYPES = OPERATION_TYPES.SYSTEM.MEDIA,
                REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;

            // MEDIA ALBUM APIS
            self.fetchMediaAlbums = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_MEDIA_ALBUM_LIST, // 256
                    mdaT: obj.mdaT || 1,
                    utId: obj.utId // optional. maybe without utid just own media album list fetch
                };
                $$connector.send(payload, REQTYPE.REQUEST, true);
            };


            self.fetchHashtagSuggestion = function(schPm) {
                return $$connector.pull({
                    actn: OTYPES.ACTION_GET_HASHTAG_SUGGESTION,
                    schPm: schPm.utf8Encode()
                }, REQTYPE.REQUEST);
            };

            self.fetchSearchResult = function(param) {
                var payload = {
                    actn : OTYPES.ACTION_MEDIA_SEARCH_RESULT,
                    schPm: param.utf8Encode()
                };
                //return $$connector.send(payload,REQTYPE.REQUEST);
                return $$connector.pull(payload, REQTYPE.REQUEST);
            };

            self.fetchContent = function(param) {
                var payload = {
                    actn : OTYPES.ACTION_SPECIFIC_MEDIA_RESULT,//278
                    schPm: param.sk.utf8Encode(),
                    sugt:param.sugt,
                    pvtid:param.pvtid || 0,
                    scl:param.scl || 1
                };
                return $$connector.send(payload,REQTYPE.REQUEST);
            };
            self.fetchAlbumDetails = function(albId) {
                var payload = {
                    actn: OTYPES.ACTION_MEDIA_ALBUM_DETAILS, // 257
                    albId: albId
                };
                return $$connector.request(payload, REQTYPE.REQUEST);
            };

            self.addMediaAlbum= function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_ADD_MEDIA_ALBUM, // 253
                    imgURL: obj.imgURL || '',
                    albn: obj.albn.utf8Encode(),
                    mdaT: obj.mdaT
                };
                return $$connector.request(payload, REQTYPE.UPDATE);
            };

            self.updateMediaAlbum = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_UPDATE_MEDIA_ALBUM, // 254
                    albId: obj.albId,
                    imgURL: obj.imgURL,
                    mdaT: obj.mdaT,
                    albn: obj.albn.utf8Encode()
                };
                return $$connector.request(payload, REQTYPE.UPDATE);
            };

            self.deleteAlbum = function(albId) {
                var payload = {
                    actn: OTYPES.ACTION_DELETE_MEDIA_ALBUM, // 255
                    albId: albId
                };
                return $$connector.request(payload, REQTYPE.UPDATE);
            };



           // MEDIA CONTENT APIS
            self.fetchAlbumContents = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST, // 261
                    albId: obj.albId,
                    utId: obj.utId, // optional. maybe without utid just own media album list fetch
                    st: obj.st || 0
                };
                $$connector.send(payload, REQTYPE.REQUEST);
            };

            self.fetchAlbumContentsForpopup = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST, // 261
                    albId: obj.albId || obj.id,
                    utId: obj.utId, // optional. maybe without utid just own media album list fetch
                    st: obj.st || 0
                };
                return $$connector.pull(payload, REQTYPE.REQUEST);
            };

            self.fetchContentDetails= function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_MEDIA_CONTENT_DETAILS, // 262,
                    cntntId: obj.cntntId,
                    utId: obj.utId
                };
                return $$connector.request(payload, REQTYPE.REQUEST);
            };

            self.addMediaToAlbum = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_ADD_MEDIA_CONTENT, // 258
                    albId: obj.albId,
                    mdaLst: obj.mdaLst, // [{strmURL, drtn, tih, tiw, thmbURL, artst, ttl}]
                    mdaT: obj.mdaT
                };

                return $$connector.request(payload, REQTYPE.UPDATE);
            };

            self.updateMediaAlbum = function(obj) {
                var payload = {
                    actn: OTYPES.ACTION_UPDATE_MEDIA_CONTENT, // 259
                    mdaCntntDTO: obj.mdaCntntDTO // {id,strmURL,albId,drtn,thmbURL,artst,ttl,utId}
                };
                return $$connector.request(payload, REQTYPE.UPDATE);
            };

            self.deleteAlbumContent = function(cntntId) {
                var payload = {
                    actn: OTYPES.ACTION_DELETE_MEDIA_CONTENT, // 260
                    cntntId: cntntId
                };
                return $$connector.request(payload, REQTYPE.UPDATE);
            };


            // CONTENT ACTIVITY APIS
            self.increaseViewCount = function(cntntId,nfId) {
                // THERE IS AN UPDATE EVENT NOT HANDLED WITH ACTION 472
                var payload = {
                    actn: OTYPES.ACTION_INCREASE_MEDIA_CONTENT_VIEW_COUNT, // 272
                    cntntId: cntntId
                };
                if(nfId){
                    payload.nfId = nfId;
                }
                return $$connector.request(payload, REQTYPE.UPDATE);
            };


            // self.likeUnlikeContent = function(obj) {
            //     // THERE IS AN UPDATE EVENT NOT HANDLED WITH ACTION 464
            //     var payload = {
            //         actn: OTYPES.ACTION_LIKE_UNLIKE_MEDIA, // 264
            //         cntntId: obj.cntntId,
            //         lkd: obj.lkd
            //     };
            //     if(obj.nfId){
            //         payload.nfId = obj.nfId;
            //     }
            //     return $$connector.request(payload, REQTYPE.UPDATE);
            // };

            // self.likeList = function(cntntId,nfId) {
            //     var payload = {
            //         actn: OTYPES.ACTION_MEDIA_LIKE_LIST, // 269,
            //         cntntId: cntntId
            //     };
            //     if(nfId){
            //         payload.nfId = nfId;
            //     }
            //     return $$connector.pull(payload, REQTYPE.REQUEST);
            // };


            self.getSearchTrends = function () {
                var payload = {
                    actn : 281
                };
                return $$connector.pull(payload,REQTYPE.REQUEST);
            };

            self.getTaggedMedia = function (param) {
                var payload = {
                    actn : OTYPES.ACTION_GET_TAGGED_MEDIA_SONGS,//279
                    htid : param,
                    pvtid : 0,
                    scl : 2
                };
                return $$connector.send(payload,REQTYPE.REQUEST);
            };

        }

})();

/*
 * Ipvision
 */


(function(){
    'use strict';
    angular
        .module('ringid.media')
        .factory('$$mediaMap', $$mediaMap);

    $$mediaMap.$inject = [ 'utilsFactory', 'userFactory', 'Auth', '$$stackedMap', 'settings', 'APP_CONSTANTS', 'mediaHttpService', '$$q', 'Storage', 'Ringalert'];
    function $$mediaMap ( Utils, User, Auth, $$stackedMap, settings, APP_CONSTANTS, mediaHttpService, $q, Storage, Ringalert) { //jshint ignore:line
        var AC = APP_CONSTANTS,
            media_defaults = {
                    ac: 0, // view count
                    albId: 0,
                    cc: 0,//count count
                    ic: 0,// i comment
                    il: 0,//i like
                    lc: 0,//like count
                    is : 0,// i share
                    ns : 0,//share count
                    // above are from notification for mdaT=2
                    nfId : 0,
                    albn:'',
                    artst: '',
                    cntntId: 0,
                    drtn: 0,
                    mdaT: 1,
                    strmURL: '',
                    thmbURL: '',
                    ttl: '',
                    tih: 0,
                    tiw: 0,
                    user: null,
                    viewtime:0,
                    utId:'',
                    autoplay:false,
                    gotDetails: false
                    //ilkd: 0, // current user liked
                   // likeUsers: $$stackedMap.createNew() // need additional api call to get this
                   // comments: $$stackedMap.createNew()

                };

                function RingMedia(obj,user){
                    var that = this;
                    that.updateMedia(obj);
                    that.setUser(obj,user);
                    obj = null;
                    Object.defineProperty(that, 'ddControl', {
                              enumerable: false,
                              configurable: false,
                              writable: false,
                              value: {
                                    key: that.media.key,
                                    showReportButton : function(){
                                        return !that._u.isCurrentUser();
                                    },
                                    showAddToAlbum : function(){
                                        return !that._u.isCurrentUser();
                                    },
                                    getSpamId : function(){
                                        return that.getKey();
                                    },
                                    getSpamType : function(){
                                        return "media";
                                    },
                                    getRingboxData : function(){
                                        return  function () {
                                                    return {
                                                        media: that
                                                    };
                                                }
                                        
                                    }
                                }
                            });



                }


                function updateRecentMedias(json) {
                    var t = new Date(), i, arrIndex = false;
                    var mediaObj = {
                        ac:json.mdaCntntDTO.ac,
                        albId:json.mdaCntntDTO.albId,
                        albn:json.mdaCntntDTO.albn,
                        artst:json.mdaCntntDTO.artst,
                        cntntId:json.mdaCntntDTO.cntntId,
                        mdaT:json.mdaCntntDTO.mdaT,
                        drtn:json.mdaCntntDTO.drtn,
                        strmURL:json.mdaCntntDTO.strmURL,
                        thmbURL:json.mdaCntntDTO.thmbURL,
                        ttl:json.mdaCntntDTO.ttl,
                        utId:json.utId,
                        viewtime: t.getTime()
                    };
                    var mediaRecent = Storage.getData('mediaRecent') || [];

                    // check if same media already exists
                    for (i = 0; i < mediaRecent.length; i++) {
                        if (mediaRecent[i].cntntId === json.mdaCntntDTO.cntntId) {
                            arrIndex = i;
                            break;
                        }
                    }

                    if( arrIndex ) {
                        mediaRecent[arrIndex] = mediaObj;
                    } else  {
                        // check if limit crossed
                        if (mediaRecent.length >= 6) {
                            mediaRecent.shift();
                        }

                        mediaRecent.push(mediaObj);
                    }

                    Storage.setData('mediaRecent',mediaRecent);

                }

                RingMedia.prototype = {
                      updateMedia : function(mediaObj, gotDetails) {
                            if (angular.isObject(mediaObj)) {
                                if(this.media){
                                    angular.extend(this.media, mediaObj);
                                }else{
                                    this.media =  angular.extend({},media_defaults, mediaObj);
                                }

                                this.media.gotDetails = !!gotDetails; // after fetchDetails call this should be true
                                this.media.key = this.media.cntntId || this.media.id;

                                // set cover image for media
                                //if (mediaObj.mdaT === AC.NEWS_FEED_MEDIA_TYPE_VIDEO && mediaObj.thmbURL  && mediaObj.thmbURL.length > 1) {
                                if (mediaObj.thmbURL  && mediaObj.thmbURL.length > 1) {
                                    this.media.poster = settings.mediaBase + mediaObj.thmbURL;
                                    // new api provides video thumb image from server not working from cloud api doc
                                    //media.poster = settings.streamServer + 'media/' + mediaObj.strmURL.substr(0, mediaObj.strmURL.lastIndexOf('.')) + '.jpg';

                                    //media.tih = mediaObj.tih || 600;
                                    //media.tiw = mediaObj.tiw || 600;
                                    //var position = mediaObj.thmbURL.lastIndexOf('/') + 1;
                                        //media.feedThumb = [settings.imBase, mediaObj.thmbURL.slice(0, position), 'p', '600',  mediaObj.thmbURL.slice(position)].join('');
                                        //return [settings.imBase, image.iurl.slice(0, position), image.iurl.slice(position)].join('');

                                } else {
                                    this.media.poster = (this.media.mdaT === AC.NEWS_FEED_MEDIA_TYPE_AUDIO ) ? 'images/default_audio_image.jpg' : 'images/default_video_image.jpg';
                                    this.media.feedThumb =  this.media.poster;
                                    this.media.tih = 330; 
                                    this.media.tiw = 600;
                                }



                            } else {
                            }

                            mediaObj = null;
                        },
                    setUser : function(_d,user){
                        if (angular.isDefined(user)) {
                            this._u = user;
                        } else {
                            if(_d.utId){
                                this._u = User.getByUtId(_d.utId);
                            }else if(_d.uId){
                                this._u =  User.getUser(_d.uId);
                            }else{
                                this._u = false;
                            }
                            if(!this._u){
                                var uOb = {};
                                    if(_d.uId){
                                        uOb.uId = _d.uId;
                                    }
                                    if(_d.utId){
                                        uOb.utId = _d.utId;
                                    }
                                    if(_d.fn){
                                        uOb.fn = _d.fn;
                                    }
                                    if(_d.prIm){
                                        uOb.prIm = _d.prIm;
                                    }
                                this._u = User.create(uOb);
                            }
                        }
                    },
                    sortBy: function() {
                        return this.media.viewtime;
                    },
                    getMediaUtId:function () {
                        return this.media.utId;
                    },
                    getAlbumId: function() {
                        return this.media.albId;
                    },
                    getAlbumName: function() {
                        return this.media.albn;
                    },
                    getArtistName: function() {
                        return this.media.artst;
                    },
                    getKey: function() {
                        return this.media.key;
                    },
                    getFeedKey : function(){
                        return this.media.nfId;
                    },
                    setFeedKey : function(nfId){
                        return this.media.nfId = nfId;
                    },
                    isAudio : function() {
                        return this.media.mdaT === AC.NEWS_FEED_MEDIA_TYPE_AUDIO;
                    },
                    isVideo : function() {
                       return this.media.mdaT === AC.NEWS_FEED_MEDIA_TYPE_VIDEO;
                    },
                    owner: function() {
                        return this._u;
                    },
                    user: function() {
                        return this._u;
                    },
                    getId: function() {
                        return this.media.cntntId;
                    },
                    setIsAutoPlay: function (param) {
                        this.media.autoplay = param;
                    },
                    getIsAutoPlay: function () {
                        return this.media.autoplay;
                    },
                    getViewCount: function() {
                        if( this.media.ac > 1 ) {
                            return 'Views : '+ this.media.ac;
                        } else {
                            return 'View : '+ this.media.ac;
                        }
                    },
                    getViewCountOnly: function () {
                      return this.media.ac;
                    },
                    getDuration: function(formated) {
                        if (formated) {
                            var minutes =  this.media.drtn/60 === 0 ? '00' : Math.floor(this.media.drtn/60);
                            var seconds =  this.media.drtn%60 === 0 ? '00': Math.floor(this.media.drtn%60);
                            minutes = (minutes < 10 && minutes !== '00') ? '0' + minutes : minutes;
                            seconds = (seconds < 10 && seconds !== '00') ? '0' + seconds : seconds;
                            return minutes + ':' + seconds;
                        } else {
                            return this.media.drtn;
                        }
                    },
                    getCaption: function() {
                        return this.media.ttl;
                    },
                    getStreamUrl: function() {
                        var streamUrl = settings.mediaBase + this.media.strmURL;
                        // check if hd available or not
                        if (this.media.mdaT === 2) {
                            var apiVersion = this.media.strmURL.match(/media-(\d+)/);
                            if (apiVersion && apiVersion.length === 2) {
                                if (parseInt(apiVersion[1]) > 140) {
                                    // got hd video add prefix 'h'
                                    var position = streamUrl.lastIndexOf('/') + 1;
                                    streamUrl = [streamUrl.slice(0, position), 'h',  streamUrl.slice(position)].join('');
                                }
                            }
                        }
                        return streamUrl;
                    },
                    getStreamUrlOnly: function () {
                      return this.media.strmURL;
                    },
                    getThumb: function() {
                        return this.media.poster;
                    },
                    getThumbUrlOnly: function () {
                        return this.media.thmbURL;
                    },
                    getThumbForMedia: function () {
                        if(this.media.thmbURL===''){
                            return this.media.mdaT===1 ? 'images/default_audio_image.jpg':'images/default_video_image.jpg';
                        }else{
                            return this.media.poster;
                        }
                    },
                    getThumbForMediaOnly: function () {
                        if(this.media.thmbURL===''){
                            return this.media.mdaT===1 ? 'images/default_audio_image.jpg':'images/default_video_image.jpg';
                        }else{
                            return this.media.poster;
                        }
                    },
                    feedThumb: function () {
                        return this.media.feedThumb;
                    },
                    iLiked: function() { // todo  : replace use of this , because all other maps(comment,feed,image) has api of self like is like()
                        return this.media.il;
                    },
                    like: function(dolike,totalLike) {
                        if (!dolike) {
                            return this.media.il;
                        }
                        this.media.il = this.media.il ^ 1;
                        if(totalLike){
                            this.media.lc = totalLike;
                        }else{
                            this.media.lc = (this.media.il === 0) ? this.media.lc-1 : this.media.lc+1;
                        }
                        return this.media.il;
                    },
                    getLikes: function() {
                        return this.media.lc;
                    },
                    getTotalLikes : function(){
                        return this.media.lc;
                    },
                    // getWhoLikes: function() {
                    //     return media.likeUsers.all();
                    // },
                    setTotalComment: function(cc,ic) {
                        this.media.cc = cc;
                        if(angular.isDefined(ic)){
                                this.media.ic = ic;
                            }
                    },
                    selfComment : function(){
                        return this.media.ic;
                    },
                    getTotalComment: function() {
                        return this.media.cc;
                    },
                    getTotalShare: function () {
                            return this.media.ns;
                    },
                    setTotalShare: function (v) {
                       this.media.ns = v;
                    },
                    share: function (doShare) {

                            if (!doShare) {
                                return this.media.is;
                            }
                            this.media.is = this.media.is ^ 1;
                            this.media.ns = this.media.is ? this.media.ns+1 : this.media.ns-1;
                            return this.media.is;
                    },
                    thumbOffset : function(dimension){
                        if (!dimension) {
                            return {width : this.media.tiw, height : this.media.tih};
                        } else {
                            return (dimension === 'height') ? this.media.tih : this.media.tiw;
                        }
                    },

                    // pushLikes: function(json) {
                    //     var user;
                    //     if(json.likes && json.likes.length > 0) {
                    //         for(var i = 0, l = json.likes.length; i < l; i++) {
                    //             user = User.create(json.likes[i]);
                    //             media.likeUsers.save(user.getKey(), user);
                    //             // check if current user liked or not
                    //             if(media.ilkd === 0 && user.getKey() === Auth.currentUser().getKey()) {
                    //                 media.ilkd = 1;
                    //             }
                    //         }
                    //     }
                    // },
                    addToAlbumData: function() {
                        return {
                            //cntntId: this.media.cntntId,
                            strmURL: this.media.strmURL,
                            tiw: this.media.tiw,
                            tih: this.media.tih,
                            drtn: this.media.drtn,
                            thmbURL: this.media.thmbURL,
                            artst: this.media.artst,
                            ttl: this.media.ttl.utf8Encode() //fileObj.meta.ttl
                        };
                    },
                    // API CALLS
                    increaseView: function() {
                        var deferred = $q.defer(),that=this;
                        mediaHttpService.increaseViewCount(that.media.cntntId).then(function(json) {
                            if (json.sucs === true) {
                                that.media.ac++;
                            }
                            deferred.resolve();
                        });
                        return deferred.promise;
                    },
                    updateRecentMedias: updateRecentMedias,
                    fetchDetails: function(user) {
                        var deferred = $q.defer(),
                            self = this;

                        if (self.media.gotDetails) {
                            deferred.resolve(self);
                        } else {
                            var reqData = {
                                cntntId: self.getKey(),
                                utId: user ? user.getUtId() : self.owner().getUtId()
                            };
                            mediaHttpService.fetchContentDetails(reqData).then(function(json) {
                                if (json.sucs === true) {
                                    self.updateMedia(json.mdaCntntDTO, true);
                                    updateRecentMedias(json);
                                    deferred.resolve(self);
                                } else {
                                    deferred.reject(json);
                                    Ringalert.show(json,'info');
                                }
                            });

                        }
                        return deferred.promise;
                    }
                };

        return function (obj, userMap) {
                return new RingMedia(obj,userMap);
        };
    }




})();

/*
 * Ipvision
 */


(function(){
    'use strict';
    angular
        .module('ringid.media')
        .factory('$$mediaAlbumMap', $$mediaAlbumMap);

    $$mediaAlbumMap.$inject = ['Ringalert', 'Auth', 'settings', 'fileUploadService', '$$stackedMap', '$$mediaMap', 'APP_CONSTANTS', 'mediaHttpService', 'utilsFactory'];
    function $$mediaAlbumMap (Ringalert, Auth, settings,  fileUploadService, $$stackedMap, $$mediaMap, APP_CONSTANTS, mediaHttpService, utilsFactory) { //jshint ignore:line
        var AC = APP_CONSTANTS;

        function createAlbumKey (obj) {
                //return obj.mdaT + '-' + obj.id;
                return parseInt(obj.id) || parseInt(obj.albId);
        }

        return {
            createKey: function(obj) {
                return createAlbumKey(obj);
            },
            createAlbum: function (obj, user) {
                var album = {
                    albn: '', // album name
                    albId: 0,
                    mc: 0, // total no of content in this album
                    mdc:0,
                    mdaT: 1, // meida time 1=audio, 2=video
                    sts: 0, // do no know
                    utId: 0, // owner user utid
                    imgURL:'',
                    contents: $$stackedMap.createNew(),

                    uniqueKey: utilsFactory.getUniqueID(),
                    // calculated data
                    cover: '',
                    key: 0,
                    type: '',
                    owner: 0
                };


                var updatealbumObj = function(albumObj) {
                    if (angular.isObject(albumObj)) {
                        album = angular.extend({}, album, albumObj);
                        album.albId = parseInt(albumObj.id) || parseInt(albumObj.albId);

                        album.owner = user;
                        album.key = createAlbumKey(albumObj);
                        if (albumObj.imgURL  && albumObj.imgURL.length > 1) {
                            album.cover = settings.imBase + albumObj.imgURL;
                        }else{
                            album.cover = (obj.mdaT === AC.NEWS_FEED_MEDIA_TYPE_AUDIO ) ? 'images/default_audio_image.jpg' : 'images/default_video_image.jpg';
                        }
                        album.type= (obj.mdaT === AC.NEWS_FEED_MEDIA_TYPE_AUDIO ) ? 'audio' : 'video';
                    } else {
                    }
                };

                updatealbumObj(obj);

                function pushContents(contentJson, owner,nfId) {
                    var mediaMap;
                    owner = owner || album.owner;

                    for(var i = 0, l = contentJson.length; i < l; i++) {
                        if(nfId){
                            contentJson[i].nfId = nfId;
                        }
                        mediaMap = $$mediaMap(angular.extend(contentJson[i], {albId: album.id}), owner);
                        album.contents.save(mediaMap.getKey(), mediaMap);
                    }
                    return album; // might not be needed
                }

                return {
                    getKey: function() {
                        return album.key;
                    },
                    getType: function() {
                        return album.type;
                    },
                    isAudio: function() {
                        return (album.mdaT === AC.NEWS_FEED_MEDIA_TYPE_AUDIO);
                    },
                    isVideo: function() {
                        return (album.mdaT === AC.NEWS_FEED_MEDIA_TYPE_VIDEO);
                    },
                    getId: function() {
                        return album.albId;
                    },
                    getName: function() {
                        return album.albn;
                    },
                    getCover: function() {
                        return album.cover;
                    },
                    getContentCount: function() {
                        return album.mc || album.mdc;
                    },
                    getContents: function() {
                        return album.contents;
                    },
                    updateAlbum: function(obj) {
                        updatealbumObj(obj);
                    },
                    pushContent: function(contentJson, owner,nfId,mediaMap) {
                        return pushContents(contentJson, owner,nfId,mediaMap);
                    },
                    getALbumUtId : function () {
                        return album.utId;
                    },
                    link: function (user, onlyPath) {
                        if( !!user.getUId()|| !!user.getUtId()){
                            var link = utilsFactory.getRingRoute('USER_PROFILE', { uId : user.getUId(), utId : user.getUtId(), subpage: 'media', albumId: album.albId});
                            if (onlyPath) {
                                return link.replace('#', '');
                            } else  {
                                return settings.baseUrl + link;
                            }
                        }else{
                            return '';
                        }
                    },
                    // api calls
                    addNewContent: function(mediaMap) {
                        var index, limit,
                            whichFiles = (album.type === 'audio') ? 'audioFiles' : 'videoFiles',
                            payload = {
                            albId: album.albId,
                            mdaLst: [],
                            mdaT: album.mdaT
                        };

                        // new content from status
                        if (!mediaMap) {
                            for(index = 0, limit = fileUploadService[whichFiles].length; index < limit; index++ ) {
                                payload.mdaLst.push(fileUploadService[whichFiles][index].getAuthData());
                            }
                        } else {
                            // check if media already in the album or not
                            if (album.contents.get(mediaMap.getKey())) {
                                Ringalert.show('Content Already Added', 'warning');
                                return;
                            }
                            // new content from other users album
                             payload.mdaLst.push(mediaMap.addToAlbumData());
                        }
                        mediaHttpService.addMediaToAlbum(payload).then(function(json) {
                            if(json.sucs === true) {
                                    album.mc += json.mdaIds.length;
                                for(index = 0, limit = json.mdaIds.length; index < limit; index++) {
                                    //payload.mdaLst[index].id = json.mdaIds[index];
                                    payload.mdaLst[index].cntntId = json.mdaIds[index];
                                }
                                pushContents(payload.mdaLst);
                                //if (mediaMap) {
                                    //Ringalert.show('Content Added to album', 'success');
                                //}
                            } else {
                                //if (mediaMap) {
                                    //Ringalert.show(json.mg || 'Failed to add media', 'error');
                                //}
                            }
                        });
                    },
                    deleteContent: function(mediaMap) {
                        mediaHttpService.deleteAlbumContent(mediaMap.getId()).then(function(json) {
                            if(json.sucs === true) {
                                // remove content from contents map
                               album.contents.remove(mediaMap.getKey());
                               //decrease total content count
                               album.mc--;
                            } else {
                            }
                        });
                    },
                    fetchContentDetails: function() {
                        var items = album.contents.all();
                        function timedCall(mediaMap, time) {
                            setTimeout(function() {
                                mediaHttpService.likeList(mediaMap.getId()).then(function(json) {
                                    // update mediaMap
                                });
                            }, time);
                        }

                        for(var i = 0, l = items.length; i < l; i++) {
                            (timedCall)(items[i].value, (i * 200 + 200) );
                        }
                    }

                };

            }
        };
    }




})();


/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.media')
        .factory('Media', MediaFactory);


        MediaFactory.$inject = ['mapFilterFilter',  'utilsFactory', 'Ringalert',  'userFactory', 'Auth', '$routeParams','Storage', 'profileFactory', 'OPERATION_TYPES',
            'APP_CONSTANTS', 'mediaHttpService', '$$mediaAlbumMap', '$$mediaMap', '$$stackedMap', '$$q', '$$connector', 'SystemEvents', '$rootScope'];
        function MediaFactory(mapFilterFilter,  utilsFactory, Ringalert, User, Auth, $routeParams, Storage, profileFactory, OPERATION_TYPES,
                              APP_CONSTANTS, mediaHttpService, $$mediaAlbumMap, $$mediaMap, $$stackedMap, $q, $$connector, SystemEvents, $rootScope) { // jshint ignore:line
            var _state = {
                    albumsLoading: false,
                    contentsLoading: false,
                    noresultfound:false
                },

                initialized = false,
                _albums = $$stackedMap.createNew(),
                _userAlbums =  $$stackedMap.createNew(),
                _otherAlbums = $$stackedMap.createNew(),

                _searchedAlbums = $$stackedMap.createNew(),
                _searchesongs   = $$stackedMap.createNew(),
                _albumOwner,
                _utId           = 0,
                OTYPES          = OPERATION_TYPES.SYSTEM.MEDIA,
                AC              = APP_CONSTANTS,
                subscriptionKey,
                searchedTagArr  = [],
                contentIdArray  = [],
                albumIdArray    = [];
                //mediaRecent     = Storage.getData('mediaRecent');


            function _processResponse(json) {
                var album, i, l, albId;
                switch(json.actn) {
                    case OTYPES.ACTION_MEDIA_ALBUM_LIST:
                        if(json.sucs === true && json.mediaAlbumList) {
                            _albumOwner = (Auth.currentUser().getUtId() === json.utId) ? Auth.currentUser() : User.create({utId: json.utId});
                            for(i = 0, l = json.mediaAlbumList.length; i < l; i++) {
                                albId = json.mediaAlbumList[i].albId || json.mediaAlbumList[i].id;
                                album = _albums.get(albId) || _userAlbums.get(albId);
                                if (album) {
                                    album.updateAlbum(json.mediaAlbumList[i]);
                                } else {
                                    album = $$mediaAlbumMap.createAlbum(json.mediaAlbumList[i], _albumOwner);
                                }

                                if(_albumOwner && _albumOwner.isCurrentUser()) {
                                    _albums.save(album.getKey(), album);
                                } else {
                                    _userAlbums.save(album.getKey(), album);
                                }
                                //_albumList[album.getKey()] = album;
                            }
                        } else {
                        }
                        break;
                    case  OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST:
                        if(json.sucs === true && json.mdaCntntLst) {
                            var key = $$mediaAlbumMap.createKey(json);
                            album = _albums.get(key) || _userAlbums.get(key); // || _albumList[key];
                            if(album) {
                                album.pushContent(json.mdaCntntLst);
                            } else {
                            }

                        } else {
                        }
                        break;
                    // case OTYPES.ACTION_SPECIFIC_MEDIA_RESULT://278
                    //     _state.noresultfound = false;var loopLength;
                    //     if ( json.sucs === true ) {
                    //         if(json.tr===10){
                    //             loopLength = json.mdaLst.length-1;
                    //         }else{
                    //             loopLength = json.mdaLst.length;
                    //             _state.noresultfound = true;
                    //         }
                    //         for(i=0;i<loopLength;i++){
                    //             if(json.mdaLst[i].sugt===1){
                    //                 contentIdArray.push(json.mdaLst[i].cntntId);
                    //                 json.mdaLst[i].viewtime = new Date().getTime();
                    //                 obj = $$mediaMap(json.mdaLst[i]);
                    //                 _searchesongs.save(obj.getKey(),obj);
                    //             }
                    //             if(json.mdaLst[i].sugt===2) {

                    //                 albumIdArray.push(json.mdaLst[i].albId);
                    //                 obj = $$mediaAlbumMap.createAlbum(json.mdaLst[i]);
                    //                 _searchedAlbums.save(obj.getKey(),obj);
                    //             }
                    //             if ( json.mdaLst[i].sugt===3 ) {
                    //                 console.log(json.mdaLst[i]);
                    //                 searchedTagArr.push(json.mdaLst[i]);
                    //             }

                    //         }
                    //     } else {
                    //           _state.noresultfound = true;
                    //     }
                    //     break;
                    // case OTYPES.ACTION_GET_TAGGED_MEDIA_SONGS:
                    //      _state.noresultfound = false;
                    //     if(json.sucs===true){
                    //         for(i=0;i<json.mdaLst.length;i++){
                    //             obj = $$mediaMap(json.mdaLst[i]);
                    //             _searchesongs.save(obj.getKey(),obj);
                    //         }
                    //     } else {
                    //          _state.noresultfound = true;
                    //     }
                    //     break;
                    //case OTYPES.ACTION_MEDIA_SEARCH_RESULT:
                    //    if ( json.sucs === true ) {
                    //        for(i=0;i<json.sgstn.length;i++){
                    //            mediaSearchResult.push(json.sgstn[i]);
                    //        }
                    //    }else{
                    //
                    //    }
                    //    break;

                    //case  OTYPES.ACTION_MEDIA_LIKE_LIST:
                        //if (json.sucs === true && json.likes) {
                            //mediaMap = getMediaMap(json.cntntId);
                            //if(mediaMap) {
                                //mediaMap.pushLikes(json);
                            //} else {
                            //}

                        //} else {
                        //}
                        //break;

                    // case  OTYPES.ACTION_MEDIA_COMMENT_LIST:
                    //     if(json.sucs === true && json.comments) {
                    //         mediaMap = getMediaMap(json.cntntId);
                    //         if(mediaMap) {
                    //             mediaMap.pushComments(json);
                    //         } else {
                    //         }
                    //     } else {
                    //     }
                    //     break;
                    default:
                }

            }



            function _fetchAllAlbums(utId, albumType) {
                    _utId = utId || (Auth.currentUser() ? Auth.currentUser().getUtId() : false);

                    switch(albumType) {
                        case 'audio':
                            mediaHttpService.fetchMediaAlbums({utId: _utId, mdaT: AC.NEWS_FEED_MEDIA_TYPE_AUDIO });
                            break;
                        case 'video':
                            setTimeout(function() {
                                mediaHttpService.fetchMediaAlbums({utId: _utId, mdaT: AC.NEWS_FEED_MEDIA_TYPE_VIDEO });
                            }, 500);
                            break;
                        default:
                            mediaHttpService.fetchMediaAlbums({utId: _utId, mdaT: AC.NEWS_FEED_MEDIA_TYPE_AUDIO });
                            setTimeout(function() {
                                mediaHttpService.fetchMediaAlbums({utId: _utId, mdaT: AC.NEWS_FEED_MEDIA_TYPE_VIDEO });
                            }, 500);
                    }

            }


            function getAlbum(albumId) {
                albumId = parseInt(albumId);
                return _albums.get(albumId) || _userAlbums.get(albumId) || _otherAlbums.get(albumId); // || _albumList[albumId]; //_albums.get(albumId) || _userAlbums.get(albumId);
            }




            subscriptionKey = $$connector.subscribe(_processResponse, {
                action:  [
                    OTYPES.ACTION_MEDIA_ALBUM_LIST,
                    //OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST,
                    // OTYPES.ACTION_SPECIFIC_MEDIA_RESULT,
                    // OTYPES.ACTION_GET_TAGGED_MEDIA_SONGS,
                    OTYPES.ACTION_MEDIA_SEARCH_RESULT
                ]
            });

            function init() {

                if (!initialized) {
                    initialized = true;
                    _fetchAllAlbums();
                    return true;
                } else {
                     return false;
                }

            }


            return {
                init: init,
                // accessors
                state: _state,
                processResponse: _processResponse,
                getAlbum: getAlbum,
                resetMediaAlbums: function() {
                    _userAlbums.reset();
                     //$$connector.unsubscribe(subscriptionKey);
                },
                getUserAlbums: function(type) {
                    if (type) {
                        return mapFilterFilter(_userAlbums.all(), {mapApi: 'getType', value: type, compare:'regex'});
                    } else {
                        return _userAlbums;
                    }
                },
                getAlbums: function(currentUser, type) {
                    var albums = currentUser ? _albums : _userAlbums;
                    if (type) {
                        return mapFilterFilter(albums.all(), {mapApi: 'getType', value: type, compare:'regex'});
                    } else {
                        return albums;
                    }
                },
                getSearchedSongs: function () {
                    return _searchesongs;
                },
                getSearchedAlbums: function () {
                    return _searchedAlbums;
                },
                getContentIdArray: function () {
                    return contentIdArray;
                },
                resetContentIdArray: function () {
                    contentIdArray = [];
                },
                getAlbumIdArray: function () {
                    return albumIdArray;
                },
                resetAlbumIdArray: function () {
                    albumIdArray = [];
                },
                getSearchedTagArr : function () {
                    return searchedTagArr;
                },
                resetSearchedSongs: function () {
                    return _searchesongs.reset();
                },
                resetSearchedAlbum: function () {
                    return _searchedAlbums.reset();
                },
                resetSearchedTagArr : function () {
                    searchedTagArr = [];
                },

                // api methods
                fetchAllAlbums: _fetchAllAlbums,
                createAlbum: function(albumObj, newAlbum) {
                    var albumMap, defer;

                    if (newAlbum) {
                        albumObj.id =  utilsFactory.getUniqueID();
                        defer = $q.defer();
                    }

                    if(newAlbum) {
                        mediaHttpService.addMediaAlbum(albumObj).then(function(json) {
                            if(json.sucs === true) {
                                albumMap = $$mediaAlbumMap.createAlbum(angular.extend(albumObj, {id: json.albId}), Auth.currentUser());
                                //_albumList[albumMap.getKey()] = albumMap;
                                _albums.save(albumMap.getKey(), albumMap);
                                //albumMap.updateAlbum({id: json.albId});
                                //_albumList[albumMap.getKey()] = albumMap;
                                defer.resolve(albumMap);
                            } else {
                                //_albums.remove(albumObj.id);
                                defer.reject(false);
                            }
                        }, function() {
                            defer.reject(false);
                        });
                    }
                    if (newAlbum) {
                        return defer.promise;
                    } else {
                        return albumMap;
                    }
                },
                deleteAlbum: function(albumMap) {
                    mediaHttpService.deleteAlbum(albumMap.getId()).then(function(json) {
                        if(json.sucs === true) {
                            _albums.remove(albumMap.getKey());
                            //delete _albumList[albumMap.getKey()];
                        } else {
                        }
                    });
                },
                fetchAlbumContents: mediaHttpService.fetchAlbumContents,
                fetchAlbumContentsForpopup: mediaHttpService.fetchAlbumContentsForpopup,
                getSearchTrends : function () {
                   return mediaHttpService.getSearchTrends();
                },
                getTaggedMedia : function (obj) {
                   mediaHttpService.getTaggedMedia(obj);
                },
                fetchSearchResult: function(param) {
                      return mediaHttpService.fetchSearchResult(param);
                },
                fetchHashtagSuggestion: mediaHttpService.fetchHashtagSuggestion,
                fetchContent: function(param) {
                     _state.noresultfound = false;
                    return mediaHttpService.fetchContent(param);
                },
                fetchContentDetails: function(cntntId, forPopup, utId) {
                    var defer = $q.defer(),
                        mediaMap,
                        reqData = {
                            cntntId: cntntId,
                            utId:  utId
                        };

                    // fetch content detail
                    mediaHttpService.fetchContentDetails(reqData).then(function(json) {
                        if (json.sucs === true) {
                            mediaMap =  $$mediaMap(json.mdaCntntDTO);
                            mediaMap.updateRecentMedias(json);
                            defer.resolve(mediaMap);
                        } else {
                            defer.reject(json);
                            Ringalert.show(json,'info');
                        }
                    });

                    return defer.promise;
                }
            };
        }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .directive('rgMedia', rgMedia);


        rgMedia.$inject = ['$window', '$document', 'Media', '$routeParams'];
        function rgMedia($window, $document, Media, $routeParams) { // jshint ignore:line

            MediaController.$inject = ['profileFactory', 'Auth', 'fileUploadService', 'SystemEvents', '$rootScope', '$scope', 'Media', '$location','$attrs','Storage',
                'OPERATION_TYPES', '$$connector', 'utilsFactory', 'userFactory', '$$mediaAlbumMap', '$$stackedMap', 'mapFilterFilter', '$ringbox'];
            function MediaController (profileFactory, Auth, fileUploadService, SystemEvents, $rootScope, $scope, Media, $location,$attrs,Storage,
                                      OPERATION_TYPES, $$connector, utilsFactory, User, $$mediaAlbumMap, $$stackedMap, mapFilterFilter, $ringbox) { //jshint ignore:line

                var subscriptionKey,
                    isCurrentUser = false,
                    albumTimeout,
                    OTYPES     = OPERATION_TYPES.SYSTEM.MEDIA,
                    profileObj = profileFactory.getProfile($routeParams.uId);

                    $scope.profilePage = $attrs.inProfile;

                $scope.showMediaPreview = false;
                $scope.activeAlbum      = null;
                $scope.state            = Media.state;
                $scope.selectedPlaylist = $$stackedMap.createNew();

                $scope.getAlbums          = getAlbums;
                $scope.deleteMedia        = deleteMedia;
                $scope.toggleAlbumPreview = toggleAlbumPreview;
                $scope.getMediaData       = getMediaData;
                $scope.selectMedia        = selectMedia;
                $scope.loadMoreContent    = loadMoreContent;

                $scope.musicTab = true;
                $scope.showAlbumContents = false;

                if($routeParams.albumId){
                    $scope.showAlbumContents = true;
                    $scope.$rgDigest();
                }

                $scope.showDesiredTab = function(param){
                    switch(param) {
                        case 'music':
                            $scope.musicTab = true;
                            break;
                        case 'video':
                            $scope.musicTab = false;
                            break;
                    };
                    $scope.$rgDigest();
                }


                function toggleLoading(bool, type) {
                    if($scope.profilePage === 'false'){
                        return;
                    }
                    if (type === 'album') {
                        $scope.state.albumsLoading = bool;
                    } else {
                        $scope.state.contentsLoading = bool;
                    }
                    $scope.$rgDigest();
                }

                function getAlbums (type) {
                    if($scope.profilePage === 'true'){
                        return Media.getAlbums(profileObj.isCurrentUser(), type);
                    }else{
                        return Media.getAlbums(true, type);
                    }
                    
                    
                    //if (type) {
                        //return mapFilterFilter(_albums.all(), {mapApi: 'getType', value: type, compare:'regex'});
                    //} else {
                        //return _albums;
                    //}
                }

                function deleteMedia(mediaMap) {
                    var message = 'Are you sure you want to delete?';
                    var boxInstance = $ringbox.open({
                            type : 'remote',
                            scope:false,
                            controller: 'RingBoxConfirmController',
                            resolve : {
                                localData : {
                                    message : message
                                }
                            },
                            templateUrl : 'pages/partials/ringbox-confirm.html'
                    });

                    boxInstance.result.then(function(confirmed){
                        if(confirmed){
                            Media.deleteMedia(mediaMap);
                        }
                    });
                }

                function toggleAlbumPreview(mediaMap,type) {
                    if($scope.profilePage === 'false'){
                        var url;var albumname = [];
                        albumname.push(mediaMap.getName());
                        albumname.push(mediaMap.getContentCount());
                        Storage.setData('albumname',albumname);
                        switch ( type ) {
                            case 'audio':
                                url = 'media/'+type+'/'+mediaMap.getALbumUtId()+'/'+mediaMap.getKey();
                                $location.path(url);
                                break;
                            case 'video':
                                url = 'media/'+type+'/'+mediaMap.getALbumUtId()+'/'+mediaMap.getKey();
                                $location.path(url);
                                break;
                            default :
                                url = 'media';
                                $location.path(url);
                                break;
                        }
                    }else{
                        if (mediaMap) {
                            window.location = mediaMap.link(profileObj);
                        } else {
                            window.location = utilsFactory.getRingRoute('USER_PROFILE', { uId : profileObj.getUId(), utId : profileObj.getUtId(), subpage: 'media'});
                        }
                    }
                    

                }

                function selectMedia(mediaMap, addToSelected) {
                    if (addToSelected) {
                        $scope.selectedPlaylist.add(mediaMap.getKey(), mediaMap);
                    } else {
                        $scope.selectedPlaylist.remove(mediaMap.getKey());
                    }
                }

                function getMediaData (playActive, mediaMap) {
                    var playlist;

                    if (playActive) {
                        playlist =  $scope.activeAlbum.getContents().all();
                    } else {
                        playlist = $scope.selectedPlaylist.all();
                    }
                    mediaMap = mediaMap || playlist[0].value;

                    return {
                            data: function () {
                                return {
                                    media: mediaMap,
                                    playlist: playlist,
                                    popupForm: 'profile'
                                };
                            },
                            promise: mediaMap.fetchDetails(profileObj) //Media.fetchContentDetails(mediaMap.getKey(), true, profileObj)
                        };
                }


                function loadMoreContent (force) {
                    if (force || !$scope.state.contentsLoading &&
                        $scope.activeAlbum &&
                        $scope.activeAlbum.getContents().length() < $scope.activeAlbum.getContentCount() ) {
                        toggleLoading(true);
                        Media.fetchAlbumContents({
                            albId: $scope.activeAlbum.getKey(),
                            utId: profileObj.getUtId(), // optional. maybe without utid just own media album list fetch
                            st: $scope.activeAlbum.getContents().length()
                        });

                    }
                }

                function activate() {
                    //if (Media.init()) {
                        //Media.fetchAllAlbums(profileObj.getUtId());
                    //}

                    //if (!profileObj.isCurrentUser()) {
                    //}


                    subscriptionKey = $$connector.subscribe(function(json) {
                        //var i, _albumOwner, l, album;
                        switch(json.actn) {
                            case OTYPES.ACTION_MEDIA_ALBUM_LIST:
                                //if (!albumTimeout && json.utId === profileObj.getUtId()) {
                                if (json.utId === profileObj.getUtId()) {
                                    setTimeout(function() {
                                        //clearTimeout(albumTimeout);
                                        if (!$scope.showMediaPreview) {
                                            $scope.activeAlbum = Media.getAlbum($routeParams.albumId);
                                            if ($scope.activeAlbum) {
                                                loadMoreContent(true);
                                            }
                                        }
                                        toggleLoading(false, 'album');
                                    }, 1000);
                                }
                                //} else {
                                    //toggleLoading(false, 'album');
                                //}
                                break;
                            case OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST:
                                Media.processResponse(json);
                                setTimeout(function() {
                                    toggleLoading(false);
                                }, 1000);
                                break;
                        }

                    }, {
                        action:  [
                            OTYPES.ACTION_MEDIA_ALBUM_LIST,
                            OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST,
                        ]
                    });


                    if ($routeParams.albumId) {
                        $scope.showMediaPreview = false;
                        $scope.activeAlbum = Media.getAlbum($routeParams.albumId);
                        if ($scope.activeAlbum) {
                            loadMoreContent(true);
                        }
                        toggleLoading(true);
                    } else {
                        $scope.showMediaPreview = true;
                    }
                    if (!profileObj.isCurrentUser()) {
                        Media.fetchAllAlbums(profileObj.getUtId());
                        toggleLoading(true, 'album');
                    }


                    if (Media.init()) {
                        toggleLoading(true, 'album');
                    }
                    

                }//end activate()

                activate();

                //currently not in use : used for 'view all' purpose
                if($scope.profilePage==='false'){
                    $scope.limitItem = 4;
                }else{
                    $scope.limitItem = 'Infinity';
                }
                //currently not in use

                $scope.$on('$destroy', function() {
                    // reset and unsubscribe media albums
                    $$connector.unsubscribe(subscriptionKey );
                    Media.resetMediaAlbums();
                });

            }


            var linkFunc = function(scope, element, attrs) {
                //var contentLength = 0, totalContentLength = 0;
                function handleScroll () {
                    if (!scope.showMediaPreview) {
                        if ( ($window.innerHeight + $window.scrollY) >= $document[0].body.offsetHeight ) {
                            scope.loadMoreContent(true);
                        }
                    }
                }

                $window.addEventListener('scroll', handleScroll);
                scope.$on('$destroy', function() {
                    $window.removeEventListener('scroll', handleScroll);
                });

            };

            return {
                restrict: 'E',
                controller: MediaController,
                link: linkFunc,
                // templateUrl: 'pages/partials/media.html'
                templateUrl: function(element,attrs) {
                    return attrs.templatepath; 
                }
            };
        }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .directive('rgMediaSearch', rgMediaSearch);

    rgMediaSearch.$inject = [ '$document', 'Media', '$routeParams' ];
    function rgMediaSearch( $document, Media, $routeParams ) { // jshint ignore:line

        MediaSearchController.$inject = ['$$stackedMap','$$mediaMap','Storage', 'OPERATION_TYPES','Auth', '$scope', 'Media','userFactory','$$mediaAlbumMap','$location','rgDropdownService','$ringbox','Ringalert' ];
        function MediaSearchController ($$stackedMap, $$mediaMap,Storage, OPERATION_TYPES,Auth, $scope, Media,userFactory,$$mediaAlbumMap,$location,rgDropdownService,$ringbox,Ringalert ) { //jshint ignore:line

            var albumname = [];
            Storage.setData('albumname',albumname);
            $scope.medias = $$stackedMap.createNew(true,'desc');
            $scope.popupmedias = $$stackedMap.createNew(true,'desc');

            var OTYPES = OPERATION_TYPES.SYSTEM.MEDIA;

            $scope.recentMediaDropdown = 'pages/dropdowns/recent-media-dropdown.html';

            $scope.searchedMedia = $$stackedMap.createNew();
            $scope.trendingArr = [];
            $scope.nodatafound = false;
            $scope.noaudiofound = false;
            $scope.activeNav = 'recent';

            //var uploadProgress = false;

            var userMap = Auth.currentUser();
            $scope.utId =  userMap.getUtId();
            Media.fetchAllAlbums();


            function activate() {
                var mediaArr = Storage.getData('mediaRecent');
                for( var i = 0; i<mediaArr.length; i++ ) {
                    var media = $$mediaMap(mediaArr[i]);
                    $scope.medias.save(media.getKey(), media);
                }
            }
            activate();


            $scope.getRecentMediaData = function( mediaMap) {
                return {
                    data: function () {
                        return {
                            media: mediaMap ,
                            playlist: $scope.medias.all()
                            //popupForm: 'profile'
                        };
                    },
                    promise: mediaMap.fetchDetails() //Media.fetchContentDetails( mediaMap.getKey(), true, albumowner, mediaMap.getMediaUtId() )
                };

            };



            $scope.getTaggedMedia = function (obj) {
                Media.getTaggedMedia(obj);
            };

            $scope.goToMyAlbums = function (param) {
              var path = 'media/'+param;
                $location.path(path);
            };

            $scope.selectAlbum = function(mediaMap) {
                return {
                        data: function () {
                            return {
                                media: mediaMap,
                                //album: feed.getAlbum(),
                                //playlist: feed.getAlbum().getContents().all(),
                                //feedTime: feed.time()
                            };
                        },
                        //promise: media.fetchDetails() // Media.fetchContentDetails(media, true, media.user())
                    };

            };

            $scope.actionRecentMediaDropdown = function(actionObject){
                switch(actionObject.action){
                    case 'addtoalbum':
                        console.log('addtoalbum');
                        var boxInstance = $ringbox.open({

                                type : 'remote',
                                scope:false,
                                onBackDropClickClose:true,
                                controller: 'RingBoxAlbumlistController',
                                resolve : {
                                    localData : {
                                        media : actionObject.data.obj
                                    }
                                    
                                },
                                templateUrl : 'pages/dropdowns/popup-album-dropdown.html'
                        });
                        break;
                    case 'sendtofriend':
                        console.log('sendtofriend');
                        break;
                    case 'shareatringid':
                    var instance = $ringbox.open({
                        type: 'remote',
                        scope: false,
                        controller: 'feedMediaShareController',
                        scopeData: {
                            media: actionObject.data.obj
                        },
                        onBackDropClickClose: true,
                        templateUrl: 'pages/home/share-media.html',
                    });
                    instance.result.then(function() {
                        $scope.$rgDigest();
                    });
                        console.log('shareatringid');
                        break;
                    case 'shareatfb':
                        console.log('shareatfb');
                        break;
                    case 'download':
                        console.log('download');
                        Ringalert.show('Currently download option is available in ringID desktop and mobile app version only','info');
                        break;
                    default:
                        break;
                }
            };

            // $scope.goToAlbum = function( obj ) {
            //     var url;
            //     albumname.push(obj.name);
            //     albumname.push(obj.mc);
            //     Storage.setData('albumname',albumname);
            //     switch ( obj.type ) {
            //         case 'audio':
            //             url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
            //             $location.path(url);
            //             break;
            //         case 'video':
            //             url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
            //             $location.path(url);
            //             break;
            //         default :
            //             url = 'media';
            //             $location.path(url);
            //             break;
            //     }
            // };


            // Media.getSearchTrends().then(function(data){
            //     if ( data.sucs === true ) {
            //         for(var i = 0; i < data.sgstn.length; i++) {
            //             //console.log(data.sgstn[i]);
            //             switch (data.sgstn[i].sugt){
            //                 case 1 :
            //                     data.sgstn[i].searchtype = 'songs';
            //                     break;
            //                 case 2 :
            //                     data.sgstn[i].searchtype = 'albums';
            //                     break;
            //                 case 3 :
            //                     data.sgstn[i].searchtype = 'tags';
            //                     break;
            //             }
            //             $scope.trendingArr.push(data.sgstn[i]);
            //         }
            //     }
            //     $scope.$rgDigest();
            // });


            $scope.$on('$destroy', function() {
                // $scope.trendingArr = [];
                Media.resetMediaAlbums();
            });
        }

        var linkFunc = function(scope,element) {
            element.bind('click',function(){
               //console.log(scope.medias.all());
            });
            //var input = element.find('input');
            //
            //input.on('keypress', function(event) {
            //    if(event.keyCode === 13) {
            //        event.preventDefault();
            //    }
            //});

        };

        return {
            restrict: 'E',
            controller: MediaSearchController,
            link: linkFunc,
            templateUrl: 'pages/partials/media-search.html'
        };
    }
})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .directive('rgTabNav', rgTabNav);

    rgTabNav.$inject = [ '$routeParams' ];
    function rgTabNav( $document, Media, $routeParams ) { // jshint ignore:line

        tabNavController.$inject = [ '$scope','$location' ];
        function tabNavController ( $scope, $location ) { //jshint ignore:line

            $scope.isCurrentPath = function (path,contain) {
                return contain ?$location.path().indexOf(path) > -1 : $location.path() == path;
            };
      
        }

        var linkFunc = function(scope,element) {
           

        };

        return {
            restrict: 'E',
            controller: tabNavController,
            link: linkFunc,
            templateUrl: 'pages/partials/media.tabnav.dir.html'
        };
    }
})();

/**
 * Created by User on 23-Jan-16.
 */
/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .directive('rgMediaSearchDirective', rgMediaSearchDirective);

    rgMediaSearchDirective.$inject = [ '$document', 'Media' ];
    function rgMediaSearchDirective( $document, Media ) { // jshint ignore:line

        searchDirectiveController.$inject = ['$rootScope','OPERATION_TYPES', '$scope', 'Media','$location','rgScrollbarService','GlobalEvents' ];
        function searchDirectiveController ($rootScope,OPERATION_TYPES, $scope, Media,$location,rgScrollbarService,GlobalEvents ) { //jshint ignore:line

            var OTYPES = OPERATION_TYPES.SYSTEM.MEDIA;

            var self = this;

            $scope.showDropdown = false;
            $scope.stoploader = false;
            $scope.showTrending = false;

            $scope.searchResult = [];
            $scope.trendingArr = [];

            $scope.doSearch = function () {
                $scope.searchResult = [];
                $scope.stoploader = false;

                if( !$scope.searchParam ) {
                    $scope.showDropdown = false;
                    $scope.showTrending = true;
                }else{
                    $scope.showTrending = false;
                    //Media.fetchSearchResult( $scope.searchParam );
                    Media.fetchSearchResult( $scope.searchParam ).then(mediaSearchResultProcess);
                    $scope.showDropdown = true;
                }
                // GlobalEvents.bindHandler('document', 'click', self.closeDropdown);
            };

            $scope.doContentSearch = function ( obj ) {
                var searchurl;
                $scope.showDropdown = false;
                switch ( obj.sugt ) {
                    case 1 :
                        searchurl = 'media/songs/'+obj.sk;
                        $location.path(encodeURI(searchurl));
                        $rootScope.$rgDigest();
                        break;
                    case 2 :
                        searchurl = 'media/albums/'+obj.sk;
                        $location.path(encodeURI(searchurl));
                        $rootScope.$rgDigest();
                        break;
                    case 3 :
                        searchurl = 'media/tags/'+obj.sk;
                        $location.path(encodeURI(searchurl));
                        $rootScope.$rgDigest();
                        break;
                }

            };

            $scope.fetchTrendingKeyword = function(){
                $scope.showDropdown = true;
                if($scope.trendingArr.length > 0){
                    // $scope.showDropdown = true;
                    $scope.showTrending = true;
                    $scope.$rgDigest();
                   return; 
                }
                    
            
                Media.getSearchTrends().then(function(data){
                    if ( data.sucs === true ) {
                        for(var i = 0; i < data.sgstn.length; i++) {
                            console.log(data.sgstn[i]);
                            switch (data.sgstn[i].sugt){
                                case 1 :
                                    data.sgstn[i].searchtype = 'songs';
                                    break;
                                case 2 :
                                    data.sgstn[i].searchtype = 'albums';
                                    break;
                                case 3 :
                                    data.sgstn[i].searchtype = 'tags';
                                    break;
                            }
                            $scope.trendingArr.push(data.sgstn[i]);
                        }
                    
                        $scope.showTrending = true;
                    }
                    
                    $scope.$rgDigest();
                });
            };

            $scope.hideDropdown = function(){
                $scope.showDropdown = false;
                $scope.showTrending = false;
                $scope.searchParam  = '';
                $scope.searchResult = [];
                // $scope.trendingArr = [];
            };

            $scope.$on('$destroy', function() {
                $scope.trendingArr = [];
                $scope.searchResult = [];
            });

            // self.closeDropdown = function() {
            //     // close dropdown
            //     $scope.searchParam = '';
            //     $scope.showDropdown = false;
            //     GlobalEvents.unbindHandler('document', 'click', self.closeDropdown);
            //     $scope.$rgDigest();
            // };



            function mediaSearchResultProcess(data){
                var i;
                switch (data.actn) {

                    case OTYPES.ACTION_MEDIA_SEARCH_RESULT :
                        if ( data.sucs === true ) {
                            $scope.showDropdown = true;
                            for(i=0;i<data.sgstn.length;i++){
                                //console.log(data.sgstn[i]);
                                $scope.searchResult.push(data.sgstn[i]);
                            }
                            //console.log($scope.searchResult);
                            //rgScrollbarService.recalculate();
                        }else{
                            $scope.stoploader = true;
                        }
                        rgScrollbarService.recalculate($scope);
                        break;
                    default :
                        break;

                }
                $scope.$rgDigest();

            }

        }

        var linkFunc = function(scope,element) {
            element.bind('click',function(){
                //console.log(scope.medias.all());
            });

            var input = element.find('input');
            scope.activeId = 0;
            scope.setActiveId = function(i){
              scope.activeId = i;
            }
            

            element.on('keydown',function(event){
                if(event.keyCode === 13) {
                    if(scope.searchResult.length){
                        var result = scope.searchResult[scope.activeId];
                        scope.doContentSearch({sk: result.sk, sugt: result.sugt});
                    }
                }else if(event.keyCode === 38) {
                    scope.activeId = Math.max(scope.activeId - 1,0);
                    scope.$rgDigest();
                }else if(event.keyCode === 40){
                    scope.activeId = Math.min(scope.activeId+1,scope.searchResult.length-1);
                    scope.$rgDigest();
                }
            })

        };

        return {
            restrict: 'E',
            controller: searchDirectiveController,
            link: linkFunc,
            templateUrl: 'pages/mediasearch/media-search-directive.html'
        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .controller('mSearchResultController',mSearchResultController);

        mSearchResultController.$inject = [ 'Auth','Storage', 'userFactory', '$routeParams', '$$mediaAlbumMap','$$stackedMap','$$mediaMap','$scope', 'Media','$location','$$connector','OPERATION_TYPES'];
        function mSearchResultController (  Auth,Storage, userFactory, $routeParams, $$mediaAlbumMap,$$stackedMap,$$mediaMap, $scope, Media,$location,$$connector,OPERATION_TYPES ) {

            var albumname         = [];
            Storage.setData('albumname',albumname);
            $scope.stype          = $routeParams.stype;
            $scope.searchkey      = decodeURI($routeParams.sk);
            var sugt;
            var OTYPES             = OPERATION_TYPES.SYSTEM.MEDIA;
            $scope.loadMoreSongs   = false;
            $scope.loadMoreAlbums  = false;
            $scope.showSearchTitle = true;

            var contentIdArray    = [];
            var albumIdArray      = [];
            $scope.searchedTagArr = [];
            var  searchedSongMap    = $$stackedMap.createNew(),
                searchedAlbumsMap   = $$stackedMap.createNew();

            $scope.searchedSongs = function(){
                return searchedSongMap;
            };

            $scope.searchedAlbums = function(){
                return searchedAlbumsMap
            };

            switch ($routeParams.stype) {
                case 'songs':
                    sugt =1;
                    break;
                case 'albums':
                    sugt = 2;
                    break;
                case 'tags':
                    sugt = 3;
                    break;
                default :
                    sugt=1;
                    break;
            }

            $scope.showSearchDropdown = false;

            var userMap = Auth.currentUser();

            $scope.searchsongsection  = false;
            $scope.searchalbumsection = false;
            $scope.searchtagsection   = false;
            $scope.noresultsection    = false;
            // Media.resetSearchedSongs();
            // Media.resetSearchedAlbum();
            // Media.resetSearchedTagArr();

            if ( $scope.stype !== 'tag' ) {
                var obj = {
                    sk:$scope.searchkey,
                    sugt:sugt
                };
                Media.fetchContent( obj );
            }

            switch ( $scope.stype ) {
                case 'songs' :
                    $scope.searchsongsection = true;
                    break;
                case 'albums' :
                    $scope.searchalbumsection = true;
                    break;
                case 'tags' :
                    $scope.searchtagsection = true;
                    break;
                case 'tag' :
                    $scope.searchsongsection = true;
                    $scope.showSearchTitle = false;
                    if( !isNaN( $scope.searchkey ) ){
                        Media.getTaggedMedia(parseInt($scope.searchkey));
                    }
                    break;
            }

            //$scope.searchedSongs  = Media.getSearchedSongs;
            //$scope.searchedAlbums = Media.getSearchedAlbums;
            $scope.searchedTags   = Media.getSearchedTagArr();
            $scope.cntntidarray   = Media.getContentIdArray;
            $scope.albumidarray   = Media.getAlbumIdArray;
            // $scope.state          = Media.state;
            $scope.noresultfound  = false;

            $scope.loadMoreSuggestedSongs = function() {
                $scope.loadMoreSongs = true;
                var reqData = {
                    sk:$scope.searchkey,
                    sugt:sugt,
                    pvtid:contentIdArray.pop(),
                    scl:2
                };
                Media.fetchContent( reqData );
                Media.resetContentIdArray();
                $scope.$rgDigest();
            };

            $scope.loadMoreSuggestedAlbums = function() {
                $scope.loadMoreAlbums = true;
                var reqData = {
                    sk:$scope.searchkey,
                    sugt:sugt,
                    pvtid:albumIdArray.pop(),
                    scl:2
                };
                Media.fetchContent( reqData );
                Media.resetAlbumIdArray();
                $scope.$rgDigest();
            };

            $scope.getTaggedMedia = function ( obj ) {
                var searchurl = 'media/tag/'+obj.htid;
                $location.path(encodeURI(searchurl));
            };

            $scope.goToAlbum = function( obj ) {
                var url;
                albumname.push(obj.name);
                albumname.push(obj.mc);
                Storage.setData('albumname',albumname);
                switch ( obj.type ) {
                    case 'audio':
                        url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
                        $location.path(url);
                        break;
                    case 'video':
                        url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
                        $location.path(url);
                        break;
                    default :
                        url = 'media';
                        $location.path(url);
                        break;
                }
            };

            $scope.getMediaData = function( mediaMap ) {
                return {
                    data: function () {
                        return {
                            media: mediaMap,
                            playlist: [{key: mediaMap.getKey(), value: mediaMap}]
                            //popupForm: 'profile'
                        };
                    },
                    promise: mediaMap.fetchDetails() // Media.fetchContentDetails( mediaMap.getKey(), true, albumowner, mediaMap.getMediaUtId() )
                };
            };

            var subscriptionKey = $$connector.subscribe(searchContentProcess, {
                action: [
                    OTYPES.ACTION_SPECIFIC_MEDIA_RESULT,//278
                    OTYPES.ACTION_GET_TAGGED_MEDIA_SONGS//279
                ]
            });



            function searchContentProcess(json) {
                console.log(json);
                // var i;
                $scope.loadMoreSongs = false;
                $scope.loadMoreAlbums = false;

                switch( json.actn ){
                    case OTYPES.ACTION_SPECIFIC_MEDIA_RESULT://278
                        $scope.noresultfound = false;
                        var loopLength;
                        if ( json.sucs === true ) {
                            if(json.tr===10){
                                loopLength = json.mdaLst.length-1;
                            }else{
                                loopLength = json.mdaLst.length;
                                $scope.noresultfound = true;
                            }
                            for(var i=0;i<loopLength;i++){
                                if(json.mdaLst[i].sugt===1){
                                    contentIdArray.push(json.mdaLst[i].cntntId);
                                    json.mdaLst[i].viewtime = new Date().getTime();
                                    obj = $$mediaMap(json.mdaLst[i]);
                                    searchedSongMap.save(obj.getKey(),obj);
                                }
                                if(json.mdaLst[i].sugt===2) {

                                    albumIdArray.push(json.mdaLst[i].albId);
                                    obj = $$mediaAlbumMap.createAlbum(json.mdaLst[i]);
                                    searchedAlbumsMap.save(obj.getKey(),obj);
                                }
                                if ( json.mdaLst[i].sugt===3 ) {
                                    console.log(json.mdaLst[i]);
                                    $scope.searchedTagArr.push(json.mdaLst[i]);
                                }

                            }
                        } else {
                              $scope.noresultfound = true;
                        }
                        break;

                    case OTYPES.ACTION_GET_TAGGED_MEDIA_SONGS://279
                         $scope.noresultfound = false;
                        if(json.sucs===true){
                            for(i=0;i<json.mdaLst.length;i++){
                                console.log(json.mdaLst[i]);
                                obj = $$mediaMap(json.mdaLst[i]);
                                searchedSongMap.save(obj.getKey(),obj);
                            }
                        } else {
                             $scope.noresultfound = true;
                        }
                        break;
                }

                // if(json.sucs===true){

                // }else{
                //     console.log('no data found');
                // }
                // Media.init();
                 $scope.$rgDigest();
            }

            $scope.$on('$destroy', function() {
                $$connector.unsubscribe(subscriptionKey);
                searchedSongMap.reset();
                searchedAlbumsMap.reset()
                // Media.resetSearchedAlbum;
                // Media.resetSearchedTagArr();
            });

        }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .controller('allAlbumTypeController',allAlbumTypeController);

    allAlbumTypeController.$inject = ['$$stackedMap','$$mediaMap','$$mediaAlbumMap','Storage','userFactory','Auth','$routeParams','OPERATION_TYPES','$scope','Media','$location','$$connector','$ringbox','Ringalert'];
    function allAlbumTypeController ( $$stackedMap,$$mediaMap,$$mediaAlbumMap,Storage,userFactory, Auth, $routeParams ,OPERATION_TYPES, $scope, Media,$location,$$connector,$ringbox,Ringalert ) {
        $scope.albumName = Storage.getData('albumname')[0];
        $scope.mediaCount = Storage.getData('albumname')[1];
        $scope.albumtype = $routeParams.albumtype;
        $scope.utid = $routeParams.utid;
        $scope.albumid = $routeParams.albumid;
        $scope.songsArray = [];
        $scope.songs = $$stackedMap.createNew();
        $scope.selectedPlaylist = $$stackedMap.createNew();
        $scope.myAlbumsMap = $$stackedMap.createNew();

        var OTYPES = OPERATION_TYPES.SYSTEM.MEDIA;
        $scope.userallalbum = false;
        $scope.showSearchDropdown = false;
        $scope.stoploader = false;
        $scope.loadMoreSong = false;
        var mdaType;

        //var albumOwner = (Auth.currentUser().getUtId() ===  $scope.utid) ? Auth.currentUser() : User.create({utId: json.utId});

        if ( !$routeParams.utid && !$routeParams.albumid ) {

            var currentUser = Auth.currentUser();
            $scope.utid = currentUser.getUtId();
            if($routeParams.albumtype === 'audio'){
                mdaType = 1;
            }else if($routeParams.albumtype === 'video'){
                mdaType = 2;
            }else{
                $location.path('media');
            }
            Media.fetchAllAlbums($scope.utid,$scope.albumtype);
            //$scope.useralbumlist = Media.getAlbums($scope.albumtype);
            $scope.userallalbum = true;
        }
        if ( isNaN($scope.utid) && isNaN($scope.albumid) ) {
            $location.path('media');
        }

        $scope.goToAlbum = function( obj ) {
            var url;
            var albumname = [];
            albumname.push(obj.name);
            albumname.push(obj.mc);
            Storage.setData('albumname',albumname);
            switch ( obj.type ) {
                case 'audio':
                    url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
                    $location.path(url);
                    break;
                case 'video':
                    url = 'media/'+obj.type+'/'+obj.utid+'/'+obj.albumid;
                    $location.path(url);
                    break;
                default :
                    url = 'media';
                    $location.path(url);
                    break;
            }
        };

        $scope.loadMoreMedia = function (songcount) {
            $scope.loadMoreSong = true;
            Media.fetchAlbumContents({
                albId: $scope.albumid,
                utId: $scope.utid, // optional. maybe without utid just own media album list fetch
                st: songcount
            });
        };

        if( $scope.utid && $scope.albumid ){
            Media.fetchAlbumContents({
                albId: $scope.albumid,
                utId: $scope.utid // optional. maybe without utid just own media album list fetch
            });
            $scope.albumMap = $$mediaAlbumMap.createAlbum({
                albn: $scope.albumName, // album name
                albId: $scope.albumid,
                //mdaT:have to use conditionaly
                utId: $scope.utid // owner user utid
            });
        }

        $scope.selectMedia = selectMedia;
        function selectMedia(mediaMap, addToSelected) {
            if (addToSelected) {
                $scope.selectedPlaylist.add(mediaMap.getKey(), mediaMap);
            } else {
                $scope.selectedPlaylist.remove(mediaMap.getKey());
            }
        }

        $scope.getMediaData = getMediaData;
        function getMediaData (playActive, mediaMap) {
            var playlist;

            if (playActive) {
                playlist =  $scope.songs.all();
            } else {
                playlist = $scope.selectedPlaylist.all();
            }
            mediaMap = mediaMap || playlist[0].value;

            return {
                    data: function () {
                        return {
                            media: mediaMap,
                            playlist: playlist
                        };
                    },
                    promise: mediaMap.fetchDetails() //Media.fetchContentDetails(mediaMap.getKey(), true, profileObj)
                };
        }



        $scope.$on('$destroy', function() {
            $$connector.unsubscribe(subscriptionKey);
        });

        var subscriptionKey = $$connector.subscribe(albumContentProcess, {
            action: [
                    OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST,//261
                    OTYPES.ACTION_MEDIA_ALBUM_LIST//256
                ]
        });

        function albumContentProcess(data){
            var i;
            switch (data.actn) {
                case OTYPES.ACTION_MEDIA_ALBUM_CONTENT_LIST:
                    if( data.sucs === true ){

                        for( i=0;i<data.mdaCntntLst.length;i++ ) {

                            //thealbum.pushContent(data.mdaCntntLst);

                            data.mdaCntntLst[i].utId = $scope.utid;
                            var media = $$mediaMap( data.mdaCntntLst[i] );
                            $scope.songs.save( media.getKey(),media );
                        }
                        //$scope.thealbum = thealbum;
                        $scope.loadMoreSong = false;
                    }else{
                        $scope.loadMoreSong = false;
                        $scope.stoploader = true;
                    }
                    break;
                case OTYPES.ACTION_MEDIA_ALBUM_LIST:
                    if ( data.sucs === true ) {
                        for( i = 0; i < data.mediaAlbumList.length; i++ ) {
                            if( data.mediaAlbumList[i].mdaT===mdaType ){
                                var albumMap = $$mediaAlbumMap.createAlbum( data.mediaAlbumList[i] );
                                $scope.myAlbumsMap.save( albumMap.getKey(), albumMap );
                            }
                        }
                    }else{
                        $scope.stoploader = true;
                    }
                    break;
                default :
                    break;
            }
            $scope.$rgDigest();
        }

    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.media')
        .controller('MediaPostController',MediaPostController);

        MediaPostController.$inject = ['$scope', '$location', 'RING_ROUTES', 'utilsFactory', 'Ringalert'];
        function MediaPostController ($scope, $location, RING_ROUTES, utilsFactory, Ringalert) {

            $scope.setFeed = setFeed;

            function setFeed(json){
                if (!!json && json.sucs === true) {
                    $location.path(RING_ROUTES.MEDIA_FEEDS);
                    $scope.$rgDigest();
                }
            }

        }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social', []);
})();


/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social')
        .service('socialUtils', function() {
            var _self = this;

            _self.camelCase = function(name) {
            return name.replace(/([\:\-\_]+(.))/g, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
                });
            };

            _self.parseQueryString = function(keyValue) {
                var obj = {}, key, value;
                angular.forEach((keyValue || '').split('&'), function(keyValue) {
                    if (keyValue) {
                        value = keyValue.split('=');
                        key = decodeURIComponent(value[0]);
                        obj[key] = angular.isDefined(value[1]) ? decodeURIComponent(value[1]) : true;
                    }
                });
                return obj;
            };

            _self.joinUrl = function(baseUrl, url) {
                if (/^(?:[a-z]+:)?\/\//i.test(url)) {
                    return url;
                }

                var joined = [baseUrl, url].join('/');

                var normalize = function(str) {
                    return str
                        .replace(/[\/]+/g, '/')
                        .replace(/\/\?/g, '?')
                        .replace(/\/\#/g, '#')
                        .replace(/\:\//g, '://');
                };

                return normalize(joined);
            };

            _self.merge = function(obj1, obj2) {
                var result = {};
                for (var i in obj1) {
                    if (obj1.hasOwnProperty(i)) {
                        if ((i in obj2) && (typeof obj1[i] === 'object') && (i !== null)) {
                            result[i] = _self.merge(obj1[i], obj2[i]);
                        } else {
                            result[i] = obj1[i];
                        }
                    }
                }
                for (i in obj2) {
                    if (obj2.hasOwnProperty(i)) {
                        if (i in result) {
                            continue;
                        }
                        result[i] = obj2[i];
                    }
                }
            return result;
        };
    });


})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social')
        .constant('socialConfig', {
            providers: {
                facebook: {
                    name: 'facebook',
                    url: '/auth/facebook',
                    clientId:  '477404429103451',  // ringid
                    authorizationEndpoint: 'https://www.facebook.com/v2.5/dialog/oauth',
                    redirectUri: window.location.origin + '/static-index.html',
                    requiredUrlParams: ['access_code'],
                    scope: ['email'],
                    scopeDelimiter: ',',
                    display: 'popup',
                    type: '2.0',
                    popupOptions: { width: 680, height: 500 }
                },
                twitter: {
                    twitterApiURL: 'https://api.twitter.com/1.1/account/verify_credentials.json',
                    name: 'twitter',
                    url: '/auth/twitter',
                    authorizationEndpoint: 'https://api.twitter.com/oauth/authenticate',
                    redirectUri: window.location.origin + '/static-index.html',
                    //function(whatFor) {
                        //return encodeURIComponent(window.location.origin + '/#/' + whatFor + '/twitter/' );
                    //},
                    type: '1.0',
                    //serverUrl: window.location.protocol + '//' + window.location.hostname+ ':9090/TwiteerLoginService',
                    serverUrl: window.location.origin + '/TwiteerLoginService',

                    popupOptions: { width: 595, height: 745 }
                },
            }
        });

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social')
        .factory('socialPopup', socialPopup);

        socialPopup.$inject = ['$$q', '$interval', '$window', 'socialConfig', 'socialUtils', 'utilsFactory'];
        function socialPopup ($q, $interval, $window, socialConfig, socialUtils, utilsFactory) { // jshint ignore:line
            var Popup = {};

            Popup.url = '';
            Popup.popupWindow = null;

            Popup.open = function(url, name, options) {
                Popup.url = url;

                var stringifiedOptions = Popup.stringifyOptions(Popup.prepareOptions(options));
                var UA = $window.navigator.userAgent;
                var windowName = (socialConfig.cordova || UA.indexOf('CriOS') > -1) ? '_blank' : name;

                Popup.popupWindow = $window.open(url, windowName, stringifiedOptions);

                $window.popup = Popup.popupWindow;

                if (Popup.popupWindow && Popup.popupWindow.focus) {
                    Popup.popupWindow.focus();
                }

                return Popup;
            };

            Popup.eventListener = function(redirectUri) {
                var deferred = $q.defer();

                Popup.popupWindow.addEventListener('loadstart', function(event) {
                    if (event.url.indexOf(redirectUri) !== 0) {
                        return;
                    }


                    var parser = document.createElement('a');
                    parser.href = event.url;

                    if (parser.search || parser.hash) {
                        var queryParams = parser.search.substring(1).replace(/\/$/, '');
                        var hashParams = parser.hash.substring(1).replace(/\/$/, '');
                        var hash = socialUtils.parseQueryString(hashParams);
                        var qs = socialUtils.parseQueryString(queryParams);

                        angular.extend(qs, hash);

                        if (!qs.error) {
                            deferred.resolve(qs);
                        }

                        Popup.popupWindow.close();
                    }
                });

                Popup.popupWindow.addEventListener('loaderror', function() {
                    deferred.reject({rc: 0, mg:'Error Loading Authorization URL'});
                });

                Popup.popupWindow.addEventListener('onbeforeunload' , function() {
                    deferred.reject({rc: 0, mg:'Popup closed unexpectedly'});
                });

                return deferred.promise;
            };

            Popup.pollPopup = function() {
                var deferred = $q.defer();

                var polling = $interval(function() {
                    try {
                        var documentOrigin = document.location.host;
                        var popupWindowOrigin = Popup.popupWindow.location.host;

                        if (popupWindowOrigin === documentOrigin  &&
                            (Popup.popupWindow.location.search ||
                            Popup.popupWindow.location.hash)) {


                            var queryParams = Popup.popupWindow.location.search.substring(1).replace(/\/$/, '');
                            var hashParams = Popup.popupWindow.location.hash.substring(1).replace(/[\/$]/, '');
                            var hash = socialUtils.parseQueryString(hashParams);
                            var qs = socialUtils.parseQueryString(queryParams);

                            angular.extend(qs, hash);

                            if (qs.error) {
                                deferred.reject(qs);
                            } else {
                                deferred.resolve(qs);
                            }

                            $interval.cancel(polling);

                            Popup.popupWindow.close();
                        }
                    } catch (error) {
                    // Ignore DOMException: Blocked a frame with origin from accessing a cross-origin frame.
                    }

                    if (!Popup.popupWindow || Popup.popupWindow.closed || Popup.popupWindow.closed === undefined) {
                        $interval.cancel(polling);
                    }
                }, 50);

                return deferred.promise;
            };

            Popup.prepareOptions = function(options) {
                options = options || {};
                //var width = (utilsFactory.viewport.y - 600) || options.width || 500;
                //var height = (utilsFactory.viewport.x - 300) || options.height || 500;
                //width  = (width > 1000) ? 1000 : width;
                //height = (height < 500) ? 500 : height;

                var width =  options.width || 500;
                var height =  options.height || 500;


                return angular.extend({
                    width: width,
                    height: height,
                    left: $window.screenX + (($window.outerWidth - width) / 2),
                    top: $window.screenY + (($window.outerHeight - height) / 2.5)
                }, options);
            };

            Popup.stringifyOptions = function(options) {
                var parts = [];
                angular.forEach(options, function(value, key) {
                    parts.push(key + '=' + value);
                });
                return parts.join(',');
            };

            return Popup;

        }
})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social')
        .factory('socialOauth', socialOauth)
        .factory('socialOauth1', socialOauth1)
        .factory('socialOauth2', socialOauth2);

        socialOauth.$inject = ['socialConfig',  'socialOauth1', 'socialOauth2'];
        function socialOauth(socialConfig, socialOauth1, socialOauth2) { //jshint ignore:line
            var Oauth = {};

            Oauth.authenticate = function(name, credentials) {
                var provider = socialConfig.providers[name].type === '1.0' ? new socialOauth1() : new socialOauth2();
                return provider.open(socialConfig.providers[name], credentials);
            };

            return Oauth;
        }


        socialOauth2.$inject = ['$$q', '$window', 'socialUtils','socialConfig','Storage', 'utilsFactory', 'socialPopup', '$ringhttp'];

        function socialOauth2($q, $window, utils, config, Storage, utilsFactory, socialPopup, $ringhttp) { //jshint ignore:line

            return function() {
                function buildQueryString () {
                    var keyValuePairs = [];
                    var urlParams = ['defaultUrlParams', 'requiredUrlParams', 'optionalUrlParams'];

                    angular.forEach(urlParams, function(params) {

                        angular.forEach(defaults[params], function(paramName) {
                            var camelizedName = utils.camelCase(paramName);
                            var paramValue = angular.isFunction(defaults[paramName]) ? defaults[paramName]() : defaults[camelizedName];
                            keyValuePairs.push([paramName, paramValue]);
                        });
                    });

                    return keyValuePairs.map(function(pair) {
                        return pair.join('=');
                    }).join('&');
                }

                var Oauth2 = {};

                var defaults = {
                    defaultUrlParams: ['response_type', 'client_id', 'redirect_uri'],
                    responseType: 'token', // code or token or both
                    responseParams: {
                        token: 'token',
                        //code: 'code',
                        clientId: 'clientId',
                        redirectUri: 'redirectUri'
                    }
                };

                Oauth2.open = function(options, whatFor) {
                    var defer = $q.defer();

                    //defaults = utils.merge(options, defaults);
                    defaults = angular.extend({}, options, defaults);

                    var url;
                    var openPopup;
                    var stateName = defaults.name + '_state';

                    if (angular.isFunction(defaults.state)) {
                      Storage.setData(stateName, defaults.state());
                    } else if (angular.isString(defaults.state)) {
                      Storage.setData(stateName, defaults.state);
                    }

                    url = [defaults.authorizationEndpoint, buildQueryString(whatFor)].join('?');


                    openPopup = socialPopup.open(url, defaults.name, defaults.popupOptions, defaults.redirectUri);
                                    //pollPopup();

                    var interval = setInterval(function() {
                        if (openPopup.popupWindow.closed) {
                            clearInterval(interval);
                            defer.reject({sucs: false, mg: 'Popup Closed unexpectedly!'});
                        }
                    }, 1000);

                    openPopup.pollPopup().then(function(authData) {
                        clearInterval(interval);
                        $ringhttp.get('https://graph.facebook.com/me' + '?access_token=' + authData.access_token)
                        .success(function(userData) {
                            if (userData.id) {
                                defer.resolve({
                                        platform: defaults.name,
                                        id: userData.id,
                                        name: userData.name,
                                        access_token: authData.access_token
                                });
                            } else {
                                defer.reject();
                            }
                        })
                        .error(function() {
                            defer.reject();
                        });
                    }, function() {
                         defer.reject({mg: 'Popup blocked by Browser. Please unblock.'});
                    });

                    return defer.promise;

                };


                return Oauth2;
            };
        }


        socialOauth1.$inject = ['$q', 'socialConfig','socialUtils', 'socialPopup', '$ringhttp'];
        function socialOauth1($q, socialConfig, socialUtils, socialPopup, $ringhttp) { //jshint ignore:line
            return function() {

                function exchangeForToken (data, credentials) {
                    credentials.uId = credentials.uId.toString();
                    var queryString = '?step=3&oauth_token=' + data.oauth_token + '&verifier=' + data.oauth_verifier +
                        ((credentials.uId && credentials.uId.length > 2) ? '&uId=' + credentials.uId : '') +
                            '&time=' + new Date().getTime();

                    return $ringhttp.get(defaults.serverUrl + queryString);
                    //return $ringhttp.get(defaults.serverUrl + '?step=3&oauth_token=' + data.oauth_token + '&verifier=' + data.oauth_verifier + '&time=' + new Date().getTime());
                }

                function exchangeForRequest() {
                    return $ringhttp.get(defaults.serverUrl + '?step=1&callback=' + encodeURIComponent(defaults.redirectUri) + '&time=' + Date.now());
                }

                function buildQueryString (obj) {
                    var str = [];

                    angular.forEach(obj, function(value, key) {
                        str.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
                        //str.push(key + '=' + value);
                    });

                    return str.join('&');
                }

                var Oauth1 = {};

                var defaults = {
                        url: null,
                        name: null,
                        popupOptions: null,
                        redirectUri: null,
                        authorizationEndpoint: null
                };

                Oauth1.open = function(options, credentials) {
                    var defer = $q.defer(),
                        popupWindow;

                    angular.extend(defaults, options);

                    popupWindow = socialPopup.open('', defaults.name, defaults.popupOptions, defaults.redirectUri);

                    var interval = setInterval(function() {
                        if (popupWindow.popupWindow.closed) {
                            clearInterval(interval);
                            defer.reject({sucs: false, mg: 'Popup Closed unexpectedly!'});
                        }
                    }, 1000);

                    exchangeForRequest().success(function(response) {
                        if (response.sucs === true) {
                            var tokenData = response.data;
                            var auth_url = [defaults.authorizationEndpoint, buildQueryString({'oauth_token': tokenData.token, 'callback_url': defaults.redirectUri})].join('?');
                            if (popupWindow.popupWindow) {
                                popupWindow.popupWindow.location =  auth_url;

                                popupWindow.pollPopup().then(function(authData) {
                                    clearInterval(interval);
                                    exchangeForToken(authData, credentials).success(function(response) {
                                        if (response.sucs === true || response.rc === 2) {
                                            var accessData = response.data.members;
                                            var userDetails = JSON.parse(accessData.userDetails);
                                            var accessToken = JSON.parse(accessData.accessToken);
                                                defer.resolve({
                                                    platform: defaults.name,
                                                    id: userDetails.id_str,
                                                    name: userDetails.name,
                                                    access_token: accessToken.token,
                                                    oauthParameters: accessToken.oauthParameters,
                                                    oauth_token: authData.oauth_token,
                                                    oauth_verifier: authData.oauth_verifier
                                                });
                                        } else {
                                            defer.reject({mg: 'exchangeForRequest failed'});
                                        }
                                    }).error(function() {
                                        defer.reject({mg: 'exchangeForRequest failed. Server error'});
                                    });
                                });

                            } else {
                                 defer.reject({mg: 'Popup blocked by Browser. Please unblock.'});
                            }

                        } else {
                            defer.reject({mg: 'exchangeForRequest failed'});
                        }

                    }).error(function() {
                        defer.reject({mg: 'exchangeForRequest failed. Server error'});
                    });

                    return defer.promise;
                };


                return Oauth1;
            };
        }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.social')
		.provider('$authSocial',['socialConfig', function social(socialConfig) {
          angular.forEach(Object.keys(socialConfig.providers), function(provider) {
            this[provider] = function(params) {
              return angular.extend(socialConfig.providers[provider], params);
            };
          }, this);

          var oauth = function(params) {
            socialConfig.providers[params.name] = socialConfig.providers[params.name] || {};
            angular.extend(socialConfig.providers[params.name], params);
          };

          this.oauth1 = function(params) {
            oauth(params);
            socialConfig.providers[params.name].type = '1.0';
          };

          this.oauth2 = function(params) {
            oauth(params);
            socialConfig.providers[params.name].type = '2.0';
          };

          this.$get = [
            '$$q',
            'socialOauth',
            function($q, oauth) {
                var $authSocial = {};

                $authSocial.login = function(platform) {
                    var deferred = $q.defer();
                    var authData; // = Storage.getData(platform);
                    if (authData) {
                        deferred.resolve(authData);
                    } else {
                        oauth.authenticate(platform, 'login').then(function(authData) {
                            deferred.resolve(authData);
                        }, function(err) {
                            deferred.reject(err);
                        });
                    }
                    return deferred.promise;
                };


                $authSocial.authenticate = function(platform, credentials) {
                    var defer = $q.defer();
                    oauth.authenticate(platform, credentials).then(function(authData) {
                        defer.resolve(authData);
                    }, function(err) {
                        defer.reject(err);
                    });

                    return defer.promise;
                  };

                return $authSocial;
            }];

    	}]);




})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.auth', [
		//	'ngCookies',
			'ringid.config',
			'ringid.connector',
            'ringid.common.services',
            'ringid.common.factories',
            'ringid.utils',
            'ringid.social'
		]);
})();


/* * © Ipvision
 */

(function () {
	'use strict';

	angular
		.module('ringid.auth')
		.controller('AuthController', AuthController);

	AuthController.$inject = ['rgDropdownService', 'Storage', 'Auth', '$scope', '$$connector', 'countryListService','$rootScope', 'Ringalert', 'settings'];

	function AuthController(rgDropdownService, Storage, Auth, $scope, $$connector, countryListService,$rootScope, Ringalert, settings) { //jshint ignore:line

        // no more needed in worker implementation
            //$$connector.init();
            //$$connector.resume();

            $scope.socialRequestFailed = socialRequestFailed;
            $scope.requestFailed = requestFailed;

            // auth data
            $scope.activeTab = 'phone';
			$scope.credentials = {
                username       : '', // only used for AutoFill login form. a placeholder for browser autofill to work properly
                authMethod     : 'phone',
                uId            : '',
                lt             : 2,
                mbl            : '',
                email          : '',
                ringid         : '',
				password       : '',
                remember       : Storage.getData('remember') ? true : false,
                mblDc          : Auth.getCountry().code,
                flagcode       :  Auth.getCountry().flagcode, //'c1'
			};

            $scope.autofill = {
                email : $scope.credentials.email,
                ringid : $scope.credentials.ringid,
                mbl : $scope.credentials.mbl
            };

			$scope.errorMsg = '';
            $scope.requestSuccess = false;
			$scope.disableForm   = false;
            $scope.formStyle = {left: '0px'};

            // auth operations
            $scope.activateTab = activateTab;
			$scope.setPrefix = setPrefix;
            $scope.login = login;

			//$scope.ddHtml = 'pages/dropdowns/country-list-dropdown.html';
            $scope.ddTemplate =
                     '<div class="country-wrapper" >' +
                        '<ul id="countrylist" class="ringdropdown" rg-scrollbar="scrollbar()">' +
                            '<div class="count-s">' +
                            '<input type="text" ng-model="countryName" placeholder="Search Country">' +
                            '</div>' +
                            '<a ng-repeat="item in ddControl.countryList() | filter:countryName" ><li class="flag {{item.flagcode}}" ng-click="ddAction()({event: $event, item: item})" > ' +
                            '<span> {{ item.country }}</span></li></a>' +
                        '</ul>' +
                      '</div>';

			$scope.ddControl = {
                append: false,
                countryList: Auth.getCountryList
			};


            var errMsg = {
                signin: {
                    email: "Login failed. Make sure you're entering your verified email and correct password.",
                    phone: "Login failed. Make sure you're entering your verified phone and correct password.",
                    ringid: "Login failed. Make sure you're entering correct ringID and password.",
                    other: 'Sorry, we are unable to complete your request. Please try again later.'
                },
                signup: {
                    sendcode: "Verification code has been sent to your email. Please check your spam folder also.",
                    verify: "",
                    signup: ''
                },
                recovery: {
                    email: "Sorry! we did not find your email. Make sure you're entering your verified email.",
                    phone: "Sorry! we did not find your phone number. Make sure you're entering your verified phone number."
                },
            };


            function socialRequestFailed (errData, which, whichOf) {
                $scope.disableForm = false;
                if (settings.analytics) {
                    ga('send', 'event',   location.hostname + ':' + which, whichOf + ' Message:' + errData.mg || 'UNKNOWN');
                }
                Ringalert.show(errData.mg || 'Request Failed', 'error');
                $scope.$rgDigest();
            }


            function requestFailed (errData, which, whichOf, showOriginal) {
                var analytics = {
                    signup: {
                        success: {
                            label: 'Signup Success',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        },
                        fail: {
                            label: 'Signup Failed',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        }
                    },
                    signin: {
                        success: {
                            label: 'Signin Success',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        },
                        fail: {
                            label: 'Signin Failed',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        }
                    },
                    recovery: {
                        success: {
                            label: 'Recovery Success',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        },
                        fail: {
                            label: 'Recovery Failed',
                            value: 'Auth Method: ' + $scope.credentials.authMethod
                        }
                    },
                };

                if (!errData) {
                    // reset form related data
                    $scope.disableForm = true;
                    $scope.requestSuccess = true;
                    $scope.errorMsg = '';
                } else {
                    // success false
                    $scope.disableForm = false;
                    if (errData.sucs === true || errData.sucs === 'true') {
                        // add event for analytics
                        if (settings.analytics) {
                            ga('send', 'event', location.hostname + ':' + analytics[whichOf].success.label + ' :' + which, analytics[whichOf].success.value + ' Message:' + errData.mg || 'UNKNOWN' + ' RC:' + errData.rc || 'UNKNOWN');
                        }
                        $scope.requestSuccess = true;
                    } else {
                        if (settings.analytics) {
                            ga('send', 'event', location.hostname + ':' + analytics[whichOf].fail.label + ' :' + which, analytics[whichOf].fail.value + ' Message:' + errData.mg || 'UNKNOWN' + ' RC:' + errData.rc || 'UNKNOWN');
                        }
                        $scope.requestSuccess = false;
                    }
                    if (showOriginal) {
                        if (errData.hasOwnProperty('sucs') && errData.sucs !== true) {
                            $scope.errorMsg = errData.mg || 'Request Failed'; //loginData.mg || 'Login Failed';
                        } else {
                            $scope.errorMsg = errData.mg || ''; //loginData.mg || 'Login Failed';
                        }
                    } else {
                        $scope.errorMsg = errMsg[whichOf][which] || errData.mg; //loginData.mg || 'Login Failed';
                    }
                }

                $scope.$rgDigest();
            }





            function activateTab (tabName) {
                if(!$scope.disableForm) { // login not in progress
                    $scope.errorMsg = '';
                    $scope.activeTab = tabName;
                    //Storage.setData('activeTab', tabName); // only succesfull login request should set activeTab to localStorage upon response
                    switch($scope.activeTab) {
                        case 'email':
                            $scope.credentials.authMethod = 'email';
                            $scope.formStyle.left = '-800px';
                            $scope.credentials.lt = 3;
                            break;
                        case 'ringid':
                            $scope.credentials.authMethod = 'ringid';
                            $scope.formStyle.left = '-400px';
                            $scope.credentials.lt = 1;
                            break;
                        case 'facebook':
                            $scope.credentials.authMethod = 'social';
                            $scope.formStyle.left = '-1200px';
                            $scope.credentials.lt = 4; // 4 or 5
                            break;
                        case 'twitter':
                            $scope.credentials.authMethod = 'social';
                            $scope.formStyle.left = '-1200px';
                            $scope.credentials.lt = 5; // 4 or 5
                            break;
                        case 'social':
                            $scope.credentials.authMethod = 'social';
                            $scope.formStyle.left = '-1200px';
                            break;
                        default:
                            $scope.credentials.authMethod = 'phone';
                            $scope.formStyle.left = '0px';
                            $scope.credentials.lt = 2;

                    }
                    $scope.$rgDigest();
                }
            }


            function setPrefix(actionObj) {
                if (actionObj.event) {
                    rgDropdownService.close(actionObj.event);
                }

                Storage.setData('country', actionObj.item);
                $scope.credentials.mblDc =  actionObj.item.code;
                $scope.credentials.flagcode = actionObj.item.flagcode;

                $scope.$rgDigest();
            }


			function login(formValid, event) {
                if(event) {
				    event.preventDefault();
                }
                if (formValid) {
                    switch($scope.credentials.authMethod) {
                        case 'ringid':
                            $scope.credentials.username = $scope.credentials.ringid;
                            break;
                        case 'email':
                            $scope.credentials.username = $scope.credentials.email;
                            break;
                        case 'phone':
                            $scope.credentials.username = $scope.credentials.mbl;
                            break;
                    }
                    $scope.requestFailed(false);
                    Auth.login($scope.credentials).then(function(loginData) {
                        if (loginData.sucs === true || loginData.sucs === 'true'){
                            if ($scope.params && $scope.params.fromPopup) {
                                $scope.closeAll();
                                window.location = '/';
                            } else {
                                $rootScope.$rgDigest();
                            }
                        } else {
                            $scope.requestFailed(loginData, $scope.credentials.authMethod, 'signin');
                        }
                    }, function(errData) {
                        $scope.requestFailed(errData, $scope.credentials.authMethod, 'signin');
                    });
                }
			}

            function activate() {
                // initialize
                var tempActive =  Storage.getData('activeTab');
                if (tempActive) {
                    // autofill
                    var tempAutofill =  Storage.getData('autoFill');
                    switch(tempActive) {
                        case 'phone':
                            $scope.credentials.mbl = tempAutofill;
                            $scope.credentials.username = tempAutofill;
                            $scope.credentials.lt = 2;
                            break;
                        case 'email':
                            $scope.credentials.lt = 3;
                            $scope.credentials.email = tempAutofill;
                            $scope.credentials.username = tempAutofill;
                            break;
                        case 'ringid':
                            $scope.credentials.ringid = tempAutofill;
                            $scope.credentials.username = tempAutofill;
                            $scope.credentials.lt = 1;
                            break;
                    }
                    activateTab(tempActive);
                }

                $scope.$rgDigest();

            }

            activate();

	}

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.auth')
        .controller('RingboxAuthController', RingboxAuthController);


    RingboxAuthController.$inject = [ '$scope', '$boxInstance', '$controller', 'localData'];
    function RingboxAuthController($scope, $boxInstance, $controller, localData) {
        /****
         *
         * Extends Basic Album List controller to use in Ringbox
         *
         *
         */

        $scope.close = $boxInstance.close;
        $scope.closeAll = $boxInstance.closeAll;

        $scope.showLoader = $boxInstance.showLoader;
        $scope.hideLoader = $boxInstance.hideLoader;

        $scope.params = localData;

        $controller('SignInController', {$scope: $scope} );

    }


})();



/* * © Ipvision
 */

(function () {
	'use strict';

	angular
		.module('ringid.auth')
		.controller('SignInController', SignInController);

	SignInController.$inject = ['$authSocial', '$controller', '$scope', 'Auth', 'Ringalert', '$rootScope'];

	function SignInController($authSocial, $controller, $scope, Auth, Ringalert, $rootScope) { // jshint ignore:line

            angular.extend(this, $controller('AuthController', {$scope: $scope}));

            $scope.noSignupAllowed = function() {
                 Ringalert.alert({
                    title : 'Sign Up',
                    message : 'Please sign up from your iOS, Android, Windows enabled device or Desktop prior to logging in from the Web version.',
                    showCancel : false,
                    okCallback : angular.noop//doLogoutTask
                 });
            };

            function authenticateUser(platform) {
                $authSocial.authenticate(platform, $scope.credentials).then(function(authData) {
                    if ($scope.params && $scope.params.fromPopup) {
                        $scope.showLoader();
                    }
                    Auth.login(angular.extend(authData, $scope.credentials), true).then(function() {
                        ga('send', 'event', 'Signin Success. ' , 'Auth Method: ' + platform );
                        // now login
                        if ($scope.params && $scope.params.fromPopup) {
                            boxInstance.hideLoader();
                            $scope.closeAll();
                            window.location = '/';
                        } else {
                            $scope.close();
                            $rootScope.$rgDigest();
                        }
                    }, function(err) {
                        if ($scope.params && $scope.params.fromPopup) {
                            boxInstance.hideLoader();
                        }
                        switch(err.rc) {
                            case 'invalidsocialid':
                                $scope.socialRequestFailed(err, platform, 'Unregistered Social ID');
                                //$boxInstance.hideLoader();

                                // right now signup is disabled
                                // open signup box
                                //$boxInstance.showLoader();
                                //Auth.sendCode($scope.credentials, true).then(function() {
                                    //$scope.close();
                                    //Auth.openSignup(authData, $scope.credentials);
                                //});
                                break;
                            default:
                                $scope.socialRequestFailed(err, platform, 'Something went wrong');
                        }
                    });
                }, function(err) {
                    if ($scope.params && $scope.params.fromPopup) {
                        boxInstance.hideLoader();
                    }
                    $scope.socialRequestFailed(err, platform, 'Authentication Failed');
                });

            }
            //social signin
            $scope.socialLogin = function(platform) {
                $scope.credentials.authMethod = platform;
                //$boxInstance.showLoader();
                if (platform === 'twitter') {
                    //Auth.sendCode($scope.credentials, true).then(function() {
                        authenticateUser(platform);
                    //});
                } else {
                    authenticateUser(platform);
                }



            };

	}

})();

/*
 * © Ipvision
 */

(function() {
    'use strict';


    angular.module('ringid.auth')
        .controller('SignUpController', SignUpController);

        SignUpController.$inject = ['countryListService', 'Ringalert', 'Auth', '$scope', '$controller', '$boxInstance', '$authSocial', 'remoteData', 'localData', 'Storage', 'rgDropdownService'];
        function SignUpController(countryListService, Ringalert, Auth, $scope, $controller, $boxInstance, $authSocial, remoteData, localData, Storage, rgDropdownService) { // jshint ignore:line

            angular.extend(this, $controller('AuthController', {$scope: $scope}));

            $scope.close = $boxInstance.close;
            $scope.closeAll = $boxInstance.closeAll;

            // sign up data
            $scope.newUid = '';
            $scope.credentials.repassword = '';
            $scope.credentials.vc = '';
            $scope.credentials.name = '';

            $scope.signupStep = 1;
            // signup operations
            //$scope.signupData = signupData;
            $scope.sendCode = sendCode;
            $scope.verifyCode = verifyCode;
            $scope.signup= signup;




            if (localData) {
                // reset from autofill
                $scope.formStyle.left  = '0px';
                $scope.credentials.mbl = '';
                $scope.credentials.email = '';
                $scope.credentials.ringid = '';
                $scope.credentials.password = '';
                if (localData.signupData) {
                    $scope.credentials.authMethod = localData.signupData.signupType;
                    $scope.credentials.flagcode = localData.signupData.flagcode;
                }

                if (localData.socialData) {
                    angular.extend($scope.credentials, localData.credentials);
                    //$scope.credentials.authMethod = localData.credentials.authMethod;
                    //$scope.credentials.countryFlag = localData.socialData.countryFlag;
                    $scope.newUid = localData.credentials.uId.toString().substr(2);

                    $scope.credentials.authMethod = localData.socialData.platform;
                    $scope.credentials.id= localData.socialData.id;
                    $scope.credentials.name = localData.socialData.name;
                    $scope.credentials.access_token= localData.socialData.access_token;

                    //$scope.credentials.login_type = remoteData.platform;
                    //$scope.credentials.authMethod = localData..platform;

                    $scope.signupStep = 3;
                    $scope.formStyle.left  = '-700px';
                }

                //$scope.credentials.authMethod = localData.signupType;
                //// reset from autofill
                //$scope.formStyle.left  = '0px';
                ////$scope.activateTab($scope.credentials.authMethod);
                //$scope.credentials.mbl = '';
                //$scope.credentials.email = '';
                //$scope.credentials.ringid = '';
            }

            if (remoteData) {
                $scope.newUid = remoteData.uId.toString().substr(2);
            }

            //function signupData(type) {
                //return  {
                    //data: function () {
                        //return {
                            //signupType: type,
                            //login_type: type === 'phone' ? $scope.credentials.mblDc : 'Email',
                            //countryFlag: type === 'phone' ? $scope.credentials.flagcode: 'remail'
                        //};
                    //}
                //};
            //}



            function sendCode(formValid, event) {
                event.preventDefault();
                if(!$scope.disableForm) {
                    $scope.requestFailed(false); // resets form
                    Auth.sendCode($scope.credentials).then(function(json) {
                        if(json.sucs === true) {
                            $scope.credentials.uId = json.uId;
                            $scope.newUid = json.uId.toString().substr(2);
                            $scope.signupStep = 2;
                            $scope.formStyle.left  = '-350px';
                        }
                        $scope.requestFailed(json, 'sendcode', 'signup');
                    }, function(errData) {
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), 'sendcode', 'signup');
                });
                } else {
                }
            }

            function verifyCode(formValid, event) {
                event.preventDefault();
                if(!$scope.disableForm) {
                    $scope.requestFailed(false); // resets form
                    Auth.verifyCode($scope.credentials).then(function(json) {
                        if(json.sucs === true) {
                            $scope.signupStep = 3;
                            $scope.formStyle.left  = '-700px';
                        }
                        $scope.requestFailed(json, 'verify', 'signup');
                    }, function(errData) {
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), 'verify', 'signup');
                    });
                } else {
                }
            }

            function signup(formValid, event) {
                event.preventDefault();
                if(!$scope.disableForm && $scope.credentials.password === $scope.credentials.repassword) {
                    $scope.requestFailed(false);
                    Auth.signup($scope.credentials).then(function(json) {
                        if(json.sucs === true) {
                            $scope.login(true);
                            Ringalert.show('Registraion succesful. You can login now', 'success');
                            $boxInstance.closeAll();
                        }
                        $scope.requestFailed(json, 'sendCode', 'signup');
                    }, function(errData) {
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), 'signup', 'signup');
                    });
                } else {
                }

            }
        }


})();

/*
 * © Ipvision
 */

(function() {
    'use strict';


    angular.module('ringid.auth')
        .controller('SignUpSelectController', SignUpSelectController);

        SignUpSelectController.$inject = [ 'Auth', '$scope', '$controller', '$boxInstance', '$authSocial', 'Ringalert',];
        function SignUpSelectController( Auth, $scope, $controller, $boxInstance, $authSocial, Ringalert) { // jshint ignore:line

            angular.extend(this, $controller('AuthController', {$scope: $scope}));

            $scope.close = $boxInstance.close;
            $scope.closeAll = $boxInstance.closeAll;

            // sign up data
            $scope.socialSignup = function(platform) {
                $boxInstance.showLoader();
                // sendCode actually initializes signup and sends code for nonsocial signup
                Auth.sendCode($scope.credentials, true).then(function() {
                    $authSocial.authenticate(platform, $scope.credentials).then(function(authData) {
                        ga('send', 'event', 'Signup Success. ' , 'Auth Method: ' + platform + ' Social Authorization done' );
                        Auth.openSignup(authData, $scope.credentials).then(angular.noop, function(err) {
                            if (err.rc  === 'dologin') {
                                Ringalert.show("Existing User! Login in as " + authData.name , 'warning');
                                $scope.credentials.authMethod = platform;
                                $boxInstance.showLoader();
                                Auth.login(angular.extend(authData, $scope.credentials), true).then(function() {
                                    ga('send', 'event', 'Signin Success. ' , 'Auth Method: ' + platform );
                                    $scope.closeAll();
                                }, function(err) {
                                    $boxInstance.hideLoader();
                                    $scope.socialRequestFailed(err, platform, 'Social Login Failed');
                                });
                            } else {
                                $boxInstance.hideLoader();
                                $scope.socialRequestFailed(err, platform, 'Authentication Failed');
                            }
                        });
                    }, function(err) {
                        $boxInstance.hideLoader();
                        $scope.socialRequestFailed(err, platform, 'Authentication Failed');
                    });

                }, function(err) {
                    $boxInstance.hideLoader();
                    $scope.socialRequestFailed(err, platform, 'Authentication Failed');
                });
            };

            $scope.signupData  = function(type) {
                return  {
                    data: function () {
                            return {
                                signupData: {
                                    signupType: type,
                                    code: type === 'phone' ? Auth.getCountry().code : 'Email',
                                    flagcode: type === 'phone' ? Auth.getCountry().flagcode : 'remail'
                                }
                            };
                        },
                    promise:  Auth.sendCode($scope.credentials)
                };
            };

        }


})();

/* * © Ipvision
 */

(function () {
	'use strict';

	angular
		.module('ringid.auth')
		.controller('PasswordRecoverController', PasswordRecoverController);

	PasswordRecoverController.$inject = ['$controller', 'Auth', '$scope', '$boxInstance',  'Ringalert'];

	function PasswordRecoverController( $controller, Auth, $scope, $boxInstance,  Ringalert) { // jshint ignore:line

            angular.extend(this, $controller('AuthController', {$scope: $scope}));

            // initialization
            $scope.close = $boxInstance.close;

            //signin data
            var sendSms;
            $scope.activeTab = 'email'; // ringid, email, phone
            $scope.activeForm = 'sendcode'; // 'sendcode', 'verifycode', 'resetpassword'

            // override method
            $scope.activateTab = activateTab;
            $scope.activateTab($scope.activeTab);
            // disable autofill
            $scope.credentials.email = '';
            $scope.credentials.mbl = '';

            // forgot pass operation
            $scope.sendCode = sendCode;
            $scope.verifyCode = verifyCode;
            $scope.resetPassword = resetPassword;

            function sendCode(formValid, $event, phone) {
                sendSms = phone;
                $event.preventDefault();
                if(!$scope.disableForm) {
                    $scope.requestFailed(false);

                    Auth.recoverySendCode($scope.credentials, sendSms).then(function(json){
                        if(json.sucs === true) {
                            $scope.activeForm = 'verifycode';
                            $scope.credentials.uId = json.uId;
                        }
                        $scope.requestFailed(json, sendSms ?  'phone' : 'email', 'recovery', true);
                    },function(errData){
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), sendSms ?  'phone' : 'email', 'recovery');
                    });
                }

            }


            function verifyCode(formValid, $event) {
                $event.preventDefault();
                if(!$scope.disableForm) {
                    $scope.requestFailed(false);
                    Auth.recoveryVerifyCode($scope.credentials).then(function(json){
                        if(json.sucs === true) {
                            $scope.activeForm = 'resetpassword';
                        }
                        $scope.requestFailed(json, 'verify', 'recovery', true);
                    },function(errData){
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), 'verify', 'recovery', true);
                    });
                }

            }


            function resetPassword(formValid, $event) {
                $event.preventDefault();
                if(!$scope.disableForm && $scope.credentials.password === $scope.credentials.repassword ) {
                    $scope.requestFailed(false);
                    Auth.resetPassword($scope.credentials).then(function(json){
                        $scope.disableForm = false;
                        $scope.errorMsg = json.mg;
                        if(json.sucs === true) {
                            Ringalert.show('Reset succesful. You can login now', 'success');
                            $scope.close();
                        }
                        $scope.requestFailed(json, 'reset', 'recovery', true);
                    },function(errData){
                        $scope.requestFailed(angular.extend(errData, {sucs: false}), 'reset', 'recovery', true);
                    });
                }

            }

            // overrided method of AuthController
            function activateTab (tabName) {
                if(!$scope.disableForm && $scope.activeForm === 'sendcode') { // login not in progress
                    $scope.activeTab = tabName;
                    if($scope.activeTab === 'email') {
                        $scope.credentials.authMethod = 'email';
                        $scope.formStyle.left = '0px';
                        //$scope.credentials.login_type = 'Email';
                    } else {
                        $scope.credentials.authMethod = 'phone';
                        $scope.formStyle.left = '-350px';
                        //$scope.credentials.login_type = $scope.country ? $scope.country.login_type : '+880';
                    }
                    $scope.$rgDigest();
                }
            }

	}

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.notification', [
			//'ringid.common.stacked_map',
			'ringid.config',
			'ringid.utils'
		]);

})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

    angular.
    module('ringid.notification').
    factory('$$notiMap', $$notiMap);

		$$notiMap.$inject = ['circlesManager', 'OPERATION_TYPES', 'utilsFactory', 'settings'];
		function $$notiMap(circlesManager, OPERATION_TYPES, utilsFactory, settings) { //jshint ignore:line
			var OTYPES = OPERATION_TYPES.SYSTEM.NOTIFICATION,
                noti_defaults = {
                            acId: 0,
                            cmnId: 0,
                            fndId: 0,
                            fndN: '',
                            id: 0,
                            imgId: 0,
                            loc: 0,
                            mt: 0,
                            nfId: 0,
                            ut: 0,
                            nt: 0,
                            prIm:0,

                            message: '',
                            updateTime: '',
                            popupType: '',
                            groupId:0,
                            user: null,
							seen: false,
                            // noti merge properties
                            mayMerge: 1, // 0=no merge, 1= merge(increase counter of no of people), 2= (profile/cover update, delete older)
                            othersCounter: 0
                        };


            function setNotiMessage(noti) {
                var gName = '',
                    messageAndPopup = {
                    message: '',
                    popupType: '',
                    mayMerge: 1
                };

                function othersHandler() {
                    //if (noti.othersCounter > 1) {
                        //return ' and ' + noti.othersCounter  + ' others ';
                    //} else if (noti.othersCounter === 1){
                        //return ' and ' + noti.othersCounter  + ' other ';
                    //} else {
                        //return '';
                    //}
                    var counter = noti.uIdList.length - 1;
                    if (counter > 1) {
                        return ' and ' + counter + ' others ';
                    } else if (counter === 1){
                        return ' and ' + counter + ' other ';
                    } else {
                        return '';
                    }
                }

                switch(noti.mt) {
                    case OTYPES.MSG_TYPE_UPDATE_PROFILE_IMAGE: // update profile image
                        messageAndPopup.message =  " changed profile photo";
                        messageAndPopup.popupType = 'image';
                        messageAndPopup.mayMerge = 2;
                        break;
                    case OTYPES.MSG_TYPE_UPDATE_COVER_IMAGE: // update cover image
                        messageAndPopup.message =  " changed cover photo";
                        messageAndPopup.popupType = 'image';
                        messageAndPopup.mayMerge = 2;
                        break;
                    case OTYPES.MSG_TYPE_LIKE_IMAGE: // like image
                        messageAndPopup.message =  othersHandler() + " liked your photo";
                        messageAndPopup.popupType = 'image';
                        break;
                    case OTYPES.MSG_TYPE_IMAGE_COMMENT: // comment image
                        messageAndPopup.message =  othersHandler() +" commented on your photo";
                        messageAndPopup.popupType = 'image';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_IMAGE_COMMENT: // like image comment
                        messageAndPopup.message =  othersHandler() + " liked your comment";
                        messageAndPopup.popupType = 'image';
                        break;

                    case OTYPES.MSG_TYPE_ADD_FRIEND: // add friend request
                        messageAndPopup.message =  " wants to be friends with you";
                        messageAndPopup.popupType = 'profile';
                        break;
                    case OTYPES.MSG_TYPE_ACCEPT_FRIEND: // accept friend
                        messageAndPopup.message =  " has accepted your friend request";
                        messageAndPopup.popupType = 'profile';
                        break;

                    case OTYPES.MSG_TYPE_ADD_GROUP_MEMBER: // add group member
                        //String group_name = "";
                        //int try_count = 0;
                        //while (try_count++ < 3) {
                            //for (Long id : loggedUserProfile.getGroupList().keySet()) {
                                //DTOGroup g = loggedUserProfile.getGroupList().get(id);
                                //if (g.getGroupId() == activity_id) {
                                    //group_name = g.getGroupName();
                                    //break;
                                //}
                            //}
                            //if (group_name.length() > 0) {
                                //break;
                            //} else {
                                //Thread.sleep(500);
                            //}
                        //}
                        if ( circlesManager.getCircle(noti.acId) ) {
                            gName = circlesManager.getCircle(noti.acId).getName();
                        } else {
                            gName = '';
                        }

                        messageAndPopup.message =  " has added you in a group " + gName;
                        messageAndPopup.popupType = 'group';
                        messageAndPopup.mayMerge = 0;
                        break;

                    case OTYPES.MSG_TYPE_ADD_STATUS_COMMENT: // add status comment
                        messageAndPopup.message =  othersHandler() + " commented on your post";
                        messageAndPopup.popupType = 'feed';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_STATUS: // like status
                        messageAndPopup.message =  othersHandler() + " liked your post";
                        messageAndPopup.popupType = 'feed';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_COMMENT: // like comment
                        messageAndPopup.message =  othersHandler() + " liked your comment";
                        messageAndPopup.popupType = 'feed';
                        break;
                    case OTYPES.MSG_TYPE_SHARE_STATUS: // share status
                        messageAndPopup.message =  othersHandler() + " shared your post";
                        messageAndPopup.popupType = 'feed';
                        break;

                    // media type notifications
                    case OTYPES.MSG_TYPE_LIKE_AUDIO_MEDIA :
                        messageAndPopup.message =  othersHandler() + " liked your music";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_AUDIO_MEDIA_COMMENT :
                        messageAndPopup.message =  othersHandler() + " commented on your music";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_AUDIO_MEDIA_COMMENT :
                        messageAndPopup.message =  othersHandler() + " liked your comment";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_AUDIO_MEDIA_VIEW :
                        messageAndPopup.message =  othersHandler() + " viewed your music";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_VIDEO_MEDIA :
                        messageAndPopup.message =  othersHandler() + " liked your video";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_VIDEO_MEDIA_COMMENT :
                        messageAndPopup.message =  othersHandler() + " commented on your video";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_LIKE_VIDEO_MEDIA_COMMENT :
                        messageAndPopup.message =  othersHandler() + " liked your comment";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_VIDEO_MEDIA_VIEW :
                        messageAndPopup.message =  othersHandler() +  " viewed you video";
                        messageAndPopup.popupType = 'media';
                        break;
                    case OTYPES.MSG_TYPE_YOU_HAVE_BEEN_TAGGED :
                        messageAndPopup.message =  " tagged you in a status";
                        messageAndPopup.popupType = 'feed';
                        break;
                    default:
                        messageAndPopup.popupType = 'nomatch';
                        messageAndPopup.mayMerge = 0;

                }
                return messageAndPopup;
            }


            function RingNoti(obj) {
                this.updateNoti(obj);
                //this.setUser(obj,user);
                obj = null;
            }


            RingNoti.prototype = {
				//getSortIndex: function() {
					//return 'ut';
				//},
                updateNoti: function(notiObj) {
                    var msgPopup;
                    if (angular.isObject(notiObj)) {
                        if (this.noti) {
                            angular.extend(this.noti, notiObj);
                        } else {
                            this.noti = angular.extend({}, noti_defaults, notiObj);
                            this.noti.uIdList = [];
                        }

						this.noti.updateTime = utilsFactory.verbalDate(this.noti.ut) || this.noti.ut;

                        msgPopup = setNotiMessage(this.noti);
                        this.noti.message = msgPopup.message;
                        this.noti.popupType = msgPopup.popupType;
                        this.noti.mayMerge = msgPopup.mayMerge;

                        // this below is needed for properly merging notifications
                        if (this.noti.fndId) {
                            this.noti.uIdList.push(this.noti.fndId);
                        }

                    } else {
                    }
                    notiObj = null;
                },
                sortBy: function() {
                    return this.noti.ut;
                },
                getName: function() {
                    return this.noti.fndN;
                },
                isInUidList: function(uId) {
                     return (this.noti.uIdList.indexOf(uId) > -1);
                },
                uIdList: function(uId) {
                    if (uId && uId.length) {
                        for(var i = 0; i < uId.length; i++) {
                            if (this.noti.uIdList.indexOf(uId[i]) === -1) {
                                this.noti.uIdList.push(uId[i]);
                            }
                        }
                        //uId.forEach(function(u) {
                            //if (this.noti.uIdList.indexOf(u) === -1) {
                                //this.noti.uIdList.push(u);
                            //}
                        //});
                    } else {
                        return this.noti.uIdList;
                    }
                },
                getUid: function() {
                    return this.noti.fndId;
                },
                getUserAvatar: function() {
                    if (this.noti.user) {
                        return this.noti.user.avatar('thumb');
                    } else {
                        if(this.noti.prIm){
                            var position = this.noti.prIm.lastIndexOf('/') + 1;
                            return [settings.imBase, this.noti.prIm.slice(0, position), 'pthumb',  this.noti.prIm.slice(position)].join('');
                        }else{
                            return 'images/prof.png';
                        }

                    }
                },
                getMessage: function() {
                    return this.noti.message;
                },
                getTime: function(original) {
                    if (original) {
                        return this.noti.ut;
                    } else {
                        return this.noti.updateTime;
                    }
                },
                updateNotiTime: function () {
                    this.noti.updateTime = utilsFactory.verbalDate(this.noti.ut);
                },
                getKey: function() {
                    return this.noti.id;
                },
                getPopupType: function() {
                    return this.noti.popupType;
                },
                getMessageType: function() {
                    return this.noti.mt;
                },
                getNotiType: function() {
                    return this.noti.nt;
                },
                getActivityId: function() {
                    return this.noti.acId;
                },
                getNewsFeedId: function() {
                    return this.noti.nfId;
                },
                getLink: function() {
                    //var commentTypeNoti = [ MSG_TYPE_ADD_STATUS_COMMENT ,MSG_TYPE_LIKE_COMMENT, MSG_TYPE_ADD_COMMENT_ON_COMMENT ,MSG_TYPE_IMAGE_COMMENT ,MSG_TYPE_LIKE_IMAGE_COMMENT ];
                    var link = '', params = {};
                    switch(this.noti.popupType) {
                        case 'image':
                            params.mediaId = this.noti.imgId;
                            if(!!this.noti.cmnId){
                                params.commentId = this.noti.cmnId;
                            }

                            link = utilsFactory.getRingRoute('SINGLE_IMAGE', params);
                            break;
                        case 'media':
                            params.mediaId = this.noti.imgId;

                            if(!!this.noti.cmnId){
                                params.commentId = this.noti.cmnId;
                            }

                            link = utilsFactory.getRingRoute('SINGLE_MEDIA', params);
                            break;
                        case 'profile':
                            link =  utilsFactory.getRingRoute('USER_PROFILE', { uId : this.noti.fndId });
                            break;
                        case 'group':
                            link =  utilsFactory.getRingRoute('CIRCLE_HOME', { circleId: this.noti.acId });
                            break;
                        case 'feed':
                            params.feedId = this.noti.nfId;

                            if(!!this.noti.cmnId){
                                params.commentId = this.noti.cmnId;
                            }

                            link = utilsFactory.getRingRoute('SINGLE_FEED', params);
                            break;
                        default:
                            link = '';
                    }
                    return link;
                },
                getImgId: function() {
                    return this.noti.imgId;
                },
                getCommentId: function() {
                    return this.noti.cmnId;
                },
                getSeenStatus: function() {
                    return this.noti.seen;
                },
                updateSeenStatus: function(seen) {
                    this.noti.seen = seen;
                },
                canMerge: function() {
                    return this.noti.mayMerge;
                },
                setNotiMessage: function(mergeCounter) {
                    this.noti.othersCounter += mergeCounter;
                    var modified = setNotiMessage(this.noti);
                    this.noti.message = modified.message;
                },
                // ringbox related api
                getRingboxTemplate: function() {
                    var templatePath = '';
                    switch(this.noti.popupType) {
                      case 'image' :
                            templatePath = 'pages/partials/notification/image-popup.html'; // IMPORTANT this template is preloaded inside auth factory
                            break;
                      case 'media' :
                            templatePath = 'pages/partials/notification/media-popup.html'; // IMPORTANT this template is preloaded inside auth factory
                            break;
                      case 'feed' :
                            templatePath = 'pages/partials/notification/feed-popup_with_image.html'; // IMPORTANT this template is preloaded inside auth factory
                            break;
                      default:
                          templatePath = '';
                    }
                    return templatePath;

                },
                getControllerName: function(){
                    return (this.noti.popupType === 'image' && 'RingBoxImagePopupController') ||
                           (this.noti.popupType === 'feed' && 'NotiPopupController') ||
                           (this.noti.popupType === 'media' && 'RingBoxMediaController');
                },
                showRingbox: function (){
                    return this.noti.popupType === 'feed' || this.noti.popupType === 'image' || this.noti.popupType === 'media' ? true : false;
                }
            };

            return function (obj) {
                    return new RingNoti(obj);
            };
		}
})();

(function () {

'use strict';

angular
        .module('ringid.notification')
        .service('notificationHttpService', notificationHttpService);

        notificationHttpService.$inject = ['$$connector', 'settings', 'OPERATION_TYPES'];
        function notificationHttpService($$connector, settings, OPERATION_TYPES) { // jshint ignore:line
            var self = this, // jshint ignore:line
                OTYPES = OPERATION_TYPES.SYSTEM.NOTIFICATION,
                REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;

            /**
            * @api {request} /APIREQUEST/111 Get Notification list
            * @apiVersion 0.1.0
            * @apiDescription This Requests list of notification for logged in user.
            * @apiName GetNotifications
            * @apiGroup Notification
            *
            * @apiParam {Number=111} actn action constant for this api call
            * @apiParam {Number{1,2}} scl this dictates if Older or Newer notification
            * @apiParam {Number} ut Update Time in Timestamp
            *
            *
            * @apiSuccess {Number} acId Undefined
            * @apiSuccess {Number=111} actn action constant for this api call
            * @apiSuccess {Number} cmnId  Not needed
            * @apiSuccess {Number} headerLength packet header length
            * @apiSuccess {Number} imgId Not Needed
            * @apiSuccess {Number} loc Undefined
            * @apiSuccess {Object[]{1..5}} nList Notification list
            * @apiSuccess {Number} nfId Not needed
            * @apiSuccess {Number} pckFs Server Packet id
            * @apiSuccess {Number} pckId Packet id
            * @apiSuccess {Number{1,2}} scl this dictates if Older or Newer notification
            * @apiSuccess {Number} seq Packet Sequence number
            * @apiSuccess {Boolean} sucs Request successfully processed or not
            * @apiSuccess {Number} tn total notification
            * @apiSuccess {Number} tr Undefined
            *
            * @apiSuccess (nList) {Number} acId Undefined
            * @apiSuccess (nList) {Number} cmnId Comment Id
            * @apiSuccess (nList) {Number} fndId Friend Id
            * @apiSuccess (nList) {String} fndN Friend Name
            * @apiSuccess (nList) {Number} groupId Group Id
            * @apiSuccess (nList) {Number} id Notification Id
            * @apiSuccess (nList) {Number} imgId Image Id
            * @apiSuccess (nList) {Number} loc Undefined
            * @apiSuccess (nList) {Number{1..13}} mt Message Type
            * @apiSuccess (nList) {Number} nfId Feed Id
            * @apiSuccess (nList) {Number{1..5}} nt Notification type
            * @apiSuccess (nList) {Number} ut Update Time in timestamp
            *
            *
            *
            *
            * @apiSuccessExample Success-Response:
            *     HTTP/1.1 200 OK
            *     {
            *       acId: 0,
            *       actn: 111,
            *       cmnId: 0,
            *       headerLength: 62,
            *       imgId: 0,
            *       loc: 0,
            *       nList: [
            *           0: {
            *               acId: 0,
            *               cmnId: 0,
            *               fndId: "2000002368",
            *               fndN: "Wasif Islam",
            *               id: 368516,
            *               imgId: 14628,
            *               loc: 0mt: 1,
            *               nfId: 16103,
            *               nt: 5,
            *               ut: 1433832601723
            *           }
            *       ],
            *       nfId: 0,
            *       pckFs: 257739,
            *       pckId: "250085192336",
            *       scl: 1,
            *       seq: "4/7",
            *       sucs: true,
            *       tn: 32,
            *       tr: 32
            *     }
            *
            * @apiError Notification list not found
            *
            * @apiErrorExample Error-Response:
            *     HTTP/1.1 404 Not Found
            *     {
            *       "sucs": false
            *     }
            */

            self.requestNotification = function(obj){
                var payload = {
                    actn: OTYPES.TYPE_MY_NOTIFICATIONS,
                    //from_index: obj.from_index || 0,
                    //to_index: obj.to_index || 10,
                    //ut: obj.ut || -1,
                    //scl: obj.scl || 2
                };
                if (obj && obj.from_index > 0) {
                    payload = angular.extend({}, payload, obj);
                }
                $$connector.send(payload, REQTYPE.REQUEST);
            };

            self.clearNotiCount = function() {
                var d = new Date();
                var t = d.getTime();
                var payload = {
                    actn: OTYPES.CLEAR_NOTIFICATION_COUNTER,
                    ut: t
                };
                return $$connector.request(payload, REQTYPE.REQUEST);
            };

            self.getNotificationDetails = function (obj) {
                 var payload = {
                        actn: OPERATION_TYPES.SYSTEM.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS,
                        nfId: obj.activityId
                };
                return $$connector.request(payload, REQTYPE.REQUEST);
            };

            self.getImageAlbumDetails = function(obj) {
                var payload = {
                    actn: OPERATION_TYPES.SYSTEM.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS,
                    request_type: REQTYPE.REQUEST,
                    imgId: obj.imgId
                };
                return $$connector.request(payload, REQTYPE.REQUEST);
            };

        }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.notification')
		.factory('NotificationFactory', NotificationFactory);

		NotificationFactory.$inject = ['$$connector','$q', 'Storage','notificationHttpService', '$$stackedMap', '$$notiMap', 'OPERATION_TYPES', '$rootScope', 'SystemEvents', 'Auth'];
		function NotificationFactory($$connector,$q, Storage, notificationHttpService, $$stackedMap, $$notiMap, OPERATION_TYPES, $rootScope, SystemEvents, Auth) { //jshint ignore:line

			var $notification = $$stackedMap.createNew(true, 'desc'),
                initialized = false,
                OTYPES = OPERATION_TYPES.SYSTEM.NOTIFICATION,

                from_index = 0,
			    notiCounter = 0,
                minUpdateTime = -1,
                state = {
                    loading: false,
                    noMoreData: false,
                };

			var process = function(json){
                var noti, saveNewNoti = true;

                function mergeNoti(n) {

                    function processMerge(merge) {
                        if (n.value.getTime(true) < noti.getTime(true) ) {
                            notiCounter = notiCounter > 0 ? notiCounter-1 : 0;
                            // updatee new noti utid list
                            noti.uIdList(n.value.uIdList());

                            // not same person increase counter
                            noti.setNotiMessage();
                            // new noti is latest
                            $notification.remove(n.value.getKey());
                        } else {
                            // new noti is old.
                            saveNewNoti = false;
                            n.value.uIdList(noti.uIdList());

                            n.value.setNotiMessage();
                            // update old noti utid list
                        }
                    }

                    if (n.value.getMessageType() === noti.getMessageType()) {
                        if (n.value.canMerge() === 1) {
                            switch(n.value.getPopupType()) {
                                case 'feed':
                                    if (n.value.getNewsFeedId() === noti.getNewsFeedId()) {
                                        //if (n.value.getUid() !== noti.getUid()) {
                                        if (!n.value.isInUidList(noti.getUid())) {
                                            processMerge(true);
                                        } else {
                                            processMerge(false);
                                        }
                                    }
                                    break;
                                case 'image':
                                case 'media':
                                    if (n.value.getImgId() === noti.getImgId()) {
                                        //if (n.value.getUid() !== noti.getUid()) {
                                        if (!n.value.isInUidList(noti.getUid())) {
                                            processMerge(true);
                                        } else {
                                            processMerge(false);
                                        }
                                    }
                                    break;
                            }
                        } else if (n.value.canMerge() === 2) {
                            // no need to merge. delete older notification
                            if (n.value.getUid() === noti.getUid()) {
                                processMerge(false);
                            }
                        }
                    }

                }

                switch(json.actn) {
                    case OTYPES.TYPE_MY_NOTIFICATIONS:
                        if (json.sucs === true || json.sucs === 'true' ) {
                            var timeArray = [];

                            from_index += json.nList.length;
                            var oldNotiCount =  parseInt(Storage.getData('oldNotiCount'));
                            notiCounter = oldNotiCount > json.tn ? json.tn : (json.tn - oldNotiCount);
                            for(var i = 0; i < json.nList.length; i++) {
                                saveNewNoti = true;
                                noti = $$notiMap(json.nList[i]);
                                // check if merge needed and do the merge
                                $notification.all().forEach( mergeNoti);
                                timeArray.push(json.nList[i].ut);

                                var seenarr = Storage.getData('notiseen');
                                if (saveNewNoti) {
                                    for(var j = 0 ; j < seenarr.length ; j++ ){
                                        if( seenarr[j] === json.nList[i].id ){
                                            noti.updateSeenStatus(true);
                                        }
                                    }
                                    $notification.save(noti.getKey(), noti);
                                }
                                // URGENT. merging new notifications the notiCounter remains incorrect
                                //else {
                                    ////notiCounter = notiCounter > 0 ? notiCounter-1 : 0;
                                    //notiCounter = notiCounter > 1 ? notiCounter-1 : 0;
                                //}
                            }

                            var sortedTime = timeArray.sort();
                            minUpdateTime = sortedTime[0] || minUpdateTime;

                        } else if (json.sucs === false && json.rc === 1111) {
                            loadMoreNoti();
                        } else {
                            state.noMoreData = true;
                        }

                        break;
                    case OTYPES.TYPE_SINGLE_NOTIFICATION:
                        from_index++;
                        saveNewNoti = true;
                        noti = $$notiMap(json);
                        // check if merge needed and do the merge
                        $notification.all().forEach( mergeNoti);
                        if (saveNewNoti) {
                            $notification.save(noti.getKey(), noti);
                            //Storage.setData('oldNotiCount', parseInt(Storage.getData('oldNotiCount')) + 1);
                        }
                        notiCounter++; // will not effect oldNotiCount in localStorage

                        break;
                    default:
                }

			};



            var loadMoreNoti = function(toIndex) {
                toIndex = toIndex || 10;
                //var deferred = $q.defer();

                var obj = {
                    from_index: (from_index > 0) ? from_index : 0,
                    to_index: (from_index > 0) ? from_index+toIndex: toIndex,
                    scl: 2,
                    ut: minUpdateTime
                };

                notificationHttpService.requestNotification(obj);
                //.then(function(json) {
                    //if (json.sucs === true || json.sucs === 'true') {
                        //deferred.resolve();
                    //} else {
                        //deferred.reject();
                    //}
                //}, function(json) {
                    //if (json.sucs === false && json.rc === 1111) {
                        //loadMoreNoti(toIndex);
                    //} else {
                        //state.noMoreData = true;
                        //deferred.reject();
                    //}
                //});
                //return deferred.promise;
            };


            function init(force) {
                if (!initialized || force) {
                    initialized = true;
                    $$connector.subscribe(process,
                                  { action: [
                                        OTYPES.TYPE_MY_NOTIFICATIONS,
                                        OTYPES.TYPE_SINGLE_NOTIFICATION
                                    ]
                                  });

                    loadMoreNoti();
                }
            }


			return {
                init: init,
                state: state,
                loadMoreNoti: loadMoreNoti,
                process: process,
				getNotifications: function() {
					return $notification;
				},
				getNotification: function(key) {
					return $notification.get(key);
				},
				clearCounter: function() {
                    if (notiCounter > 0)  {
                        Storage.setData('oldNotiCount', notiCounter + parseInt(Storage.getData('oldNotiCount')) );
                        notiCounter = 0;
                        // TODO BELOW CODE IS IMPORTANT. BUT REQURIES AUTH SERVER CHANGES FOR WEB TO WORK PROPERLY WITH CORRECT NEW NOTI COUNTER
						//notificationHttpService.clearNotiCount().then(function(json) {
                            //notiCounter = 0;
                        //});
                    }
                    // update notification times
                    //var notifications = NotificationFactory.getNotifications();
                        for(var i=0; i < $notification.length(); i++){
                            var timediff = Date.now() - $notification.all()[i].value.sortBy();
                            if(timediff < 3600000) {
                                $notification.all()[i].value.updateNotiTime();
                            }
                        }
				},
				getNotiCount: function() {
                    return  notiCounter > 99 ? '99+' : notiCounter;
				},
                //getNotificationDetails : function(obj) {
                    //var defer =  $q.defer();
                    //notificationHttpService.getNotificationDetails(obj).then(function(json){
                        //if(json.sucs ===true) {
                             //defer.resolve(json);
                        //}else{
                             //defer.reject(json);
                        //}

                    //});
                    //return defer.promise;
                //}

			};
		}

})();


/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.notification')
        .directive('rgNotification', rgNotification);

    rgNotification.$inject = [ '$window', '$document', '$ringhttp', '$compile'];
    function rgNotification( $window, $document, $ringhttp, $compile) { // jshint ignore:line

        NotificationController.$inject = ['NotificationFactory', '$location', 'circlesManager', 'AlbumFactory', 'Auth', 'Media', 'rgDropdownService', 'Ringalert', 'Storage', '$scope', 'rgScrollbarService',
                                            'OPERATION_TYPES', '$$connector', 'notificationHttpService', 'SystemEvents'];
        function NotificationController(NotificationFactory, $location, circlesManager, AlbumFactory, Auth, Media, rgDropdownService, Ringalert, Storage, $scope, rgScrollbarService,
                                            OPERATION_TYPES, $$connector, notificationHttpService, SystemEvents) { //jshint ignore:line

            var loadCount = parseInt($scope.loadCount),
                timeOut,
                OTYPES = OPERATION_TYPES.SYSTEM.NOTIFICATION;

            $scope.state = NotificationFactory.state;
            $scope.notifications = NotificationFactory.getNotifications();
            $scope.loadMoreNotification = loadMoreNotification;
            $scope.getRingboxData = getRingboxData;
            $scope.notificationAction = NotificationFactory.notificationAction;


            function getRingboxData (noti) {
                switch(noti.value.getPopupType()){
                  case 'image' :
                    return notificationAction( { action:'image',noti:noti.value, nfId : noti.value.getNewsFeedId(), imgId: noti.value.getImgId(), templateType : 'image' } );
                  case 'media' :
                    return notificationAction( { action:'media',noti:noti.value, nfId : noti.value.getNewsFeedId(), mediaId: noti.value.getImgId(), templateType : 'media' } );
                  case 'feed' :
                    return notificationAction( {
                        action:'ringbox',
                        nfId : noti.value.getNewsFeedId(),
                        noti:noti.value,
                        templateType : 'feed_with_text'
                      }
                    );
                }
            }

            function notificationAction (actionObj) {
                //rgDropdownService.close(actionObj.event);
                var seenarr = Storage.getData('notiseen');
                if(!seenarr){
                    seenarr = [];
                    Storage.setData('notiseen',seenarr);
                }
                if(seenarr.indexOf(actionObj.noti.getKey()) === -1){
                    seenarr.push(actionObj.noti.getKey());
                    actionObj.noti.updateSeenStatus(true);
                    if(seenarr.length > 150){
                        seenarr.shift();
                    }
                }
                Storage.setData('notiseen',seenarr);
                switch (actionObj.action) {
                        case 'redirect':
                            var circle = circlesManager.getCircle(actionObj.circleId);
                            if(circle){
                                var loc = actionObj.link.slice(1);
                                $location.path(loc);
                            }else{
                                Ringalert.show('Circle does not exist!', 'error');
                            }
                            break;
                        case 'ringbox' :
                              return {
                                 data: function () {
                                   return {notiKey: actionObj.noti.getKey(),noti : actionObj.noti, templateType : actionObj.templateType };
                                 },
                                 promise: notificationHttpService.getNotificationDetails({activityId: actionObj.nfId})
                               };
                        case 'media' :
                          return {
                              data: function() {
                                  return {
                                      notiKey: actionObj.noti.getKey(),
                                      noti : actionObj.noti,
                                      mediaId: actionObj.mediaId,
                                      popupFrom: 'notification',
                                      templateType: actionObj.templateType
                                  };
                              },
                              promise: Media.fetchContentDetails(actionObj.mediaId, true, Auth.currentUser().getUtId()),
                          };
                        case 'image' :
                            return {
                               data: function() {
                                  return {
                                        notiKey: actionObj.noti.getKey(),
                                        noti : actionObj.noti,
                                        imgId: actionObj.imgId,
                                        popupFrom: 'notification',
                                        templateType: actionObj.templateType
                                  };
                                },
                                promise: AlbumFactory.getImageDetails(actionObj.imgId,actionObj.nfId)
                            };
                        default :
                }
            }


            function toggleLoading(bool) {
                $scope.state.loading = bool;
                if (!bool) {
                    rgScrollbarService.recalculate($scope);
                    $scope.$emit(SystemEvents.FEED.HEIGHT);
                }
                $scope.$rgDigest();
            }


            function loadMoreNotification() { // jshint ignore:line
                if (!$scope.state.loading && !$scope.state.noMoreData) {
                    toggleLoading(true);
                    NotificationFactory.loadMoreNoti(loadCount);
                }
            }


            // initialize
            if (loadCount > 20)  {
                // a loose condition to check if its see all or just the dropdown
                $scope.$emit(SystemEvents.FEED.HEIGHT);
            }
            if ($scope.notifications.length() < loadCount) {
                loadMoreNotification();
            }

             var subscriptionKey = $$connector.subscribe(
                            function() {
                                if (!timeOut) {
                                    timeOut = setTimeout(function() {
                                        timeOut = null;
                                        toggleLoading(false);
                                    }, 200);
                                }
                            },
                            { action: [
                                OTYPES.TYPE_MY_NOTIFICATIONS,
                                OTYPES.TYPE_SINGLE_NOTIFICATION
                            ]
                        });

            $scope.$on('$destroy', function() {
                $$connector.unsubscribe(subscriptionKey);
            });

        }

        function linkFunc(scope, element, attr) {
            var templateUrl =  attr.templateUrl ? attr.templateUrl : 'pages/dropdowns/notification-dropdown.html';

            $ringhttp.get(templateUrl).success(function(template) {
                element.append($compile(template)(scope));
                scope.$rgDigest();
            });

        }

        return {
            restrict: 'AE',
            controller: NotificationController,
            //templateUrl: 'pages/dropdowns/notification-dropdown.html', // IMPORTANT template preloaded inside auth factory
            //scope: true,
            scope: {
                 loadCount: '@',
                 templateUrl: '@'
            },
            link: linkFunc

        };

    }
})();

/**
 *
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.notification' )
        .controller('NotiPopupController', NotiPopupController );

    NotiPopupController.$inject =
        ['$$connector', 'OPERATION_TYPES', 'Auth','$scope','localData','remoteData', 'NotificationFactory', '$$feedMap','feedFactory','rgDropdownService','Ringalert','MESSAGES'];
    function NotiPopupController($$connector, OPERATION_TYPES,  Auth, $scope,   localData,remoteData, notificationFactory, $$feedMap, feedFactory,rgDropdownService,Ringalert,MESSAGES) { // jshint ignore:line
        var OTYPES = OPERATION_TYPES.SYSTEM,OTYPES_NOTI = OPERATION_TYPES.SYSTEM.NOTIFICATION,showWhoShare=true;
        //console.warn(localData.notification.value.getCommentId());
        // view model
        $scope.currentUser = Auth.currentUser();
        $scope.feed = {};
        $scope.focused = false;
        $scope.showCommentBox = true;

        $scope.nocontent = false;

        // dropdown specific data and methods
        $scope.ddHtml = 'pages/dropdowns/feed-edit-dropdown.html';


        // methods
        //$scope.like = likeFeed;
        $scope.getMediaData = getMediaData;
        // end mothods list



        if (localData && localData.notiKey) {
            $scope.key = localData.notiKey;
            $scope.noti = localData.noti;
            $scope.templateType = localData.templateType;

            // switch(localData.noti.getMessageType()){

            //     case OTYPES_NOTI.MSG_TYPE_LIKE_STATUS:
            //     case OTYPES_NOTI.MSG_TYPE_LIKE_COMMENT:
            //          showWhoShare = false;break;
            //     case OTYPES_NOTI.MSG_TYPE_SHARE_STATUS:

            //     case OTYPES_NOTI.MSG_TYPE_ADD_STATUS_COMMENT:
            //         showWhoShare = true;break;
            // };
        }
        // check what to show using nt, mt value

        $scope.boxIsLoading = false;
        if(remoteData.sucs === false) {
            $scope.nocontent = true;
            Ringalert.show(remoteData,'error');
            $scope.$close();
            return false;
        }else{

            var shareData = angular.fromJson(remoteData.newsFeedList)
            //console.log(remoteData.newsFeedList[0]);
            //

             if(showWhoShare && shareData[0] && shareData[0].orgFd){
                $scope.feed = $$feedMap.create(shareData[0]);
                var _d1 = $$feedMap.create(shareData[0].orgFd);
                $scope.feed.shares(_d1);
            }else{
                $scope.feed = $$feedMap.create(remoteData.newsFeedList[0]);
            }
                $scope.keyid = $scope.feed && $scope.feed.getKey();//used in template as keyid

        }


        // like on a comment in feed
        //if($scope.noti.getMessageType() === 8 && $scope.noti.getNotiType() === 2) {

            //  $$connector.subscribe(function(json) {
            //         console.log(commentJson);
            //         $scope.feed.pushComment(commentJson);
            //  },{
            //     action : OTYPES.ACTION_GET_FULL_COMMENT
            //  });
            // // get specific comment and highlight it
            //  feedFactory.fetchCommentById($scope.noti.getNewsFeedId(), $scope.noti.getCommentId()).then(function(commentJson) {
            //         console.log(commentJson);
            //         $scope.feed.pushComment(commentJson);
            //  });
        //}

        if( $scope.feed.hasMedia() || ( $scope.feed.hasSharedFeed() && $scope.feed.getOrginalFeed().getImages().length )){
            $scope.templateType = 'feed_with_image';
        }



        // function likeFeed (feed){

        //      var key = $scope.feed.getKey();
        //             feedFactory.likeUnlikeFeed(key,$scope.feed).then(function(json){
        //             });
        //             if($scope.feed.like()){
        //                 $scope.$broadcast('LikeChange',true);
        //             }
        // }




        if($scope.noti.getCommentId() > 0){
            $scope.activeCommentId = $scope.noti.getCommentId();
        }




        function getMediaData(media,feed) {
            if(!feed)feed = $scope.feed;
            return {
                    data: function () {
                        return {
                            media: media,
                            album: feed.getAlbum(),
                            feedTime: feed.time()
                        };
                    },
                    promise: media.fetchDetails()//Media.fetchContentDetails(media.getKey(),true, feed.user())
                };
         }




        $scope.shareMenuDisabled = $scope.shareMenuDisabled ? $scope.shareMenuDisabled : false;

        var commentInitialFetch = false;
        $scope.toggleCommentBox = function (event) {
            event.stopPropagation();
            $scope.showCommentBox = !$scope.showCommentBox;
            if($scope.showCommentBox) {
                $scope.showShareBox = false;
            }
        };

        $scope.toggleShareBox = function(event) {
            event.stopPropagation();
            var f = $scope.feed.hasSharedFeed() ? $scope.feed.getOrginalFeed():$scope.feed;
            var shareablle = f.isShareAble(true);
            if(shareablle.sucs) {
                $scope.showShareBox = !$scope.showShareBox;
                if($scope.showShareBox) {
                    $scope.showCommentBox = false;
                }
            } else {
                Ringalert.show(MESSAGES[shareablle.rc],'warning');
            }
        };
        $scope.getImageData = function (image, feed) {

                return function () {
                            return {
                               image: image,
                               feed: feed
                           };
                        };
            };
        //$scope.singleFeed = true;

    }
})();



/*
* © Ipvision
*/

(function(){
    'use strict';
    angular
        .module('ringid.friend.friends_factory', [
            'ringid.auth',
            //'ringid.common.stacked_map',
            'ringid.common.contacts_factory',
            'ringid.common.user_factory',
            'ringid.common.services',
            'ringid.common.factories'
        ])
        .factory('friendsFactory', friendsFactory);

		friendsFactory.$inject = ['$rootScope', 'SystemEvents', '$$q', 'Contacts', 'APP_CONSTANTS', 'Auth', 'Storage',  '$$connector', 'OPERATION_TYPES', 'userFactory', 'friendsHttpService', '$$stackedMap', 'Ringalert', 'utilsFactory'];
        function friendsFactory($rootScope, SystemEvents,  $q, Contacts, APP_CONSTANTS, Auth, Storage,  $$connector, OPERATION_TYPES,  userFactory, friendsHttpService, $$stackedMap, Ringalert, utilsFactory) { //jshint ignore:line

            var OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS,
                initialized = false,
                AC = APP_CONSTANTS,
                userFriendsCount = 0,
                userFriendsSt = 0,
                utIdRequest = {
                        totalPacket: 0,
                        complete: false
                };


            var _utIDsToByteArray = function(utIds, doNotFilter) {
                var byteArray = [],
                    contactList = [],
                    i,
                    l,
                    index,
                    requestedUtIds = [];

                if (doNotFilter) {
                    requestedUtIds = utIds;
                } else {
                    // filter utid whose request are already made and data already available in localStorage
                    for(i = 0, l = utIds.length; i < l; i++) {
                        if(utIds[i] === Auth.currentUser().getUtId()) { //already requested. remove this item
                            continue;
                        } else if(Storage.getContact(utIds[i])) { // set contact from localStorage
                            contactList.push(Storage.getContact(utIds[i]));
                        } else {
                            requestedUtIds.push(utIds[i]);
                        }
                    }

                    // already got these contacts from localStorage. so add these to friends lists
                    if (contactList.lenght > 0) {
                        _setContacts(contactList);
                    }
                }

                var buf = new ArrayBuffer(requestedUtIds.length * 8),
                    utIDsArray = new DataView(buf);
                // create byte array
                for(i = 0, index = 0, l = requestedUtIds.length; i < l; i++) {
                    utIDsArray.setInt32(index,0);
                    index += 4;
                    utIDsArray.setInt32(index,requestedUtIds[i]);
                    index += 4;
                }

                for(i = 0; i < utIDsArray.byteLength; i++){
                    byteArray.push(utIDsArray.getInt8(i));
                }

                return byteArray;
            };

            var _clearUtId = function(utId, removeContacts,  removeAll) {
                var success =  Contacts.remove('utIds', utId);
                if (removeContacts) {
                    fFactory.friends.remove(utId);
                }
                if (!success || removeAll) {
                    success = Contacts.remove('incomingUtIds', utId);
                    if (removeContacts) {
                        fFactory.incomingFriends.remove(utId);
                    }
                    if (!success || removeAll) {
                        success = Contacts.remove('outgoingUtIds', utId);
                        if (removeContacts) {
                            fFactory.outgoingFriends.remove(utId);
                        }
                    }
                }
            };

            var _setContacts = function(contactList) {
                var friend, frnS;
                for (var i = 0, l = contactList.length; i < l; i++) {
                    friend = userFactory.create(contactList[i]);
                    frnS = friend.friendshipStatus();

                    //if(contactList[i].deleted && contactList[i].deleted === 1) { // if contact is deleted do not save it
                        //continue;
                    //}

                    if(frnS === AC.FRIEND) { // friend
                        //Contacts.remove('utIds', contactList[i].utId);
                        fFactory.friends.save(friend.getUtId(), friend);
                    } else if (frnS  === AC.INCOMING_FRIEND) { // friend request received
                        //Contacts.remove('incomingUtIds', contactList[i].utId);
                        fFactory.incomingFriends.save(friend.getUtId(), friend);
                    } else if(frnS === AC.OUTGOING_FRIEND){ // friend request sent
                        //Contacts.remove('outgoingUtIds', contactList[i].utId);
                        fFactory.outgoingFriends.save(friend.getUtId(), friend);
                    } else {
                    }

                    _clearUtId(contactList[i].utId, false, true);
                    //Contacts.remove('utIds', contactList[i].utId);
                    //Contacts.remove('incomingUtIds', contactList[i].utId);
                    //Contacts.remove('outgoingUtIds', contactList[i].utId);

                }


            };



            var _requestFailed = function(defer, json) {
                var mg = (json && json.mg) ? json.mg : 'Reqeust Failed';
                Ringalert.show(mg, 'error');
                if (defer) {
                    defer.reject({sucs: false, mg: mg});
                }
            };



            var processResponse = function(json) {
                var friend, i, l;
                switch(json.actn) {
                    case OTYPES.TYPE_CONTACT_UTIDS:
                        if(json.sucs === true) {
                            if (utIdRequest.totalPacket === 0 &&  !utIdRequest.complete) { // check total response
                                utIdRequest.totalPacket = json.totalPacket;
                            }
                            utIdRequest.totalPacket--;
                            for(i = 0, l = json.utIds.length; i < l; i++) {
                                // save new utids in localstorage;
                                switch(json.utIds[i].value.frnS) {
                                    case AC.FRIEND:
                                        Contacts.add('utIds', json.utIds[i].key, json.utIds[i].value);
                                        break;
                                    case AC.INCOMING_FRIEND:
                                        Contacts.add('incomingUtIds', json.utIds[i].key, json.utIds[i].value);
                                        break;
                                    case AC.OUTGOING_FRIEND:
                                        Contacts.add('outgoingUtIds', json.utIds[i].key, json.utIds[i].value);
                                        break;
                                    default:
                                }
                            }

                            if (utIdRequest.totalPacket === 0) { // got all the packets for utid
                                utIdRequest.complete = true;
                                Contacts.initStorage();

                            }

                            utilsFactory.triggerCustomEvent(SystemEvents.FRIEND.UTID_LIST_RECEIVED);


                        } else if (json.sucs === false && json.rc === 1111){
                            friendsHttpService.getContactList() ;
                        } else {
                        }
                        break;

                    //case OTYPES.TYPE_CONTACT_LIST: // fetch own contacts response
                        //fFactory.state.isFriendsLoading = false;
                        //fFactory.state.isRequestsLoading = false;
                        //fFactory.state.noFriends = false;
                        //if (json.sucs === true) {
                            //// get matchby Value and remove this contact from fFactory.utIDs list
                            //for(i = 0; i < json.contacts.length; i++) {
                                //Storage.setContact(json.contacts[i].utId, json.contacts[i]); // store in localStorage
                                //_setContacts(json.contacts[i]);
                            //}
                        //} else {
                        //}
                        //break;
                    //case OTYPES.TYPE_FRIEND_CONTACT_LIST: // fetch friends contacts response
                        //fFactory.state.isUserFriendsLoading = false;
                        //userFriendsCount = json.tf;
                        //if (json.sucs === true) {
                            //for(i = 0; i < json.contactList.length; i++) {
                                //friend = userFactory.create(json.contactList[i]);
                                //fFactory.userFriends.save(friend.getUtId(), friend);
                            //}
                        //}
                        //break;

                    case OTYPES.TYPE_UPDATE_ADD_FRIEND: // 327, //"add_friend"
                        if(json.sucs === true) {
                            Contacts.add('incomingUtIds', json.utId, {frns: AC.INCOMING_FRIEND});
                        }
                    break;
                    case OTYPES.TYPE_UPDATE_DELETE_FRIEND: //328, // "delete_friend"
                        if(json.sucs === true) {
                            if(json.utId) {
                                _clearUtId(json.utId, true, true);
                                //if(!fFactory.friends.remove(json.utId)) { // remove from friend list
                                    //if(!fFactory.incomingFriends.remove(json.utId)) { // remove from incoming friends
                                        //Contacts.remove('outgoingUtIds', json.utId); // remove from outgoing utid list
                                    //} else {
                                        //Contacts.remove('incomingUtIds', json.utId); // remove from incoming utid list
                                    //}
                                //} else {
                                    //Contacts.remove('utIds', json.utId); // remove from friend utid list
                                //}
                                // in case user in in search result or current user visiting his/her profile then we
                                // need to update the userMap object too
                                friend = userFactory.create(json);
                                friend.updateUserObj({frnS: AC.NOT_FRIEND});
                            } else {
                            }
                        }
                        break;
                    case OTYPES.TYPE_UPDATE_ACCEPT_FRIEND: // 329, //"friend accepts me acknowledgement"
                        if(json.sucs === true) {
                            //Contacts.remove('outgoingUtIds', json.utId);
                            //Contacts.add('utIds', json.utId);
                            _clearUtId(json.utId, true);
                            fFactory.friends.add(json.utId, userFactory.create(json));
                        }
                        break;
                    default:
                }

            };

            var getFriends = function(type) {
                switch(type) {
                    case 'friendslist':
                    case 'friends':
                        return fFactory.friends;
                    case 'incoming':
                        return fFactory.incomingFriends;
                    case 'outgoing':
                        return fFactory.outgoingFriends;
                    case 'userfriends':
                        return fFactory.userFriends;
                }
            };

            // when leaving user friends page, empty userFriends
            var resetUserFriends =  function() {
                userFriendsCount = 0;
                fFactory.userFriends.reset();
            };

            // friends contact list of a friend
            var getUserContacts =  function(utId) {
                var defer = $q.defer(), friend;
                friendsHttpService.getUserContacts(utId, userFriendsSt).then(function(json) {
                    userFriendsCount = (userFriendsCount === 0 )? json.tf : userFriendsCount;
                    if (json.sucs === true) {
                        userFriendsSt += json.contactList.length;
                        for(var i = 0; i < json.contactList.length; i++) {
                            friend = userFactory.create(json.contactList[i]);
                            fFactory.userFriends.save(friend.getKey(), friend);
                        }
                        defer.resolve();
                    } else {
                        defer.reject(json);
                    }
                }, function(json) {
                    defer.reject(json);
                });
                return defer.promise;
            };

            //current user friend list
            var getContactDetails =  function(type, getRecord) {
                var i,
                    utidByteArray = [],
                    defer = $q.defer();

                getRecord = getRecord ? getRecord : 20;
                type = type ? type : 'utIds';

                switch(type) {
                    case 'friends':
                    case 'friendslist':
                    case 'utIds':
                        utidByteArray = _utIDsToByteArray(Contacts.utIds().keys().slice(0, getRecord) );
                        fFactory.state.isFriendsLoading = utidByteArray.length > 0 ? true : false;
                        break;
                    case 'userfriends':
                        break;
                    case 'incoming':
                    case 'incomingUtIds':
                        utidByteArray = _utIDsToByteArray( Contacts.incomingUtIds().keys().slice(0, getRecord) );

                        break;
                    case 'outgoing':
                    case 'outgoingUtIds':
                        utidByteArray = _utIDsToByteArray( Contacts.outgoingUtIds().keys().slice(0, getRecord) );
                        break;
                }

                if (utidByteArray.length > 0) {
                    friendsHttpService.getContactListDetails({
                        utIDs: utidByteArray,
                        uo: false
                    }).then( function(json) {

                        if (json.sucs === true) {
                            // get matchby Value and remove this contact from fFactory.utIDs list
                            for(i = 0; i < json.contacts.length; i++) {
                                Storage.setContact(json.contacts[i].utId, json.contacts[i]); // store in localStorage
                            }
                            _setContacts(json.contacts);
                            defer.resolve(json);
                        } else {
                            defer.reject(json);
                        }
                    }, function(json) {
                        defer.reject(json);
                    });
                } else {
                    defer.reject({sucs: false});
                }
                return defer.promise;

            };



            //contact details by UtIds
            var getContactDetailsByUtIds =  function(utIds){
                if(utIds.length > 0) {
                    var utidByteArray =  _utIDsToByteArray(utIds, true);

                    if(utidByteArray.length > 0) {
                        return friendsHttpService.getContactListDetails({
                            utIDs: utidByteArray,
                            uo: false
                        });
                    }
                }
            };


            var friendAction = function(obj, returnPromise) { // obj= {friend: userObj, action: 'accept', 'addfriend' etc }
                obj.friend.isLoading(true);
                switch(obj.action) {
                    case 'remove':
                    case 'unfriend': // AC.FRIEND :  // unfriend
                        return removeFriend(obj, returnPromise);
                    case 'add':
                    case 'addfriend': //AC.NOT_FRIEND: // send new friend request
                        return addFriend(obj, returnPromise);
                    case 'accept': // accept friend request
                        return acceptFriendRequest(obj, returnPromise);
                    case 'incoming_reject': // reject or cancel incoming or outgoig friend request
                    case 'outgoing_reject': // reject or cancel incoming or outgoig friend request
                    case 'reject': // reject or cancel incoming or outgoig friend request
                        return rejectFriendRequest(obj, returnPromise);
                    case 'block':
                        obj.block = 1;
                        obj.bv = 0;
                        return blockFriend(obj, returnPromise);
                    case 'unblock':
                        obj.block = 0;
                        obj.bv = 1;
                        return blockFriend(obj, returnPromise);
                    default:
                        obj.friend.isLoading(false);
                        return false;
                }

            };



            var addFriend =  function(obj, returnPromise) {
                var defer = returnPromise ? $q.defer(): false;
                var utId = obj.friend.getUtId();
                if(!utId) {
                }
                friendsHttpService.sendFriendRequest({uId: obj.friend.getKey()}).then(function(json){
                    obj.friend.isLoading(false);
                    if(json.sucs === true) {
                        //Ringalert.show('Friend request sent', 'success');
                        Contacts.add('outgoingUtIds', utId, {frns: AC.OUTGOING_FRIEND});
                        if(returnPromise) {
                            defer.resolve(json);
                        }
                        obj.friend.updateUserObj( angular.extend({}, json, {frns: AC.OUTGOING_FRIEND}) );
                    } else {
                        _requestFailed(defer, json);
                    }
                }, function(json) {
                    obj.friend.isLoading(false);
                    _requestFailed(defer, json);
                });
                if(returnPromise) {
                    return defer.promise;
                }
            };

            var acceptFriendRequest =  function(obj, returnPromise) {
                var defer = returnPromise ? $q.defer(): false;
                var utId = obj.friend.getUtId();
                friendsHttpService.acceptFriendRequest({friendId: obj.friend.getKey(),utId: obj.friend.getUtId()}).then(function(json) {
                    obj.friend.isLoading(false);
                    if(json.sucs === true) {
                        _clearUtId(utId, true);
                        //fFactory.incomingFriends.remove(utId);
                        //Contacts.remove('incomingUtIds', utId);

                        obj.friend.updateUserObj( angular.extend({}, json, {frnS: AC.FRIEND}) );
                        fFactory.friends.save(utId, obj.friend);

                        //Ringalert.show('You have become friends with ' + obj.friend.getName(), 'success');
                        if(returnPromise) {
                            defer.resolve(json);
                        }
                    } else {
                        _requestFailed(defer, json);
                    }
                }, function(json) {
                    obj.friend.isLoading(false);
                    _requestFailed(defer, json);
                });

                if(returnPromise) {
                    return defer.promise;
                }
            };



            // remove existing friend
            var removeFriend =  function(obj, returnPromise) {
                var defer = returnPromise ? $q.defer(): false;
                var utId = obj.friend.getUtId();
                friendsHttpService.unFriend({friendId: obj.friend.getKey()}).then(function(json){
                    obj.friend.isLoading(false);
                    if (json.sucs === true) {
                        //Ringalert.show('Friend removed succesfully', 'success');
                        _clearUtId(utId, true, true);
                        //fFactory.friends.remove(utId); // remove from friend list
                        //Contacts.remove('utIds', utId);
                        obj.friend.updateUserObj( angular.extend({}, json, {frnS: AC.NOT_FRIEND}) );
                       if(returnPromise) {
                           defer.resolve(json);
                       }
                    } else {
                        _requestFailed(defer, json);
                    }
                }, function(json) {
                    obj.friend.isLoading(false);
                    _requestFailed(defer, json);
                });

                if(returnPromise) {
                    return defer.promise;
                }
            };


            // remove request incoming,outgoing both
            var rejectFriendRequest = function(obj, returnPromise) {
                var defer = returnPromise ? $q.defer(): false;
                var utId = obj.friend.getUtId();
                if(!utId) {
                }
                friendsHttpService.unFriend({friendId: obj.friend.getKey()}).then(function(json) {
                     obj.friend.isLoading(false);
                    if (json.sucs === true) {
                        //Ringalert.show('Rejected succesfully', 'success');
                        obj.friend.updateUserObj( angular.extend({}, json, {frnS: AC.NOT_FRIEND}) );
                        _clearUtId(utId, true, true);
                        //Contacts.remove('incomingUtIds', utId);
                        //fFactory.incomingFriends.remove(utId);
                        //Contacts.remove('outgoingUtIds', utId);
                        if(returnPromise) {
                            defer.resolve(json);
                        }
                    } else {
                        _requestFailed(defer, json);
                    }
                }, function(json) {
                     obj.friend.isLoading(false);
                     _requestFailed(defer, json);
                });

                if(returnPromise) {
                    return defer.promise;
                }
            };
            var blockFriend =  function(obj, returnPromise) {
                var defer = returnPromise ? $q.defer(): false;
                friendsHttpService.blockFriend(obj).then(function (json) {
                     obj.friend.isLoading(false);
                    if (json.sucs === true){
                        //Ringalert.show('Friend ' + (obj.bv === 0 ? 'blocked' : 'unblocked') + ' successfully', 'success');
                        obj.friend.setBlock(obj.block);
                    }
                    //else {
                        ////Ringalert.show('Friend ' + (obj.bv === 0 ? 'blocked' : 'unblocked') + ' successfully', 'error');
                    //}
                    if(returnPromise) {
                        defer.resolve();
                    }
                }, function() {
                    obj.friend.isLoading(false);
                    if(returnPromise) {
                        defer.reject();
                    }
                });

                if(returnPromise) {
                    return defer.promise;
                }
            };


            var getIds =  function() {
                var keys = '';
                for(var i = 0; i < fFactory.friends.size(); i++) {
                    keys = keys + ','.fFactory.friends[i].getKey();
                }
                return keys;
            };


            var searchContact = function(searchVal, friendOnly) {
                if (friendOnly) {
                    var defer = $q.defer();
                    friendsHttpService.searchContact(searchVal, friendOnly).then(function(json) {
                        if (json.sucs) {
                            defer.resolve();
                        } else {
                            defer.reject();
                        }
                    }, function() {
                        defer.reject();
                    }, function(json) {
                        // process json
                        if(json.sucs === true) {
                            for (var i = 0; i < json.searchedcontaclist.length; i++) {
                                Storage.setContact(json.searchedcontaclist[i].utId, json.searchedcontaclist[i]); // store in localStorage
                            }
                            _setContacts(json.searchedcontaclist);
                        } else {
                            defer.reject();
                        }
                    });

                    return defer.promise;

                } else {
                    return friendsHttpService.searchContact(searchVal, false);
                }

            };




            function addToUtIdList(which, utid) {
                switch(which) {
                    case 'utIds':
                        Contacts.utIds().save(utid, {frnS: AC.FRIEND});
                        break;
                    case 'incomingUtIds':
                        Contacts.incomingUtIds().save(utid, {frnS: AC.INCOMING_FRIEND});
                        break;
                    case 'outgoingUtIds':
                        Contacts.outgoingUtIds().save(utid, {frnS: AC.OUTGOING_FRIEND});
                        break;
                }
            }


            var fFactory = {
            // api data
                state : {
                    noFriends : false,
                    isFriendsLoading : false,
                    isUserFriendsLoading : false,
                    isRequestsLoading: false
                },
                getRequestCount: function() {
                    var count =  Contacts.incomingUtIds().length() + fFactory.incomingFriends.length();
                    return  count > 99 ? '99+' : count;
                },
                getPendingCount: function() {
                    return Contacts.outgoingUtIds().length() + fFactory.outgoingFriends.length();
                },
                totalFriends: function(friendType) {
                    if (friendType === 'userfriends' ) {
                        return userFriendsCount;
                    } else {
                        return  Contacts.utIds().length() + fFactory.friends.length();
                    }
                },
                totalUserFriends: function() {
                    return userFriendsCount;
                },
                friends : $$stackedMap.createNew(),
                userFriends : $$stackedMap.createNew(),
                incomingFriends : $$stackedMap.createNew(),
                outgoingFriends : $$stackedMap.createNew(),

            // api methods

                process : processResponse, // processes server response regarding contacts(add, updated, fetch etc)
                getFriends : getFriends, // returns friends, outgoing requests, incoming requests etc
                resetUserFriends : resetUserFriends, // emptyis contacts friendlist once use leaves that users profile page and friends tab
                getUserContacts : getUserContacts, // returns conjtact's friendlist
                getContactDetails : getContactDetails, // fetch given or 20 friends details
                getContactDetailsByUtIds : getContactDetailsByUtIds, // fetch contacts detail of given utIds
                removeFriend : removeFriend, // remove friend from contact list
                friendAction: friendAction, // add friend, accept friend request, reject friend request etc
                addFriend : addFriend, // send friend request
                rejectFriendRequest : rejectFriendRequest, // reject friend request
                acceptFriendRequest : acceptFriendRequest, // accept friend request
                searchContact: searchContact,
                initFriends : initFriends, // initialize friends factory
                addToUtIdList: addToUtIdList,
                // below apis may not be needed anymore
                blockFriend : blockFriend, // block friend
                getIds : getIds, // get friends uids comma seperated list
                getCurrentUser : function(){
                    return Auth.currentUser;
                },

                utIDsToByteArray : _utIDsToByteArray


            };


            $$connector.subscribe(fFactory.process, {
                action: [
                    OTYPES.TYPE_CONTACT_UTIDS,
                    //OTYPES.TYPE_CONTACT_LIST,
                    //OTYPES.TYPE_FRIEND_CONTACT_LIST,
                    OTYPES.TYPE_UPDATE_ADD_FRIEND,
                    OTYPES.TYPE_UPDATE_DELETE_FRIEND,
                    OTYPES.TYPE_UPDATE_ACCEPT_FRIEND,
                    //OTYPES.ACTION_FRIEND_SEARCH
                ],
                //scope: scope,
                callWithUnresolved : true
            });

            /// initialize friend list and people you may know
            function initFriends(force) {
                if (!initialized || force) {
                    initialized = true;
                    // restore Data from LocalStorage if any
                    Contacts.init();
                    // initial contact list utids request
                    friendsHttpService.getContactList() ;
                }

            }


            return fFactory;


		}
        //merging tool testing

})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

	angular
		.module('ringid.friend.friends_factory')
		.service('friendsHttpService', friendsHttpService);

		friendsHttpService.$inject = [ '$$connector', 'OPERATION_TYPES', 'APP_CONSTANTS'];
		function friendsHttpService( $$connector, OPERATION_TYPES, APP_CONSTANTS) {
			var self = this,
                firstRequestForContact = false,
				OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS,
                AC = APP_CONSTANTS,
                REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;


            /**
            * @api {request} /APIREQUEST/34 Search Contacts
            * @apiVersion 0.1.0
            * @apiDescription Search Contacts by Name, phone, email, ringid, location or all
            * @apiName SearchContacts
            * @apiGroup Friends
            *
            * @apiParam {Number=34} actn TYPE_CONTACT_SEARCH
            * @apiParam {Number{0..5}} scat=0 Search By Category(i.e. Name, Phone, Email, Roingid, Location or all)
            * @apiParam {String} Search Value. i.e. name or phone or email or ringid or location or anything
            */

			self.searchContact = function(obj, friendOnly) {

            //TYPE_SEARCH_BY_ALL : 0,
            //TYPE_SEARCH_BY_NAME : 1,
            //TYPE_SEARCH_BY_PHONE : 2,
            //TYPE_SEARCH_BY_EMAIL : 3,
            //TYPE_SEARCH_BY_RINGID : 4,
            //TYPE_SEARCH_BY_LOCATION : 5,
                var payload = {
					actn: friendOnly ? OTYPES.ACTION_FRIEND_SEARCH : OTYPES.TYPE_CONTACT_SEARCH,
                    scat: AC.TYPE_SEARCH_BY_ALL,
					schPm: obj.schPm.utf8Encode(),
                    st: obj.st || 0
				};
                var regexEmail = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i,
                    regexRingid =  /^10\d{6}/,
                    regexNumber = /^\d{5,}$/i;
                    //regexName = /^[A-Za-z\s]+$/i;

                if (regexEmail.test(obj.schPm)) {
                    // search by email
                    payload.scat = AC.TYPE_SEARCH_BY_EMAIL;
                }
                //else if (regexRingid.test(obj.schPm)) {
                    //// search by ringid
                    //payload.scat = AC.TYPE_SEARCH_BY_RINGID;
                //} else  if (regexNumber.test(obj.schPm)) {
                    //// search by mobile no
                    //payload.scat = AC.TYPE_SEARCH_BY_PHONE;
                //} else {
                    //// search by name
                    //payload.scat = AC.TYPE_SEARCH_BY_NAME;
                //}

				return $$connector.pull(payload, REQTYPE.REQUEST, true);
			};


            /**
            * @api {request} /APIREQUEST/29 Get Friends Utids
            * @apiVersion 0.1.0
            * @apiDescription This Requests list of Friends  utids for logged in user.
            * @apiName GetFriendsUtids
            * @apiGroup Friends
            *
            * @apiParam {Number=29} actn TYPE_CONTACT_UTIDS
            * @apiParam {Number} cut=-1 Undefined
            * @apiParam {Number} ut=-1 Update Time in Timestamp
            */

            self.getContactList = function(ut) {
				var payload = {
					actn: OTYPES.TYPE_CONTACT_UTIDS,
					cut: -1, //timestamp,
					ut: ut || -1 //timestamp
				};
                return $$connector.send(payload, REQTYPE.REQUEST);
            };



            /**
            * @api {request} /APIREQUEST/23 Get Friends Details
            * @apiVersion 0.1.0
            * @apiDescription This Requests Gets Friends  Details i.e. name, profileImage etc for logged in user.
            * @apiName GetFriendsDetails
            * @apiGroup Friends
            *
            * @apiParam {Number=23} actn TYPE_CONTACT_LIST
            * @apiParam {Number{0,1}} uo=0 First time request or not
            * @apiParam {Object[]} utIDs Byte array of utids. i.e. 10 utids becomes 10 * 8(per utid) no of bytes and so 80 items array. each item represends an 8 bit integer
            */
			self.getContactListDetails = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_CONTACT_LIST,
                    uo: obj.uo || false, // TRUE=only Update, FALSE=Fresh Details //firstRequestForContact ? true : false,
                    utIDs: obj.utIDs
				};
                return $$connector.pull(payload, REQTYPE.REQUEST, true);
			};

			self.getUserContacts = function(utId, st){
				var payload = {
					actn:OTYPES.TYPE_FRIEND_CONTACT_LIST,//107,
					utId:utId,
					st: st || 0
				};
				return $$connector.pull(payload, REQTYPE.REQUEST);

			};

            //self.getMutualContacts = function(uId) {
                //var params = {
                    //actn: REQPRF.FETCH_FRIEND_MUTUAL_FRIEND_LIST,
                    //uId: uId
                //};
                //return $$connector.request(params, REQTYPE.REQUEST)
            //}

            /**
            * @api {request} /APIREQUEST/128 Delete Friend
            * @apiVersion 0.1.0
            * @apiDescription This Requests To Unfriend an existing Friends.
            * @apiName FriendDelete
            * @apiGroup Friends
            *
            * @apiParam {Number=128} actn TYPE_DELETE_FRIEND
            * @apiParam {Number} friendId Friend uid
            */
			self.unFriend = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_DELETE_FRIEND,
					uId: obj.friendId
				};
				return $$connector.request(payload, REQTYPE.UPDATE, true);
			};


            /**
            * @api {request} /APIREQUEST/244 Change Friend Type
            * @apiVersion 0.1.0
            * @apiDescription This Requests To Change Friend Type from Full to Call&Chat only and viceversa
            * @apiName FriendChangeType
            * @apiGroup Friends
            *
            * @apiParam {Number=244} actn TYPE_ACTION_CHANGE_FRIEND_ACCESS
            * @apiParam {Number{1,2}} ct Contact type
            * @apiParam {Number} utId Friend utid
            */
			self.changeFriendType = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_ACTION_CHANGE_FRIEND_ACCESS,
					ct: obj.ct ,
                    utId: obj.utId
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};



            /**
            * @api {request} /APIREQUEST/127 New Friend Request
            * @apiVersion 0.1.0
            * @apiDescription This Sends New Friend request
            * @apiName FriendAdd
            * @apiGroup Friends
            *
            * @apiParam {Number=127} actn TYPE_ADD_FRIEND
            * @apiParam {Number{1,2}} ct Contact type
            * @apiParam {Number} uId Contact uId
            */
			self.sendFriendRequest = function(obj) {
				var payload = {
                    actn: OTYPES.TYPE_ADD_FRIEND,
                    uId: obj.uId
                    //ct: obj.ct
				};
                return $$connector.request(payload, REQTYPE.UPDATE, true);
			};




            /**
            * @api {request} /APIREQUEST/243 Block Unblock Friend
            * @apiVersion 0.1.0
            * @apiDescription This Sends Block Friend request
            * @apiName FriendBlockUnblock
            * @apiGroup Friends
            *
            * @apiParam {Number=243} actn TYPE_ACTION_BLOCK_UNBLOCK_FRIEND
            * @apiParam {Number} utid Friend utid
            * @apiParam {Boolean} block Friend Block/Unblock
            */
			self.blockFriend = function(obj) {
				//console.log(obj);
				var payload = {
					actn: OTYPES.TYPE_ACTION_BLOCK_UNBLOCK_FRIEND,
					idList: [
						obj.friend.getUtId()
					],
					bv: obj.bv
				};
				return $$connector.request(payload, REQTYPE.REQUEST);
			};

			self.saveCallPvcEdit = function (obj) {
				var payload = {
					actn:obj.actn,
					sn:obj.callsn,
					sv:obj.sv,
					utId:obj.friend.getUtId()
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.saveChatPvcEdit = function (obj) {
				var payload = {
					actn:obj.actn,
					sn:obj.chatsn,
					sv:obj.sv,
					utId:obj.friend.getUtId()
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.saveFeedPvcEdit = function (obj) {
				var payload = {
					actn:obj.actn,
					sn:obj.feedsn,
					sv:obj.sv,
					utId:obj.friend.getUtId()
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};




            /**
            * @api {request} /APIREQUEST/129 Friend Request Accept
            * @apiVersion 0.1.0
            * @apiDescription This Sends New Friend request Acceptance
            * @apiName FriendAccept
            * @apiGroup Friends
            *
            * @apiParam {Number=129} actn TYPE_ACCEPT_FRIEND
            * @apiParam {Number{1,2}} ct Contact type
            * @apiParam {Number} friendId Friend uid
            */
			self.acceptFriendRequest = function(obj) {
				//console.log(obj);
				var payload = {
                    actn: OTYPES.TYPE_ACCEPT_FRIEND,//129,
                    //ct: obj.contactType,
					utId:obj.utId
				};
				return $$connector.request(payload, REQTYPE.UPDATE, true);
			};




		}
})();

/* 
 * © Ipvision 
 */

(function() {
	'use strict';

	angular
		.module('ringid.friend', [
			'ringid.config',
			'ringid.friend.friends_factory',
		]);

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.friend')
        .directive('rgFriends', rgFriends);

    rgFriends.$inject = ['friendsFactory', '$ringhttp', '$compile',  '$routeParams', '$window', '$document', 'Contacts', 'APP_CONSTANTS'];
    function rgFriends(friendsFactory, $ringhttp, $compile,  $routeParams, $window, $document, Contacts, APP_CONSTANTS) { // jshint ignore:line


        FriendsController.$inject = ['$scope', '$attrs', 'profileFactory', '$document', 'InviteFactory', 'rgScrollbarService', 'Contacts', 'userFactory', '$$stackedMap', 'rgDropdownService', '$$connector', 'OPERATION_TYPES', 'Ringalert'];
        function FriendsController($scope, $attrs, profileFactory, $document, InviteFactory, rgScrollbarService, Contacts, User, $$stackedMap, rgDropdownService, $$connector, OPERATION_TYPES, Ringalert) { //jshint ignore:line
            var OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS,
                friendsFetchRetry = 0,
                firstContactsRequest = true,
                subscriptionKey,
                mutualFriends = [];

            $scope.isOwner = false;
            $scope.showMutual = false;
            $scope.showPending = false;
            $scope.friendName = '';

            $scope.state = {
                loading: false,
                noData: false
            };

            $scope.friends = friendsFactory.getFriends($scope.rgFriendsType);
            $scope.totalFriends = friendsFactory.totalFriends;
            $scope.getPendingCount  = friendsFactory.getPendingCount;
            $scope.toggleShowMutual = toggleShowMutual;
            $scope.toggleShowPending = toggleShowPending;
            $scope.loadMoreFriends = loadMoreFriends;
            $scope.getMutualFriend = getMutualFriend;
            $scope.searchContact = searchContact;

            $scope.showComingSoon = function($event) {
                $event.preventDefault();
                $event.stopPropagation();
                Ringalert.show('Coming soon', 'info');
            };


            function toggleShowMutual (bool) {
                $scope.showMutual = !!bool;
                if ($scope.showMutual) {
                    loadMutualFriends();
                }
                $scope.$rgDigest();
            }

            function toggleShowPending (bool) {
                $scope.showPending = !!bool;
                if ($scope.showPending) {
                    $scope.friends = friendsFactory.getFriends('outgoing');
                    toggleLoading(true);
                    friendsFactory.getContactDetails('outgoing').then(function() {
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                    });
                } else {
                    $scope.friends = friendsFactory.getFriends($scope.rgFriendsType);
                }
                $scope.$rgDigest();
            }


            function loadMutualFriends() {
                var friend;
                if (mutualFriends.length > 0) {
                    toggleLoading(true);
                    friendsFactory.getContactDetailsByUtIds(mutualFriends.splice(0, 10), true).then(function(json) {
                        if (json.sucs === true) {
                            for(var i=0;i< json.contacts.length;i++){
                                friend = User.create(json.contacts[i]);
                                $scope.friends.save(friend.getKey(), friend);
                            }
                        }
                        toggleLoading(false);
                    }, function(json) {
                        if (json.sucs === false && json.rc === 1111) {
                            loadMutualFriends();
                        } else {
                            toggleLoading(false);
                        }
                    });
                }
            }



            function toggleLoading(bool) {
                $scope.state.loading = !!bool;
                if (!bool) {
                    rgScrollbarService.recalculate($scope);
                    //$scope.friends = friendsFactory.getFriends($scope.rgFriendsType);
                }
                if ($scope.state.loading) {
                } else {
                    $scope.state.noData = ($scope.friends.length() === 0 && Contacts.utIds().length() === 0);
                }
                $scope.$rgDigest();
            }


            function searchContact() {
                if (($scope.rgFriendsType === 'friends' ||  $scope.rgFriendsType === 'friendslist') && $scope.friendName && $scope.friendName.length > 0) {
                    toggleLoading(true);
                    friendsFactory.searchContact({schPm: $scope.friendName}, true).then(function() {
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                    });
                }
            }

            function loadMoreFriends(force) {
                var whatToCall, param;
                // no request in progress
                if ($scope.showMutual) {
                    loadMutualFriends();
                } else if ($scope.showPending) {
                    toggleLoading(true);
                    friendsFactory.getContactDetails('outgoing').then(function() {
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                    });
                } else if (force || (!$scope.state.loading && $scope.friends.length() !== $scope.totalFriends($scope.rgFriendsType)) )  {
                    toggleLoading(true);
                    if ($scope.rgFriendsType === 'userfriends') {
                        whatToCall = friendsFactory.getUserContacts;
                        param = $scope.profileObj.getUtId();
                    } else {
                        whatToCall = friendsFactory.getContactDetails;
                    }
                    whatToCall(param).then(function() {
                        //$scope.friends = friendsFactory.getFriends($scope.rgFriendsType);
                        if ($scope.friends.length() < 20 && $scope.friends.length() < $scope.totalFriends($scope.rgFriendsType)) {
                            toggleLoading(false);
                            loadMoreFriends();
                        } else {
                            toggleLoading(false);
                        }
                    }, function(json) {
                        if (json.sucs === false && json.rc === 1111) {
                            loadMoreFriends(force);
                        } else if ($scope.rgFriendsType === 'friendslist') {
                            if (friendsFetchRetry < 5) {
                                friendsFetchRetry++;
                                setTimeout(function() {
                                    loadMoreFriends(force);
                                }, 2000);
                            } else {
                                toggleLoading(false);
                            }
                        } else {
                            toggleLoading(false);

                        }
                    });

                    // in case the promise never resolves or rejects
                    //timeOut = setTimeout(toggleLoading, 5000);
                }
            }

            function getMutualFriend(user) {
                return{
                    data: function() {
                        return {
                            target: user
                        };
                    },
                    promise: InviteFactory.getMutualFriend(user)

                };
            }



            function setDropdown() {
                // settings dropdown data
                //$scope.ddHtml = 'pages/dropdowns/friend-settings-dropdown.html';
                $scope.ddTemplate =
                    '<div class="action friend-settings-dropdown">' +
                        '<a  ng-if="ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'unfriend\', friend: ddControl, event: $event})" href="#"> <span class="icon-into-border f-Block"></span><span class="txt">{{consType.unfriend}}</span></a>' +
                        '<a  ng-if="ddControl.isBlocked()===0 && !ddControl.isCurrentUser() && ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'block\', friend: ddControl, event:$event})" class="border-0" href="#"><span class="icon-block"></span><span class="txt">{{consType.block}}</span></a>' +
                        '<a  ng-if="ddControl.isBlocked()===1 && !ddControl.isCurrentUser() && ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'unblock\', friend: ddControl, event:$event})" class="border-0" href="#"><span class="icon-right f-Block"></span><span class="txt">{{consType.unblock}}</span></a>' +
                    '</div>';
                $scope.ddAction = function(actionObj) {
                    if (!actionObj.friend.isLoading()) {
                        friendsFactory.friendAction(actionObj, true).then(function() {
                            $scope.$rgDigest();
                        }, function() {
                            $scope.$rgDigest();
                        });
                        rgDropdownService.close(actionObj.event);
                    }
                };


                $scope.showBackKey = 0;
                $scope.showBack = function(key, event) {
                    var isAnchor = event.target.getAttribute('data-is-anchor');
                    if (!isAnchor) {
                        $scope.showBackKey = key;
                        event.preventDefault();
                        event.stopPropagation();
                        $scope.$rgDigest();
                    }
                };
            }



            function activate() {
                subscriptionKey = $$connector.subscribe(function(json) {
                    switch(json.actn) {
                        case OTYPES.TYPE_CONTACT_UTIDS:
                            if ( ($scope.rgFriendsType === 'friends' || $scope.rgFriendsType === 'friendslist') && firstContactsRequest ) {
                                firstContactsRequest = false;
                                setTimeout(function() {
                                    if (Contacts.utIds().length() > 0 && $scope.friends.length() < 20  ) {
                                        loadMoreFriends(true);
                                    }
                                    $scope.state.noData = ($scope.friends.length() === 0 && Contacts.utIds().length() === 0);
                                }, 1000);
                            }
                            break;
                        default:
                            toggleLoading(false);

                    }
                }, {
                    action: [
                        OTYPES.TYPE_CONTACT_UTIDS,
                        OTYPES.TYPE_UPDATE_ADD_FRIEND,
                        OTYPES.TYPE_UPDATE_DELETE_FRIEND
                    ],
                    callWithUnresolved : true
                });

                switch($scope.rgFriendsType) {
                    case 'friendslist':
                        //toggleLoading(true);
                        break;
                    case 'friends':
                        friendsFactory.initFriends();
                        $scope.isOwner = true;
                        $scope.pendingRequests = friendsFactory.getFriends('outgoing');
                        setDropdown();
                        break;
                    case 'userfriends':
                        setDropdown();
                        $scope.totalUserFriends = friendsFactory.totalUserFriends;
                        $scope.profileObj = profileFactory.getProfile($routeParams.uId); //.commonFriends();
                        loadMoreFriends(true);

                        // fetch mutual friend utid list
                        InviteFactory.getMutualFriend($scope.profileObj).then(function(json) {
                            if (json.sucs === true) {
                                $scope.profileObj.updateUserObj({nmf: json.mfIDs.length});
                                mutualFriends = json.mfIDs;
                                $scope.$rgDigest();
                            }
                        });
                        break;
                    default:
                }


            }

            activate();

            $scope.$on('$destroy', function() {
                // empty friend list of other user when leaving friends page of other user
                if ($scope.rgFriendsType === 'userfriends') {
                    friendsFactory.resetUserFriends();
                }
                 $$connector.unsubscribe(subscriptionKey);
            });



        }

        function linkFunc(scope, element, attrs) {
            var utids;

            $ringhttp.get(attrs.rgFriendsTpl).success(function(template) {
               element.append( $compile(template)(scope) );
                scope.$rgDigest();
            });

            function loadMore() {
                if ( ($window.innerHeight + $window.scrollY) >= $document[0].body.offsetHeight ) {
                    scope.loadMoreFriends();
                }
            }

            if (scope.rgFriendsType === 'friends' || scope.rgFriendsType === 'userfriends') {
                angular.element($window).on('scroll', loadMore);
            }


            scope.$on('$destroy', function() {

                switch(scope.rgFriendsType) {
                    case 'friends':
                        // put outgoing utids back to utid list and reset outgoing friends
                        utids =  friendsFactory.outgoingFriends.keys();
                        for(var i = 0; i < utids.length; i++) {
                             Contacts.add('outgoingUtIds', utids[i], {frnS: APP_CONSTANTS.INCOMING_FRIEND});
                        }
                        friendsFactory.outgoingFriends.reset();
                    case 'userFriends':
                        angular.element($window).off('scroll', loadMore);
                }


            });

        }

        return {
            restrict: 'AE',
            scope: {
                rgFriendsType: '@'
            },
            controller: FriendsController,
            link: linkFunc
        };

    }
})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.friend')
        .directive('rgRequests', rgRequests);

    rgRequests.$inject = ['friendsFactory', '$compile',  '$routeParams', '$window', '$document', '$ringhttp'];
    function rgRequests(friendsFactory,  $compile,  $routeParams, $window, $document, $ringhttp) { // jshint ignore:line

        RequestsController.$inject = ['$scope', 'profileFactory',  'InviteFactory', 'rgScrollbarService', 'Contacts', 'OPERATION_TYPES', '$$connector', 'userFactory', 'Ringalert', 'SystemEvents'];
        function RequestsController($scope, profileFactory,  InviteFactory, rgScrollbarService, Contacts, OPERATION_TYPES, $$connector, userFactory, Ringalert, SystemEvents) { //jshint ignore:line
            var OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS,
                loadCount = parseInt($scope.loadCount),
                subscriptionKey;
                //intervalCount = 0,
                //intervalTrack;

            $scope.state = {
                loading: false,
                noMoreData: false,
            };

            $scope.requests = friendsFactory.getFriends('incoming');
            $scope.getRequestCount = friendsFactory.getRequestCount;

            $scope.friendAction = friendAction;
            $scope.loadMoreRequests = loadMoreRequests;
            $scope.getMutualFriend = getMutualFriend;




            function friendAction(actionObj) {
                if (!actionObj.friend.isLoading()) {
                    friendsFactory.friendAction(actionObj, true).then(function() {
                        //$scope.requests = friendsFactory.getFriends('incoming');
                        if ($scope.requests.length() < loadCount) {
                            loadMoreRequests();
                        }
                        $scope.$rgDigest();
                    }, function() {
                        //$scope.requests = friendsFactory.getFriends('incoming');
                        if ($scope.requests.length() < loadCount) {
                            loadMoreRequests();
                        }
                        $scope.$rgDigest();
                    });
                }
            }

            function toggleLoading(bool) {
                $scope.state.loading = bool;
                if (!bool) {
                    $scope.state.noMoreData = (Contacts.incomingUtIds().length() === 0);
                    rgScrollbarService.recalculate($scope);
                    $scope.$emit(SystemEvents.FEED.HEIGHT);
                }
                $scope.$rgDigest();
            }


            function loadMoreRequests(force) { // jshint ignore:line
                // no request in progress
                if (force || (!$scope.state.noMoreData && !$scope.state.loading)) {
                    toggleLoading(true);
                    friendsFactory.getContactDetails('incoming', loadCount).then(function() {
                        //$scope.requests = friendsFactory.getFriends('incoming');
                        toggleLoading(false);
                    }, function(json) {
                        if (json.sucs === false && json.rc === 1111) {
                            loadMoreRequests(true);
                        } else {
                            toggleLoading(false);
                        }
                    });

                }
            }

            function getMutualFriend(user) { //jshint ignore:line
                return{
                    data: function() {
                        return {
                            target: user
                        };
                    },
                    promise: InviteFactory.getMutualFriend(user)

                };
            }


            function activate() {

                if (loadCount > 20) {
                    // a loose condition to check if its see all or just the dropdown
                    $scope.$emit(SystemEvents.FEED.HEIGHT);
                }
                if (Contacts.incomingUtIds().length() > 0 && $scope.requests.length() < loadCount) {
                    loadMoreRequests(true);
                }

                // initialization everytime dropdown opens
                subscriptionKey = $$connector.subscribe(function(json) {
                    switch(json.actn) {
                        case OTYPES.TYPE_CONTACT_UTIDS:
                            if (Contacts.incomingUtIds().length() > 0 && $scope.requests.length() < loadCount) {
                                loadMoreRequests(true);
                            }
                            break;
                        default:
                            toggleLoading(false);
                    }

                }, {
                    action: [
                        OTYPES.TYPE_CONTACT_UTIDS,
                        OTYPES.TYPE_UPDATE_ADD_FRIEND,
                        OTYPES.TYPE_UPDATE_DELETE_FRIEND
                    ]
                });
            }

            activate();


            $scope.$on('$destroy', function() {
                 $$connector.unsubscribe(subscriptionKey);
            });


        }


        function linkFunc(scope, element, attr) {
            var templateUrl =  attr.templateUrl ? attr.templateUrl : 'pages/dropdowns/friend-request-dropdown.html';

            $ringhttp.get(templateUrl).success(function(template) {
                element.append($compile(template)(scope));
                scope.$rgDigest();
            });

        }

        return {
            restrict: 'AE',
            //templateUrl: 'pages/dropdowns/friend-request-dropdown.html', // IMPORTANT this template is preloaded from auth factory
            //template:
                    //'<li  rg-dropdown="dropdown()" dd-html="header.freq.ddHtml"' +
                         //' dd-control="header.freq.ddControl" dd-action="header.freq.ddAction"' +
                         //' dd-opened="header.freq.ddOpened()" dd-before-close="header.freq.ddBeforeClose()"' +
                         //' ng-class="{ active : header.getActiveMenu() == \'friend_request\' }" >' +
                        //' <a  class="showpointer" title="Friend Request">' +
                            //' <div class="tm-ico  icon-contact-b">' +
                                //' <div ng-bind="header.freq.ddControl.friendsFactory.getFriends(\'incoming\').length()" ng-show="header.freq.ddControl.friendsFactory.getFriends(\'incoming\').length() > 0"' +
                                     //' class="ng-cloak counter-not"></div>' +
                            //' </div>' +
                        //' </a>'+
                    //' </li>',
            scope: {
                loadOnScroll: '@',
                loadCount: '@',
                templateUrl: '@'
            },
            link: linkFunc,
            controller: RequestsController
            //transclude: true
        };

    }
})();

/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
 * * Copyright : Ipvision
 * _._._._._._._._._._._._._._._._._._._._._.*/

(function() {
    'use strict';

    angular
            .module('ringid.common.rghashtag_directive', ['ringid.common.services', 'ringid.common.factories'])
            .service('rgHashtagService', rgHashtagService)
            .directive('rgHashtag', rgHashtag);


		rgHashtagService.$inject = ['GlobalEvents'];
		function rgHashtagService(GlobalEvents) {
			var self = this, // jshint ignore:line
                _scope = false,
                _template = false;

			self.close= function(clearInput) {
                if (_template) {
                    _template.style.display = 'none';
                    _scope.resetTag(clearInput);
                    _scope.$rgDigest();
                    _template = false;
                    _scope = false;

                    GlobalEvents.unbindHandler('document', 'click', self.close);
                }
			};
			self.open= function(template, scope) {
                _template = template;
                _scope = scope;
                _template.style.display = 'block';
                GlobalEvents.bindHandler('document', 'click', self.close);
			};

		}

    rgHashtag.$inject = ['$compile', 'fileUploadService', 'Media', 'rgHashtagService', 'SystemEvents', '$rootScope', 'rgScrollbarService'];
    function rgHashtag($compile, fileUploadService, Media, rgHashtagService, SystemEvents, $rootScope, rgScrollbarService) { // jshint ignore:line


        var linkFunc = function(scope, element) {

            var tagDropdownElement,
                searchParam,
                hashTagTimeout,
                tagInputElement;

            scope.selectedTag = -1;
            // add hashtag
            scope.tagList = fileUploadService.tagList;
            scope.tagSuggestions = [];
            scope.tagLoading = false;
            tagInputElement = element[0].parentNode.querySelector('textarea#add-hashtag');
            tagDropdownElement = element[0].parentNode.querySelector('div#hashtag-dropdown');
            tagInputElement.addEventListener('keyup', handleHashTag);
            tagInputElement.addEventListener('keydown', handleEnter);

            scope.removeTag = function(event, index) {
                event.preventDefault();
                fileUploadService.tagList.splice(index, 1);
                //if (scope.tagList.length === 0) {
                //tagDropdownElement.style.display = 'none';
                //}

                scope.$rgDigest();
            };


            scope.addHashTag = function(tag) {
                scope.tagList.push(tag);
                rgHashtagService.close(true);
            };


            scope.resetTag = function (clearInput) {
                fileUploadService.tagSuggestions = [];
                scope.selectedTag = -1;
                if (clearInput) {
                    tagInputElement.value =  '';
                }
                scope.$rgDigest();
            };

            scope.gotMedias = function() {
                return fileUploadService.audioFiles.length > 0 ||  fileUploadService.videoFiles.length > 0;
            };


            scope.$on(SystemEvents.FILE_UPLOAD.UPLOADS_POSTED, function() {
                scope.tagList = [];
                scope.resetTag(true);
            });

            function selectTag(moveUp) {
                if (moveUp) {
                    scope.selectedTag = scope.selectedTag <= 0 ? 0 : scope.selectedTag - 1;
                } else {
                    scope.selectedTag = scope.selectedTag+1 >= scope.tagSuggestions.length ? scope.tagSuggestions.length - 1: scope.selectedTag + 1;
                }
                if (scope.selectedTag >= 0) {
                    tagInputElement.value = scope.tagSuggestions[scope.selectedTag].sk;
                }
                rgScrollbarService.scrollTo(scope, (scope.selectedTag / scope.tagSuggestions.length * 100));
                scope.$rgDigest();

            }


            function handleEnter(event) {
                var key = event.keyCode || event.which,
                    tagValue = tagInputElement.value.trim();

                if (key === 27 || key === 13 || key === 10) {
                    event.preventDefault();
                    event.stopPropagation();

                    if (tagValue.length > 0) {
                        if (scope.selectedTag > -1) {
                            scope.addHashTag(scope.tagSuggestions[scope.selectedTag]);
                        } else {
                            // add hashtag
                            scope.addHashTag({
                                sk: tagValue,
                                ukey: 0
                            });
                        }
                        rgHashtagService.close();
                        scope.tagLoading = false;
                    } else {
                        tagInputElement.value = '';
                    }
                }
            }


            function handleHashTag(event) {
                var key = event.keyCode || event.which,
                    tagValue = tagInputElement.value.trim();

                if (key === 38 && tagValue.length > 0) { // up key
                    // move tag selection up
                    selectTag(true);
                } else if (key === 40 && tagValue.length > 0) {
                    // move tag selection down
                    selectTag(false);
                } else if (key === 27 || key === 13 || key === 10) {
                    // escape or enter pressed. add hashtag
                    event.preventDefault();
                    //if (tagValue.length > 0) {
                        //if (scope.selectedTag > -1) {
                            //scope.addHashTag(scope.tagSuggestions[scope.selectedTag]);
                        //} else {
                            //// add hashtag
                            //scope.addHashTag({
                                //sk: tagValue,
                                //ukey: 0
                            //});
                        //}
                        //rgHashtagService.close();
                        //scope.tagLoading = false;
                    //} else {
                        //tagInputElement.value = '';
                    //}
                } else if (tagValue.length > 0) {
                    //fetchTags();
                    //clearTimeout(hashTagTimeout);
                    hashTagTimeout = setTimeout(fetchTags, 200);
                } else if (tagValue.length === 0) {
                    clearTimeout(hashTagTimeout);
                    rgHashtagService.close();
                }
                scope.$rgDigest();
            }

            function fetchTags() {
                var tagValue = tagInputElement.value.trim();
                // pull tag suggestion and show in dropdown
                if (tagValue.length > 0 && searchParam !== tagValue) {
                    rgHashtagService.open(tagDropdownElement, scope);
                    searchParam = tagValue;
                    scope.tagLoading = true;
                    scope.selectedTag = -1;
                    scope.tagSuggestions = [];
                    Media.fetchHashtagSuggestion(tagValue).then(function(json) {
                        if (scope.tagLoading) {
                            clearTimeout(hashTagTimeout);
                            scope.tagLoading = false;
                            if (json.sucs === true) {
                                scope.tagSuggestions = json.sgstn;
                            } else {
                                rgHashtagService.close();
                            }
                            scope.$rgDigest();
                        }
                    });

                } else {
                    clearTimeout(hashTagTimeout);
                }
                scope.$rgDigest();
            }


            scope.$on('$destroy', function() {
                tagInputElement.removeEventListener('keyup', handleHashTag);
                tagInputElement.removeEventListener('keypress', handleEnter);
            });




        };  // LINK function END

        return {
            restrict: 'E',
            link: linkFunc,
            template:
                    '<div ng-show="gotMedias()">' +
                        '<div >' +
                            '<ul class="tag-fnd-lst">' +
                                '<li ng-repeat="tag in tagList" ><span class="tag-title" ng-bind="tag.sk" ></span>&nbsp;<span class="icon-close f-11" rg-click="removeTag($event, $index)"></span></li>' +
                            '</ul>' +
                        '</div>'+
                    '</div>' +
                    '<div  ng-show="ddControl.uploadWhat !== \'image\' && getMedia(true).length > 0"  class="b-t-b"><span class="top-r float-left" data-tool="Type something for tags suggestion OR press enter to add new tag"><img class="p-10" src="images/view.png"/></span><textarea id="add-hashtag" ng-model="tagName" type="text"  class="media-tags float-left"  placeholder="Add Hashtag" ></textarea><div class="clear"></div></div>' +
                    '<div id="hashtag-dropdown" class="m-s-height tag-dd active" style="display:none;">' +
                        '<div class="loader-s" ng-show="tagLoading">' +
                            '<div class="lr1"></div>' +
                            '<div class="lr2"></div>' +
                            '<div class="lr3"></div>' +
                        '</div>' +
                        '<div class="ringscroll" style="position:relative;width:auto;overflow:hidden;height:100%;">' +
                            '<ul class="m-s-result" rg-scrollbar="true" style="overflow: hidden;">' +
                                '<li ng-repeat="tag in tagSuggestions track by tag.ukey" ng-class="{active:$index==selectedTag}"  class="m-t-icon" rg-click="addHashTag({sk: tag.sk, ukey: tag.ukey})">' +
                                    '<a href="javascript:void(0)" title="{{tag.sk}}" ng-bind="tag.sk" > abc</a>' +
                                '</li>' +
                            '</ul>' +
                        '</div>' +
                    '</div>'
        };
    }

})();

/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
 * * Copyright : Ipvision
 * _._._._._._._._._._._._._._._._._._._._._.*/

(function() {
    'use strict';

    angular
            .module('ringid.common.rgupload_directive', [
                'ringid.common.rghashtag_directive',
                'ringid.common.services',
                'ringid.common.factories'])
            .directive('rgUpload', rgUpload);

    rgUpload.$inject = ['$compile', 'fileUploadService', 'Media'];
    function rgUpload($compile, fileUploadService, Media) { // jshint ignore:line

        UploadController.$inject = ['Auth', '$scope', 'mediaMetadata', 'imageQuality', 'APP_CONSTANTS', 'SystemEvents', 'Ringalert', '$$q', '$rootScope', 'rgDropdownService'];
        function UploadController(Auth, $scope, mediaMetadata, imageQuality, APP_CONSTANTS, SystemEvents, Ringalert, $q, $rootScope, rgDropdownService) { // jshint ignore:line
            var AC = APP_CONSTANTS,
                totalFileSize = 0;


            $scope.uploadProgress = fileUploadService.uploadProgress;
            $scope.previewStartAt = 0;
            //$scope.statusMediaCount = fileUploadService.statusMediaCount;
            $scope.tagList = fileUploadService.tagList;

            // album list dropdown
            $scope.ddHtml = 'pages/dropdowns/album-dropdown.html';
            $scope.ddControl = {
                Media: Media,
                uploadWhat: 'image',
                createAlbum: false,
                albumName: '',
                selectedAlbum: 0
            };
            //$scope.ddAction = selectAlbum;

            $scope.selectAlbum = function() {
                return {
                        data: function () {
                            return {
                                from: 'feedpost',
                                mediaType: $scope.ddControl.uploadWhat
                            };
                        },
                    };
            };



            $scope.getMedia = getMedia;
            $scope.removeMedia = removeMedia;
            $scope.loadPrevious = loadPrevious;
            $scope.loadNext = loadNext;

            $scope.disableUpload = disableUpload;

            $scope.uploadAudio = uploadAudio;
            $scope.uploadVideo = uploadVideo;
            $scope.uploadImage = uploadImage;


            function resetUpload() {
                totalFileSize = 0;
                $scope.previewStartAt = 0;
                $scope.ddControl.uploadWhat = 'image';
                $scope.ddControl.createAlbum = false;
                $scope.ddControl.albumName = '';
                $scope.ddControl.selectedAlbum = 0;
                fileUploadService.resetUpload();
                //$scope.tagList = fileUploadService.tagList;
                $scope.$rgDigest();
            }


            //$rootScope.$on(SystemEvents.FILE_UPLOAD.QUEUE_COMPLETE, resetUpload);
            $scope.$on(SystemEvents.FILE_UPLOAD.UPLOADS_POSTED, resetUpload);

            // PREVIEW RELATED CODE
            function getMedia(returnAll) { // jshint ignore:line
                if (returnAll) {
                    return fileUploadService[$scope.ddControl.uploadWhat + 'Files'];
                } else {
                    return fileUploadService[$scope.ddControl.uploadWhat + 'Files'].slice($scope.previewStartAt, $scope.previewStartAt + 3);
                }
            }

            function removeMedia(index) { // jshint ignore:line
                // abort upload request if queued or remove from queuelist
                if (fileUploadService[$scope.ddControl.uploadWhat + 'Files'][index].getQueued()) {
                    fileUploadService[$scope.ddControl.uploadWhat + 'Files'][index].cancelUpload();
                } else {
                    fileUploadService[$scope.ddControl.uploadWhat + 'Files'].splice($scope.previewStartAt + index, 1);
                }

                if (fileUploadService[$scope.ddControl.uploadWhat + 'Files'].length === 0) { // all images removed from upload queue
                    resetUpload();
                } else {
                    $scope.previewStartAt = $scope.previewStartAt > 0 ? $scope.previewStartAt - 1 : $scope.previewStartAt;
                }
            }

            function loadPrevious() { // jshint ignore:line
                $scope.previewStartAt = ($scope.previewStartAt - 3 > 0) ? $scope.previewStartAt - 3 : 0;
            }

            function loadNext() { // jshint ignore:line
                $scope.previewStartAt = ($scope.previewStartAt + 3 <= fileUploadService[$scope.ddControl.uploadWhat + 'Files'].length - 4) ?
                $scope.previewStartAt + 3 : fileUploadService[$scope.ddControl.uploadWhat + 'Files'].length - 3;

            }
            // END PREVIEW CODE


            function disableUpload(uploadType) {
                //if ($scope.uploadProgress) {
                    //if ($scope.ddControl.uploadWhat !== uploadType) {
                        //return false;
                    //} else {
                        //return false;
                    //}
                //} else {
                    if (fileUploadService[$scope.ddControl.uploadWhat + 'Files'].length > 0) {
                        if ($scope.ddControl.uploadWhat === uploadType) {
                            return false;
                        } else {
                            return true;
                        }
                    } else {
                        return false;
                    }
                    //return ($scope.ddControl.uploadWhat === uploadType);
                    //if ($scope.ddControl.uploadWhat !== uploadType && getMedia(true).length > 0) {
                        //return true;
                    //} else {
                        //return false;
                    //}
                //}

                $scope.$rgDigest();

            }

            function uploadAudio() { // jshint ignore:line

                fileUploadService.videoFiles = [];
                fileUploadService.imageFiles = [];
                var i,
                        l,
                        input = this; // jshint ignore:line

                // upload size limit check
                for(i = 0; i < input.files.length; i++) {
                    totalFileSize += input.files[i].size;
                }

                if ((input.files.length + fileUploadService.audioFiles.length) > AC.AUDIO_UPLOAD_LIMIT) {
                    Ringalert.show('Maximum upload limit ' + AC.AUDIO_UPLOAD_LIMIT, 'warning');
                } else if ( totalFileSize > AC.MEDIA_UPLOAD_SIZE_LIMIT ) {
                    Ringalert.show('Maximum allowed total upload files size 500MB!', 'warning');
                    // remove new uploaded file sizes
                    for(i = 0; i < input.files.length; i++) {
                        totalFileSize -= input.files[i].size;
                    }
                } else {

                    if ($scope.hasOwnProperty('rgUploadAction')) {
                        $scope.rgUploadAction('audio');
                    }
                    // if fresh new upload
                    if (fileUploadService.audioFiles.length === 0) {
                        $scope.ddControl.uploadWhat = 'audio';
                        //$scope.uploadProgress = true;
                        $scope.ddControl.selectedAlbum = null;
                        fileUploadService.setUploadAlbum(-1);
                    }
                    //for every file.push to upload Queue
                    var startIndex = fileUploadService.audioFiles.length;
                    for (i = 0, l = input.files.length; i < l; i++) {
                        if (validateUpload('audio', input.files[i])) {
                            fileUploadService.queueFile('audio', input.files[i]);
                        } else {
                            Ringalert.show('Invalid Audio File: ' + input.files[i].name, 'error');
                        }
                    }
                    $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.QUEUE_START);
                    // now upload images queue
                    fileUploadService.uploadQueue('audio', startIndex);
                }
                input.value = null;
                $scope.$rgDigest();
            }

            function uploadVideo() {  // jshint ignore:line

                var i, l,
                        input = this; // jshint ignore:line
                //thumbsUploadPromises = [];

                // upload size limit check
                for(i = 0; i < input.files.length; i++) {
                    totalFileSize += input.files[i].size;
                }

                if ((input.files.length + fileUploadService.videoFiles.length) > AC.VIDEO_UPLOAD_LIMIT) {
                    Ringalert.show('Maximum upload limit ' + AC.VIDEO_UPLOAD_LIMIT, 'warning');
                } else if ( totalFileSize > AC.MEDIA_UPLOAD_SIZE_LIMIT ) {
                    Ringalert.show('Maximum allowed total upload files size 500MB!', 'warning');
                    // remove new uploaded file sizes
                    for(i = 0; i < input.files.length; i++) {
                        totalFileSize -= input.files[i].size;
                    }
                } else {

                    // if fresh new upload
                    if (fileUploadService.videoFiles.length === 0) {
                        $scope.ddControl.uploadWhat = 'video';
                        //$scope.uploadProgress = true;
                        $scope.ddControl.selectedAlbum = null;
                        fileUploadService.setUploadAlbum(-1);
                    }
                    if ($scope.hasOwnProperty('rgUploadAction')) {
                        $scope.rgUploadAction('video');
                    }
                    //for every file.push to upload Queue
                    var startIndex = fileUploadService.videoFiles.length;
                    for (i = 0, l = input.files.length; i < l; i++) {
                        if (validateUpload('video', input.files[i])) {
                            fileUploadService.queueFile('video', input.files[i]);
                        } else {
                            Ringalert.show('Invalid Video File: ' + input.files[i].name, 'error');
                        }
                    }


                    // now upload videos queue
                    fileUploadService.uploadQueue('video', startIndex);
                    $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.QUEUE_START);
                }
                input.value = null;
                $scope.$rgDigest();
            }


            function uploadImage() { // jshint ignore:line
                $scope.ddControl.uploadWhat = 'image';

                var input = this; // jshint ignore:line
                switch ($scope.rgUploadType) {
                    case 'coverphoto':
                    case 'profilephoto':
                    case 'tagchatimage':
                    case 'chatimage':
                        if (validateUpload('image', input.files[0])) {
                            var uploadFile = fileUploadService.queueFile($scope.rgUploadType, input.files[0]);
                            if ($scope.hasOwnProperty('rgUploadAction')) {
                                $scope.rgUploadAction()({action: $scope.rgUploadType, uploadFile: uploadFile});
                            }

                        } else {
                            Ringalert.show('Invalid Image File: ' + input.files[0].name, 'error');
                        }
                        input.value = null;
                        break;
                    case 'status':
                        // check maximum no of files upload
                        if (input.files.length + fileUploadService.imageFiles.length > AC.IMAGE_UPLOAD_LIMIT) {
                            Ringalert.show('Maximum upload limit ' + AC.IMAGE_UPLOAD_LIMIT, 'warning');
                            break;
                        }

                        var startIndex = fileUploadService.imageFiles.length;
                        for (var i = 0; i < input.files.length; i++) {
                            //reduce size if necessary and put to queue for upload
                            if (validateUpload('image', input.files[i])) {
                                fileUploadService.queueFile('image', input.files[i]);
                            } else {
                                Ringalert.show('Invalid Image File: ' + input.files[i].name, 'error');
                            }
                        }

                        $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.QUEUE_START);
                        // now upload images queue
                        fileUploadService.uploadQueue('image', startIndex);
                        input.value = null;
                        break;
                }
                $scope.$rgDigest();
                // empty element
            }

            function validateUpload(fileType, inputFile) {
                var regEx;
                switch (fileType) {
                    case 'image':
                        regEx = new RegExp('image\/*');
                        break;
                    case 'audio':
                        regEx = new RegExp('audio\/mp3*');
                        break;
                    case 'video':
                        regEx = new RegExp('video\/mp4');
                        break;
                    case 'default':

                }

                return regEx.test(inputFile.type);
            }


            $scope.$on('$destroy', function() {
                var i, l;
                switch ($scope.rgUploadType) {
                    case 'coverphoto':
                        if (fileUploadService.coverImageFile) {
                            fileUploadService.coverImageFile.cancelUpload();
                            fileUploadService.coverImageFiles = null;
                        }
                        break;
                    case 'profilephoto':
                        if (fileUploadService.profileImageFile) {
                            fileUploadService.profileImageFile.cancelUpload();
                            fileUploadService.profileImageFiles = null;
                        }
                        break;
                    case 'tagchatimage':
                    case 'chatimage':
                        if (fileUploadService.chatImageFiles[$scope.rgUploadBoxValue]) {
                            fileUploadService.chatImageFiles[$scope.rgUploadBoxValue].cancelUpload();
                            delete  fileUploadService.chatImageFiles[$scope.rgUploadBoxValue];
                        }
                        break;
                    case 'status':
                        if (fileUploadService.imageFiles.length > 0) {
                            for (i = 0, l = fileUploadService.imageFiles.length; i < l; i++) {
                                fileUploadService.imageFiles[i].cancelUpload();
                            }
                            fileUploadService.imageFiles = [];
                        } else if (fileUploadService.videoFiles.length > 0) {
                            for (i = 0, l = fileUploadService.videoFiles.length; i < l; i++) {
                                fileUploadService.videoFiles[i].cancelUpload();
                            }
                            fileUploadService.videoFiles = [];
                        } else if (fileUploadService.audioFiles.length > 0) {
                            for (i = 0, l = fileUploadService.audioFiles.length; i < l; i++) {
                                fileUploadService.audioFiles[i].cancelUpload();
                            }
                            fileUploadService.audioFiles = [];
                        }
                        break;
                }
            });

        }

        var linkFunc = function(scope, element, attr) {

            var
                //tagDropdownElement,
                //hashTagTimeout,
                uploadType = attr.rgUploadType,
                    //tagInputElement,
                    imgPreviewElem,
                    template = '',
                    inputFile = '',
                    inputVideo,
                    inputAudio,
                    imgPreviewTmpl =
                    '<div class="to-add" ng-show="ddControl.uploadWhat !== \'image\' && getMedia(true).length > 0" >' +
                        //'<span rg-dropdown dd-html="ddHtml" dd-control="ddControl" dd-action="ddAction">' +
                      //  '<div class="addalbum"><input  name="" placeholder="Add Album Title" /></div>'+
                        '<span >' +
                            '<a  class="btn-share vid top-l" data-tooltip-post="Add to album"  ' +
                                'rg-ringbox="true" ringbox-controller="RingBoxAlbumlistController" ringbox-animation="true" ' +
                                'ringbox-type="remote" ringbox-target="pages/dropdowns/popup-album-dropdown.html" ringbox-data="selectAlbum(media.value)" ></a> ' +

                            //'<a data-tooltip-post="Add to Album"><label class="btn-share"></label></a>
                        '</span>' +
                    '</div>' +
                    '<rg-hashtag></rg-hashtag>' +
                    '<div class="status-photo-view" style="border-bottom:1px solid #ebebeb;margin:0;padding:0;margin-bottom:10px;" id="img-height" ng-show="getMedia(true).length > 0">' +
                        '<div id="sts-img-preview" style="text-align:center;" class="scroll">' +
                            '<div ng-show="previewStartAt+3 < getMedia(true).length" class="np-box icon-right-arrow"  style="right:0;margin-top:60px;" rg-click="loadNext()"></div>' +
                            '<div ng-show="previewStartAt > 0" class="np-box icon-left-arrow" style="left:0;margin-top:60px;"  rg-click="loadPrevious()"></div>' +
                            '<div style="margin-top:3px;" class="status-photo-view-thumb" ng-repeat="image in getMedia()">' +
                                '<div ng-show="image.getProgress() !== 100" class="progress-bar-placement" style="position:absolute;width:100%;text-align:center;">' +
                                    '<div class="percent">{{image.getProgress()}}%</div>' +
                                    '<div class="progress-bar">' +
                                        '<div class="uploaded" ng-style="{\'width\': image.getProgress()+ \'%\'}"></div>' +
                                    '</div>' +
                                '</div>' +
                            '<div  id="singleImage{{$index}}"  style="position:absolute;width:100%;text-align:center;">' +
                                '<input class="add-title" ng-model="image.cptn" ng-model-options="{ getterSetter: true }" type="text" name="" placeholder="Add Photo Title" ng-show="!image.progressVisible" />' +
                                '<div class="photo-view" style="background-image: url({{image.getPreview()}}); background-position:50% 50%; background-size:100% 100%; background-repeat:no-repeat; cursor: pointer;">' +
                                    '<div class="status-photo-view-thumb-hover">' +
                                        '<span id="closebtn0" class="close" style="display: block;" rg-click="removeMedia($index)" inc="0">' +
                                            '<div class="icon-close up-p"></div>' +
                                        '</span>' +
                                    '</div>' +
                                '</div>' +
                            '</div>' +
                        '</div>' +
                    //'</div>' +
                    '</div>';



            switch (uploadType) {
                case 'coverphoto':
                case 'profilephoto':
                    template = '<input  id="' + uploadType + '" type="file" name="' + uploadType + '"  accept="image/*" >';
                    element.append($compile(template)(scope));
                    break;
                case 'tagchatimage':
                case 'chatimage':
                    template = '<label  class="icon-camera ico-sty ng-binding ng-scope">' +
                            '<input  id="' + uploadType + '" type="file" style="display:none;" accept="image/*" ></label>';
                    element.append($compile(template)(scope));
                    break;
                case 'audio':
                    template = '<a data-tooltip-post="Add Audios" href="javascript:void(0)"><label  class="audio-ico ng-binding ng-scope" ng-show="rgUploadEnabled">' +
                            '<input ng-disabled="uploadProgress" id="audio" type="file" style="display:none;" multiple="multiple" accept="audio/mp3"></label></a>';
                    element.append($compile(template)(scope));
                    break;
                case 'video':
                    template = '<a data-tooltip-post="Add Videos" href="javascript:void(0)"><label  class="video-ico ng-binding ng-scope" ng-show="rgUploadEnabled">' +
                            '<input ng-disabled="uploadProgress" id="video" type="file" style="display:none;" multiple="multiple" accept="video/mp4"></label></a>';
                    element.append($compile(template)(scope));
                    break;
                case 'status':
                    template =
                            //'<div ng-show="rgUploadEnabled" class="post-b-ico"><a data-tooltip-post="Add Photos"  href="javascript:void(0)" class="p-ab"><label  class="status-ico camera-ico ng-binding ng-scope" >' +
                            //'<input ng-disabled="disableUpload(\'image\')" id="' + uploadType + '" type="file" style="display:none;" multiple="multiple" accept="image/*"></label></a></div>' +
                            '<div ng-show="rgUploadEnabled "class="post-b-ico"><a data-tooltip-post="Add Videos" href="javascript:void(0)" class="p-ab"><label  class="status-ico video-ico ng-binding ng-scope" >' +
                            '<input ng-disabled="disableUpload(\'video\')" id="video"type="file" style="display:none;" multiple="multiple" accept="video/mp4"></label></a></div>' +
                            '<div ng-show="rgUploadEnabled" class="post-b-ico"><a data-tooltip-post="Add Audios" href="javascript:void(0)" class="p-ab"><label  class="status-ico audio-ico ng-binding ng-scope" >' +
                            '<input ng-disabled="disableUpload(\'audio\')" id="audio" type="file" style="display:none;" multiple="multiple" accept="audio/mp3"></label></a></div>';

                    if (attr.rgUploadFeed && attr.rgUploadFeed == 'true') {
                        template = '<div ng-show="rgUploadEnabled" class="post-b-ico"><a data-tooltip-post="Add Photos"  href="javascript:void(0)" class="p-ab"><label  class="status-ico camera-ico ng-binding ng-scope" >' +
                                    '<input ng-disabled="disableUpload(\'image\')" id="' + uploadType + '" type="file" style="display:none;" multiple="multiple" accept="image/*"></label></a></div>' +
                                    template;
                    }

                    element.append($compile(template)(scope));

                    imgPreviewElem = element.parent().prepend($compile(imgPreviewTmpl)(scope)); // image preview template added for status
                    break;
            }



            //inputFile = angular.elementent( element[0].querySelector('input#' + uploadType) );
            inputFile = element[0].querySelector('input#' + uploadType);

            if (uploadType === 'status') {
                if (attr.rgUploadFeed && attr.rgUploadFeed == 'true') {
                    inputFile.addEventListener('change', scope.uploadImage);
                }
                // grab video input element
                //inputVideo = angular.element( element[0].querySelector('input#video') );
                inputVideo = element[0].querySelector('input#video');
                inputVideo.addEventListener('change', scope.uploadVideo);

                //inputAudio = angular.element( element[0].querySelector('input#audio') );
                inputAudio = element[0].querySelector('input#audio');
                inputAudio.addEventListener('change', scope.uploadAudio);

            } else if (uploadType === 'audio') {
                inputFile.addEventListener('change', scope.uploadAudio);
            } else if (uploadType === 'video') {
                inputFile.addEventListener('change', scope.uploadVideo);
            } else {
                // image, chatimage, tagchatimage upload
                inputFile.addEventListener('change', scope.uploadImage);
            }

            scope.$rgDigest();

            scope.$on('$destroy', function() {
                switch (uploadType) {
                    case 'status':
                        inputFile.removeEventListener('change', scope.uploadImage);
                        inputAudio.removeEventListener('change', scope.uploadAudio);
                        inputVideo.removeEventListener('change', scope.uploadVideo);
                        break;
                    case 'image':
                        inputFile.removeEventListener('change', scope.uploadImage);
                        break;
                    case 'audio':
                        inputFile.removeEventListener('change', scope.uploadAudio);
                        break;
                    case 'video':
                        inputFile.removeEventListener('change', scope.uploadVideo);
                        break;
                }

                fileUploadService.removeScope(scope);
            });



            fileUploadService.setScopeForDigest(scope);


        };  // LINK function END

        return {
            restrict: 'AE',
            scope: {
                rgUploadEnabled: '=',
                rgUploadType: '@',
                rgUploadAction: '&',
                rgUploadBoxValue: '='
            },
            link: linkFunc,
            controller: UploadController
        };
    }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.common.rgsearch_directive', [
			'ringid.config',
			'ringid.common.user_factory',
			'ringid.friend.friends_factory'
		])
		.service('rgSearchService', rgSearchService)
		.directive('rgSearch', rgSearch);

		rgSearchService.$inject = ['GlobalEvents'];
		function rgSearchService(GlobalEvents) {
			var self = this, // jshint ignore:line
                _scope = false,
                _template = false;

			self.close= function() {
                if (_template) {
                    _scope.searchText = '';
                    _template.style.display = 'none';
                    _scope.$rgDigest();
                    _template = false;
                    _scope = false;
                    GlobalEvents.unbindHandler('document', 'click', self.close);
                }
			};
			self.open= function(template, scope) {
                _template = template;
                _scope = scope;
                _template.style.display = 'block';
                GlobalEvents.bindHandler('document', 'click', self.close);
			};

		}

		rgSearch.$inject = [ 'rgSearchService'];
		function rgSearch( rgSearchService) {
			var	linkFunc = function(scope, element) {
                var input = element.find('input');

                scope.template = element[0].querySelector('#search-dropdown');
                scope.template.style.display = 'none';

                input.on('keypress', function(event) {
                    if(event.keyCode === 13) {
                        event.preventDefault();
                    }
                });

                // show search bar and search result box before search result bound to input ng-change attr
                scope.doTheSearch = function() {
                    if( scope.searchText.length > 0 ) {
                        // before every new search string change reset no of result
                        //scope.resetSearch();
                        scope.doSearch();
                    } else {
                        rgSearchService.close();
                    }
                };

                function stopPropagate(event) {
                    if (event.target.tagName.toLowerCase() !== 'a' && event.target.parentNode.tagName.toLowerCase() !== 'a') {
                        event.preventDefault();
                    }
                    event.stopPropagation();
				}


                // this is to prevent clicking on search dropdown and closing it. unless it links to user profile
				element.on('click', stopPropagate);
                scope.$on('$destroy', function() {
                    element.off('click', stopPropagate);
                });

            };

		SearchController.$inject = [ '$scope', '$$stackedMap', 'userFactory', 'friendsFactory','InviteFactory', 'friendsHttpService', '$timeout', 'rgScrollbarService'];
        function SearchController( $scope,  $$stackedMap, userFactory, friendsFactory,InviteFactory, friendsHttpService,  $timeout, rgScrollbarService) {
                var user,
                    searchFailCount = 0,
                    schPm = '',
                    timeOut;

                // initiate dropdown with data
                $scope.searchText = '';
                $scope.gotAllResult = false;
                $scope.showLoadbar = false;
                $scope.noResult = true;
                $scope.listData = $$stackedMap.createNew();

                $scope.resetSearch = function() {
                    searchFailCount = 0;
                    $scope.noResult = false;
                    $scope.gotAllResult = false;
                    //$scope.showLoadbar = false;
                    $scope.listData.reset();

                    $scope.$rgDigest();
                };


                $scope.contactListAction = function(actionObj) {
                    if (!actionObj.friend.isLoading()) {
                        friendsFactory.friendAction(actionObj, true).then(function() {
                            $scope.$rgDigest();
                        }, function() {
                            $scope.$rgDigest();
                        });
                        $scope.$rgDigest();
                    }
                };
                $scope.doSearch = doSearch;

                $scope.getMutualFriend = function(user) {

                    return{
                        data: function() {
                            return {
                                target: user
                            };
                        },
                        promise: InviteFactory.getMutualFriend(user)

                    };
                };



                function checkIfNewSearch() {
                    if ( schPm !== $scope.searchText) {
                        $scope.resetSearch();
                        searchFailCount = 0;
                    }
                }

                function searchFail(){
                    $scope.noResult = ($scope.listData.length() === 0);
                    $scope.gotAllResult = ($scope.listData.length() > 0 ) ? true : false;
                    $scope.showLoadbar = false;
                    $scope.$rgDigest();
                }

                function doSearch (force) {
                    checkIfNewSearch();
                    if (force || (!$scope.showLoadbar && !$scope.gotAllResult))   {
                        clearTimeout(timeOut);
                        $scope.showLoadbar = true;
                        if(!$scope.showDropdown) {
                            rgSearchService.open($scope.template, $scope);
                        }
                        schPm = $scope.searchText;
                        friendsHttpService.searchContact({schPm: $scope.searchText, st: $scope.listData.length()})
                        .then(getSearchResult, getSearchResult );

                        timeOut = setTimeout(searchFail, 8000);
                        $scope.$rgDigest();
                    }
                }

                function getSearchResult (json) {
                    clearTimeout(timeOut);
                    if ( json.sucs === true)
                    {
                        for (var i = 0, l = json.searchedcontaclist.length; i < l; i++) {
                            user = userFactory.create(json.searchedcontaclist[i]);
                            if (user) {
                                $scope.listData.save(user.getKey(), user);
                            }
                        }
                        if (json.searchedcontaclist.length > 0) {
                            rgScrollbarService.recalculate($scope);
                        }

                        $scope.showLoadbar = false; // hide loader
                        $scope.noResult = ($scope.listData.length() === 0);
                        $scope.$rgDigest();
                    } else {
                        searchFailCount++;
                        if(searchFailCount < 3) {
                            doSearch(true);
                        } else {
                            clearTimeout(timeOut);
                            searchFail();
                        }
                    }
                }


            }

			return {
				restrict: 'E',
				scope: {
					placeholder: '@'
				},
				templateUrl: 'pages/dropdowns/search-dropdown.html', // IMPORTANT this tempalte is preloaded inside auth factory
				link: linkFunc,
				controller: SearchController
			};

		}

})();


/**
 * © Ipvision
 */



(function() {
    'use strict';

    angular
        .module('ringid.common.rginvite_directive', [
            'ringid.common.invite_factory',
            'ringid.friend.friends_factory'
        ]).directive('rgInvite', rgInvite);


    rgInvite.$inject  = ['$$connector', 'OPERATION_TYPES', 'InviteFactory', 'friendsFactory'];
    function rgInvite($$connector, OPERATION_TYPES, InviteFactory, friendsFactory) {


            function linkFunc(scope,element) {
                var
                    nameElm,
                    avatarLinkElm,
                    avatarImgElm,
                    mutualElm,
                    addFriendElm,
                    interval,
                    currentSuggestion,
                    timeOut,
                    OTYPES = OPERATION_TYPES.SYSTEM.FRIENDS;


                element[0].style.display = 'none';

                scope.removeOutGoingFriends = function () {
                    var outGoingUtid = [];
                    var findOutGoing = InviteFactory.suggestionFriends.all();
                    var loopLength = InviteFactory.suggestionFriends.length();

                    for( var i = 0; i < loopLength; i++ ){
                        if(findOutGoing[i].value.friendshipStatus() !== 0) {
                            outGoingUtid.push(findOutGoing[i].value.getUtId());
                        }
                    }
                    for(var j=0;j<outGoingUtid.length;j++){
                        InviteFactory.suggestionFriends.remove(outGoingUtid[j]);
                    }
                };

                scope.getSuggestions = function(){
                    scope.removeOutGoingFriends();
                    if(InviteFactory.suggestionFriends.length() < 5){
                        InviteFactory.getSuggestionContactsDetails();
                    }
                    return{
                        data: function() {
                            return {
                                target: InviteFactory.suggestionFriends
                            };
                        }
                    };

                };

                scope.removeSugg = function() {
                    InviteFactory.removeSuggestion(currentSuggestion.getUtId(), 'remove');
                    changeSuggestion();
                };

                scope.getMutualFriend = function() {
                    return{
                        data: function() {
                            return {
                                target: currentSuggestion
                            };
                        },
                        promise: InviteFactory.getMutualFriend(currentSuggestion)

                    };
                };

                scope.friendRequestAction = function() {
                    var action = currentSuggestion.friendshipStatus() === 3 ? 'remove' : 'addfriend';
                    var friend = currentSuggestion;
                    stopSuggestion();
                    friendsFactory.friendAction({friend: friend, action: action}, true).then(function(json) {
                        changeSuggestion();
                        fixFriendButton(json.sucs);
                        startSuggestion();

                        if (json.sucs === true) {
                            InviteFactory.removeSuggestion(friend.getUtId()).then(function(json){
                                if(json.sucs===true){
                                    InviteFactory.suggestionFriends.remove(friend.getUtId());
                                }

                            });
                        }
                    }, function() {
                        fixFriendButton();
                        startSuggestion();
                    });
                    fixFriendButton();
                };


                function initSuggestion() {
                    nameElm = element[0].querySelector('#invname');
                    avatarLinkElm = element[0].querySelector('#invavatarlink');
                    avatarImgElm = element[0].querySelector('#invavatarimg');
                    mutualElm = element[0].querySelector('#invmutual');
                    addFriendElm = element[0].querySelector('#invaddfriend');

                    element[0].addEventListener('mouseenter', stopSuggestion);
                    element[0].addEventListener('mouseleave', startSuggestion);

                    element[0].style.display = 'block';
                    changeSuggestion();
                    startSuggestion();
                }


                function startSuggestion() {
                    // console.log('START SUGGESTION');
                    stopSuggestion();
                    interval = setInterval(changeSuggestion, 5000);
                }

                function stopSuggestion() {
                    // console.log('STOP SUGGESTION');
                    clearInterval(interval);
                }


                function changeSuggestion() {
                    if (!currentSuggestion) {
                         currentSuggestion = InviteFactory.suggestionFriends.bottom();
                    } else {
                         currentSuggestion = InviteFactory.suggestionFriends.next(currentSuggestion.getUtId()) || InviteFactory.suggestionFriends.bottom();
                    }
                    // set data
                    if (currentSuggestion) {
                        nameElm.textContent = currentSuggestion.getName();
                        nameElm.setAttribute('href', currentSuggestion.link());

                        avatarLinkElm.setAttribute('href', currentSuggestion.link());
                        avatarImgElm.setAttribute('src', currentSuggestion.avatar('thumb'));

                        mutualElm.textContent = currentSuggestion.commonFriends() + ' mutual friends';
                        if (currentSuggestion.commonFriends() > 0) {
                            mutualElm.style.display = 'block';
                        } else {
                            mutualElm.style.display = 'none';
                        }

                        fixFriendButton();
                    } else {
                        element[0].style.display = 'none';
                    }

                }

                function fixFriendButton(force) {
                    //if (force || currentSuggestion.friendshipStatus() === 3) {
                        ////addFriendElm.text = 'Remove';
                        //addFriendElm.classList.add('reject');
                        //addFriendElm.classList.remove('addfnd');
                    //} else {
                        ////addFriendElm.text = 'Add Friend';
                        //addFriendElm.classList.add('addfnd');
                        //addFriendElm.classList.remove('reject');
                    //}

                    if (currentSuggestion.isLoading()) {
                         addFriendElm.parentElement.classList.add('f-loading');
                    } else {
                         addFriendElm.parentElement.classList.remove('f-loading');
                    }

                }

                function activate() {
                    $$connector.subscribe(function() {
                        if (!timeOut) {
                            timeOut = setTimeout(function() {
                                initSuggestion();
                            }, 1000);
                        }
                    },{
                        action: [OTYPES.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS]
                    });

                    setTimeout(InviteFactory.init, 5000);
                }

                activate();


                scope.$on("$destroy",function(){
                    element[0].removeEventListener("mouseenter", startSuggestion);
                    element[0].removeEventListener("mouseenter", stopSuggestion);
                });
            }



        return {
            restrict: 'A',
            //controller: InviteController,
            templateUrl: 'pages/partials/friend-invite.html',
            link : linkFunc
        };


    }

})();



/**
 * Copyright @ 2015 by RingID Inc.
 *
 */


(function () {
    'use strict';

    angular
            .module('ringid.common.rgemoticon_directive', [])
            .directive('rgEmoticon', rgEmoticon);
            //.directive('rgEmoticonList', rgEmoticonList);



    rgEmoticon.$inject = ['$compile', '$timeout', '$document', 'utilsFactory', 'StickerFactory', 'rgScrollbarService', '$templateCache', '$ringhttp'];
    function rgEmoticon($compile, $timeout, $document, utilsFactory, StickerFactory, rgScrollbarService, $templateCache, $ringhttp) { //jshint ignore:line
        var linkFunc = function (scope, element, attrs) {
            var
                emoticonListTemplate = 'pages/partials/emoticon-window.html',
                showEmoticon = false,
                emoBoxLimit = 400,
                emoBoxWidth = 300,
                emoBoxHeight = (attrs.showSticker == 'true') ? 300 : 260, //jshint ignore:line
                compiledDom,
                openEmoticonEvent;

            scope.emoWindowStyle = {
                height: emoBoxHeight + 'px',
                width: emoBoxWidth + 'px'
            };

            scope.showsticker = (attrs.showSticker == 'true') ? true : false; // jshint ignore:line
            scope.selectedStickerCatId = 0;

            function safeDigest(){
                if(scope.$parent && scope.$parent.$id !==1){
                    scope.$parent.$rgDigest();
                }else{
                    scope.$rgDigest();
                }
            }

            function handleClick(event) {
                // event.stopImmediatePropagation();
                event.preventDefault();
                //if (!showEmoticon) {
                    showEmoticon = !showEmoticon;
                    if (showEmoticon) {
                        openEmoticonPopUp(event);
                    } else {
                        closeEmoticonPopup();
                    }
                    //safeDigest();
                //}
            }

            element[0].addEventListener('click', handleClick);



            function closeEmoticonPopup(e) {
                if(e && e.type === "click"){
                    if(e.target !== element[0] &&
                        e.target.parentNode &&
                        e.target.parentNode !== element[0] &&
                        e.target.parentNode.parentNode !== element[0] &&
                        e.target.className !== 'pt-top') {

                    }else{
                        return;
                    }
                }
                showEmoticon = false;
                document.removeEventListener('click', closeEmoticonPopup);
                document.removeEventListener('scroll', closeEmoticonPopup);
                element[0].removeEventListener('resize', calculatePosition);
                compiledDom[0].parentNode.removeChild(compiledDom[0]);
            }


            function attachTemplate(templateHtml) {
                compiledDom = $compile(templateHtml)(scope);
                element.append(compiledDom);
                calculatePosition();

                document.addEventListener('click', closeEmoticonPopup);
                document.addEventListener('scroll', closeEmoticonPopup);
                window.addEventListener('resize', calculatePosition);
            }

            function openEmoticonPopUp(event) {
                openEmoticonEvent = event; // catch the event for window resize recalculation of position

                if ($templateCache.get( emoticonListTemplate )) {
                    attachTemplate($templateCache.get(emoticonListTemplate));
                } else {
                    $ringhttp.get(emoticonListTemplate).success(function(templateHtml) {
                        attachTemplate(templateHtml);
                    });
                }
            }

            scope.selectEmoOrSticker = selectEmoOrSticker;

            function calculatePosition() {
                console.info('Calculate Emo Position');
                var elemD = 0,
                    elemRect = element[0].getBoundingClientRect(),
                    availWidth = utilsFactory.viewport.x - elemRect.width,
                    availHeight = utilsFactory.viewport.y;
                elemD = Math.floor(elemRect.width / 2);

                if (openEmoticonEvent.clientX + emoBoxLimit < availWidth && openEmoticonEvent.clientY + emoBoxLimit < availHeight) {
                    //console.info('bottom right');
                    scope.emoWindowStyle.top = elemRect.top + (elemD+15) + 'px';
                    scope.emoWindowStyle.left = elemRect.left + (elemD+5) + 'px';
                } else if (openEmoticonEvent.clientX + emoBoxLimit > availWidth && openEmoticonEvent.clientY + emoBoxLimit > availHeight) {
                    //console.info('top left');
                    scope.emoWindowStyle.top = (elemRect.top - emoBoxHeight) + (elemD-5) + 'px';
                    scope.emoWindowStyle.left = (elemRect.left - emoBoxWidth) + (elemD-5) + 'px';
                } else if (openEmoticonEvent.clientX + emoBoxLimit > availWidth) {
                     //console.info('bottom left');
                    scope.emoWindowStyle.top = elemRect.top + (elemD+5) + 'px';
                    scope.emoWindowStyle.left = (elemRect.left - emoBoxWidth) + (elemD-5) + 'px';
                } else if (openEmoticonEvent.clientY + emoBoxLimit > availHeight) {
                    //console.info('top right');
                    scope.emoWindowStyle.top = (elemRect.top - emoBoxHeight) + (elemD-5) + 'px';
                    scope.emoWindowStyle.left = elemRect.left + (elemD+5) + 'px';
                }
                safeDigest();
            }

            function selectEmoOrSticker(emo, $event) {
                $event.stopPropagation();
                //scope.$broadcast('insertEmoji', emo);
                //scope.$emit('insertEmoji', emo); /* don't need broadcast, expensive rather than callback*/
                if(attrs.clicked) {
                  scope.$eval(attrs.clicked)(emo, $event);
                }
                closeEmoticonPopup(); // close emoticon
                safeDigest();
            }

            scope.selectStickerCatId = function (e, stickerKey) {
                e.stopPropagation();
                scope.selectedStickerCatId = stickerKey;
                StickerFactory.getStickerMapByCatId(stickerKey).then(function(data){
                    scope.emoticonMap = data;
                    safeDigest();

                });
                rgScrollbarService.scrollTop(scope);
                safeDigest();
            };

            // most likely not needed
            //scope.selectSticker = function(stickerKey){
                //scope.selectStickerCatId(stickerKey);
                //closeEmoticonPopup(); // close emoticon
                ////safeDigest();
            //};

            scope.showEmoticons = function(e){
                e.stopPropagation();
                scope.emoticonMap = StickerFactory.getEmoticonMap();
                safeDigest();
            };

            scope.$on('$destroy', function() {
                document.removeEventListener('click', closeEmoticonPopup);
                document.removeEventListener('scroll', closeEmoticonPopup);
                element[0].removeEventListener('resize', calculatePosition);
            });

        };

        EmoticonController.$inject = ['$scope'];
        function EmoticonController($scope) {

            function safeDigest(){
                if($scope.$parent && $scope.$parent.$id !==1){
                    $scope.$parent.$rgDigest();
                }else{
                    $scope.$rgDigest();
                }
            }
            $scope.startAt = 0;
            $scope.getMyStickers = function() {
                return $scope.myStickerCatIds().slice($scope.startAt, $scope.startAt+4);
            };
            $scope.getTopStickers = function() {
                return StickerFactory.getStickerCategories('top').slice(0, 4);
            };

            $scope.loadPrevious = function($event) {
                $scope.startAt = ($scope.startAt > 0) ? $scope.startAt-1 : 0;
                $event.stopPropagation();
                safeDigest();
            };
            $scope.loadNext = function($event) {
                $scope.startAt = ( $scope.startAt+3 < $scope.myStickerCatIds().length - 1 ) ? $scope.startAt+1 : $scope.startAt;
                $event.stopPropagation();
                safeDigest();
            };

            $scope.myStickerCatIds = StickerFactory.getMyStickerCatIds;
            $scope.getSticker = StickerFactory.getStickerCategoryObject;
            $scope.emoticonMap = StickerFactory.getEmoticonMap();

        }

        return {
            restrict: 'A',
            link: linkFunc,
            controller: EmoticonController
        };
    }

    //function rgEmoticonList() {
        //return {
            //link:function(scope, element) {
                //var stopPropagation = function($event) {
                    //console.warn('inside emoticon box clicked');
                    //$event.stopPropagation();
                //};

                //element.on('click', stopPropagation);
                //scope.$on('$destroy', function() {
                    //element.off('click', stopPropagation);
                //});
               //scope.$rgDigest();
            //},
            //restrict: 'E',
            //templateUrl: 'pages/partials/emoticon-window.html'
        //};
    //}


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.rgimg_directive', [])
        .directive('rgImg', rgImg)
        .directive('rgImgChange', rgImgChange);

    function rgImgChange(){ //jshint ignore:line
        return {
            restrict : 'A',
            controller: ['$scope','$element',function($scope, $element) {
                this.setPopupStyle = function(height, width) {
                    $element[0].style.height = height + 'px';
                    $element[0].style.width = width + 'px';
                };
            }]
        };
    }

    rgImg.$inject = ['$compile', 'utilsFactory'];
    function rgImg($compile, utilsFactory) { //jshint ignore:line
        return {
            restrict: 'A',
            require: '^rgImgChange',
            scope: {
                rgImgObj: '='
            },
            link: function(scope, element, attr, rgImgChangeCntrl) {
                var dH= 500,
                    dW = 500,
                    minW = 0,
                    minH = 0,
                    leftbarW = 300,
                    imgPadding = 60,
                    maxW = 0,
                    maxH = 0,
                    resizedW = 0,
                    resizedH = 0,
                    image = $compile('<img src="' + scope.rgImgObj.src() + '" />')(scope);


                maxW = utilsFactory.viewport.x - 40 - leftbarW - imgPadding;
                maxH = utilsFactory.viewport.y - 40 - imgPadding;
                minW = (maxW - dW) > dW? maxW-dW : dW;
                minH =  (maxH - dH) > dH? maxH-dH : dH;

                //element.html(image[0].outerHTML);
                element.append(image);
                //calculateImgSize(scope.rgImgObj.getIh(), scope.rgImgObj.getIw());

                attr.$observe('rgImg', function(newVal) {
                    image[0].setAttribute('src', '');
                    image[0].setAttribute('src', newVal);
                    calculateImgSize(scope.rgImgObj.getIh(), scope.rgImgObj.getIw());
                });

                function calculateImgSize(imgH, imgW) {
                    if (imgH > maxH || imgW > maxW) {
                        if ( (imgW/maxW) >= (imgH/maxH) ) {
                            resizedW = maxW;
                            resizedH = Math.floor( (maxW/imgW) * imgH );
                        } else {
                            resizedH = maxH;
                            resizedW = Math.floor( (maxH/imgH) * imgW );
                        }
                    } else {
                        // set to image actual height, width
                        resizedH = imgH;
                        resizedW = imgW;
                    }

                    image[0].style.width = resizedW + "px";
                    image[0].style.height = resizedH + "px";


                    // below recalculation is for ringbox resize
                    //fix height,width to minimum
                    if (resizedW < minW) {
                        resizedW = minW;
                    }
                    if (resizedH < minH) {
                        resizedH = minH;
                    }

                    resizedW = resizedW + leftbarW + imgPadding;
                    resizedH = resizedH + imgPadding;

                    rgImgChangeCntrl.setPopupStyle(resizedH, resizedW);
                    //scope.$broadcast('ringbox.content.changed', {width:resizedW,height:resizedH} );
                }


            }

        };
    }
})();


/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.rgphotos_directive', [
            'ringid.profile',
            //'ringid.ringbox'
        ])
        .directive('rgPhotos', rgPhotos);


        rgPhotos.$inject = ['$window', '$document', 'utilsFactory'];
        function rgPhotos($window, $document, utilsFactory) { //jshint ignore:line

           PhotosController.$inject = ['rgScrollbarService', '$scope', '$rootScope', 'AlbumFactory', '$routeParams', 'profileFactory',
               'fileUploadService', 'SystemEvents', 'Auth', '$ringbox', 'Ringalert', '$$connector', 'OPERATION_TYPES'];
           function PhotosController (rgScrollbarService, $scope, $rootScope, AlbumFactory, $routeParams, profileFactory,
                                      fileUploadService, SystemEvents, Auth, $ringbox, Ringalert, $$connector, OPERATION_TYPES) { //jshint ignore:line

               var subscriptionKey,
                    OTYPES = OPERATION_TYPES.SYSTEM.IMAGE;

                $scope.showAlbumPreview = true;
                $scope.activeAlbum = null;
                $scope.state = AlbumFactory.state;
                $scope.albums =  AlbumFactory.getAlbums($routeParams.uId);

                // controller methods
                $scope.loadMoreImage = loadMoreImage;
                $scope.deleteImage = deleteImage;
                $scope.getImageData = getImageData;
                $scope.toggleAlbumPreview = toggleAlbumPreview;
                $scope.selectPhoto = selectPhoto;


                function _toggleLoading(bool, type) {
                    if (type === 'album') {
                        $scope.state.albumsLoading = bool;
                    } else {
                        $scope.state.imagesLoading = bool;
                        rgScrollbarService.recalculate($scope);
                    }

                    $scope.$rgDigest();
                }

                function loadMoreImage () {
                    if (!$scope.state.imagesLoading && $scope.activeAlbum.getImages().length() < $scope.activeAlbum.getTotalImageCount()) {
                        _toggleLoading(true, 'image');
                        AlbumFactory.loadMoreImage($scope.activeAlbum.getKey(), $routeParams.uId);
                        //.then(function() {
                            //_toggleLoading(false, 'image');
                        //}, function() {
                            //_toggleLoading(false, 'image');
                        //});

                    }
                }


                function getImageData (imageMap) {
                    return function() {
                        return {
                            image: imageMap,
                            popupFrom: 'profile'
                        };
                    };
                }

                function deleteImage (imageMap) {
                    var message = 'Are you sure you want to delete?';
                    var boxInstance = $ringbox.open({
                            type : 'remote',
                            scope:false,
                            controller: 'RingBoxConfirmController',
                            resolve : {
                                localData : {
                                    message : message
                                }
                            },
                            templateUrl : 'pages/partials/ringbox-confirm.html'
                    });

                    boxInstance.result.then(function(confirmed){
                        if(confirmed){
                            AlbumFactory.deleteImage(imageMap).then(function(response) {
                                if(response.sucs === true) {
                                    // remove image from album image list
                                    //AlbumFactory.getAlbums(Auth.currentUser().getKey()).get(imageMap.getAlbumId()).removeImage(imageMap.getKey());
                                    $scope.activeAlbum.removeImage(imageMap.getKey());
                                } else {
                                    Ringalert('Image delete failed', 'error');
                                }
                                $scope.$rgDigest();
                            });
                        }
                    });
                }

                function toggleAlbumPreview(album) {
                    if (album) {
                        $scope.activeAlbum  = album;
                        $scope.showAlbumPreview = false;
                        // load more image
                        if ($scope.activeAlbum.getImages().length() < 20) {
                            $scope.loadMoreImage();
                        }
                    } else {
                        $scope.showAlbumPreview = true;
                        $scope.activeAlbum = null;
                    }
                    $scope.$rgDigest();
                }


                function selectPhoto (image){
                    if ($scope.forSelection) {
                        $rootScope.$broadcast(SystemEvents.IMAGE.DO_REPOSITION, { image : image.src() });
                    }
                }



                function _activate() {
                    subscriptionKey = $$connector.subscribe(function(json) {
                            switch(json.actn) {
                                case OTYPES.TYPE_ALBUM_IMAGES:
                                case OTYPES.TYPE_FRIEND_ALBUM_IMAGES:
                                    if (json.sucs === false && json.rc === 1111) {
                                        AlbumFactory.fetchAllAlbums($routeParams.uId);
                                    } else {
                                        AlbumFactory.processResponse(json);
                                        _toggleLoading(false);
                                    }
                                    break;
                                case OTYPES.FETCH_FRIEND_ALBUM_LIST:
                                case OTYPES.FETCH_ALBUM_LIST:
                                    if (json.sucs === false && json.rc === 1111) {
                                        loadMoreImage();
                                    } else {
                                        AlbumFactory.processResponse(json, $routeParams.uId);
                                        _toggleLoading(false, 'album');
                                    }
                                    break;
                            }

                        }, {
                        action: [
                            OTYPES.TYPE_ALBUM_IMAGES,
                            OTYPES.TYPE_FRIEND_ALBUM_IMAGES,
                            OTYPES.FETCH_FRIEND_ALBUM_LIST,
                            OTYPES.FETCH_ALBUM_LIST
                        ]
                    });

                    _toggleLoading(true, 'album');
                    AlbumFactory.fetchAllAlbums($routeParams.uId);
                }
                _activate();

                $scope.$on('$destroy', function() {
                    $scope.albums.reset();
                    $$connector.unsubscribe(subscriptionKey);
                });

            }


            var linkFunc = function(scope, element) {

                function handleScroll() {
                    if (!scope.showAlbumPreview) {
                        if ( ($window.innerHeight + $window.scrollY) >= $document[0].body.offsetHeight ) {
                            scope.loadMoreImage();
                        }
                    }
                }

                if (scope.hasOwnProperty('forSelection') && (scope.forSelection === true || scope.forSelection === 'true') ) { //jshint ignore:line
                    // add maxheight from utilsfactory
                    element[0].children[0].children[0].style.overflow = 'hidden';
                    element[0].children[0].children[0].style.maxHeight = utilsFactory.viewportsize().y - 200 + 'px';

                } else {
                    scope.forSelection = false;
                    // load more image on scroll
                    $window.addEventListener('scroll', handleScroll);

                }

                scope.$on('$destroy', function() {
                    $window.removeEventListener('scroll', handleScroll);
                });

                scope.$rgDigest();
            };

            return {
                restrict: 'E',
                controller: PhotosController,
                link: linkFunc,
                templateUrl: 'pages/partials/photos.html',
                scope: {
                    forSelection: '@forSelection',
                    $close : '&boxClose'
                }
            };
        }


})();

(function() {
    'use strict';

    angular
        .module('ringid.common.rghref_directive', [])
        .directive('rgHref', ['$location', '$route','$rootScope',
            function($location, $route,$rootScope) {
                function clickHandler(value,attrs) {
                            var match = /#/g.exec(value);
                            if(match){
                                match = value.substr(match.index+1);
                            }else{
                                match = value;
                            }
                            if($location.path() == match && attrs.reloadpage === 'true') {
                                $route.reload();
                            }
                            $rootScope.$coreDigest();
                        }
                return function(scope, element, attrs) {
                    var fn;
                    attrs.$observe('rgHref', function(value) {
                        if(fn){
                            element.unbind('click',clickHandler);    
                        }
                        
                        if (!value) {
                            element.removeAttr('href');
                            return;
                        }
                        fn = angular.bind(null,clickHandler,value,attrs);
                        element.attr('href', value);
                        element.bind('click',fn);

                    });

                    scope.$on('$destroy',function(){
                        if(fn){
                            element.unbind('click',fn);
                        }
                        
                    });
                }
            }]);


})();

/*
 * © Ipvision
 */

(function() {
    'use strict';
      angular.module('ringid.common.rgslider_directive', [] )

       .directive('rgSlider', function () {

    return {

        link: function (scope, element, atrr) {

            var nextSlide = 0,
                autoSlide = false,
                sliderTimer = null,
                navs = [],
                i;


            var slider_dom = element[0];

            var nav_selector = atrr.navClass || '';
            var slide_selector = atrr.slideClass || '';
            var desc_selector = atrr.descClass || '';
            var delay = parseInt(atrr.delay) * 1000 || 3000;

            var slides = angular.element(slider_dom.querySelectorAll('.' + slide_selector));
            var desc = angular.element(slider_dom.querySelectorAll('.' + desc_selector));
            var nav_dom = slider_dom.querySelectorAll('.' + nav_selector) || {};

            /* vars for carousel*/
            var crsl_distance = 120;
            var crsl_distance_multiplier = 0.6;
            var crsl_size_multiplier = 0.6;
            var crsl_opacity_multiplier = 0.8;

            var crsl = slider_dom.querySelector('.nav-carousel');
            var crsl_items = crsl.querySelectorAll('img');
            crsl_items = Array.prototype.slice.call(crsl_items);
            var crsl_data = [];
            var crls_width = crsl.clientWidth;
            var crls_height = crsl.clientHeight;
            var center = Math.floor(crsl_items.length/2);
            /* end of carousel*/

            setupEvent();
            playSlide();

            function playSlide() {

                slides.removeClass('active');
                slides.eq(nextSlide).addClass('active');

                desc.removeClass('active');
                desc.eq(nextSlide).addClass('active');

                for (i = 0; i < navs.length; i++) {
                    navs[i].find('li').removeClass('active');
                    navs[i].find('li').eq(nextSlide).addClass('active');
                }

                /* Move carousel*/
                if(crsl_data[0]) {
                    playCarousel(findMappedItem(nextSlide));
                }


                if (autoSlide) {
                    nextSlide = (nextSlide + 1 == slides.length) ? 0 : nextSlide + 1;
                    setTimer();
                }

            }

            function setTimer() {

                sliderTimer = setTimeout(function () {
                    playSlide();
                }, delay);
            }

            function clearTimer() {
                clearTimeout(sliderTimer);
            }

            function index(node) {

                var children = node.parentNode.childNodes;
                var num = 0;
                for (var i = 0; i < children.length; i++) {

                    if (children[i] == node) return num;
                    if (children[i].nodeType == 1) num++;

                }
                return -1;
            }

            function setupEvent() {
                var nav;
                for (i = 0; i < nav_dom.length; i++) {

                    nav = angular.element(nav_dom[i]);
                    navs.push(nav);
                    nav.find('li').on('click', function (e) {
                        nextSlide = index(this);
                        clearTimer();
                        playSlide();
                    });
                }

                slides.on('mouseenter', function (e) {
                    e.stopPropagation();
                    autoSlide = false;
                    clearTimer();
                });

                slides.on('mouseleave', function (e) {
                    e.stopPropagation();
                    autoSlide = false;
                    setTimer();
                });

                desc.on('mouseenter', function (e) {
                    e.stopPropagation();
                    autoSlide = false;
                    clearTimer();
                });

                desc.on('mouseleave', function (e) {
                    e.stopPropagation();
                    autoSlide = false;
                    setTimer();
                });

            }

             /*function for carousel*/
            function initCarousel() {

                var item_w, item_h, item_opacity, item_left, item_top, depth, separation;

            	/*for centered item*/
            	item_w= crsl_items[0].clientWidth;
            	item_h= crsl_items[0].clientHeight;
            	item_opacity= 1;
            	item_left = Math.round(crls_width/2)-Math.round(item_w/2);
            	item_top = Math.round(crls_height/2)-Math.round(item_h/2);
            	crsl_data[center]={
                 	'w':item_w,
                 	'h':item_h,
                 	'o':item_opacity,
                 	'l':item_left,
                 	't':item_top,
                 	'z':center,
                 	'i':0
                 };

                /* calculate position for right items*/
            	separation = crsl_distance;
            	depth = center;
            	for(i=center+1;i<crsl_items.length;i++) {

               		separation = separation*crsl_distance_multiplier;
              		item_w =	crsl_size_multiplier * crsl_data[i-1].w;
               		item_h =	crsl_size_multiplier * crsl_data[i-1].h;
               		item_opacity = crsl_opacity_multiplier * crsl_data[i-1].o;
               		item_left = crsl_data[i-1].l+crsl_data[i-1].w+separation-item_w;
                	--depth;
                	item_top = Math.round(crls_height/2)-Math.round(item_h/2);

                	crsl_data[i]={
                 		'w':item_w,
                 		'h':item_h,
                 		'o':item_opacity,
                 		'l':item_left,
                 		't':item_top,
                 		'z':depth,
                 		'i':i
                 	};
                }

              /* calculate position for left items*/
               separation = crsl_distance;
               depth = center;
               for(i=center-1;i>=0;i--) {

               		separation = separation*crsl_distance_multiplier;
               		item_w =	crsl_size_multiplier * crsl_data[i+1].w;
               		item_h =	crsl_size_multiplier * crsl_data[i+1].h;
               		item_opacity = crsl_opacity_multiplier * crsl_data[i+1].o;
               		item_left = crsl_data[i+1].l-separation;
                	--depth;
                	item_top = Math.round(crls_height/2)-Math.round(item_h/2);

                	crsl_data[i]={
                 		'w':item_w,
                 		'h':item_h,
                 		'o':item_opacity,
                 		'l':item_left,
                 		't':item_top,
                 		'z':depth,
                 		'i':i
                 	};
               }


             /* set initial position and enable event*/
              for(i=0;i<crsl_items.length;i++) {

                  crsl_items[i].orgPos = i;
                  crsl_items[i].crslPos = i;
                  crsl_items[i].addEventListener('click', function (e) {
                     if (this.crslPos==center) return ;

                     nextSlide = this.orgPos;
                     clearTimer();
                     playSlide();
                     playCarousel(this);


                  });
               }

           }

           function playCarousel(item) {
             moveItem(item);
             setItemPosition();
           }

           function moveItem (item) {

                   var temp, direction = item.crslPos < center ? 'forward' : 'backward';

                   while (item.crslPos != center) {
                        if( direction == 'forward') {
                        	temp = crsl_items.pop();
                        	crsl_items.unshift(temp);
                        } else {
                            temp = crsl_items.shift();
                            crsl_items.push(temp);
                        }

                        //update position
                        for(i=0;i<crsl_items.length;i++) {
                            crsl_items[i].crslPos = i;
                            crsl_items[i].className = '';
                        }
                   }
                 item.className= 'active';
           }


         function setItemPosition() {

             	for(i=0;i<crsl_items.length;i++) {
                	crsl_items[i].style.width =  crsl_data[i].w+'px';
                	crsl_items[i].style.height =  crsl_data[i].h+'px';
                	crsl_items[i].style.opacity =  crsl_data[i].o;
                	crsl_items[i].style.left =  crsl_data[i].l+'px';
                	crsl_items[i].style.top =  crsl_data[i].t+'px';
                	crsl_items[i].style.zIndex =  crsl_data[i].z;
                	crsl_data[i].i = i;
               }

               //console.log(crsl_items);
          }

         function findMappedItem(position) {

            for(i=0;i<crsl_items.length;i++) {
               if(position ==crsl_items[i].orgPos ) {
                  return crsl_items[i];
               }
            }
         }
        
         crsl_items[0].src = crsl_items[0].src; // loading cache issue 
         crsl_items[0].addEventListener('load', function() {
            initCarousel();
            playCarousel(crsl_items[0]);
            
            setTimeout(function(){
               crsl.style.visibility =  'visible'; 
              }, 800);
         });

         /* End of carousel*/

        }
    }
});
})();


(function () {
    'use strict';

    angular
        .module('ringid.common.rg_friend_dropdown',['ringid.friend.friends_factory'])
        .filter('userListFilter', userListFilter)
        .directive('rgFriendDropdown', rgFriendDropdown);


        function userListFilter() {
                return function(items, name, tagItems) {
                    if (items) {
                        var filtered = [], tempu;
                        var nameMatch = new RegExp(name, 'i');
                        for (var i = 0; i < items.length; i++) {
                            if (filtered.length > 10)
                                return filtered;
                            tempu = items[i].value.getLiteUser();
                            if (nameMatch.test(tempu.getName()) && tagItems.indexOf(tempu) === -1) {
                                filtered.push(tempu);
                            }
                        }
                        return filtered;
                    }
                };
            }

    rgFriendDropdown.$inject = ['friendsFactory', '$filter'];
    function rgFriendDropdown(friendsFactory, $filter) {
        return {
            scope: {
                filterText: '=',
                focusFilter: '=',
                onSelect: '&',
                onClose: '&',
                tagItems: '=',
            },
            templateUrl: function(elem,attrs) {
                  return attrs.templateUrl || 'pages/dropdowns/tag-friend-dropdown.html';
            },
            compile: function compile(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink(scope, iElement, iAttrs, controller) {
                        var sentRequest = false;
                        scope.users = [];
                        function setUser() {
                            scope.users = $filter('userListFilter')(friendsFactory.friends.all(), scope.filterText, scope.tagItems);
                            if(scope.activeId >= scope.users.length){
                                scope.activeId = 0;
                            }
                            //scope.loading = !!scope.users.length;
                        }
                        function searchRequest() {
                            if (sentRequest)
                                return;
                            friendsFactory.searchContact({schPm: scope.filterText}, true).then(function(){
                                scope.$rgDigest();
                            });
                            scope.loading = true;
                            sentRequest = true;
                        }
                        scope.$watch(friendsFactory.friends.length, function(newValue, oldValue) {
                            setUser();
                            if (sentRequest) {
                                scope.loading = false;
                                sentRequest = false;
                            }
                        });

                        scope.$watch('filterText', function(newValue, oldValue) {
                            setUser();
                            sentRequest = false
                            if (scope.users.length < 5 && oldValue.length < newValue.length) { // oldVal.length < newval.length is for making sure not to send request while backspacing
                                searchRequest();
                            }
                        });
                        scope.$watch('users.length', function(newval, oldVal) { // users is poped from users after selecting and no feed text is set so requesting for more contact
                            if (newval < 5 && newval < oldVal) {
                                if (scope.filterText.length > 0) {
                                    searchRequest();
                                } else {
                                    friendsFactory.getContactDetails();
                                }
                            }
                            if(newval > 5 && !sentRequest){
                              scope.loading = false;
                            }

                        });
                        scope.loading = !!scope.users.length;
                        scope.choose = function(item, event) {
                            scope.onSelect()(item, event);
                            setUser();
                            scope.$rgDigest();
                        }
                        scope.close = angular.isFunction(scope.onClose) ? scope.onClose() : angular.noop;
                        var ignoreKey = false;
                        scope.processKeyup = function(e){
                            if (ignoreKey)
                            {
                                e.preventDefault();
                                return;
                            }
                            if (e.keyCode == 38 || e.keyCode == 40) 
                            {
                                var pos = this.selectionStart;
                                this.value = (e.keyCode == 38?1:-1)+parseInt(this.value,10);        
                                this.selectionStart = pos; this.selectionEnd = pos;

                                ignoreKey = true; setTimeout(function(){ignoreKey=false},1);
                                e.preventDefault();
                            }
                         };
                        
                        scope.activeId = 0;
                        scope.setActiveId = function(i){
                          scope.activeId = i;
                        }
                       iElement.bind("keydown",function(e,keyCode){
                         keyCode = keyCode || e.which || e.keyCode || e.key;
                           if(keyCode=== 13){
                              if(scope.users.length){
                                scope.choose(scope.users[scope.activeId],e);
                                scope.filterText = "";  
                              }
                              
                           }else if(keyCode === 38){
                             scope.activeId = Math.max(scope.activeId - 1,0);
                           }else if(keyCode === 40){
                              scope.activeId = Math.min(scope.activeId+1,scope.users.length-1);
                           }
                           scope.$rgDigest();
                       });
                       iElement.bind("mouseleave",function(){
                        scope.activeId = 0;
                       })
                    },
                    post: function postLink(scope, iElement, iAttrs, controller) {
                        iElement.on("click", function(event) {
                            event.stopPropagation();
                        });
                        scope.$rgDigest();

                    }
                }
            }
        }
    }


})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
            .module('ringid.common.rgeditor_directive', [])
            .provider('$editor', EditorProvider)
            .directive('rgEditor', rgEditor);


    function EditorProvider() {

        this.$get = ['$compile', 'StickerEmoticonService', 'StickerEmoticonFactory', '$sniffer','$rootScope', function ($compile, StickerEmoticonService, StickerEmoticonFactory, $sniffer,$rootScope) {
   
                  var emoMap = StickerEmoticonService.getEmoticonMap();
                  var emoPattern = StickerEmoticonFactory.getEmoticonPattern();
                  var dataBlockPattern = /<a.*?data-link="(.*?)".*?>.*?<\/a>/ig;  
                  var prefix = $sniffer.vendorPrefix.toLowerCase();
                  var isIE11 = !!(navigator.userAgent.match(/Trident/) && navigator.userAgent.match(/rv[ :]11/));

                  var keys = {
                      '13' : {'fn':'enter', 'action':'enter', 'event':'keydown'},
                      '8'  : {'fn':'backspace', 'action':'backspace', 'event':'keydown'},
                      '32' : {'fn':'space', 'action':'space', 'event':'keydown'}, 
                      '46' : {'fn':'delete', 'action':'delete', 'event':'keydown'},
                      '27' : {'fn':'escape', 'action':'escape', 'event':'keydown'},
                      '37' : {'fn':'adjust', 'action':'left', 'event':'keyup'},
                      '39' : {'fn':'adjust', 'action':'right', 'event':'keyup'},
                      '38' : {'fn':'adjust', 'action':'up', 'event':'keyup'},
                      '40' : {'fn':'adjust', 'action':'down', 'event':'keyup'},
                      '00' : {'fn':'adjust', 'action':'click', 'event': 'mouseup'},
                  }

                  if(prefix == 'moz') {
                      keys['8'] = {'fn':'backspace', 'action':'backspace', 'event':'both'};
                      keys['46'] = {'fn':'delete', 'action':'delete', 'event':'both'};
                  }

                  /*Editor Modifier based on different action and event*/
                  var Modifiers = {
                          
                            container :   null,
                            event :  null,
                            keyCode: 0,
                            selection : null,
                            range : null,
                            previousSelection : {},
                           
                            init : function (container, keyCode, event, callbacks, processors) {

                                   var boundary, i, callback, processor, isProceed = true, firstChild =null, lastChild = null;

                                   this.container = container;
                                   this.keyCode = keyCode;
                                   this.event = event;
                                   this.selection = Cursor.getSelection();
                                   this.range = Cursor.getCurrentRange();
                                   this.action = '';

                                   firstChild = Utils.getFirstNode(this.container);
                                   lastChild = this.container.lastChild;

                                   boundary = Utils.getCurrentBoundary(this.selection);
                                   boundary = Utils.getSafeBoundary(this.selection, boundary, keyCode, firstChild, lastChild);

                                   /* processor*/ 
                                   for(i=0;i<processors.length;i++) {
                                      processor = processors[i];
                                      if(processor  && (processor.event == event.type || processor.event =='both') && ((keys[keyCode] && processor.action && processor.action.indexOf(keys[keyCode].action) != -1) ||  processor.action === false)) {
                                         if(processor.fn.call(processor.context, event, keyCode) === false) {
                                           isProceed = false;
                                         } 
                                      }
                                   }
                                   processors = [];
                                   /*End of processor*/

                                   if(!isProceed) return;

                                   /* Action on variouos event*/
                                   if (keys[keyCode] && Modifiers[keys[keyCode].fn] && (keys[keyCode].event==event.type || keys[keyCode].event =='both')) {  
                                       this.action = keys[keyCode].action;
                                       Modifiers[keys[keyCode].fn](boundary);
                                   }

                                   /* If cursor somehow in the middle of data block node, it will move cursor correct position*/
                                   if(!keys[keyCode] && event.type == 'keydown' && boundary) {
                                     Modifiers.adjust(boundary, false);
                                   }

                                   /* External callback */ 
                                   for(i=0;i<callbacks.length;i++) {
                                      callback = callbacks[i];
                                      if(callback  && callback.event == event.type && ((keys[keyCode] && callback.action == keys[keyCode].action) ||  callback.action === false)) {
                                        callback.fn.call(callback.context, event, keyCode); 
                                      }
                                   }
                                   callbacks = [];
                                   /*End of callback*/

                                  firstChild = lastChild = null; 
                                    
                            },

                            setContainer : function(container, focus) {
                              this.container = container;
                              
                               if(focus && Cursor.intersectsNode(container) === false) {
                                   Cursor.toElmentEnd(container);
                                   this.container.focus();
                               }

                            },

                            adjust : function(boundary, preventDefault) {

                                  if(!boundary) return;
                              
                                  preventDefault = (typeof preventDefault !== 'undefined') && (preventDefault !== null) ? preventDefault : true;

                                  if(boundary['zws'] && boundary['candidate'].length ==0 && (this.action =='left' || this.action =='right' || this.action =='click')) {
                                    if(preventDefault) {
                                      this.event.preventDefault();  
                                    }   
                                    return;
                                  }
                                 
                                 
                                  if(!this.selection.isCollapsed 
                                     && this.event.type == 'mouseup' && this.previousSelection 
                                     && this.previousSelection.anchorNode == this.selection['anchorNode'] 
                                     && this.previousSelection['anchorOffset'] == this.selection['anchorOffset']
                                     && this.previousSelection['focusOffset'] == this.selection['focusOffset']) {
                                     this.previousSelection = {};
                                     return;
                                  }


                                

                                  if(!preventDefault && this.selection.isCollapsed === false) {
                                      
                                      if(this.event.ctrlKey || this.event.shiftKey || this.event.metaKey) return;

                                      if(boundary && boundary.direction == 'ltr') {
                                        Cursor.deleteContents(boundary['start'],boundary['startPos'],boundary['end'], boundary['endPos']); 
                                      }
                                      else if(boundary && boundary.direction == 'rtl') {
                                        Cursor.deleteContents(boundary['end'], boundary['endPos'], boundary['start'],boundary['startPos']);
                                      }
                                      else {
                                        Cursor.deleteContents(this.range.startContainer, this.range.startOffset, this.range.endContainer, this.range.endOffset);  
                                      }

                                      return;
                                  }

                                  Utils.adjustCursor(this.selection, boundary);

                                  if(preventDefault) {
                                    this.event.preventDefault();  
                                  }

                                 if(this.selection && this.selection['anchorNode']) {
                                   this.previousSelection['anchorNode'] = this.selection['anchorNode'];
                                   this.previousSelection['anchorOffset'] = this.selection['anchorOffset'];
                                   this.previousSelection['focusOffset'] = this.selection['focusOffset'];
                                 }  
                                 
                            },

                            enter : function (boundary) {

                                  var rgNode, i, tagDropdownOpen = false, brNode, nodeData, exeBR = false, textNode;

                                 
                                   if(boundary && !this.selection.isCollapsed) {

                                      if(boundary.direction == 'ltr') {
                                      
                                       Cursor.deleteContents(boundary['start'],boundary['startPos'],boundary['end'], boundary['endPos']); 
                                      }
                                      else {
                                        Cursor.deleteContents(boundary['end'], boundary['endPos'], boundary['start'],boundary['startPos']);
                                      }
                                     this.range = Cursor.getCurrentRange();  
                                   }

                                   /*For gecko*/
                                   try {
                                    exeBR = document.execCommand('insertBrOnReturn', false, true);
                                   }
                                   catch (error) {
                                    exeBR = false;
                                   }

                                   if(exeBR) return;

                                   this.event.preventDefault();  
   
                                   this.range.deleteContents();
                                   brNode = document.createElement('br');
                                   this.range.insertNode(brNode);

                                   if(this.container.style.maxHeight !="") {
                                     this.container.scrollTop = this.container.scrollTop + 18;
                                   }
                                   
                                   Cursor.toElmentAfter(brNode); 
                                   nodeData = brNode = textNode = null; 
                            },

                            escape : function () {

                            },

                            backspace : function (boundary) {
                             
                                   if(!boundary) return;

                                   var text = this.container.innerText || this.container.textContent;

                                   if(text.length ==2) {
                                     this.event.preventDefault();
                                     return;   
                                   }

                                   if(boundary['zwsType'] =='last' && boundary['start'] === boundary['end'] && boundary['startPos'] == boundary['endPos'] ) return;

                                   if(boundary['zws'] && boundary['zwsType'] =='first' && boundary['candidate'].length ==0) {
                                    this.event.preventDefault();   
                                    return;
                                   }

                                   var nodeData;

                                   if(boundary.direction == 'ltr') {
                                     nodeData =  Utils.getNode(boundary['start'], 'prev', boundary['start'].length-boundary['startPos']);
                                     Cursor.deleteContents(boundary['start'],boundary['startPos'], boundary['end'], boundary['endPos']);
                                   }
                                   else {
                                     nodeData =  Utils.getNode(boundary['end'], 'next', boundary['end'].length-boundary['endPos']);
                                     Cursor.deleteContents(boundary['end'], boundary['endPos'], boundary['start'],boundary['startPos']);
                                   }

                                   /* adjust pos after removing node*/ 
                                   if(nodeData['parent']) {
                                      nodeData['pos'] = (boundary.direction == 'rtl') ? nodeData['node'].childNodes.length : 0;
                                   }

                                   Cursor.toElementByType(nodeData['node'], nodeData['type'], nodeData['pos']);  
                                   this.event.preventDefault();   

                                   nodeData = null;
                            },

                            delete : function (boundary) {
                             
                                   if(!boundary) return; 

                                   var text = this.container.innerText || this.container.textContent;

                                   if(text.length ==2) {
                                     this.event.preventDefault();
                                     return;   
                                   }

                                   if(boundary['zwsType'] =='first' && boundary['start'] === boundary['end'] && boundary['startPos'] == boundary['endPos'] ) return;

                                   if(boundary['zws'] && boundary['zwsType'] =='last' && boundary['candidate'].length ==0) {
                                    this.event.preventDefault();   
                                    return;
                                   }
                                   
                                   var nodeData;

                                   if(this.selection.isCollapsed || boundary.direction == 'ltr') {
                                     nodeData =  Utils.getNode(boundary['start'], 'next', boundary['start'].length-boundary['startPos']);
                                     Cursor.deleteContents(boundary['start'],boundary['startPos'],boundary['end'], boundary['endPos']); 
                                   }
                                   else {
                                     nodeData =  Utils.getNode(boundary['end'], 'prev', boundary['end'].length-boundary['endPos']);
                                     Cursor.deleteContents(boundary['end'], boundary['endPos'], boundary['start'],boundary['startPos']);
                                   }

                                   /* adjust pos after removing mode*/ 
                                   if(nodeData['parent']) {
                                      nodeData['pos'] = (this.selection.isCollapsed || boundary.direction == 'ltr') ? nodeData['node'].childNodes.length : 0;
                                   } 

                                   Cursor.toElementByType(nodeData['node'], nodeData['type'], nodeData['pos']);  
                                   this.event.preventDefault();  

                                   nodeData = null; 
                          },
                          
                          space : function () {

                                var code = '', ieFix;

                                code = Utils.findCurrentWord(null, this.container);

                                if(code) {
                                   code = code.replace(/\u200B|\n/g,'');
                                }

                                if(emoMap[code]) {

                                  var ieFix = (prefix == 'ms' && Utils.isEditorTag(this.range.endContainer) && this.range.endContainer.childNodes[this.range.endOffset].nodeType  == 3 && this.range.endContainer.childNodes[this.range.endOffset].nodeValue.charCodeAt(0) == '8203') ? true : false;

                                  if(ieFix) {
                                    
                                    var tempNode = this.range.endContainer.childNodes[this.range.endOffset-1];
                                    this.range.setStart(tempNode,tempNode.length); 
                                    this.range.setEnd(tempNode,tempNode.length); 
                                    tempNode = null;
                                  }

                                  this.range.setStart(this.range.startContainer, (this.range.endOffset - code.length));
                                  this.range.deleteContents(); /* Manual delete since we don't need undo here*/
                                  this.addEmoticon(code,true);
                                  this.event.preventDefault();
                                }  
                             
                           },

                           addEmoticon : function(code, appendSpace) {

                                var nodeData, attrs = {}, html, gotoEl, emoNode;
                               
                                this.range = Cursor.getCurrentRange();

                                html = Utils.parseText(code);

                                if(appendSpace && html.replace(dataBlockPattern,'') == '') {
                                   html += String.fromCharCode(32);
                                }

                                Utils.removeClass(this.container);

                                Cursor.insertHtml(html);

                                emoNode = this.container.querySelectorAll(".caret");
                                emoNode = Array.prototype.slice.call(emoNode); 
                                
                                if(this.selection) {
                                  gotoEl = this.selection.focusNode;  
                                }
                                

                                 /* InsertHTML bug perhaps!. Sometimes it is inserting unexpected newline*/
                                if(gotoEl && gotoEl.nextSibling 
                                   && gotoEl.nextSibling.nodeType ==3 
                                   && gotoEl.nextSibling.length ==1 
                                   && gotoEl.nextSibling.nodeValue.charCodeAt(0) == 10) {
                                   gotoEl.nextSibling.parentNode.removeChild(gotoEl.nextSibling);  
                                }

                                if(gotoEl && gotoEl.nodeType== 3 && gotoEl.nodeValue.charCodeAt(gotoEl.nodeValue.length-1) == 10) {
                                   gotoEl.nodeValue =  gotoEl.nodeValue.replace(/\u200B|\n/g,'');
                                }

                                if(!gotoEl && emoNode.length > 0) {
                                  var tempNode = emoNode[emoNode.length-1].nextSibling.nextSibling; 
                                  
                                  if(tempNode && tempNode.nodeType== 3 && tempNode.length ==1 && tempNode.nodeValue.charCodeAt(0) == 10) {
                                    tempNode.parentNode.removeChild(tempNode);  
                                  }
                                  tempNode = null;
                                }
                                /*Newline issue done*/

                               
                                if(emoNode.length > 0 ) {
                                  
                                  gotoEl = emoNode[emoNode.length-1];
                                  
                                  if(gotoEl.nextSibling && gotoEl.nextSibling.nodeType ==3) {
                                     Cursor.toElementByType(gotoEl.nextSibling, 'pos', 1); 
                                  }
                                  else {
                                    Cursor.toElmentAfter(gotoEl); 
                                  }
                                  
                                }
                                else if(gotoEl) {
                                  nodeData = Utils.getNode(gotoEl, 'next', 0);
                                  Cursor.toElementByType(nodeData['node'], nodeData['type'], nodeData['pos']); 
                                }
                                else {
                                  Cursor.toElmentEnd(this.container);
                                }

                                this.container.focus(); 
                                nodeData = emoNode = gotoEl=  null;
                           },

                          addTag : function (user, word) {
                              
                              var nodeData, blockData, attrs = {}, html, gotoEl, offset, tagNode;

                              word = '@'+word;

                              if(this.range.startContainer.nodeType !=3) { 
                                this.range = Cursor.getCurrentRange();  
                              }

                              offset = this.range.collapsed ? this.range.endOffset : this.range.startOffset;

                              var ieFix = (prefix == 'ms' && Utils.isEditorTag(this.range.endContainer) && this.range.endContainer.childNodes[this.range.endOffset].nodeType  == 3 && this.range.endContainer.childNodes[this.range.endOffset].nodeValue.charCodeAt(0) == '8203') ? true : false;

                              if(ieFix) {
                                offset = this.range.endContainer.childNodes[this.range.endOffset-1].nodeValue.length;
                                var tempNode = this.range.endContainer.childNodes[this.range.endOffset-1];
                                this.range.setStart(tempNode,0); 
                                this.range.setEnd(tempNode,0); 
                                tempNode = null;
                              }

                              if((offset - word.length) < 0) return;
                              
                              this.range.setStart(this.range.startContainer, (offset - word.length)); 
                              this.range.setEnd(this.range.startContainer, offset); 
                              this.range.deleteContents(); /* Manual delete since we don't need undo here*/

                              attrs['class']  = 'tag';
                              attrs['title']  = user.getName().trim();
                              attrs['data-link']  = user.getUtId();
                              attrs['text']  = user.getName().trim();

                              Utils.removeClass(this.container);

                              html = Utils.getBlockHTML(attrs);
                              Cursor.insertHtml(html);

                              tagNode = this.container.querySelectorAll(".caret");
                              tagNode = Array.prototype.slice.call(tagNode); 

                              if(this.selection.focusNode !== this.container && this.selection.focusNode.nextSibling && this.selection.focusNode.nextSibling !== this.container.lastChild) {
                                  gotoEl = this.selection.focusNode.nextSibling; 
                                }
                              else {
                                  gotoEl = this.selection.focusNode; 
                              }

                              blockData = Utils.examineNode(gotoEl,'focus', this.selection);
                              if(blockData.node && blockData.position =='parent') {
                                  gotoEl = blockData.node;
                              }

                               /* InsertHTML bug perhaps!. Sometimes it is inserting unexpected newline*/
                                if(gotoEl && gotoEl.nextSibling 
                                   && gotoEl.nextSibling.nodeType ==3 
                                   && gotoEl.nextSibling.length ==1 
                                   && gotoEl.nextSibling.nodeValue.charCodeAt(0) == 10) {
                                   gotoEl.nextSibling.parentNode.removeChild(gotoEl.nextSibling);  
                                }

                                if(gotoEl && gotoEl.nodeType== 3 && gotoEl.nodeValue.charCodeAt(gotoEl.nodeValue.length-1) == 10) {
                                   gotoEl.nodeValue =  gotoEl.nodeValue.replace(/\u200B|\n/g,'');
                                }

                                if(!gotoEl && tagNode.length > 0) {
                                  var tempNode = tagNode[tagNode.length-1].nextSibling; 
                                  
                                  if(tempNode && tempNode.nodeType== 3 && tempNode.length ==1 && tempNode.nodeValue.charCodeAt(0) == 10) {
                                    tempNode.parentNode.removeChild(tempNode);  
                                  }
                                  tempNode = null;
                                }
                                /*Newline issue done*/  

                            
                              if(tagNode.length > 0 ) {
                                Cursor.toElmentAfter(tagNode[tagNode.length-1]);
                              }
                              else if(gotoEl) {
                                nodeData = Utils.getNode(gotoEl, 'next', 0);
                                Cursor.toElementByType(nodeData['node'], nodeData['type'], nodeData['pos']);  
                              }
                              else {
                                Cursor.toElmentEnd(this.container);
                              }
                              
                              this.container.focus(); 
                              nodeData = tagNode =gotoEl=  null;
                          },

                          paste : function(text){

                            var html = Utils.parseText(text), gotoEl;
                            Cursor.insertHtml(html);
                            this.container.focus();
                            gotoEl = null;

                          }
                       };

                    
                      /* Dom and other ultity methods*/ 
                      var Utils = {

                            examineNode : function(node, type, selection) {

                                var result = Object.create(null),
                                    offset = (type == 'focus') ? selection.focusOffset : selection.anchorOffset,
                                    tempNode;
                                
                                result['position'] = false;
                                result['length'] = 0;
                                result['node'] = null;

                               
                                if(!node) {
                                  return result;
                                }

                                if(node.nodeType ==1 && node.getAttribute('data-block')=='true') {
                                    result['node'] = node;
                                    result['position'] = 'self';
                                }

                                tempNode = Utils.getNextNode(node, node.length);

                                if(tempNode && tempNode.nodeType ==1 && tempNode.getAttribute('data-block')=='true' && (node.nodeType ==1 || (node.nodeType == 3 && offset == node.length))) {
                                    result['node'] = tempNode;
                                    result['position'] = 'next';
                                }

                                tempNode = Utils.getPrevNode(node, node.length);
                                if(tempNode && tempNode.nodeType ==1 && tempNode.getAttribute('data-block')=='true' && (node.nodeType ==1 || (node.nodeType == 3 && offset == 0))) {
                                    result['node'] = tempNode;
                                    result['position'] = 'prev';
                                }

                                tempNode = node.parentNode.nodeName.toLowerCase() == 'b' ? node.parentNode.parentNode : node.parentNode;
                                if(tempNode && tempNode.nodeType ==1 && tempNode.getAttribute('data-block')=='true') {
                                    result['node'] = tempNode;
                                    result['position'] = 'parent';
                                }

                                if(result['node']) {
                                  result['length']    =  (result['node'].nodeType ==3) ? result['node'].nodeValue.length : 0;
                                }

                                tempNode= null;
                                return result;
                           },

                           getCurrentBoundary : function (selection) {

                                var direction = Cursor.getDirection();
                                var result = Object.create(null);

                                if(!selection) return result;

                                result['start'] = selection.anchorNode;
                                result['startPos'] = selection.anchorOffset;
                                result['end'] = selection.focusNode;
                                result['endPos'] = selection.focusOffset; 
                                result['direction'] = direction; 
                                return result;   
                           },

                           adjustCursor : function(selection, boundary) {

                                  if(selection.isCollapsed) {
                                      Cursor.toElementByType(boundary['end'], boundary['type'], boundary['endPos']);  
                                   }
                                  else if(!selection.isCollapsed && boundary['isAnchorMoved']) {
                                      Cursor.extendSelection(boundary, false); 
                                   }
                                   else {
                                       Cursor.extendSelection(boundary);
                                   } 

                           },

                           getSafeBoundary : function (selection, boundary, keyCode, firstChild, lastChild) {

                                   var adjust = false, blockData = null, nodeData = null,
                                   action, nodeToBechecked = [], dir, current, length;
                                  
                                  /*
                                    - if reverse is true, it will reverse focus and anchor node searching direction 
                                      in case of right to left selection (backward selection)
                                    - If both is true, it will consider anchor node also regardless collapsed status
                                  */
                                  var dirRules = {
                                      'enter'     : {'focus':'next', 'anchor':'prev', 'dir' : 'ltr', 'reverse': true, 'both':false},
                                      'backspace' : {'focus':'prev', 'anchor':'next', 'dir' : 'rtl', 'reverse': true, 'both':true},
                                      'delete'    : {'focus':'next', 'anchor':'prev', 'dir' : 'ltr', 'reverse': true, 'both':true},
                                      'space'     : {'focus':'next', 'anchor':'next', 'dir' : 'ltr', 'reverse': false, 'both':false},
                                      'escape'    : {},
                                      'left'      : {'focus':'prev', 'anchor':'next', 'dir' : 'rtl', 'reverse': false, 'both':false},
                                      'right'     : {'focus':'next', 'anchor':'prev', 'dir' : 'ltr', 'reverse': false, 'both':false},
                                      'up'        : {'focus':'next', 'anchor':'prev', 'dir' : 'ltr', 'reverse': true, 'both':false},
                                      'down'      : {'focus':'next', 'anchor':'prev', 'dir' : 'ltr', 'reverse': true, 'both':false},
                                      'click'     : {'focus':'next', 'anchor':'prev', 'dir' : 'ltr', 'reverse': true, 'both':false},
                                      'any'       : {'focus':'next', 'anchor':'prev', 'dir' : 'ltr', 'reverse': true, 'both':false}
                                  };

                                  action = keys[keyCode] ? keys[keyCode].action : 'any';

                                   if(action == '' || !dirRules[action] || !dirRules[action].hasOwnProperty('focus')) return;

                                   boundary['isAnchorMoved'] = false;
                                   boundary['candidate'] = [];

                                   if(!selection.isCollapsed || dirRules[action]['both']) {
                                      nodeToBechecked.push({'node':selection.anchorNode, 'type':'anchor', 'offset': selection.anchorOffset});
                                   }

                                   nodeToBechecked.push({'node':selection.focusNode, 'type':'focus', 'offset': selection.focusOffset});  

                                   while(current = nodeToBechecked.pop()) {

                                          if(!current.node) continue;

                                          dir = dirRules[action][current.type];

                                          if(dirRules[action]['reverse'] && boundary.direction != dirRules[action]['dir']) {
                                             dir = (dir == 'next') ? 'prev' : 'next';
                                          }

                                          blockData = Utils.examineNode(current.node, current.type, selection);

                                           /* For any key action, don't need to adjust boundary if cursor in the most right of data-block*/
                                           if(action == 'any' && selection.isCollapsed && ((blockData.length == selection.focusOffset)
                                              || (blockData.position =='next' && selection.focusNode.length == selection.focusOffset))) {
                                              blockData['node'] = null;
                                           }

                                           if((action == 'backspace' || action=='click') && blockData.position =='next' && selection.isCollapsed && selection.focusNode.nodeType ==3 && selection.focusNode.length == selection.focusOffset) {
                                              blockData['node'] = null;
                                           }
                 
                                           if(blockData.node) {

                                                nodeData =  Utils.getNode(blockData.node, dir, 0);

                                                if(current.type == 'focus') {
                                                  boundary['end'] = nodeData['node'];
                                                  boundary['endPos'] = nodeData['pos']; 
                                                }
                                                else {
                                                  boundary['start'] = nodeData['node'];
                                                  boundary['startPos'] = nodeData['pos']; 
                                                  boundary['isAnchorMoved'] = true;
                                                }
                                                
                                                boundary['type'] = nodeData['type'];
                                                adjust = true;

                                                boundary['candidate'].push(blockData.node); 
                                           }
                                  }

                               /*We have to protect first and last zero width space chars anyhow*/   
                               boundary['zws'] = false;
                               boundary['zwsType'] = '';
                               
                               /*For first zero width space*/      
                               if(boundary.direction == 'ltr' && boundary['start'] === firstChild) {
                                  
                                  if(boundary['startPos'] ==0) {

                                      if(selection.isCollapsed) {
                                        boundary['endPos'] = boundary['startPos'] = 1; 
                                        boundary['type'] = (boundary['type']) ? boundary['type'] : 'pos';
                                      }
                                      else {
                                        boundary['startPos'] = 1; 
                                        boundary['type'] = (boundary['type']) ? boundary['type'] : 'pos'; 
                                      } 
                                      adjust = true; 
                                  }
                                  else if(boundary['startPos'] ==1 && action!='any' && boundary['start'].nodeType ==3 &&  boundary['start'].nodeValue.charCodeAt(0)=='8203' && selection.isCollapsed) {
                                      boundary['zws'] = true; 
                                      boundary['zwsType'] = 'first';
                                      adjust = true;
                                  }
                               }

                               if( action == 'backspace' && selection.isCollapsed && boundary['startPos']==0 &&  Utils.getPrevNode(boundary['start'],boundary['start'].length) === firstChild) {
                                  boundary['zws'] = true; 
                                  boundary['zwsType'] = 'first';
                                  adjust = true; 
                               }

                               if(boundary.direction == 'rtl' && boundary['end'] == firstChild && boundary['endPos'] ==0) {
                                  boundary['endPos'] = 1;

                                  boundary['type'] = (boundary['type']) ? boundary['type'] : 'pos'; 
                                  adjust = true;
                               }

                               if(Utils.isEditorTag(boundary['end']) && boundary['endPos'] ==0) {
                                  boundary['end'] = boundary['end'].firstChild; 
                                  boundary['endPos'] = 1; 
                                  boundary['type'] = (boundary['type']) ? boundary['type'] : 'pos'; 
                                  adjust = true; 
                               } 

                               if(Utils.isEditorTag(boundary['end']) 
                                  && boundary['endPos'] == boundary['end'].childNodes.length 
                                  && boundary['end'].lastChild && boundary['end'].lastChild.nodeType == 3
                                  && boundary['end'].lastChild.nodeValue.charCodeAt(0) == '8203' ) {

                                  boundary['end'] = boundary['end'].firstChild; 
                                  boundary['endPos'] = 1; 
                                  boundary['type'] = (boundary['type']) ? boundary['type'] : 'pos'; 
                                  adjust = true; 
                               }

                              /*For last zero width space*/ 
                              if(boundary.direction == 'ltr' && boundary['end'] === lastChild) {
                                  
                                  length = boundary['end'].length;

                                  if(length > 0 && boundary['endPos'] == length) {

                                      if(selection.isCollapsed) {
                                        boundary['endPos'] = boundary['startPos'] = length-1; 
                                        boundary['type'] = (boundary['type']) ? boundary['type'] : 'pos';
                                      }
                                      else {
                                        boundary['endPos'] = length-1; 
                                        boundary['type'] = (boundary['type']) ? boundary['type'] : 'pos'; 
                                      } 
                                      adjust = true; 
                                  }
                                  else if(boundary['endPos'] ==(length-1) && action!='any' && boundary['end'].nodeType ==3 &&  boundary['end'].nodeValue.charCodeAt(length-1)=='8203' && selection.isCollapsed) {
                                      boundary['zws'] = true; 
                                      boundary['zwsType'] = 'last';
                                      adjust = true;
                                  }
                               }

                               if( action == 'delete' && selection.isCollapsed && boundary['end'].length == boundary['endPos'] &&  Utils.getNextNode(boundary['end'],boundary['endPos']) === lastChild) {
                                  boundary['zws'] = true; 
                                  boundary['zwsType'] = 'last';
                                  adjust = true; 
                               }

                               length = boundary['start'].length;
                               if(boundary.direction == 'rtl' && boundary['start'] == lastChild && boundary['startPos'] ==length) {
                                  boundary['startPos'] = length-1; 

                                  boundary['type'] = (boundary['type']) ? boundary['type'] : 'pos';
                                  adjust = true;
                               }               
                                      
                               blockData = nodeData = nodeToBechecked = firstChild = lastChild = current = null;
                               return adjust ? boundary : false;
                           },

                           parseText : function (text) {

                              text =  text.replace(emoPattern, function(match) {
                                  var attrs = [];
                                  attrs['class']  = 'em_list '+emoMap[match].replace(/\.[A-Za-z]{3}/,'');
                                  attrs['title']  = match;
                                  attrs['data-link']  = match;
                                  attrs['text']  = '<b>'+match.replace(/</g, '&lt;').replace(/>/g, '&gt;')+'</b>&nbsp;';
                                  return Utils.getBlockHTML(attrs);
                               });

                              return text;

                           },

                           removeClass : function(node) {

                              if(!node) return;
                              var elmentList = node.querySelectorAll('.caret'), i;

                              for(i=0;i<elmentList.length;i++) {
                                 elmentList[i].className =  elmentList[i].className.replace('caret','').trim();
                              }
                              elmentList = null;
                           },

                           adjustMarkup : function(node) {

                              if(!node) return;
                              var elmentList = node.querySelectorAll('.em_list'), i;

                              for(i=0;i<elmentList.length;i++) {
                                 elmentList[i].innerHTML = '<b>'+elmentList[i].getAttribute('data-link')+'</b>&nbsp;';
                              }
                              elmentList = null;

                           },
                            
                           getBlockHTML : function(attrs) {

                              var html = '<a href="#" onclick="return false" class="'+attrs['class']+' caret" title="'+attrs['title']+'" data-link="'+attrs['data-link']+'" spellcheck="false" data-block="true">'+attrs['text']+'</a>';
                              return html; 
                           }, 

                           getPrevNode : function(node,selfOffset) {

                               selfOffset = (typeof selfOffset !== 'undefined') && (selfOffset !== null) ? selfOffset : 0;

                               if(!node) return node;

                               if(node.length > selfOffset) {
                                  return node;
                               }
                              
                              var prevNode = node.previousSibling;

                              while(prevNode) {

                                if(prevNode.length > 0 || prevNode.nodeType == 1) {
                                   break;
                                }

                                prevNode = prevNode.previousSibling;
                               }

                               return prevNode;
                          },

                          getNextNode : function(node, selfOffset) {

                              selfOffset = (typeof selfOffset !== 'undefined') && (selfOffset !== null) ? selfOffset : 0;

                              if(!node) return node;

                              if(node.length > selfOffset) {
                                  return node;
                              }
                              
                              var nextNode = node.nextSibling;

                              while(nextNode) {

                                if(nextNode.length > 0 || nextNode.nodeType == 1) {
                                   break;
                                }
                                nextNode = nextNode.nextSibling;
                              }

                              return nextNode;

                          },

                          getNode : function(node,type,selfOffset) { 

                              var result = Object.create(null), self = false, isEditorNode = this.isEditorTag(node);

                              if(!node) return node;

                              result['node'] = null;

                              type = (typeof type !== 'undefined') && (type !== null) ? type : 'prev';
                              selfOffset = (typeof selfOffset !== 'undefined') && (selfOffset !== null) ? selfOffset : 0;
                              
                              if(node.length > selfOffset) {
                                 self = true;
                              }

                              if(!isEditorNode) {
                                result['node'] = (type == 'prev') ? this.getPrevNode(node,selfOffset) : this.getNextNode(node,selfOffset); 
                              }
                              
                              if(result['node']) {

                                  if(type == 'prev') {
                                   result['pos'] = self ? (result['node'].length - selfOffset) : result['node'].length;
                                  }

                                  if(type == 'next') {
                                       result['pos'] = self  ? (result['node'].length - selfOffset) : 0;
                                  } 

                                  result['type'] = 'pos';
                              }
                              
                              result['parent'] = false;

                              if(!result['node']) {
                                result['node'] = isEditorNode ? node : node.parentNode;
                                result['pos'] = (type == 'next') ? result['node'].childNodes.length : 0;
                                result['type'] = 'pos';
                                result['parent'] = true;
                              }

                              return result;  
                          },

                          isEditorTag : function(node) {

                              return (node && node.nodeType==1 && node.getAttribute('data-editor')=='true') || false;
                          },

                          isEmpty : function(node) {

                              if(node.childNodes.length ==0) return false;

                              var nextNode = node.firstChild;

                              while(nextNode) {

                                if(nextNode.nodeType ==1 || nextNode.length > 0) {
                                   break;
                                }
                                nextNode = nextNode.nextSibling;
                              }

                              return (nextNode) ? false : true;
                          },

                          getFirstNode : function(node, ignoreZWS) {

                              if(node.childNodes.length ==0) return false;

                              var nextNode = node.firstChild;

                              ignoreZWS = (typeof ignoreZWS !== 'undefined') && (ignoreZWS !== null) ? ignoreZWS : false;

                              while(nextNode) {

                                if(nextNode.nodeType ==1 || nextNode.length > 0) {

                                   if(!ignoreZWS || nextNode.nodeType !=3 || nextNode.length > 1 || nextNode.nodeValue.charCodeAt(0) != '8203') {
                                      break;
                                   }
                                   
                                }
                                nextNode = nextNode.nextSibling;
                              }

                              return nextNode;
                          },

                          findCurrentWord : function(delimiter, parent) {

                              var sel = Cursor.getSelection(),i,
                                  nodeText = '', delimiterPos = -1, word = '', 
                                  spaceFound = false,
                                  firstChild = Utils.getFirstNode(parent, true);

                               delimiter = delimiter ? delimiter : null;   

                               var ieFix = (prefix == 'ms' && Utils.isEditorTag(sel.focusNode) && sel.focusNode.childNodes[sel.focusOffset].nodeType  == 3 && sel.focusNode.childNodes[sel.focusOffset].nodeValue.charCodeAt(0) == '8203') ? true : false;

                               if(sel && sel.focusNode.nodeType == 3 || ieFix) {

                                 nodeText = ieFix ? sel.focusNode.childNodes[sel.focusOffset-1].nodeValue : sel.focusNode.nodeValue.substr(0, sel.anchorOffset);
                                 nodeText = nodeText.replace(/\s+$/,'');
                                 delimiterPos = (delimiter) ? nodeText.lastIndexOf(delimiter) : 1;

                                 
                                 if(delimiterPos >= 0) {

                                    for(i = nodeText.length -1; i >= 0; i-- ) {

                                      if(/\s/.test(nodeText[i])) {
                                         spaceFound = true;
                                         break;
                                      }
                                       
                                      if(nodeText[i] == delimiter) {
                                        word = nodeText[i]+word;
                                        break; 
                                      } 
                                      word = nodeText[i]+word;
                                    } 
                                 }
                                 
                              }

                              /* If delimiter is space, we can return*/  
                              if(delimiter == null) {
                                
                                if(!spaceFound && !ieFix && firstChild !== sel.anchorNode) {
                                  word = '';
                                }
                                firstChild = null;
                                return word;
                              } 

                              if(word[0] != delimiter) word = '';

                              if(word.length > 1 && ((firstChild === sel.anchorNode && sel.anchorNode.nodeValue[0] == delimiter) 
                                  || ieFix
                                  || (parent.firstChild === sel.anchorNode && sel.anchorNode.nodeValue[1] == delimiter) 
                                  || (sel.anchorNode.previousSibling && sel.anchorNode.previousSibling.nodeType == 3 && sel.anchorNode.previousSibling.nodeValue.charCodeAt(sel.anchorNode.previousSibling.length-1) == 32)
                                  || nodeText.charCodeAt(delimiterPos-1) == 32) 
                                  || nodeText.charCodeAt(delimiterPos-1) == 160) {
                                
                                 word = word.replace(delimiter,''); 
                              } 
                              else {
                                word = ''; 
                              }

                              firstChild = null;
                              return word;
                          },

                          findPos : function (el) {
                              var x = 0, y = 0;
                              if (el.offsetParent) {
                                  do {
                                      x += el.offsetLeft;
                                      y += el.offsetTop;
                                  } while (el = el.offsetParent);
                              }
                              return {x: x, y: y};
                          }

                      };

                     /*Curor, seleciton and range Utility*/
                     var Cursor = {
                         
                          toPos : function(el, pos) {
                            
                             var sel = this.getSelection(),
                             range =  this.getRange();

                              /* if pos is not defined, consider length for text node and childnode.length for element node*/
                              pos = (typeof pos !== 'undefined') && (pos !== null) ? pos : (el.length || el.childNodes.length);   

                              range.setStart(el, pos);
                              range.setEnd(el, pos);
                              range.collapse(true);
                              sel.removeAllRanges();
                              sel.addRange(range);  
                              range.detach();
                              sel = null; 
                          }, 

                          toElementStart : function(el, focus) {
                            if(focus) el.focus();
                            this.toPos(el, 0);
                          },

                          toElmentEnd : function(el, focus) {
                            if(focus) el.focus();

                            if(Utils.isEditorTag(el) && el.lastChild 
                              && el.lastChild.nodeType ==3 
                              && el.lastChild.nodeValue.charCodeAt(el.lastChild.nodeValue.length-1)=='8203') {
                              this.toPos(el.lastChild,el.lastChild.nodeValue.length-1);
                              return;
                            }
                            this.toPos(el);
                          },

                          toElmentBefore : function(el) {
                             var sel = this.getSelection(),
                             range =  this.getRange();
                             range.setStartBefore(el);
                             range.collapse(true);
                             sel.removeAllRanges();
                             sel.addRange(range);  
                             range.detach();
                             sel = null; 
                          },

                          toElmentAfter : function(el) {
                             var sel = this.getSelection(),
                             range =  this.getRange();
                             range.setStartAfter(el);
                             range.collapse(true);
                             sel.removeAllRanges();
                             sel.addRange(range); 
                             range.detach();

                             sel = null; 
                          },

                          toElementByType : function (el, type, pos) {
                             
                             type = (typeof type !== 'undefined') ? type : 'end';

                             if (type == 'end') {
                                this.toElmentEnd(el);
                             }

                             if (type == 'start') {
                                this.toElementStart(el);
                             }

                             if(type == 'pos') {
                                this.toPos(el, pos);
                             }
                             
                          },

                          deleteContents : function(startEl, startPos, endEl, endPos) {
                              
                              var sel = this.getSelection(), range =  this.getRange();

                              startPos = (typeof startPos !== 'undefined') && (startPos !== null) ? startPos : (startEl.length || startEl.childNodes.length);
                              endEl = (typeof endEl !== 'undefined') ? endEl : startEl;
                              endPos = (typeof endPos !== 'undefined') && (endPos !== null) ? endPos : (endEl.length || endEl.childNodes.length);  

                              if(startEl === endEl && startPos == endPos ) return;

                              if(startEl.nodeType == 1) {
                                  range.setStartBefore(startEl);     
                              }
                              else {
                                 range.setStart(startEl, startPos);  
                              }

                              if(endEl.nodeType == 1) {
                                  range.setEndAfter(endEl);     
                              }
                              else {
                                 range.setEnd(endEl, endPos); 
                              } 

                              //range.deleteContents();
                              sel.removeAllRanges();
                              sel.addRange(range); 
                              document.execCommand('delete', false);
                              range.detach();
                          },

                          insertHtml : function(html) {

                              var sel = this.getSelection(), range =  this.getCurrentRange();

                              if(this.isIE()) {
                                range.pasteHTML(html); 
                              }
                              else if(isIE11) {
                                  
                                  var el = document.createElement('div'), frag = document.createDocumentFragment(), node;
                                  el.innerHTML = html;

                                  while ( (node = el.firstChild) ) {
                                     frag.appendChild(node);
                                  }
                                  range.insertNode(frag); 

                                  el = frag = node = null;
                              }
                              else {
                                   
                                  document.execCommand('insertHtml', false, html); 
                              }
                          },

                          getSelection : function() {
                            return (this.isIE()) ? document.selection : window.getSelection();  
                          },

                          isIE : function () {
                              return document.selection && document.selection.type != "Control";
                          },

                          extendSelection : function(boundary, nativeAPI) {
                              
                              var sel = this.getSelection(),
                              range =  this.getRange();

                              nativeAPI = (nativeAPI != 'undefined') && (nativeAPI != null) ? nativeAPI : true;

                              /*If browser support extend method, then extend natively*/
                              if(sel.extend && nativeAPI) {
                                 
                                 sel.extend(boundary['end'], boundary['endPos']);
                                 return;
                              }

                              if(boundary.direction == 'ltr') {
                                range.setStart(boundary['start'], boundary['startPos']);
                                range.setEnd(boundary['end'], boundary['endPos']); 
                              }
                              else {
                                range.setStart(boundary['end'], boundary['endPos']);
                                range.setEnd(boundary['start'], boundary['startPos']);
                              }
                              
                              sel.removeAllRanges();
                              sel.addRange(range);  
                              range.detach();

                              sel = null; 
                          },

                          reset : function () {

                             var sel = this.getSelection(), range = this.getRange(), direction = this.getDirection();

                             if(direction == 'ltr') {
                               range.setStart(sel.focusNode, sel.focusOffset);
                             }
                             else {
                              range.setStart(sel.anchorNode, sel.anchorOffset);
                             }
                             
                             range.collapse(true);
                             sel.removeAllRanges();
                             sel.addRange(range);  
                             range.detach();
                             sel = null;
                          },

                          getRange : function() {
                            return document.createRange();
                          },

                          getCurrentRange : function() {
                             var sel = this.getSelection();

                             if(this.isIE()) return sel.createRange();

                             return (sel.rangeCount) ? sel.getRangeAt(0) : false;
                          },

                          getDirection : function() {

                               var sel = this.getSelection(), backwards = false,
                               range = this.getRange();

                               if(sel && !sel.isCollapsed) {

                                  range.setStart(sel.anchorNode, sel.anchorOffset);
                                  range.setEnd(sel.focusNode, sel.focusOffset);
                                  backwards = range.collapsed;
                                  range.detach();
                               }

                               sel = null;
                               return backwards ? 'rtl' : 'ltr';
                          },

                          intersectsNode : function(node) {
                            
                            var range = this.getCurrentRange(), found = null; 
                            found = range.commonAncestorContainer;

                             if(range.intersectsNode) {
                                return range.intersectsNode(node);
                             }

                             while(found) {
                              
                                if(found === node) {
                                   break;
                                }
                                found = found.parentNode;
                              }

                              return found ? true : false;
                          }
                  };


                  /* Editor Instance creator*/
                  function Editor(option) {

                            var that = this;  
                            this.content = '';
                            this.tagOpen     = false;
                            this.fragment    = null;
                            this.dom         = {};
                            this.processors  = [];
                            this.callback    = [];
                            this.lastDisable = 0;
                            this.maxHeight = 0;

                            this.init = function (option) {

                                this.newLine     = option.newLine === false? false : true;
                                this.maxHeight   = option.maxHeight;
                                this.placeholder = option.placeholder || '';
                                this.isDisabled  = option.isDisabled || false;
                                this.emotion     = option.emotion ? option.emotion : null;

                                this.fragment = document.createDocumentFragment();

                                this.dom.placeholder = document.createElement('span');
                                this.dom.placeholder.setAttribute('data-placeholder', this.placeholder);
                                this.fragment.appendChild(this.dom.placeholder);

                                this.dom.editor = document.createElement('div');
                                this.dom.editor.setAttribute('contenteditable', 'true');
                                this.dom.editor.setAttribute('spellcheck', 'true');
                                this.dom.editor.setAttribute('data-editor', 'true');
                                this.dom.editor.setAttribute('class', 'editor');
                                this.fragment.appendChild(this.dom.editor);

                                if(this.emotion) {
                                   this.fragment.appendChild(this.emotion); 
                                } 

                               this.addProcessor('keydown', false, this.checkDisability, this);
                               this.addProcessor('keydown', 'enter',  this.checkNewLine, this);
                               this.addProcessor('both', 'enter,up,down', this.checkTag, this);
                               
                               this.addCallback('keyup', 'delete,backspace', this.checkBR, this);
                               this.addCallback('keyup', false, this.addDelimiter, this);
                               this.addCallback('keydown', false, this.setPlaceholderContent, this);
                               this.addCallback('keyup', false, this.updateContent, this);
                              
                              /*add an inital br node for positioning cursor correctly*/
                               this.addDelimiter();
                               this.initEvent();

                               if(this.maxHeight > 0) {
                                 this.dom.editor.style.maxHeight = this.maxHeight+'px';
                               }
                            };

                             this.addDelimiter = function () {
                               
                               var text = this.dom.editor.innerText || this.dom.editor.textContent, 
                                   textNode, firstChild;

                               firstChild = Utils.getFirstNode(this.dom.editor);

                               if(text.charCodeAt(0) != '8203') {
                                  textNode = document.createTextNode("\u200B");

                                  if(firstChild) {
                                     this.dom.editor.insertBefore(textNode,firstChild); 
                                  }
                                  else {
                                     this.dom.editor.appendChild(textNode); 
                                  }
                               }

                               /* add last zws*/
                               text = this.dom.editor.innerText || this.dom.editor.textContent;
                               if(text.length == 1 || text.charCodeAt(text.length-1) != '8203') {
                                  textNode = document.createTextNode("\u200B");
                                  this.dom.editor.appendChild(textNode); 
                               }
                               /* append done */

                               firstChild = textNode= null;   
                            };
                            
                             this.addProcessor = function(event, action, fn, context) {
                                this.processors.push({'event':event, 'action':action, 'fn':fn, 'context':context});
                             };

                             this.addCallback = function(event, action, fn, context) {
                                this.callback.push({'event':event, 'action':action, 'fn':fn, 'context':context});
                             };

                             this.setFocus = function () {
                                Cursor.toElmentEnd(this.dom.editor, true);
                             };

                             this.showError = function () {
                                this.hideError();
                                this.dom.editor.className =  this.dom.editor.className+' error';
                             };

                             this.hideError = function () {
                                this.dom.editor.className =  this.dom.editor.className.replace('error','').trim();
                             };

                             this.enable = function () {
                                this.isDisabled = false;
                             };

                             this.disable = function () {
                                this.isDisabled = true;
                             };

                             this.set = function (content) {
                                if(!content) return;

                                /*revert to editor mode*/
                                content = content.replace(/\n/g, '<br />');
                                content = content.replace(/href="(.*?)"/g, 'href="#"');
                                content = content.replace(/<span/g, '<a href="#" onclick="return false" data-block="true"');
                                content = content.replace(/<\/span>/g, '</a>');
                                content = content.replace(/class="tag"/g, 'class="tag" onclick="return false" data-block="true"');
                                
                                this.dom.editor.innerHTML = content;
                                this.updateContent();

                                this.addDelimiter();
                                Utils.adjustMarkup(this.dom.editor);
                             };

                             this.get = function () {
                                return this.content;
                             };

                             this.clear = function () {
                                this.dom.editor.innerHTML = '';
                                this.dom.placeholder.innerHTML = '';
                                this.updateContent();

                                this.addDelimiter();

                                $rootScope.unloadWarn = false;
                             };

                             this.setNewLineMode = function (mode) {
                                this.newLine = mode;
                             };

                             this.getNode = function () {
                                return this.fragment;
                             };

                             this.addEmoticon = function (code) {
                                Modifiers.setContainer(this.dom.editor, true);
                                Modifiers.addEmoticon(code, true);
                                this.updateContent();
                             };
                             
                             this.addTag = function (user, filterFriend) {
                                Modifiers.setContainer(this.dom.editor, true);
                                Modifiers.addTag(user, filterFriend);  
                                this.updateContent();
                             },

                             this.findWord = function (delimiter) {
                                return Utils.findCurrentWord(delimiter, this.dom.editor);
                             };

                             /* Methods for communicating externally*/
                             this.setPlaceholderContent = function(event, keyCode) {
                                
                                if(event.ctrlKey || event.shiftKey || event.metaKey) return;

                                if(!keys[keyCode] && this.dom.placeholder.innerHTML == '') {
                                  this.dom.placeholder.innerHTML = String.fromCharCode(keyCode);  
                                } 
                             };

                             this.checkDisability = function (event, keyCode) {

                                 if(this.isDisabled) {
                                    event.preventDefault();
                                    this.lastDisable = new Date().getTime() / 1000;

                                    if(new Date().getTime() - this.lastDisable > 2000) {
                                      this.isDisabled = false;
                                    }

                                    return false;
                                 }

                                 return true;
                             };

                             this.checkTag = function (event, keyCode) {

                                  if(this.tagOpen) {
                                    event.preventDefault();
                                    return false;
                                 }

                                 return true;
                             };

                             this.checkNewLine = function (event, keyCode) {

                                 if(!this.newLine && !event.shiftKey && !event.ctrlKey) {
                                   event.preventDefault();
                                   return false;
                                 }

                                 return true;
                             };

                             this.checkBR = function (event, keyCode) {
                                /*Firefox oops! buggy.. inserting extra br if there is no node*/
                                if(this.dom.editor.firstElementChild && this.dom.editor.firstElementChild === this.dom.editor.lastElementChild && this.dom.editor.firstElementChild.nodeName.toLowerCase() =='br') {
                                   this.dom.editor.removeChild(this.dom.editor.firstElementChild);
                                }
                               
                             }

                            
                             this.updateContent = function (event, keyCode) {
                        
                                    var content = this.dom.editor.innerHTML.replace(/<br>/g, '\n');
                                    content = content.replace(/&lt;/g,'<');
                                    content = content.replace(/&gt;/g,'>');
                                    content = content.replace(/&amp;/g,'&');
                                    content = content.replace(/&nbsp;/g, ' ');
                                    content = content.replace(/\u200B/g, '');
                                    content = content.replace(/\n{3,}/g, '\n\n');

                                    content = content.replace(dataBlockPattern,function(match,$1) {
                                        return isNaN($1)? $1 : '##'+$1+'##';
                                    });

                                    this.content = content.trim();
                                    
                                    var placeholder = this.dom.editor.innerHTML.replace(/<br>/g, '\n');
                                    placeholder = placeholder.replace(/&nbsp;/g, ' ');
                                    placeholder = placeholder.replace(/\u200B/g, '');
                                    placeholder = placeholder.replace(/\n{3,}/g, '\n\n');
                                    this.dom.placeholder.innerHTML = placeholder;

                                    if(this.onUpdate && typeof this.onUpdate == 'function') {
                                      this.onUpdate.call(null);
                                    }

                                    if(this.content != "") {
                                      $rootScope.unloadWarn = true; 
                                    }
                                    else
                                    {
                                      $rootScope.unloadWarn = false;  
                                    }  

                              };

                             this.initEvent = function () {
                                    this.dom.editor.addEventListener('mouseup', mouseupCallback);
                                    this.dom.editor.addEventListener('keydown', keydownCallback);
                                    this.dom.editor.addEventListener('keyup', keyupCallback);
                                    this.dom.editor.addEventListener('dragover', dragoverCallback);
                                    this.dom.editor.addEventListener('drop', dropCallback);
                                    this.dom.editor.addEventListener('paste',  pasteCallback);
                                    this.dom.editor.addEventListener('cut',cutCallback);
                             };

                            this.getPosition = function () {

                                var  x=0, y=0, rect =  this.dom.editor.getBoundingClientRect(), 
                                rangeRect = Cursor.getCurrentRange().getClientRects();

                                x = rect.left;
                                y = rect.top;

                                if(rangeRect.length > 0) {
                                   rangeRect = rangeRect[0];
                                   x = rangeRect.left - x;
                                   y = rangeRect.top - y;
                                } 

                                return {'x':x, 'y':y+12};
                            }

                            this.destroy = function () {
                                this.dom.editor.removeEventListener('mouseup', mouseupCallback);
                                this.dom.editor.removeEventListener('keydown', keydownCallback);
                                this.dom.editor.removeEventListener('keyup', keyupCallback);
                                this.dom.editor.removeEventListener('dragover', dragoverCallback);
                                this.dom.editor.removeEventListener('drop', dropCallback);
                                this.dom.editor.removeEventListener('paste', pasteCallback);
                                this.dom.editor.removeEventListener('cut', cutCallback);
                                this.dom = that = null;
                                $rootScope.unloadWarn = false;  
                            };

                            this.init(option);

                             /*Callback method*/
                             function mouseupCallback(e){
                                  Modifiers.init(that.dom.editor,'00',e, that.callback, that.processors);
                                  e.stopPropagation();
                             }

                             function keydownCallback(e) {
                                  e.stopPropagation();
                                  var keyCode = e.which || e.keyCode || e.key;
                                  Modifiers.init(that.dom.editor, keyCode, e, that.callback, that.processors);
                              }

                             function keyupCallback(e) {
                                  e.stopPropagation();
                                  var keyCode = e.which || e.keyCode || e.key;
                                  Modifiers.init(that.dom.editor, keyCode, e, that.callback, that.processors);
                              }

                              function dragoverCallback(e) {
                                  e.stopPropagation();
                                  e.preventDefault();
                                  return false;  
                              }

                              function dropCallback(e) {
                                  e.stopPropagation();
                                  e.preventDefault();
                                  return false;  
                              } 

                              function pasteCallback(e) {
                                           
                                  e.stopPropagation();
                                  e.preventDefault();
                                  var text = '';
                                     
                                  if (e.clipboardData) {
                                      text = e.clipboardData.getData('text/plain');
                                    }
                                  else if (window.clipboardData) {
                                    try {
                                       text = window.clipboardData.getData('Text');
                                    } catch (e) {
                                       console.log('clipboard copy error');
                                    }
                                  }

                                  text = text.replace(/\n/g, '<br />');
                                  text = text.replace(/\s\s+/g, ' ');
                                  Modifiers.paste(text);
                                  that.updateContent();
                              }

                             function cutCallback(e) {  
                                  e.stopPropagation(); 
                                  that.updateContent();
                              }
                             /*End of callback*/ 
                    }   


                  /*At last, lets focus on editor Provider actually huh!*/    
                  var $editorProvider = {};    
                  $editorProvider.create = function (option) {
                        var editor = new Editor(option);
                        return editor;
                    } 

                  return $editorProvider;    
        }];  
    }

          

    rgEditor.$inject = ['$compile','$editor'];

    function rgEditor( $compile, $editor) {
    

        function link(scope, element, attrs) {


                  var editor, showSticker, option, DropdownFriendElement;

                      scope.filterFriend = "";
                      scope.editorContent = "";

                      showSticker = attrs['showSticker'] == "true" || attrs['showSticker'] === true ? 'true' : 'false';

                      option = {
                        'newLine': attrs['newLine'] == "false" || attrs['newLine'] === false ? false : true,
                        'placeholder': attrs['placeholder'] ? attrs['placeholder'] : '',
                        'isDisabled': attrs['isDisabled'] == "true" || attrs['newLine'] === true ? true : false,
                        'maxHeight': attrs['maxHeight'] ? parseInt(attrs['maxHeight']) : 0 
                      };


                      if(attrs['showEmoji']) {
                          option['emotion'] = $compile('<a href="javascript:void(0)"><i class="icon-emoticon ico-sty" rg-emoticon="" clicked="insertEmoji" show-sticker="'+showSticker+'"></i></a>')(scope)[0];
                          element.addClass('with_emo');
                      }

                      editor = $editor.create(option); 
                      element.append(editor.getNode());
                      editor.onUpdate = updateContent;

                      scope.insertEmoji = function(emoticon) {
                         editor.addEmoticon(emoticon.symbol(),true);
                      }

                      scope.closeDropdownFriend = function() {

                         if(DropdownFriendElement){
                             DropdownFriendElement.remove();
                             DropdownFriendElement = undefined;
                          }

                          editor.tagOpen = false;
                      }

                      scope.chooseFriend = function(user, $event) {

                          if(scope.filterFriend) {
                              editor.addTag(user, scope.filterFriend);
                              scope.closeDropdownFriend();
                          }
                       };


                       function processAtTagFriend(e, keyCode) {

                           scope.filterFriend = editor.findWord('@');

                           if(keyCode == 32) scope.filterFriend = "";
                           
                           if(scope.filterFriend == "" && DropdownFriendElement){
                              scope.closeDropdownFriend();
                           }

                           if(scope.filterFriend && !DropdownFriendElement){
                              DropdownFriendElement = $compile('<rg-friend-dropdown template-url="pages/dropdowns/tag-editor-dropdown.html" tag-items="[]" filter-text="filterFriend" focus-filter="" on-close="closeDropdownFriend" on-select="chooseFriend"></rg-friend-dropdown>')(scope);
                              element.after(DropdownFriendElement);

                              var pos = editor.getPosition();
                              DropdownFriendElement.css({'position':'absolute','left':pos.x+'px', 'top': pos.y+'px'});
                           }

                           if(DropdownFriendElement) {

                               editor.tagOpen = true;

                               /* Close dropdown if click on document*/
                               document.addEventListener('click', function friendDDCallback(e) {
                                  if(DropdownFriendElement && e.target !== DropdownFriendElement[0]) {
                                     scope.closeDropdownFriend(); 
                                  } 
                                  document.removeEventListener('click', friendDDCallback);  
                               }, false);
                           } 

                        }

                        function tagKeyHander(e, keyCode) {
                           if(DropdownFriendElement) {
                             e.preventDefault();
                             DropdownFriendElement.triggerHandler(e,keyCode);
                           }

                           return true;
                        }

                        function updateContent(e, keyCode) {
                           
                           scope.editorContent = editor.get();

                           if(scope.$parent && scope.$parent.$id !==1){
                                scope.$parent.$rgDigest();
                            } else{
                                scope.$rgDigest();
                            }
                        }


                       if(attrs['tagFriend']) {
                          editor.addCallback('keyup', false, processAtTagFriend, null);
                          editor.addCallback('keyup', 'escape', scope.closeDropdownFriend, scope);

                          editor.addProcessor('keydown', 'up,down,enter', tagKeyHander, null);
                       }

                       if (attrs['onEscape']) {
                           editor.addCallback('keyup', 'escape', scope.onEscape(), scope);
                       }

                       if (attrs['onEnter']) {
                           
                           editor.addProcessor('keydown', 'enter', function(event, keyCode) {
                                if(option.newLine === false && !event.shiftKey && !event.ctrlKey) {
                                   scope.onEnter()(scope.onEnterArg);
                                   return false;
                                }
                                return true;
                            }); 
                       }

                      
                      /* this is basically making editor empty when post a feed*/
                        scope.$on('cleareditor', function () {
                            editor.clear();
                        });

                        scope.$on('seteditor', function (e,content) {
                            content = content || scope.editorContent;
                            editor.set(content);
                        });

                        /* It is a scope properties. It will make editor disabled from typing */
                        scope.$watch('isDisabled', function (value) {
                             
                             if(!!value) {
                                editor.disable();
                                editor.clear();
                             }
                             else {
                               editor.enable();
                             }
                        });

                        /*on focus*/
                        if (attrs['focus']) {
                            scope.$watch('focus', function (value) {
                                if (value) {
                                    setTimeout(function () {
                                        editor.setFocus();
                                    }, 0);

                                    /*fetch data on edit mode*/
                                    if (attrs['editMode']) {
                                      editor.set(scope.editMode()().toString());
                                    }
                                }
                            });
                        }
                      
                        /*On scope destry, clear resource*/
                        scope.$on("$destroy",function(){
                            editor.destroy();
                            editor = option = DropdownFriendElement = null;
                        }); 

              }

        return {
            scope: {
                editorContent: '=',
                onEnter: '&',
                onEscape: '&',
                onEnterArg: '=',
                isDisabled: '=',
                focus: '=',
                editMode: '&'
            },
            restrict: 'E',
            link: link
        }
    }
})();
/**
 * Copyright @ 2015 by RingID Inc.
 *
 */


(function () {
    'use strict';

    angular
        .module('ringid.common.emotion_directives', ['ringid.common.emotion_factory'])
        .directive('rgEmotion', rgEmotionDirective)
        .directive('rgEmotionDropdown', rgEmotionDropDOwn);

    rgEmotionDirective.$inject = ['$compile','$document','EmotionFactory'];
    function rgEmotionDirective($compile,$document,EmotionFactory) { // jshint ignore:line


        //function controllerFn($scope,$element){
        //
        //    var emotionDropdownElement;
        //    $scope.emotions = [];
        //    $scope.initEMotionList = function(){
        //        if(!emotionDropdownElement){
        //            emotionDropdownElement = $compile('<rg-emotion-dropdown filter-text='emotionFilterText' on-select='choose'></rg-emotion-dropdown>')($scope);
        //            $element.append(emotionDropdownElement);
        //        }
        //    };
        //    $scope.choose = function(subCat){
        //        $scope.emotions.length = 0;//note : now we only support one media at a limt
        //        $scope.emotions.push(subCat);
        //        $scope.showEmotion = false;
        //        $scope.emotionFilterText = '';
        //    };
        //
        //}
        return {
            restrict : 'A',
            scope : {
            //showWhen : '=',
                onSelect : '&'
            },
            //template : '',
            //controller : controllerFn,
            link : function(scope, element){
                var emotionDropdownElement;
                scope.active=false;
                scope.emotionFilterText = '';
                   function safeDigest(){
                        if(scope.$parent && scope.$parent.$id !==1){
                            scope.$parent.$rgDigest();
                        }else{
                            scope.$rgDigest();
                        }
                    }
                scope.initEMotionList = function(display){
                     EmotionFactory.init();
                    if(!emotionDropdownElement){
                        emotionDropdownElement = $compile('<rg-emotion-dropdown filter-text="emotionFilterText" focus-filter="active" on-close="close" on-select="choose"></rg-emotion-dropdown>')(scope);
                        element.after(emotionDropdownElement);
                        //emotionDropdownElement.css({
                        //    top : (event.pageY+10) +'px',
                        //    left : (event.pageX+10) + 'px'
                        //});
                    }

                    emotionDropdownElement.css('display',display);
                };
                scope.choose = function(subCat,$event){
                    scope.onSelect({item:subCat});
                    scope.emotionFilterText = '';
                    scope.initEMotionList('none',$event);
                    scope.active = false;
                    //document on lick will close the box so no need to close
                    safeDigest();
                };
               // scope.$watch('showWhen',function(newVal){
               //     var display = 'none';
               //     if(newVal){
               //         display = 'block';
               //         scope.initEMotionList(display);
               //     }
               //     //element.css('display',display);
               //});
                function showBox(event){
                    event.preventDefault();
                    //event.stopPropagation();
                    if(scope.active){
                        scope.initEMotionList('none',event);
                    }else{
                        scope.initEMotionList('block',event);
                    }
                    scope.active = !scope.active;
                    safeDigest();
                }
                element.on('click',showBox);
                function checkToHide(e){
                     if(e.target !== element[0] &&
                        e.target.parentNode &&
                        e.target.parentNode !== element[0] &&
                        e.target.parentNode.parentNode !== element[0] &&
                        e.target.className !== 'pt-top') {
                        scope.close(e);
                    }
                }
                $document.on('click',checkToHide);
                scope.close = function(event){
                    if(scope.active){
                        scope.initEMotionList('none',event);
                        scope.active = false;
                    }
                    safeDigest();
                };
                scope.$on('$destroy',function(){
                    element.off('click',showBox);
                    $document.off('click',checkToHide);
                    emotionDropdownElement = undefined;
                });

            }
           // template : 'pages/common/emotion-dropdown.html'
        };
    }



    rgEmotionDropDOwn.$inject = ['EmotionFactory'];
    function rgEmotionDropDOwn(EmotionFactory){ // jshint ignore:line
        function bindClick(event){
            event.stopPropagation();
        }
        return {
            scope : {
                filterText: '=filterText',
                focusFilter : '=',
                onSelect : '&',
                onClose : '&onClose'
            },
            templateUrl : 'pages/dropdowns/emotion-dropdown.html',
            compile: function compile() {
                return {
                    pre: function preLink(scope) {
                        scope.emotions={};
                        scope.emotions[0] = EmotionFactory.getEmotions();
                        scope.setEmotion = function(emotions){
                            scope.emotions[0] = emotions;
                            scope.$rgDigest();
                        };
                        EmotionFactory.setScopeForDigest(scope);
                        scope.updateModel = function(e){
                            scope.filterText = e.target.value;
                            scope.$parent.$rgDigest();
                        }
                        scope.loading = !!scope.emotions.length;
                        scope.choose = angular.isFunction(scope.onSelect)? scope.onSelect() : angular.noop;
                        scope.close = angular.isFunction(scope.onClose)? scope.onClose() : angular.noop;
                        // scope.filterName = function(items) { //no use
                        //     var result = {};
                        //     angular.forEach(items, function(value, key) {
                        //         if (!value.hasOwnProperty('secId')) {
                        //             result[key] = value;
                        //         }
                        //     });
                        //     return result;
                        // }
                        scope.$on('$destroy',function () {
                            EmotionFactory.removeScope(scope);
                        });
                    },
                    post: function postLink(scope, iElement) {
                        iElement.on('click',bindClick);
                        scope.$on("$destroy",function(){
                            iElement.off("click",bindClick);
                        });
                        scope.$rgDigest();
                    }
                };
            }
        };
    }

})();


(function() {
	'use strict';

	angular
		.module('ringid.common.rghover_card_directive', [])
		.directive('rgHovercard', rgHovercard);

		rgHovercard.$inject = ['$ringhttp', '$templateCache','$compile','$window'];

		function rgHovercard($ringhttp, $templateCache,$compile,$window){
				var bodyEl = angular.element(document.querySelector('body'));
				return {
					scope : true,
					link: function($scope, iElm, iAttrs) {
						var hoverEl;
							function initiateHover(data){
									var mouseoutFlag = false,timer;
									function closeHoverELement(){
										//console.log("closed called");
										if(mouseoutFlag && hoverEl){
													hoverEl.off('mouseenter',hoverElementMouseEnter);
											    hoverEl.off('mouseleave',hoverElementMouseLeave);
													//hoverEl.css("display",'none');
                            hoverEl.remove();
                            hoverEl = undefined;
													//console.log("close done");
										}
									   mouseoutFlag = false;
									}
									function hoverElementMouseEnter(){
									//	console.log("hover element mouse enter");
										mouseoutFlag = false;
									}
									function hoverElementMouseLeave(){
										//console.log("hover element mouse leave");
										  mouseoutFlag = true;
											closeHoverELement();
									}
									function directiveElMouseEnter(e){
										  if(mouseoutFlag){
                          return;
                      }
											if(!hoverEl){
												hoverEl = angular.element('<div class="fr-menu"></div>');
												hoverEl.html(data);
												iElm.after(hoverEl);
											}
											if(iAttrs.onHoverStart && typeof $scope[iAttrs.onHoverStart] === 'function'){
													$scope[iAttrs.onHoverStart]();
											}

											$compile(hoverEl)($scope);
											//var rect = iElm[0].getBoundingClientRect();
											hoverEl.css({
												display : 'block'
												//left : rect.left +'px',
												//top : rect.bottom + 'px'
											});
											hoverEl.on('mouseleave',hoverElementMouseLeave);
											hoverEl.on('mouseenter',hoverElementMouseEnter);
											$scope.$rgDigest();
									}

									function directiveElMouseLeave(e){
											mouseoutFlag = true;
											window.setTimeout(closeHoverELement,500);
											//console.log("directive element mouse leave");
                      window.clearTimeout(timer);
                      timer = false;
                      iElm.off('mouseleave',directiveElMouseLeave);
									}
                  function initiate(e){
                      if(!timer){
                        timer = window.setTimeout(directiveElMouseEnter.bind(this,e),1200);
                      }
                      iElm.on("mouseleave",directiveElMouseLeave);
                  }
									iElm.on("mouseenter",initiate);
									
									$scope.$on('$destroy', function(){
										  directiveElMouseLeave();
											iElm.off('mouseenter',directiveElMouseEnter);
											iElm.off('mouseleave',directiveElMouseLeave);

									});
							}



							if(iAttrs.rgHovercard !== "false"){
                   $ringhttp.get(iAttrs.hoverTemplateUrl).success(function(result) {
                            initiateHover(result);
                  });
							}


					}
				}



		}


})();

(function() {
    'use strict';
    angular.module('ringid.common.rg_tag_friend', ['ringid.common.rg_friend_dropdown'])
            .directive('rgTagFriend', rgTagFriend);
            // .filter('userListFilter', userListFilter)
            // .directive('rgTagFriendDropdown', rgTagFriendDropdown);
        
        // function userListFilter() {
        //         return function(items, name, tagItems) {
        //             if (items) {
        //                 var filtered = [], tempu;
        //                 var nameMatch = new RegExp(name, 'i');
        //                 for (var i = 0; i < items.length; i++) {
        //                     if (filtered.length > 10)
        //                         return filtered;
        //                     tempu = items[i].value.getLiteUser();
        //                     if (nameMatch.test(tempu.getName()) && tagItems.indexOf(tempu) === -1) {
        //                         filtered.push(tempu);
        //                     }
        //                 }
        //                 return filtered;
        //             }
        //         };
        //     }
    rgTagFriend.$inject = ['$compile', '$document'];
    function rgTagFriend($compile, $document) {
      return {
            restrict : 'A',
            scope : {
                onSelect : '&',
                tagItems : '='
            },
            //template : '',
            //controller : controllerFn,
            link : function(scope,element,attr){
                  if(attr.rgTagFriend === "false"){
                    element.parent().remove();
                    return;
                  }
                var DropdownElement;
                scope.active=false;
                scope.filterText = "";
                scope.init = function(display, event) {
                    if (!DropdownElement) {
                        DropdownElement = $compile('<rg-friend-dropdown tag-items="tagItems" filter-text="filterText" focus-filter="active" on-close="close" on-select="choose"></rg-friend-dropdown>')(scope);
                        element.after(DropdownElement);
                        //DropdownElement.css({
                        //    top : (event.pageY+10) +'px',
                        //    left : (event.pageX+10) + 'px'
                        //});
                       // DropdownElement.on('keydown',processKeyup);
                    };

                    scope.active = true;
                };
                scope.choose = function(subCat, $event) {
                    scope.onSelect({item: subCat});
                    scope.filterText = "";
                    if(scope.$parent && scope.$parent.$id !==1){
                        scope.$parent.$rgDigest();
                    }else{
                        $scope.$rgDigest();
                    }
                    // scope.FilterText = "";
                    //  scope.init("none",$event);
                    //scope.active = false;
                    //document on lick will close the box so no need to close
                };
                // scope.$watch('showWhen',function(newVal){
                //     var display = 'none';
                //     if(newVal){
                //         display = 'block';
                //         scope.init(display);
                //     }
                //     //element.css('display',display);
                //});
                
                function bindFn(event) {
                    event.preventDefault();
                    //event.stopPropagation();
                    if (scope.active) {
                        scope.close(event);
                        $document.off("click", bindDocumentClicktoControlClose);
                    } else {
                        scope.init(event);
                        $document.on("click", bindDocumentClicktoControlClose);
                    }

                }
                function bindDocumentClicktoControlClose (e) {
                    if (e.target != element[0] && e.target.parentNode != element[0] && e.target.parentNode !=null && e.target.parentNode.parentNode != element[0] && e.target.className != 'pt-top') {
                        scope.close(e);
                    }

                }
                element.on("click", bindFn);

                
                scope.close = function(event) {
                    if (scope.active) {
                        DropdownElement.off("keydown");
                        DropdownElement.remove();
                        DropdownElement = undefined;
                        scope.active = false;
                    }
                }

                
                // function processKeyup(e){
                //      var keyCode = e.which || e.keyCode || e.key;
                //     if(keyCode === 38 || keyCode === 40){
                //         e.preventDefault();e.stopPropagation();
                //           DropdownElement.triggerHandler(e,keyCode);
                //         return;
                //     }else if(keyCode === 13){
                //         e.stopPropagation();e.preventDefault();
                //         DropdownElement.triggerHandler(e,keyCode);
                //     }
                // }
                scope.$on("$destroy", function() {
                    element.off("click",bindFn);
                    $document.off("click",bindDocumentClicktoControlClose);
                    if(DropdownElement){
                        //DropdownElement.off("keydown");
                        DropdownElement = undefined;
                    }
                    
                });

            }
            // template : 'pages/common/emotion-dropdown.html'
        }
    }

})();

/*
 * © Ipvision
 */

angular.module('ringid.common.rg_column', ['ngRoute'])
.directive('rgColumn', ['$document','Storage','utilsFactory',
    function ($document,Storage,utilsFactory) {
        return {
            restrict: "A",
            controller : ['utilsFactory','$scope','SystemEvents','$rootScope',
            function(utilsFactory,$scope,SystemEvents,$rootScope){
                $scope.spans = utilsFactory.feedColumn();
                $scope.defaultSpan = utilsFactory.getDefaultColumn();
                $scope.choose = function(val){

                    utilsFactory.resetScroll();
                    utilsFactory.animateScroll();    

                    utilsFactory.setFeedColumn(val);
                    $scope.spans = val;
                    $rootScope.$broadcast(SystemEvents.COMMON.COLUMN_CHANGED, val);
                };
                $scope.$watch(utilsFactory.feedColumn, function(newValue) {
                    $scope.spans = newValue;
                    $rootScope.$broadcast(SystemEvents.COMMON.COLUMN_CHANGED, newValue);
                });
                $scope.$on(SystemEvents.COMMON.WINDOW_RESIZED,function(){
                    $scope.defaultSpan = utilsFactory.getDefaultColumn();
                });
            }],//l-act
            template : '<span></span>\
                        <span></span>\
                        <span></span>\
                        <div class="col-area">\
                        <div class="col-area-wrapper">\
                            <div class="list-ico width-26 top-l" data-tool="3 Column" ng-click="choose(3)"  ng-if="defaultSpan > 2" ng-class="{\'list-act\' : spans == 3 }">\
                                <span></span>\
                                <span></span>\
                                <span></span>\
                            </div>\
                            <div class="list-ico width-17 top-l" data-tool="2 Column" ng-click="choose(2)"  ng-if="defaultSpan > 1" ng-class="{\'list-act\' : spans == 2 }">\
                                <span></span>\
                                <span></span>\
                            </div>\
                            <div  class="list-ico width-9 top-l" data-tool="1 Column" ng-click="choose(1)" ng-class="{\'list-act\' : spans == 1 }">\
                                <span></span>\
                            </div>\
                            </div>\
                        </div>',
            link: function (scope, element, attrs, ctrls) {
                var dropEl;


                function bindFn(event) {
                    event.preventDefault();
                    if(!dropEl){
                        dropEl = angular.element(element.find('div')[0]);
                        $document.on("click", bindDocumentClicktoControlClose);
                    }
                    dropEl.toggleClass('colshow');
                }
                function bindDocumentClicktoControlClose (e) {
                    var checkEl = element.parent().parent()[0];
                    if (e.target != checkEl && e.target.parentNode != checkEl && e.target.parentNode !=null && e.target.parentNode.parentNode != checkEl && e.target.className != 'pt-top') {
                        closeColumnSelector(e);
                    }

                }
                element.parent().parent().on("click", bindFn);

                function closeColumnSelector (event) {
                    dropEl.removeClass('colshow');
                }

                scope.$on("$destroy", function() {
                    element.off("click",bindFn);
                    $document.off("click",bindDocumentClicktoControlClose);
                    dropEl = undefined;
                });

            }
        };
    }
]);

/**
 * © Ipvision
 *public static final int ACTION_SPAM_REASON_LIST = 1001;
Sending data for action 1001

{"pckId":"14633967158912110000087","actn":1001,"sId":"426416336646596312110000087","spmt":1}   
Received data for action 1001

{"seq":"1/1","rsnLst":[{"id":2,"rsn":"It is for harresment"},{"id":1,"rsn":"Uncensored content"}],"sucs":true,"tr":2}
public static final int ACTION_REPORT_SPAM = 1002;
Sending data for action 1002

{"pckId":"14633967710002110000087","spmt":2,"actn":1002,"sId":"426416336646596312110000087","spmid":698765,"rsnid":1}
Received data for action 1002

{"sucs":true,"rc":0,"spmid":698765,"spmt":2}
 *
 *
 *
 *
 *
 *
 *
 * 
 *
 *  spmt= SpamType (SPAM_USER:1/SPAM_FEED:2/SPAM_IMAGE:3/SPAM_MEDIA_CONTENT:4)

    rsnLst=Reason List

    rsn=Reason

    spmid=SpamID (userid/newsfeed/image/mediacontent ID)

    rsnid=ReasonID (got from reason list [action 1001])
 */

(function() {
    'use strict';

    angular
        .module('ringid.common.rg_report',["ringid.global.services","ringid.config","ringid.connector"])
        .factory('ReportHttpService',ReportHttpService)
        .controller('ReportController',ReportController)
        .directive('rgReport', rgReport)
        ReportHttpService.$inject = ['$$connector','$$q','OPERATION_TYPES','SPAM_TYPES'];
        function ReportHttpService($$connector,$q,OPERATION_TYPES,SPAM_TYPES){
                  var OTYPES = OPERATION_TYPES.SYSTEM.REPORT,ob;
                      var SPAM_REASON_LIST = {};
                    ob = {
                        getSpamReasonList : getSpamReasonList,
                        reportSpam : reportSpam
                    };


                function getSpamReasonList(stringSpamType){
                    var defer = $q.defer();
                    if(!stringSpamType || typeof stringSpamType !== "string"){
                      throw new Error("PARAMS_ERROR SPAM_TYPE Must be string");
                    }
                    var spam_type = SPAM_TYPES[stringSpamType.toUpperCase()];
                    if(SPAM_REASON_LIST[spam_type]){
                      setTimeout(function(){
                          defer.resolve(SPAM_REASON_LIST[spam_type]);
                      });
                    }else{
                        $$connector.pull({
                            actn : OTYPES.ACTION_SPAM_REASON_LIST,
                            spmt : spam_type
                        },OPERATION_TYPES.SYSTEM.REQUEST_TYPE.REQUEST).then(function(json){
                            if(json.sucs){
                               SPAM_REASON_LIST[spam_type] = json.rsnLst;
                               defer.resolve(SPAM_REASON_LIST[spam_type]);
                            }else{
                              defer.reject(json);
                            }
                        },function(json){
                          defer.reject(json);
                        });
                    }
                    return defer.promise;
                }

                function reportSpam(ob){
                    if(!ob.spmt || !ob.spmid || !ob.rsnid){
                      throw new Error("PARAMS_ERROR");
                    }
                    var payload = {
                      actn : OTYPES.ACTION_REPORT_SPAM,
                      spmt : SPAM_TYPES[ob.spmt],
                      spmid : ob.spmid,
                      rsnid : ob.rsnid
                    };
                    return $$connector.request(payload,OPERATION_TYPES.SYSTEM.REQUEST_TYPE.UPDATE);
                 }
          

          return ob;
        }

 

ReportController.$inject = ['$scope','remoteData','ReportHttpService','Ringalert'];
function ReportController($scope,remoteData,ReportHttpService,Ringalert){
    $scope.title = 'Let us know why that\'s bothers you !';
    $scope.spamList = remoteData;
    $scope.reason = 4;
   $scope.report = function(){
     if(!$scope.reason){
        $scope.error = "Please choose one reason";
        return;
     }

     ReportHttpService.reportSpam({
          spmt : $scope.spamType.toUpperCase(),
          spmid : $scope.spamId,
          rsnid : $scope.reason
     }).then(function(json){
            $scope.$close();
           if(json.sucs){              
               Ringalert.show(json,"success");
           }else{
               Ringalert.show(json,"error");
              // $scope.error = 
           }
     });
   }

}





        rgReport.$inject = ['$ringbox',"ReportHttpService","rgDropdownService","SPAM_TYPES"];
        function rgReport($ringbox,ReportHttpService,rgDropdownService,SPAM_TYPES) {



            return {
                restrict: 'EA',
                scope : {
                    spamId : '=',
                    spamType : '@'
                },
                link : function(scope,element,attr){

                    function MainFunction(){
                       rgDropdownService.close();
                         
                         var boxInstance = $ringbox.open({
                                  type : 'remote',
                                  scope:scope,
                                  controller: 'ReportController',
                                  resolve : {
                                      remoteData : ReportHttpService.getSpamReasonList(scope.spamType)
                                  },
                                  templateUrl : 'pages/popups/rg-report.html'
                          });

                          boxInstance.result.then(function(confirmed){
                              // if(confirmed){
                              //     feedFactory.deleteFeed($scope.currentUser, key).then(function (json) {
                              //         $scope.setFeed(true);
                              //         Ringalert.show(json,'success');
                              //     }, function(errJson){
                              //         $scope.setFeed(true);
                              //         Ringalert.show(errJson,'error');
                              //     });
                              // }
                          });
                    }

                    element.on("click",MainFunction);

                }
            };
        }


})();

(function() {
    'use strict';

    angular
        .module('ringid.common.rgsrc_directive', [])
        .directive('rgSrc', rgSrc);

    function rgSrc(){ //jshint ignore:line
        return {
            restrict : 'A',
            link : function(scope,element,attr){
                if(attr.rgSrc){
                    scope.$watch(attr.rgSrc, function(newValue) {
                        if (newValue === null || newValue === undefined) {
                            element.removeAttr('src');
                        } else {
                            element.attr('src', newValue);
                        }
                    });
                }
            }
        };
    }

    })();

/**
 * © Ipvision
 */

(function () {
    'use strict';

    angular.module('ringid.common.rgrepeat_directive', [])
    .directive('rgRepeat', rgRepeat);

    rgRepeat.$inject = ['$parse', '$rootScope', '$animate','SystemEvents'];

    function rgRepeat($parse, $rootScope, $animate, SystemEvents) {

        function compile(element, attr) {


            return function ($scope, $element, $attr, ctrl, $transclude) {

                var expression = $attr.rgRepeat;
                var match = expression.match(/^\s*(.+)\s+in\s+(.*?)\s+track\s+by\s+(.+)\s*$/),
                    index, lhs, rhs, trackByExp, valueIdentifier, cell, cells = [],
                    lastBlockMap = Object.create(null);

                if (!match) {
                    throw "Expected expression in form of '_item_ in _collection track by _key_'";
                }
                
                var rgRepeatEndComment = document.createComment(' end rgRepeat: ' + expression + ' ');

                lhs = match[1];
                rhs = match[2];

                /* find getter function by parsing track by*/
                var getTrackID = $parse(match[3]);

                valueIdentifier = match[1];
                
                $scope.$watchCollection(rhs, update);

                function update(collection) {

                    var index, i, length = collection.length,
                        value, childScope, cellIndex, trackID, block, getterLocals, prevNode = $element[0],
                        nextNode, nextBlockMap = Object.create(null), parent, clone, temp;
                        
                        
                        $rootScope.$$postDigest(function() {
                         	 var index, value, block;
                         	 
                 	   		 for (index = 0; index < collection.length; index++) {
                       			value = collection[index];
                       			if(!lastBlockMap[value.$TrackID]) continue;
                       			block = lastBlockMap[value.$TrackID];
                 	     		if(block.childHead) block.scope.$$childHead = block.childHead;
                 	      	 }
                         }); 

                    /* Find next Blocks that are going to added*/
                    for (index = 0; index < length; index++) {
                    
                        value = collection[index];
                        getterLocals = {};
                        getterLocals[valueIdentifier] = value;
                        trackID = getTrackID($scope, getterLocals);
                    
                        if (lastBlockMap[trackID]) {
                            block = lastBlockMap[trackID];
                            /* found it and it is going to be processed in next blockmap so deleted it from last block map */
                            delete lastBlockMap[trackID];
                        } 
                        else {
                        
                            childScope = $scope.$new();
                            childScope[valueIdentifier] = value;
                            block = {};
                            block.clone = null;
                            block.scope = childScope;
                        }

                        collection[index]['$TrackID'] = trackID;
                        nextBlockMap[trackID] = block;
                    }
                    
                    /* Remove blocks from existing which are not going to process*/
                    for (trackID in lastBlockMap) {
                        if (lastBlockMap[trackID]) {

                            block = lastBlockMap[trackID];
                            for (i = 0; i < block.clone.length; i++) {
                                prevNode.parentNode.removeChild(block.clone[i]);
                            }
                            block.scope.$destroy();
                        }
                    }

                    /* Build DOM now*/
                    for (index = 0; index < length; index++) {

                        value = collection[index];
                        trackID = value['$TrackID'];
                        block = nextBlockMap[trackID];
                        block.scope.$index = index;
                        clone = block.clone;

                        if (clone) {
                        
                            nextNode = prevNode;
                            
                            if (block.startNode != nextNode) {
                                $animate.move(block.clone, null, angular.element(prevNode));
                            }
                            
                            prevNode = block.clone[block.clone.length-1];
                            
                            block.childHead = block.scope.$$childHead;
                            block.scope.$$childHead = null;
                            
                        } 
                        else {

                            $transclude(block.scope, function rgRepeatTransclude(clone) {
                                
                                var endNode = rgRepeatEndComment.cloneNode(false);  
                                clone[clone.length++] = endNode;
                                $animate.enter(clone, null, angular.element(prevNode));
                                prevNode = endNode;
                               
                                block.clone = clone;
                                block.startNode = clone[0];
                            });
                        }
                        
                   }
                   
                   /*broadcast feed-height change*/
                   if($scope.target && $scope.target.getMapKey) {
                      $scope.$emit(SystemEvents.FEED.HEIGHT, $scope.target.getMapKey());
                   }
                   
                    /* Updating last blockmap from current block map*/
                    lastBlockMap = nextBlockMap;
                }
            }
        }

        return {
            restrict: 'A',
            transclude: 'element',
            priority: 1000,
            terminal: true,
            compile: compile
        };
    }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
            .module('ringid.common.directives', [
                //'ringid.common.rgfocus_directive',
                'ringid.common.rgsearch_directive',
                //'ringid.common.rgdropdown_directive',
                //'ringid.common.rgscrollbar_directive',
                'ringid.common.rground_progress_directive',
                'ringid.common.rginvite_directive',
                'ringid.common.rgemoticon_directive',
                //'ringid.common.rgclick_directive',
                'ringid.common.rgimg_directive',
                'ringid.common.rghashtag_directive',
                'ringid.common.rgupload_directive',
                'ringid.common.rgphotos_directive',
                'ringid.common.rg_friend_dropdown',
                'ringid.common.rgeditor_directive',
     //           'ringid.common.rgselectoption_directive',

                'ringid.common.rghref_directive',
                'ringid.common.rgslider_directive',
                'ringid.common.emotion_directives',
                'ringid.common.rghover_card_directive',
                'ringid.common.rg_tag_friend',
                'ringid.common.rgplayer_directive',
                'ringid.common.rgrepeat_directive',
                'ringid.common.rg_column',
                'ringid.common.rg_report',
                'ringid.common.rgsrc_directive',
                'ringid.common.rgloading_directive',
                'ringid.common.rgRecorder',
                'ringid.common.rg_global_loader_directive'
            ]);
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid.profile.http_service', ['ringid.config'])
        .service('profileHttpService', profileHttpService);

    profileHttpService.$inject = [ '$$connector','OPERATION_TYPES', 'utilsFactory'];
    function profileHttpService( $$connector, OPERATION_TYPES, utilsFactory) { //jshint ignore:line
        var self = this, //jshint ignore:line
            OTYPES = OPERATION_TYPES.SYSTEM.PROFILE,
            REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;


        /**
         * @api {request} /APIREQUEST/21 Get profile info
         * @apiVersion 0.1.0
         * @apiDescription Profile INfo for logged in user.
         * @apiName GetProfileInfo
         * @apiGroup Profile
         *
         * @apiParam {Number=21} actn action constant for this api call
         *
         *
         * @apiSuccess {Number=21} actn action constant for this api call
         * @apiSuccess {Number} bDay  timestamp
         * @apiSuccess {Number} mDay  timestamp
         * @apiSuccess {Number} cIm cover image
         * @apiSuccess {Number} cImId cover image id
         * @apiSuccess {string} cc current city
         * @apiSuccess {string} cnty country
         * @apiSuccess {string} fn Fullname
         * @apiSuccess {string} gr gender
         * @apiSuccess {string} prIm Profile Image
         * @apiSuccess {string} hc home city
         * @apiSuccess {array} pvc Privacy setting
         * @apiSuccess {Boolean} sucs Request successfully processed or not
         * @apiSuccess {Number} uId User Id
         *
         *
         *
         *
         *
         * @apiSuccessExample Success-Response:
         *     HTTP/1.1 200 OK
         *     {
            *       acId: 0,
            *       actn: 111,
            *       cmnId: 0,
            *       headerLength: 62,
            *       imgId: 0,
            *       loc: 0,
            *       nList: [
            *           0: {
            *               acId: 0,
            *               cmnId: 0,
            *               fndId: "2000002368",
            *               fndN: "Wasif Islam",
            *               id: 368516,
            *               imgId: 14628,
            *               loc: 0mt: 1,
            *               nfId: 16103,
            *               nt: 5,
            *               ut: 1433832601723
            *           }
            *       ],
            *       nfId: 0,
            *       pckFs: 257739,
            *       pckId: "250085192336",
            *       scl: 1,
            *       seq: "4/7",
            *       sucs: true,
            *       tn: 32,
            *       tr: 32
            *     }
         *
         * @apiError Notification list not found
         *
         * @apiErrorExample Error-Response:
         *     HTTP/1.1 404 Not Found
         *     {
            *       "sucs": false
            *     }
         */


        // dependonUtId
        self.basicAndPrivacy = function (utId,iscurrent) {
            var payload;
            if (!iscurrent) {
                payload = {
                    actn: OTYPES.TYPE_ACTION_OTHER_USER_BASICINFO,
                    utId: utId
                };
            } else {
                payload = {
                    actn : OTYPES.TYPE_ACTION_CURRENT_USER_BASICINFO
                };
            }

            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.getUserDetails = function (obj,withMutualFriendCount) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_GET_USER_DETAILS,//204
                wmfc : !!withMutualFriendCount
            };
            angular.extend(payload, obj);

            return $$connector.request(payload, REQTYPE.REQUEST, true);// flooding true
        };


        /**
        * @api {request} /APIREQUEST/136 Check Presence of user
        * @apiVersion 0.1.0
        * @apiDescription Check Presence(i.e. online, away, offline ) of user/users
        * @apiName FriendPresence
        * @apiGroup Friends
        *
        * @apiParam {Number=136} actn
        * @apiParam {Number[]} uIds
        */
        self.fetchPresence = function(uIds) {
            var payload = {
                actn: OTYPES.ACTION_USERS_PRESENCE_DETAILS,
                uIds: uIds
            };
            return $$connector.send(payload, REQTYPE.REQUEST);
        };

        self.fetchPresenceAndMood = function(fndId) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_USER_MOOD_PRESENCE,
                fndId: fndId
            };
            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.changeMood = function(mood){
            var payload = {
                actn: OTYPES.TYPE_ACTION_USER_MOOD,
                mood: mood
            };
            return $$connector.request(payload, REQTYPE.AUTHENTICATION);
        };

        self.getMutualFriends = function(friendId) {
            var payload = {
                actn: OTYPES.FETCH_FRIEND_MUTUAL_FRIEND_LIST,
                uId: friendId
            };

            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        //requesting other users profile data
        //dependonUtId
        self.getUserProfileData =function(utId) {
            var payload;
            if(utId){
                payload = {
                    actn:OTYPES.TYPE_ACTION_LIST_WORK_AND_EDUCATIONS,//230 :Work-education-skill list
                    utId:utId
                };
            }else{
                payload = {
                    actn:OTYPES.TYPE_ACTION_LIST_WORK_AND_EDUCATIONS//230 :Work-education-skill list
                };
            }
            return $$connector.send(payload, REQTYPE.REQUEST);

        };


        self.updateProfile = function (userId,obj,dateObj,mobj) {

            if(mobj!==1){
                mobj = mobj.getTime();
            }
            var payload = {
                actn: OTYPES.TYPE_ACTION_MODIFY_USER_PROFILE,
                //gr: obj.gr,
                nOfHd: 7,
                fn: obj.fn.utf8Encode(),
                hc: obj.hc ? obj.hc.utf8Encode() : ' ',
                cc: obj.cc ? obj.cc.utf8Encode() : ' ',
                gr: obj.gr,
                am: obj.am.utf8Encode(),
                bDay: dateObj ? dateObj.getTime() : 1,
                mDay: mobj
            };
            return $$connector.request(payload, REQTYPE.UPDATE);

        };


        self.updateProfilePrivacy = function () {
            var payload = {
                actn: OTYPES.TYPE_ACTION_MODIFY_PRIVACY_SETTINGS,
                pvc:[
                    3,3,3,3,3
                ]
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        //self.frndSuggestion = function(obj){
            //var payload = {
                //actn:OTYPES.ACTION_UPDATE_LOGIN_SETTINGS,
                //sn:obj.sn,
                //sv:obj.sv
            //};
            //return $$connector.request(obj, REQTYPE.REQUEST);
        //};

        self.submitNewEducation = function(obj) {

            var payload = {
                actn: OTYPES.TYPE_ACTION_ADD_EDUCATION,
                request_type:REQTYPE.UPDATE,
                edu : {
                    af : 1,
                    cntn : obj.cntn? obj.cntn.utf8Encode() : '',
                    desc : obj.desc ? obj.desc.utf8Encode() : '',
                    dgr :  obj.dgr ? obj.dgr.utf8Encode() : '',
                    grtd : obj.grtd,
                    iss : obj.iss,
                    scl : obj.scl.utf8Encode(),
                    ft : obj.ft ? obj.ft : 1,
                    tt : obj.tt ? obj.tt : 1,
                    ut : 0
                }
            };
            return $$connector.request(payload, REQTYPE.UPDATE);

        };

        self.deleteEducation = function(id) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_REMOVE_EDUCATION,
                id : id
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.updateEducationById = function (obj) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_UPDATE_EDUCATION,
                edu:{
                    id: obj.id,
                    scl: obj.scl.utf8Encode(),
                    ft: obj.ft ? obj.ft : 1,
                    tt: obj.tt ? obj.tt : 1,
                    desc: obj.desc ? obj.desc.utf8Encode() : "",
                    af: obj.af,
                    grtd: obj.grtd,
                    iss: obj.iss,
                    cntn: obj.cntn ? obj.cntn.utf8Encode() : "",
                    dgr: obj.dgr ? obj.dgr.utf8Encode() : ""
                }
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.getAllSkill = function() {
            var payload = {
                actn: 230
            };
            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.submitNewSkill = function(obj) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_ADD_SKILL,
                skill:
                {
                    skl : obj.skl.utf8Encode(),
                    desc: obj.desc.utf8Encode()
                }
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.updateSkill = function(obj) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_UPDATE_SKILL,
                skill:{
                    id  : obj.id,
                    skl : obj.skl.utf8Encode(),
                    desc: obj.desc.utf8Encode()
                }

            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.deleteSkill = function(sid) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_REMOVE_SKILL,
                id  : sid
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };


        self.submitNewWork = function(obj) {
            var payload = {
                actn     : OTYPES.TYPE_ACTION_ADD_WORK,
                request_type:REQTYPE.UPDATE,
                wrk      :{
                    pstn  :obj.pstn ? obj.pstn.utf8Encode() : '',
                    desc  :obj.desc ? obj.desc.utf8Encode() :'',
                    //ct    :obj.ct ? obj.ct.utf8Encode() :'',
                    cnm   :obj.cnm.utf8Encode(),
                    tt    :obj.tt || 1,
                    ft    :obj.ft || 1
                }
            };
            return $$connector.request(payload, REQTYPE.UPDATE);

        };

        self.updateWork = function (obj) {
            var payload = {
                actn     : OTYPES.TYPE_ACTION_UPDATE_WORK,
                wrk:{
                    id       : obj.id,
                    pstn     : obj.pstn.utf8Encode(),
                    cnm      : obj.cnm.utf8Encode(),
                    desc     : obj.desc.utf8Encode(),
                    //ct       : obj.ct.utf8Encode(),
                    tt       :obj.tt || 1,
                    ft       :obj.ft || 1
                }

            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.deleteWork = function (workid) {
            var payload = {
                actn: OTYPES.TYPE_ACTION_REMOVE_WORK,
                id  : workid
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.changeProfilePicture = function(obj) {
            var payload = {
                    actn: OTYPES.TYPE_CHANGE_PROFILE_PIC,
                    type: 1,
                    imT: 2,
                    pimX : obj.pimX,
                    pimY : obj.pimY,
                    ih: obj.ih,
                    iw: obj.iw,
                    iurl: obj.iurl,
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.changeCoverPicture = function(obj) {
            var payload = {
                    actn: OTYPES.TYPE_CHANGE_COVER_PIC, // 103
                    type: 1,
                    imT: 3,
                    cimX : obj.cimX,
                    cimY : obj.cimY,
                    ih: obj.ih,
                    iw: obj.iw,
                    iurl: obj.iurl
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };


        self.removeProfilePicture = function (prIm) {
            var payload  = {
                actn: OTYPES.TYPE_REMOVE_PROFILE_IMAGE,
                prIm: prIm
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.removeCoverPicture = function (cIm) {
            var payload = {
                actn: OTYPES.TYPE_REMOVE_COVER_IMAGE,
                cIm: cIm
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.changePassword = function (oldPass,newPass) {
            var payload = {
                actn: OTYPES.CHANGE_PASSWORD,
                oPw:oldPass,
                nPw:newPass
            };
            return $$connector.request(payload, REQTYPE.UPDATE);

        };

        self.sendCode = function(obj){
            var payload = {
                actn: OTYPES.SEND_VERIFICATION_CODE_TO_MAIL,//221
                el: obj.email
            };

            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.sendCodeToPhn = function(obj){
            var payload = {
                actn: OTYPES.SEND_VERIFICATION_CODE_TO_PHONE,//212,
                mbl : obj.phone,
                mblDc :obj.countryCode
            };
            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.verifyCode = function (obj) {
            var payload = {
                actn:OTYPES.SEND_VERIFICATION_CODE_TO_MAIL,//221,
                el:obj.email,
                vc:obj.code
            };
            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        self.verifyPhnCode = function (obj) {
            var payload = {
                actn:OTYPES.SEND_VERIFICATION_CODE_TO_PHONE,//212,
                uId: obj.uId,
                mbl: obj.phone,
                mblDc:obj.mblDc,
                vc:obj.code
            };
            return $$connector.request(payload, REQTYPE.REQUEST);
        };

        //self.verifyCheck = function(){
            //var payload = {
                //actn:OTYPES.PHN_MAIL_VERIFICATION_CHECK//28
            //};
            //return $$connector.request(payload, REQTYPE.REQUEST);
        //};


        self.changePrivacy = function(obj) {
            var payload = {
                actn: obj.utId,
                sn:obj.sn,
                sv:obj.sv
            };

            if (obj.hasOwnProperty('utId')) {
                payload.utId = obj.utId;
            }
            return $$connector.request(payload, REQTYPE.UPDATE, true);
        };

        self.saveCallPvcEdit = function (obj) {
            var payload = {
                actn:obj.actn,
                sn:obj.sn,
                sv:obj.sv
            };
            if(!obj.isCurrent){
                payload.utId = obj.utId;
            }
            return $$connector.request(payload, REQTYPE.UPDATE,true);
        };

        self.saveChatPvcEdit = function (obj) {
            var payload = {
                actn:obj.actn,
                sn:obj.sn,
                sv:obj.sv
            };
            if(!obj.isCurrent){
                payload.utId = obj.utId;
            }
            return $$connector.request(payload, REQTYPE.UPDATE,true);
        };

        self.saveFeedPvcEdit = function (obj) {
            var payload = {
                actn:obj.actn,
                sn:obj.sn,
                sv:obj.sv
            };
            if(!obj.isCurrent){
                payload.utId = obj.utId;
            }
            return $$connector.request(payload, REQTYPE.UPDATE,true);
        };

        self.addSocialAccount = function(obj) {
            var payload = {
                actn: OTYPES.ADD_SOCIAL_NETWORK,
                it : obj.access_token,
                smid: obj.id,
                wk: utilsFactory.getUniqueID() // webserver dependency
            };

            if (obj.platform === 'facebook') {
                payload.smt = 4;
            } else if (obj.platform === 'twitter') {
                payload.smt = 5;
            }

            return $$connector.request(payload, REQTYPE.AUTHENTICATION);

        };

        self.saveAchatSetting = function (obj) {
            var payload = {
                actn:OTYPES.TYPE_CHANGE_PRIVACY,
                sn:obj.sn,
                sv:obj.sv
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.saveAinfndreqSettings = function (obj) {
            var payload = {
                actn:OTYPES.TYPE_CHANGE_PRIVACY,
                sn:obj.sn,
                sv:obj.sv
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };

        self.saveAfamSettings = function (obj) {
            var payload = {
                actn:OTYPES.TYPE_CHANGE_PRIVACY,
                sn:obj.sn,
                sv:obj.sv
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };
        
        self.saveAafSetting = function (obj) {
            var payload = {
                actn:OTYPES.TYPE_CHANGE_PRIVACY,
                sn:obj.sn,
                sv:obj.sv
            };
            return $$connector.request(payload, REQTYPE.UPDATE);
        };
    }
})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.profile', [
            'ringid.auth',
            'ringid.profile.http_service',
            'ringid.common.user_factory',
			'ringid.friend.friends_factory',
            'ringid.media',
			'ui.bootstrap',
            'ringid.common.services',
			'angular-svg-round-progress'
		]);
})();


/**
 * Copyright 2015 by RingID Inc.
 *
 */


(function () {
    'use strict';

    angular.module("ringid.profile")
            .directive('rgImgReposition', rgImgReposition);

    rgImgReposition.$inject = ['imageQuality', 'fileUploadService', '$document', 'APP_CONSTANTS', 'Ringalert'];
    function rgImgReposition(imageQuality, fileUploadService, $document, APP_CONSTANTS, Ringalert) {

        // Helper function to guarantee a value between low and hi unless bool is false
        var limit = function (low, hi, value, bool) {
            //console.log('low: ' + low + ' hi: ' + hi+ ' value: ' + value);
            if (arguments.length === 3 || bool) {
                if (value < low) {
                    return low;
                }
                if (value > hi) {
                    return hi;
                }
            }
            return value;
        };


        function linkFunc(scope, element, attrs) {
            var elementWidth = element[0].clientWidth,
                elementHeight = element[0].clientHeight,
                cropWidth = (scope.imgType === 'profilephoto') ? APP_CONSTANTS.PROFILE_PIC_CROP_WIDTH : APP_CONSTANTS.COVER_PIC_CROP_WIDTH,
                cropHeight = (scope.imgType === 'profilephoto')? APP_CONSTANTS.PROFILE_PIC_CROP_WIDTH : APP_CONSTANTS.COVER_PIC_CROP_HEIGHT,
                cropToImageRatio = 1,
                bgSrc = '',
                xPos,
                yPos,
                x0,
                y0,
                repositionScale = 1,
                calculate = false,
                options = {"bound": true},
                imageDimensions = {
                    width: 0,
                    height: 0
                };

            scope.selectFromAlbum = fileUploadService.selectFromAlbum;



            if (scope.imgType === 'coverphoto') {
                var adjustedHeight = Math.ceil(
                    ( (APP_CONSTANTS.COVER_PIC_CROP_HEIGHT * elementWidth ) / APP_CONSTANTS.COVER_PIC_CROP_WIDTH )
                                              );
                scope.elemStyle.height =  adjustedHeight + "px";
                elementHeight = adjustedHeight;
            }



            scope.$watch('enabled', function(newVal, oldVal){
                if (newVal) {
                    if (scope.repositionExisting) { // put existing image in file upload queue
                        imageQuality.resizeImage(
                            (scope.elemStyle.backgroundImage.match(/^url\(['"]?(.*?)['"]?\)$/i) || [])[1],
                            scope.imgType
                        ).then(function() {
                            checkImageDimensions(); // initialize image dimension
                        });
                    } else {
                        checkImageDimensions(); // initialize image dimension

                    }

                } else {
                    toggleReposition(false);
                }
            });


            function toggleReposition(enable) {
                if (enable || scope.enabled) {
                    element.bind('mousedown', mouseDown);
                    element.bind('mouseup', mouseUp);
                } else {
                    element.unbind('mousedown', mouseDown);
                    element.unbind('mouseup', mouseUp);
                }
                scope.$rgDigest();
            }

            function mouseDown(e) {
                //console.log('MOUSE DOWN');
                if (scope.enabled) {
                    if (e.which === 1) {
                        x0 = e.clientX;
                        y0 = e.clientY;
                        calculate = true;
                    }
                    //angular.element($document).bind('mousemove', mouseMove);
                    element.bind('mousemove', mouseMove);
                }
            }

            function mouseMove(e) {
                var pos, x, y;
                //console.log('MOUSE MOVE');
                if (scope.enabled && calculate) {
                    pos = scope.elemStyle.backgroundPosition.match(/(-?\d+).*?\s(-?\d+)/) || [];
                    x = e.clientX;
                    y = e.clientY;
                    xPos = parseInt(pos[1]) || 0;
                    yPos = parseInt(pos[2]) || 0;

                    xPos = limit(elementWidth - imageDimensions.width, 0, xPos + x - x0, options.bound);
                    yPos = limit(elementHeight - imageDimensions.height, 0, yPos + y - y0, options.bound);

                    element.css({
                        'backgroundPosition': xPos + 'px ' + yPos + 'px'
                    });
                }
            }

            function mouseUp(e) {
                //console.log('MOUSE UP');
//                e.stopPropagation();
                if (scope.enabled && calculate) {
                    if (xPos !== undefined && yPos !== undefined) {
                        scope.elemStyle.backgroundPosition = xPos + 'px ' + yPos + 'px';
                        // reset position with respect to original image dimensions;
                        //xPos = xPos / scale;
                        //yPos = yPos / scale;
                        // set x,y and imh, imw in fileuploader service
                        console.log('%c: ' + 'yPos: ' + yPos + ' xpos: ' + xPos, 'color:red');
                        console.log('%c: ' + 'REPOSITION SCALE: ' + repositionScale, 'color:red');
                        fileUploadService.setReposition({
                            cimX: Math.ceil( Math.abs(xPos) / repositionScale) || 0,
                            cimY: Math.ceil( Math.abs(yPos) / repositionScale ) || 0,
                        }, scope.imgType);
                    }

                    // reset reposition
                    calculate = false;
                    xPos = undefined;
                    yPos = undefined;

                    element.unbind('mousemove', mouseMove);
                }

            }


            var checkImageDimensions = function () {

                var src = scope.elemStyle.backgroundImage;
                bgSrc = (src.match(/^url\(['"]?(.*?)['"]?\)$/i) || [])[1];

                if (!bgSrc) {
                    return;
                }

                var image = new Image();
                image.onload = setDimensions;
                image.src = bgSrc;
            };



            function setDimensions() {
                // disable resize progress show
                scope.toggleResizeShow()(scope.imgType, false);
                var self = this;
                imageDimensions.width = self.width;
                imageDimensions.height = self.height;

                // set width to elementWidth and adjust height
                if ( (imageDimensions.width / cropWidth) <= (imageDimensions.height / cropHeight) ) {
                //if ( Math.abs(elementWidth - imageDimensions.width) < Math.abs(elementHeight - imageDimensions.height) ) {
                    repositionScale = elementWidth / imageDimensions.width;
                    imageDimensions.width = elementWidth;
                    imageDimensions.height = Math.floor(imageDimensions.height * repositionScale);


                    cropToImageRatio = self.width / cropWidth;
                    fileUploadService.setReposition({
                        iw: Math.ceil(self.width),
                        ih: Math.ceil(cropHeight * cropToImageRatio)
                        //scale: repositionScale
                    }, scope.imgType);
                } else {   // set height to elementheight and adjust width
                    repositionScale = elementHeight / imageDimensions.height;
                    imageDimensions.height = elementHeight;
                    imageDimensions.width = Math.floor(imageDimensions.width * repositionScale);

                    cropToImageRatio = self.height / cropHeight;
                    fileUploadService.setReposition({
                        ih: Math.ceil(self.height),
                        iw: Math.ceil(cropWidth * cropToImageRatio)
                        //scale: repositionScale
                    }, scope.imgType);
                }

                // bind events and remove loadder class
                toggleReposition(true);
                //angular.element(element).removeClass('p-loader');
                console.log('repositionScale: ' + repositionScale);
                console.log('elementW: ' + elementWidth + ' elementH: ' + elementHeight);
                console.log('cropMinW: ' + cropWidth + ' cropMinH: ' + cropHeight);
                console.log('imageW: ' + imageDimensions.width + ' imageH: ' + imageDimensions.height );
            }



        }

        return {
            restrict: 'A',
            replace: false,
            scope: {
                elemStyle: "=",
                enabled: "=",
                imgType: "@",
                repositionExisting: '=',
                toggleResizeShow: '&'
            },
            link: linkFunc
        };
    }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfile', rgProfile);


        function rgProfile()  {

            ProfileController.$inject = ['$ringbox', '$scope', 'Notification', 'Storage', 'friendsFactory', '$routeParams', 'Auth', 'profileFactory', 'fileUploadService',
                'imageQuality', 'AlbumFactory', 'SystemEvents', 'utilsFactory', 'Ringalert', 'languageConstant', '$rootScope', 'rgDropdownService'];
            function ProfileController ($ringbox, $scope, Notification, Storage, friendsFactory, $routeParams, Auth, profileFactory, fileUploadService,
                                          imageQuality, AlbumFactory, SystemEvents, utilsFactory, Ringalert, languageConstant, $rootScope, rgDropdownService) {
                /* INITIALIZATION */
                var uId =  $routeParams.uId,
                    newCoverpic,
                    newPropic;

                $scope.isOwner = Auth.currentUser().getKey() === uId ? true : false;

                $scope.consType = languageConstant.get();

                $scope.profilePicDragEnable = false;
                $scope.coverPicDragEnable = false;

                $scope.processing = false;

                $scope.profileDdControl = {
                    showOnHover : true,
                    enableCoverReposition: true,
                    enableProfileReposition: true
                };
                $scope.showCoverDD = false; // show or hide cover setting dropdown
                $scope.coverPhotoStyle = {
                    "backgroundSize": "cover"
                };
                $scope.profilePhotoStyle = {
                    "backgroundSize": "cover"
                };

                $scope.link = utilsFactory.getRingRoute('USER_PROFILE', { uId : uId});
                $scope.profileObj = profileFactory.getProfile(uId);

                $scope.profileObj = profileFactory.getProfile(uId);


                if ($routeParams.subpage === undefined) {
                    //if ($scope.profileObj.isFriend() || $scope.profileObj.isCurrentUser()) {
                        $scope.subPage = 'post';
                    //} else {
                        //$scope.subPage = 'about';
                        //$scope.activeNav = 'basic';
                    //}
                } else {
                    $scope.subPage = $routeParams.subpage;
                    if ($scope.subPage === 'about') {
                        $scope.activeNav = 'basic';
                    }
                }
                $scope.subPageLink = 'pages/profile/profile.' + $scope.subPage + '.html';

                // get profile details
                profileFactory.init($scope.profileObj).then(function() {
                    updateStyle('coverphoto');
                    updateStyle('profilephoto');

                });


                var updateStyle = function(type) {
                    if (type === 'profilephoto') {
                        $scope.profilePhotoStyle.backgroundImage = "url(" + $scope.profileObj.avatar('thumb')  + ")";
                        $scope.profilePhotoStyle.backgroundPosition = '50% 50%';
                        if($scope.profilePhotoStyle.backgroundImage.indexOf('prof.png') > -1) {
                            $scope.profileDdControl.enableProfileReposition = false;
                        } else {
                            $scope.profileDdControl.enableProfileReposition = true;
                        }
                    } else {
                        $scope.coverPhotoStyle.backgroundImage = "url(" + $scope.profileObj.getCover()  + ")";
                        $scope.coverPhotoStyle.backgroundPosition = '0px 0px';
                        if($scope.coverPhotoStyle.backgroundImage.indexOf('default_cover') > -1) {
                            $scope.profileDdControl.enableCoverReposition = false;
                        } else {
                            $scope.profileDdControl.enableCoverReposition = true;
                        }
                    }
                    $scope.$rgDigest();
                };
                updateStyle('coverphoto');
                updateStyle('profilephoto');

                $scope.frndAction = function(actionObj) {
                    //actionObj.event.preventDefault();
                   rgDropdownService.close(actionObj.event);
                    if (!actionObj.friend.isLoading()) {
                        friendsFactory.friendAction(actionObj,true).then(function() {
                            $scope.$rgDigest();
                        }, function() {
                            $scope.$rgDigest();
                        });
                        $scope.$rgDigest();
                    }
                };
                /* END OF INITIALIZATION */


                /* cover photo dropdown */
                $scope.repositionExisting = false; // reposition existing pro pic or cover.

                $scope.coverDdHtml = 'pages/dropdowns/coverphoto-dropdown.html'; //$templateCache.get('coverphoto-dropdown.html');
                $scope.coverDdAction = function(actionObj) {
                    rgDropdownService.close(actionObj.event);
                    switch(actionObj.action) {
                        case 'coverphoto':
                            $scope.toggleResizeShow('coverphoto', true);
                            $scope.uploadAction(actionObj); // new cover photo selected
                            break;
                        case 'toggleReposition':
                            $scope.repositionExisting = true;
                            $scope.toggleResizeShow('coverphoto', true);

                            $scope.uploadAction({
                                action: 'coverphoto',
                                uploadFile: fileUploadService.queueFile('coverphoto', $scope.profileObj.getCover('original'))
                            });
                            break;
                        case 'popupData':
                            fileUploadService.uploadType = 'coverphoto';
                            return function() {
                                return {
                                    popupType: 'coverphoto'
                                };
                            };
                        default :
                            console.warn('Cover Photo Dropdown Action did not Match');
                    }
                    $scope.$rgDigest();
                };

                /* end cover photo dropdown */

                /* Profile photo Dropdown */

                $scope.profileDdHtml = 'pages/dropdowns/profilephoto-dropdown.html'; //$templateCache.get('profilephoto-dropdown.html');
                //$scope.frndActionHtml = 'pages/dropdowns/friend-settings-dropdown.html'; //$templateCache.get('profilephoto-dropdown.html');
                $scope.frndActionTemplate =
                    '<div class="action friend-settings-dropdown">' +
                        '<a  ng-if="ddControl.friendshipStatus()==0 && !ddControl.isCurrentUser()" rg-click="ddAction()({ action: \'addfriend\', friend: ddControl, event:$event})" href="#"><span class="icon-addf pro-f"></span><span class="txt">{{consType.add_friend}}</span></a>' +
                        '<a  ng-if="ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'unfriend\', friend: ddControl, event:$event})" href="#"> <span class="icon-into-border f-Block"></span><span class="txt">{{consType.unfriend}}</span></a>' +
                        '<a  ng-if="ddControl.friendshipStatus()==2" rg-click="ddAction()({ action: \'accept\', friend: ddControl, event:$event})" href="#"><span class="icon-incoming pro-f"></span><span class="txt">{{consType.accept}}</span></a>' +
                        '<a  ng-if="ddControl.friendshipStatus()==3" rg-click="ddAction()({ action: \'remove\', friend: ddControl, event:$event})" href="#"><span class="friend-ico cancel-req"></span><span class="txt">{{consType.remove}}</span></a>' +
                        '<a  ng-if="ddControl.isBlocked()===0 && !ddControl.isCurrentUser() && ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'block\', friend: ddControl, event:$event})" class="border-0" href="#"><span class="icon-block"></span><span class="txt">{{consType.block}}</span></a>' +
                        '<a  ng-if="ddControl.isBlocked()===1 && !ddControl.isCurrentUser() && ddControl.friendshipStatus()==1" rg-click="ddAction()({ action: \'unblock\', friend: ddControl, event:$event})" class="border-0" href="#"><span class="icon-right f-Block"></span><span class="txt">{{consType.unblock}}</span></a>' +
                      //  '<a  ng-if="!ddControl.isCurrentUser()" rg-report spam-type="user" spam-id="ddControl.getKey()">Report</a>' +
                    '</div>';
                $scope.profileDdAction = function (actionObj) {
                    rgDropdownService.close(actionObj.event);
                    switch(actionObj.action) {
                        case 'profilephoto': // dropdown image selected for new profile photo
                            $scope.toggleResizeShow('profilephoto', true);
                            $scope.uploadAction(actionObj);
                            break;
                        case 'toggleReposition':
                            $scope.toggleResizeShow('profilephoto', true);
                            $scope.repositionExisting = true;

                            $scope.uploadAction({
                                action: 'profilephoto',
                                uploadFile: fileUploadService.queueFile('profilephoto', $scope.profileObj.avatar('original'))
                            });
                            break;
                        case 'popupData':
                            fileUploadService.uploadType = 'profilephoto';
                            return function() {
                                return {
                                    popupType: 'profilephoto'
                                };
                            };
                        default :
                            console.warn('Cover Photo Dropdown Action did not Match');
                    }
                    $scope.$rgDigest();
                };
                /* END Profile photo dropdown */

                $scope.toggleResizeShow = function(type, value) {
                    if(type === 'coverphoto') {
                        $scope.cvResizeProgressShow = value || false;
                    } else {
                        $scope.ppResizeProgressShow = value || false;
                    }
                    $scope.$rgDigest();
                };

                // photo selected from album for propic or coverpic
                $scope.$on(SystemEvents.IMAGE.DO_REPOSITION, function(event, args){
                    $scope.toggleResizeShow(fileUploadService.uploadType, true);
                    $scope.uploadAction({action: fileUploadService.uploadType, uploadFile: fileUploadService.queueFile(fileUploadService.uploadType, args.image)});
                    $ringbox.closeAll();
                });

                // cover photo, profile photo upload events handler
                $scope.uploadAction = function(actionObj) {
                    var fileToUpload;
                    $scope.repositionExisting = false;

                    if (actionObj.action === 'coverphoto') {
                        newCoverpic = actionObj.uploadFile;
                        fileToUpload = newCoverpic;
                    } else {
                        newPropic = actionObj.uploadFile;
                        fileToUpload = newPropic;
                    }

                    if (fileToUpload) {
                        $rootScope.$broadcast(SystemEvents.LOADING, true);
                        fileToUpload.fetchMeta(function(result) {
                            $rootScope.$broadcast(SystemEvents.LOADING, false);
                            if (result.success) {
                                if (actionObj.action === 'coverphoto') {
                                    $scope.toggleCoverPhotoReposition(fileToUpload.getPreview());
                                } else {
                                    $scope.toggleProfilePhotoReposition(fileToUpload.getPreview());
                                }
                            } else {
                                $scope.toggleResizeShow(actionObj.action, false);
                                Ringalert.show(result.message, 'error');
                            }
                            $scope.$rgDigest();
                        });
                    }
                    $scope.$rgDigest();
                };


                // set reposition and upload cover photo new/old
                $scope.uploadPicture = function(type,event) {
                    var fileToUpload;
                    if (type === 'coverphoto') {
                        $scope.cvUploadProgressShow = true;
                        $scope.coverPicDragEnable = false;
                        fileToUpload = newCoverpic;
                    } else if(type === 'profilephoto' ) {
                        $scope.ppUploadProgressShow = true;
                        $scope.profilePicDragEnable = false;
                        fileToUpload = newPropic;
                    }

                    $rootScope.$broadcast(SystemEvents.LOADING, true);
                    // upload file to image server and set cover or profile picture in auth server
                    //fileUploadService.uploadFile(type).then(function(response) {
                    fileToUpload.initUpload().then(function(response) {
                        $scope.cvUploadProgressShow = false;
                        $scope.ppUploadProgressShow = false;
                        if (response.sucs === true) {
                            if (type === 'profilephoto' ) {
                                profileFactory.changeProfilePicture(response).then(function() {
                                    $rootScope.$broadcast(SystemEvents.LOADING, false);
                                    $rootScope.$rgDigest();
                                    updateStyle(type);
                                });
                            } else if (type === 'coverphoto') {
                                profileFactory.changeCoverPicture(response).then(function() {
                                    $rootScope.$broadcast(SystemEvents.LOADING, false);
                                    $rootScope.$rgDigest();
                                    // in case of profile pic update localStorage
                                    updateStyle(type);
                                });
                            }

                        } else {
                            updateStyle(type);
                            $rootScope.$broadcast(SystemEvents.LOADING, false);
                        }

                    }, function(errorData) {
                        updateStyle(type);
                    });

                    if (event) {
                        event.stopPropagation();
                    }
                    $scope.$rgDigest();

                };


                // enable or disalbe cover pic reposition
                $scope.toggleCoverPhotoReposition = function (src, event) {
                    var originalSrc = '',
                        coverXY = $scope.profileObj.getCoverXY(),
                        imageFile;

                    if ($scope.coverPicDragEnable) {
                        $scope.coverPicDragEnable = false;
                        updateStyle('coverphoto');
                        //$scope.coverPhotoStyle.backgroundImage = "url(" + $scope.currentUser.getCover() + ")";
                    } else {
                        if (!src) {

                            src = $scope.profileObj.getCover();
                            imageFile = src.slice(src.lastIndexOf('/') + 1, src.length);
                            originalSrc = src.replace(imageFile, imageFile.replace('crp', '') );

                        } else {
                            originalSrc = src;
                        }
                        $scope.coverPhotoStyle.backgroundImage = "url(" + originalSrc + ")";

                        //$scope.coverPhotoStyle.backgroundPosition =  '0px ' + '0px';
                        $scope.coverPhotoStyle.backgroundPosition =  (-coverXY.x) + 'px ' + (-coverXY.y) + 'px';
                        $scope.coverPicDragEnable = true;
                        $scope.$rgDigest();
                    }

                    if (event) {
                        event.stopPropagation();
                    }

                };

                $scope.$watch('profilePicDragEnable', function(newVal) {
                    if(! newVal && !$scope.ppUploadProgressShow) {
                        updateStyle('profilephoto');
                    }
                });

                $scope.$watch('coverPicDragEnable', function(newVal) {
                    if(!newVal && !$scope.cvUploadProgressShow) {
                        updateStyle('coverphoto');
                    }
                });



                // enable or disalbe cover pic reposition

                $scope.toggleProfilePhotoReposition = function (src,event) {
                    var originalSrc = '',
                        imageFile,
                        prefix;

                    if ($scope.profilePicDragEnable) {
                        $scope.profilePicDragEnable = false;
                        updateStyle('profilephoto');

                    } else {

                        if (!src) {
                            src = $scope.profileObj.avatar('original');
                            imageFile = src.slice(src.lastIndexOf('/') + 1, src.length);
                            originalSrc = src.replace(imageFile, imageFile.replace(prefix, '') );
                        } else {
                            originalSrc = src;
                        }

                        $scope.profilePhotoStyle.backgroundImage = "url(" + originalSrc + ")";
                        $scope.profilePhotoStyle.backgroundPosition = '0px 0px';
                        $scope.profilePicDragEnable = true;
                        $scope.$rgDigest();
                    }
                    if (event) {
                        event.stopPropagation();
                    }
                };


                $scope.getImageData = function (imageId) {
                    return {
                        data: function() {
                            return {
                                imgId: imageId
                            };
                        },
                        promise: AlbumFactory.getImageDetails(imageId)
                    };
                };


//--------------------------------- profile pic round-progress-bar (start) -------------
                $scope.cvUploadProgressShow = false;
                $scope.cvResizeProgressShow = false;
                $scope.ppResizeProgressShow = false;

                $scope.uploadStyle =  function() {
                    return {
                        width: fileUploadService.progress + '%'
                    };
                };

                $scope.roundProgressBarStyle = {
                    "dataRoundProgressWidth": "200",
                    "dataRoundProgressHeight": "200",
                    "dataRoundProgressOuterCircleWidth": "4",
                    "dataRoundProgressInnerCircleWidth": "8",
                    "dataRoundProgressOuterCircleRadius": "85",
                    "dataRoundProgressInnerCircleRadius": "85",
                    "dataRoundProgressLabelFont": '24',
                    "dataRoundProgressOuterCircleBackgroundColor": "#fff",
                    "dataRoundProgressOuterCircleForegroundColor": "#f47727",
                    "dataRoundProgressInnerCircleColor": "#fff",
                    "dataRoundProgressLabelColor": "#fff"
                };

                $scope.ppUploadProgressShow = false;
                $scope.uploadImageFileSize = function() {
                    return fileUploadService.currentUploadImageSize;
                };

                $scope.getRoundedProgressTextStyle = function(){
                    return {
                        'top': '50%',
                        'bottom': 'auto',
                        'left': '50%',
                        'transform': 'translateY(-50%) ' + 'translateX(-50%)',
                        'font-size': 100/3.5 + 'px',
                        'position' : 'absolute'
                    };
                };

                $scope.roundProgressData = function(){
                    return {
                        label: fileUploadService.progress + '%',
                        percentage: fileUploadService.progress,
                        dataLoaded : fileUploadService.dataLoaded
                    };
                };

                $scope.openRingbox = function(type){
                    if (type === 'cover') {
                        return !$scope.coverPicDragEnable && !$scope.cvResizeProgressShow && !$scope.cvUploadProgressShow && $scope.profileDdControl.enableCoverReposition;
                    } else {
                        return !$scope.profilePicDragEnable && !$scope.ppResizeProgressShow && !$scope.ppUploadProgressShow && $scope.profileDdControl.enableProfileReposition;
                    }
                };


                $scope.$on(SystemEvents.FILE_UPLOAD.PROGRESS_UPDATE, function(){
                    $scope.$rgDigest();
                });

                //profile about menu section for smaller device start
                $scope.showMenuItems = false;
                $scope.toggleMenuItem = function () {
                    $scope.showMenuItems = !$scope.showMenuItems;
                    $scope.$rgDigest();
                };
                $scope.closeDropdown = function () {
                    $scope.showMenuItems = false;
                    $scope.$rgDigest();
                };
                //profile about menu section for smaller device end

//--------------------------------- profile pic round-progress-bar (end) ---------------

                $scope.$on('$destroy', function() {
                    // remove all redundant data
                    if ($routeParams.subPage === 'about') {
                        // remove about data like education, skill etc
                        profileFactory.removeProfileData($scope.profileObj.getUtId());
                    }
                });


            } // END CONTROLLER FUNC

            var linkFunc = function(scope, element) {
                function handleMouse(event) {
                    // event mouseenter=true, mouseleave=false
                    scope.showCoverDD = !scope.showCoverDD;
                    scope.$rgDigest();
                }

                element.on('mouseenter', handleMouse);
                element.on('mouseleave', handleMouse);

                scope.$on('$destroy', function() {
                    element.off('mouseenter', handleMouse);
                    element.off('mouseleave', handleMouse);
                });
            };

            return {
                restrict: 'E',
                scope: true,
                templateUrl: 'pages/profile/profile-header.html',
                controller: ProfileController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileBasic', rgProfileBasic);


    function rgProfileBasic()  {

        ProfileBasicController.$inject = ['Storage', '$scope','utilsFactory', 'profileFactory','Ringalert', '$rootScope'];
        function ProfileBasicController (Storage, $scope,utilsFactory, profileFactory,Ringalert, $rootScope) { //jshint ignore:line

            $scope.isEditProfile = false;
            $scope.processing = false;

            //$scope.$watch('tmpBasic.fn', function (newval, oldval) {
            //    var rexpression =/(!?[\.\-\_\!\@\#\$\%\&\*\{\}\(\)\[\]\:\;\~\,\\\^\/\<\>\?\'\"\|\=\+\`])+/;
            //
            //    $scope.fullnameRegex = rexpression.test(newval);
            //});

            $scope.enableEditBasic = enableEditBasic;
            $scope.updateMyBasicInfo = updateMyBasicInfo;
            $scope.cancelUpdateMyBasicInfo = cancelUpdateMyBasicInfo;

            function enableEditBasic(event) {
                event.preventDefault();
                $scope.tmpBasic = angular.copy($scope.profileObj.getBasicInfo());
                if ($scope.tmpBasic.mDay === 1 || $scope.tmpBasic.mDay === '1') {
                    $scope.tmpBasic.marriageDay = null;
                }
                if ($scope.tmpBasic.birthDay === 1 || $scope.tmpBasic.birthDay === '1') {
                    $scope.tmpBasic.birthday = null;
                }
                //if ($scope.isEditProfile === false) {
                $scope.isEditProfile = true;
                $scope.$rgDigest();
                //}
            }

            function cancelUpdateMyBasicInfo() {
                //$scope.tmpBasic = $scope.tmpBasic;
                $scope.isEditProfile = false;
                $scope.$rgDigest();
                //$scope.isOwner = true;
            }
            function updateMyBasicInfo() {
                $scope.processing = true;
                var mdateobj = $scope.tmpBasic.marriageDay;
                if (mdateobj==null){
                    mdateobj = 1;
                }
                var dateobj;

                var datetype = typeof($scope.tmpBasic.birthday);
                var mdatetype = typeof(mdateobj);
                if (datetype==='string') {
                    var data = $scope.tmpBasic.birthday.split('-');
                    var bdDate = parseInt(data[0])+','+parseInt(data[1])+','+parseInt(data[2]);
                    dateobj = new Date(bdDate);
                } else {
                    dateobj = $scope.tmpBasic.birthday;
                    if($scope.tmpBasic.birthDay !== 1){
                        if($scope.tmpBasic.birthDay !== '1'){
                            var frTime = utilsFactory.profileVerbalDate($scope.tmpBasic.birthDay);
                            $scope.tmpBasic.birthday = frTime;
                        }

                    }

                }

                if(mdatetype === 'string'){
                    var mdata = mdateobj.split('-');
                    var mDate = parseInt(mdata[0])+','+parseInt(mdata[1])+','+parseInt(mdata[2]);
                    mdateobj = new Date(mDate);
                }


                profileFactory.updateUserProfile($scope.uId,$scope.tmpBasic,dateobj,mdateobj).then(function(data){
                    if(data.sucs===true){
                        $scope.tmpBasic.birthDay = dateobj ? dateobj.getTime() : '1';
                        if( typeof(dateobj) ==='object' ){
                            $scope.currentUser.setBirthday($scope.tmpBasic.birthDay);
                        }else{
                            $scope.currentUser.setBirthday('1');
                        }
                        if( mdatetype ==='object' ){
                            $scope.currentUser.setMarriageday(mdateobj.getTime());
                        }else{
                            $scope.currentUser.setMarriageday('1');
                        }


                        $scope.profileObj.getBasicInfo().birthDay = $scope.tmpBasic.birthDay;

                        $scope.currentUser.setName($scope.tmpBasic.fn);
                        $scope.currentUser.setHomeCity($scope.tmpBasic.hc);
                        $scope.currentUser.setCurrentCity($scope.tmpBasic.cc);
                        $scope.currentUser.setAboutMe($scope.tmpBasic.am);
                        Storage.updateLoginData('fn', $scope.tmpBasic.fn);
                        $scope.currentUser.setGender($scope.tmpBasic.gr);

                        Ringalert.show('Successfully updated','success');
                        $scope.isEditProfile = false;
                        //$scope.isOwner = true;
                    }else{
                        $scope.isEditProfile = false;
                        Ringalert.show(data.mg,'error');
                    }
                    $scope.processing = false;
                    $rootScope.$rgDigest();
                });
            }



            //datepicker
            $scope.isDatePickerOpen = false;
            $scope.model = {};

            $scope.open = function($event, elementOpened) {
                $event.preventDefault();
                $event.stopPropagation();
                switch(elementOpened){
                    case 'wcalendar':
                        $scope.model.wcalendarTo = false;
                        break;
                    case 'wcalendarTo':
                        $scope.model.wcalendar = false;
                        break;
                    case 'ecalendar':
                        $scope.model.ecalendarTo = false;
                        break;
                    case 'ecalendarTo':
                        $scope.model.ecalendar = false;
                        break;
                    case 'mcalendar':
                        $scope.model.mcalendar = false;
                        break;
                }
                $scope.model[elementOpened] = !$scope.model[elementOpened];

            };
            $scope.dateOptions = {
                showWeeks:'false',
                startingDay: 1
            };

            var today = new Date();
            today.setMonth(today.getMonth()+6);
            $scope.minDate = new Date();

            $scope.maxBirthDate = new Date(today.getFullYear(),today.getMonth() , today.getDate());
            $scope.maxWeddingDate = new Date(today.getFullYear()+20,today.getMonth() , today.getDate());


        } // END CONTROLLER FUNC


        return {
            restrict: 'E',
            //scope: true,
            templateUrl: 'pages/profile/profile.about-basic.html',
            controller: ProfileBasicController
        };

    }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfilePrivacy', rgProfilePrivacy);


        function rgProfilePrivacy()  {

            ProfilePrivacyController.$inject = ['Auth', 'Storage',  '$timeout', '$scope','utilsFactory', 'friendsFactory', 'profileFactory','languageConstant'];
            function ProfilePrivacyController (Auth, Storage,  $timeout, $scope,utilsFactory, friendsFactory, profileFactory, languageConstant) { //jshint ignore:line

                $scope.isEditProfilePrivacy = false;
                $scope.callPvcEdit = false;
                $scope.chatPvcEdit = false;
                $scope.feedPvcEdit = false;

                //default settings
                $scope.fPrivacyInfo = {
                    callPrivacy : 0,
                    chatPrivacy : 0,
                    feedPrivacy : 0
                };

                $scope.enablePrivacyEditMode = enablePrivacyEditMode;
                $scope.savePvcEdit = savePvcEdit;
                $scope.cancelPvcEdit = cancelPvcEdit;

                if($scope.profileObj.isCurrentUser()){
                    Auth.fetchPrivacy().then(function(data){
                        if(data.sucs===true){
                            //$scope.emailVerified = data.iev;
                            //$scope.phoneVerified = data.imnv;

                            $scope.fPrivacyInfo.callPrivacy = data.cla;
                            $scope.fPrivacyInfo.chatPrivacy = data.chta;
                            $scope.fPrivacyInfo.feedPrivacy = data.fda;
                            //$scope.chatsettings.achat = data.ancht;

                            //if($scope.emailVerified){$scope.emailValue = 'Verified Email';$scope.emailTitle = 'Your Email is verified.';}
                            //if($scope.phoneVerified){$scope.phoneValue = 'Verified Phone';$scope.phoneTitle = 'Your Phone is verified.';}

                        }
                        $scope.$rgDigest();
                    });
                }else{
                    $scope.access = $scope.profileObj.getAccess;
                    $scope.fPrivacyInfo.callPrivacy = $scope.profileObj.getAccess().cla;
                    $scope.fPrivacyInfo.chatPrivacy = $scope.profileObj.getAccess().chta;
                    $scope.fPrivacyInfo.feedPrivacy = $scope.profileObj.getAccess().fda;
                    if( !$scope.fPrivacyInfo.callPrivacy && !$scope.fPrivacyInfo.chatPrivacy && !$scope.fPrivacyInfo.feedPrivacy ) {
                        $scope.profileObj.setBlock(1);
                    }
                    $scope.$rgDigest();
                }


                function  enablePrivacyEditMode ($event) {
                    $event.preventDefault();
                    $scope.isEditProfilePrivacy = true;
                    $scope.$rgDigest();
                }


                 function savePvcEdit(fPrivacyInfo) {
                    var callobj;
                    $scope.isEditProfilePrivacy = false;
                    // TODO REFACTOR API CALL FOR SAVING PRIVACY CHANGE
                    //var obj = {
                        //sv: 0,
                        //sn: 0,
                    //};
                    //if (!$scope.profileObj.isCurrentUser()) {
                        //obj.utId = $scope.profileObj.getUtId();
                    //}

                    //$scope.isFrndsPrivacyEdit=false;
                    //call privacy settings
                    if($scope.profileObj.isCurrentUser()){
                        callobj = {
                            actn:216,
                            sv:fPrivacyInfo.callPrivacy,
                            sn:6,
                            isCurrent:true
                        };
                    }else{
                        callobj = {
                            actn:82,
                            sv:fPrivacyInfo.callPrivacy,
                            sn:6,
                            utId:$scope.profileObj.getUtId(),
                            isCurrent:false
                        };
                    }
                    $scope.fPrivacyInfo.callPrivacy = fPrivacyInfo.callPrivacy;
                    // $timeout(function(){
                        profileFactory.saveCallPvcEdit(callobj).then(function(data){
                            if(data.sucs===true){
                                $scope.fPrivacyInfo.callPrivacy = fPrivacyInfo.callPrivacy;
                            }

                            //$scope.callPvcEdit = false;
                        });
                    // },100);

                    //chat privacy settings
                    var chatobj;
                    if($scope.profileObj.isCurrentUser()){
                        chatobj = {
                            actn:216,
                            sv:fPrivacyInfo.chatPrivacy,
                            sn:7,
                            isCurrent:true
                        };
                    }else{
                        chatobj = {
                            actn:82,
                            sv:fPrivacyInfo.chatPrivacy,
                            sn:7,
                            utId:$scope.profileObj.getUtId(),
                            isCurrent:false
                        };
                    }
                    $scope.fPrivacyInfo.chatPrivacy = fPrivacyInfo.chatPrivacy;
                    // $timeout(function(){
                        profileFactory.saveChatPvcEdit(chatobj).then(function(data){
                            if(data.sucs===true){
                                $scope.fPrivacyInfo.chatPrivacy = fPrivacyInfo.chatPrivacy;
                            }

                            //$scope.chatPvcEdit = false;
                        });
                    // },200);

                    //feed privacy settings
                    var feedObj;
                    if($scope.profileObj.isCurrentUser()){
                        feedObj = {
                            actn:216,
                            sv:fPrivacyInfo.feedPrivacy,
                            sn:8,
                            isCurrent:true
                        };
                    }else{
                        feedObj = {
                            actn:82,
                            sv:fPrivacyInfo.feedPrivacy,
                            sn:8,
                            utId:$scope.profileObj.getUtId(),
                            isCurrent:false
                        };
                    }
                    $scope.fPrivacyInfo.feedPrivacy = fPrivacyInfo.feedPrivacy;
                    // $timeout(function(){
                        profileFactory.saveFeedPvcEdit(feedObj).then(function(data){
                            if(data.sucs===true){
                                $scope.fPrivacyInfo.feedPrivacy = fPrivacyInfo.feedPrivacy;
                            }

                            //$scope.feedPvcEdit = false;
                        });
                    // },300);
                     $scope.$rgDigest();

                }

                function cancelPvcEdit() { // profile-privacy
                    $scope.isEditProfilePrivacy = false;
                    //$scope.isFrndsPrivacyEdit = false;
                    $scope.$rgDigest();
                }



            } // END CONTROLLER FUNC

            var linkFunc = function() {
            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-privacy.html',
                controller: ProfilePrivacyController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileEducation', rgProfileEducation);


        function rgProfileEducation()  {

            ProfileEducationController.$inject = [ 'Ringalert', '$scope','utilsFactory', 'profileFactory','$routeParams','rgDropdownService' ];
            function ProfileEducationController ( Ringalert, $scope,utilsFactory, profileFactory, $routeParams,rgDropdownService ) { //jshint ignore:line
                var tmpEducation,contentIndex;

                if($scope.profileObj.isCurrentUser()){
                    $scope.isOwner = true;
                }else{
                    $scope.isOwner = false;
                }

                var tempEduList;

                // initialization
                profileFactory.getUserProfileData({uId:$routeParams.uId}, $scope.profileObj.isCurrentUser());
                $scope.getProfileData = profileFactory.getProfileData;
                $scope.educationlist = $scope.getProfileData('educationList', $scope.profileObj.getUtId());


                $scope.edusclerror = false;
                $scope.edudgrerror = false;
                $scope.educntnerror = false;

                $scope.$watch('eduObjInfo.scl', function (newval,oldval) {
                    if(newval){
                        $scope.edusclerror = false;
                    }
                });
                $scope.$watch('eduObjInfo.dgr', function (newval,oldval) {
                    if(newval){
                        $scope.edudgrerror = false;
                    }
                });
                $scope.$watch('eduObjInfo.cntn', function (newval,oldval) {
                    if(newval){
                        $scope.educntnerror = false;
                    }
                });


                // dropdown
                $scope.ddActionHtml = 'pages/dropdowns/action-dropdown.html';//$templateCache.get('action-dropdown.html');
                $scope.actionEduDropdown = function(actionObj) {
                    //actionObj.event.preventDefault();
                    rgDropdownService.close(actionObj.event);
                    switch(actionObj.action) {
                        case 'edit':
                            enableEducationEditMode(actionObj.data.index,actionObj.data.obj);

                            break;
                        case 'delete':
                            deleteEducation(actionObj.data.index);

                            break;
                        default:
                    }
                };

                // models and methods
                $scope.isaddNewEducation = false;
                $scope.isEditEducation = -1;
                $scope.eduObjInfo = {}; // profile education

                $scope.addNewEducation = addNewEducation;
                $scope.submitNewEducation = submitNewEducation;
                $scope.updateEducation = updateEducation;
                $scope.cancelAddEducation = cancelAddEducation;
                $scope.cancelUpdateEducation = cancelUpdateEducation;

                function addNewEducation(){ // profile-education
                    if(tmpEducation){
                        $scope.educationlist[contentIndex] = tmpEducation;
                    }
                    $scope.isEditEducation = -1;
                    $scope.eduObjInfo.scl='';
                    $scope.eduObjInfo.dgr='';
                    $scope.eduObjInfo.cntn='';
                    $scope.eduObjInfo.toTimeE='';
                    $scope.eduObjInfo.fromTimeE='';
                    $scope.isaddNewEducation = true;

                    $scope.$rgDigest();
                }

                function enableEducationEditMode(index,object) {
                    contentIndex = index;
                    $scope.eduObjInfo = $scope.educationlist[index];
                    tmpEducation = angular.copy($scope.educationlist[index]);

                    if ($scope.eduObjInfo.tt === 1) {
                        $scope.eduObjInfo.toTimeE = null;
                    }
                    if ($scope.eduObjInfo.ft === 1) {
                        $scope.eduObjInfo.fromTimeE = null;
                    }
                    $scope.isaddNewEducation = false;
                    $scope.isEditEducation = index;

                    $scope.$rgDigest();

                }

                function cancelAddEducation(){
                    if(tmpEducation){
                        $scope.educationlist[contentIndex] = tmpEducation;
                    }
                    //$scope.educationlist = $scope.getProfileData('educationList', $scope.profileObj.getUtId());
                    //$scope.eduObjInfo.scl='';
                    //$scope.eduObjInfo.dgr='';
                    //$scope.eduObjInfo.cntn='';
                    //$scope.eduObjInfo.toTimeE='';
                    //$scope.eduObjInfo.fromTimeE='';

                    $scope.isaddNewEducation = false;
                    $scope.isEditEducation = -1;

                    $scope.$rgDigest();
                }

                function cancelUpdateEducation() {
                    $scope.educationlist[contentIndex] = tmpEducation;
                    $scope.isEditEducation = -1;
                    //$scope.isaddNewEducation = false;
                    //$scope.showAddButton = true;
                    $scope.$rgDigest();

                }


                function updateEducation() {

                    if( !$scope.eduObjInfo.scl ){
                        $scope.edusclerror = true;
                        $scope.$rgDigest();
                    }

                    if( !$scope.eduObjInfo.dgr ) {
                        $scope.edudgrerror = true;
                        $scope.$rgDigest();
                    }

                    if( !$scope.eduObjInfo.cntn ) {
                        $scope.educntnerror = true;
                        $scope.$rgDigest();
                    }

                    if( $scope.edusclerror || $scope.edudgrerror || $scope.educntnerror ){
                        return;
                    }

                    $scope.processing = true;

                    if($scope.eduObjInfo.fromTimeE && $scope.eduObjInfo.toTimeE){
                        var eduFromTime,eduToTime;
                        eduFromTime = $scope.eduObjInfo.fromTimeE;
                        eduToTime   = $scope.eduObjInfo.toTimeE;

                        if(typeof(eduFromTime)=='string'){
                            eduFromTime = new Date(eduFromTime);
                        }
                        if(typeof(eduToTime)=='string'){
                            eduToTime = new Date(eduToTime);
                        }
                        if(eduFromTime > eduToTime){
                            Ringalert.show('Your end date can\'t be earlier than your start date. Please try again','info');
                            $scope.processing = false;
                            return;
                        }
                        $scope.$rgDigest();
                    }
                    //$scope.eduObjInfo.ft = new Date($scope.eduObjInfo.fromTimeE).getTime();//will alert something like 1330192800000
                   // $scope.eduObjInfo.tt = new Date($scope.eduObjInfo.toTimeE).getTime();//will alert something like 1330192800000

                    if($scope.eduObjInfo.fromTimeE){
                        $scope.eduObjInfo.ft = new Date($scope.eduObjInfo.fromTimeE).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.eduObjInfo.ft = 1;
                    }
                    if($scope.eduObjInfo.toTimeE){
                        $scope.eduObjInfo.tt = new Date($scope.eduObjInfo.toTimeE).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.eduObjInfo.tt = 1;
                    }

                    profileFactory.updateEducation($scope.eduObjInfo).then(function(json){
                        if(json.sucs===true){
                            if($scope.eduObjInfo.fromTimeE){
                                $scope.eduObjInfo.fromTimeE = utilsFactory.profileVerbalDate($scope.eduObjInfo.ft);
                            }else{
                                $scope.eduObjInfo.ft = 1;
                                $scope.eduObjInfo.fromTimeE = '';
                            }
                            if($scope.eduObjInfo.toTimeE){
                                $scope.eduObjInfo.toTimeE = utilsFactory.profileVerbalDate($scope.eduObjInfo.tt);
                            }else{
                                $scope.eduObjInfo.tt = 1;
                                $scope.eduObjInfo.toTimeE = '';
                            }
                            $scope.isEditEducation = -1;

                            Ringalert.show('Successfully updated','success');
                        }else{
                            $scope.isEditEducation = -1;
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.processing = false;
                        $scope.$rgDigest();

                    });
                }


                function submitNewEducation() {

                    if( !$scope.eduObjInfo.scl ){
                        $scope.edusclerror = true;
                        $scope.$rgDigest();
                    }

                    if( !$scope.eduObjInfo.dgr ) {
                        $scope.edudgrerror = true;
                        $scope.$rgDigest();
                    }

                    if( !$scope.eduObjInfo.cntn ) {
                        $scope.educntnerror = true;
                        $scope.$rgDigest();
                    }

                    if( $scope.edusclerror || $scope.edudgrerror || $scope.educntnerror ){
                        return;
                    }

                    $scope.processing = true;

                    if($scope.eduObjInfo.fromTimeE && $scope.eduObjInfo.toTimeE){
                        if($scope.eduObjInfo.fromTimeE > $scope.eduObjInfo.toTimeE){
                            Ringalert.show('Your end date can\'t be earlier than your start date. Please try again','info');
                            $scope.processing = false;
                            return;
                        }
                    }

                    if($scope.eduObjInfo.fromTimeE){
                        $scope.eduObjInfo.ft = new Date(utilsFactory.profileVerbalDate($scope.eduObjInfo.fromTimeE)).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.eduObjInfo.ft = 1;
                    }
                    if($scope.eduObjInfo.toTimeE){
                        $scope.eduObjInfo.tt = new Date(utilsFactory.profileVerbalDate($scope.eduObjInfo.toTimeE)).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.eduObjInfo.tt = 1;
                    }

                    $scope.eduObjInfo.ut = new Date().getTime();
                    $scope.eduObjInfo.af = 1;
                    $scope.eduObjInfo.grtd = false;//have to add in ui
                    $scope.eduObjInfo.iss = true;

                    profileFactory.submitNewEducation($scope.eduObjInfo).then(function(json) {
                        if (json.sucs === true) {
                            // new education
                            $scope.eduObjInfo.id = json.id;
                            var obj = angular.copy($scope.eduObjInfo);
                            profileFactory.setProfileData('educationList', obj, $scope.profileObj.getUtId());
                            Ringalert.show('Education info added successfully','success');
                            $scope.isaddNewEducation = false;
                            $scope.isEditEducation = -1;
                        }else{
                            Ringalert.show('Request did not process successfully','error');
                            $scope.isaddNewEducation = false;
                            $scope.isEditEducation = -1;
                        }
                        $scope.isaddNewEducation = false;
                        $scope.isEditEducation = -1;
                        $scope.processing = false;
                        $scope.$rgDigest();
                    });
                }


                function deleteEducation(index) {
                    var eduId = $scope.getProfileData('educationList', $scope.profileObj.getUtId())[index].id;
                    $scope.isEditEducation = -1;
                    profileFactory.deleteEducation(eduId).then(function(data){
                        if(data.sucs===true){
                            $scope.getProfileData('educationList', $scope.profileObj.getUtId()).splice(index, 1);
                            Ringalert.show('Successfully deleted','success');
                        }else{
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.$rgDigest();

                    });
                }

                $scope.$on('$destroy', function() {
                    //profileFactory.setProfileData('educationList', [], $scope.profileObj.getUtId());
                });

            } // END CONTROLLER FUNC

            var linkFunc = function() {
            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-education.html',
                controller: ProfileEducationController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileWork', rgProfileWork);


        function rgProfileWork()  {

            ProfileWorkController.$inject = [  '$scope','utilsFactory', 'profileFactory','$routeParams','rgDropdownService','Ringalert' ];
            function ProfileWorkController (  $scope,utilsFactory, profileFactory, $routeParams,rgDropdownService,Ringalert ) { //jshint ignore:line

                // initialization
                if($scope.profileObj.isCurrentUser()){
                    $scope.isOwner = true;
                }else{
                    $scope.isOwner = false;
                }

                profileFactory.getUserProfileData({uId:$routeParams.uId}, $scope.profileObj.isCurrentUser());
                $scope.getProfileData = profileFactory.getProfileData;
                $scope.worklist = $scope.getProfileData('workList', $scope.profileObj.getUtId());

                // dropdown
                $scope.ddActionHtml = 'pages/dropdowns/action-dropdown.html';//$templateCache.get('action-dropdown.html');
                $scope.actionWorkDropdown = actionWorkDropdown;

                // models and methods
                $scope.isAddNewWork = false;
                $scope.isEditWork = -1;
                $scope.workObjInfo = {};
                var tmpWork,contentIndex;

                $scope.addNewWork = addNewWork;
                $scope.cancelNewWork = cancelNewWork;
                $scope.submitNewWork = submitNewWork;
                $scope.cancelUpdateWork = cancelUpdateWork;
                $scope.updateWork = updateWork;

                $scope.workcnmerror = false;
                $scope.workpstnerror = false;

                $scope.$watch('workObjInfo.cnm', function (newval,oldval) {
                    if(newval){
                        $scope.workcnmerror = false;
                    }
                });
                $scope.$watch('workObjInfo.pstn', function (newval,oldval) {
                    if(newval){
                        $scope.workpstnerror = false;
                    }
                });

                $scope.$watch('workObjInfo.status', function (newval,oldval) {
                    $scope.workObjInfo.toTimeE = '';
                });

                function addNewWork () {
                    if(tmpWork){
                        $scope.worklist[contentIndex] = tmpWork;
                    }
                    $scope.isEditWork = -1;
                    $scope.workObjInfo.cnm = '';
                    $scope.workObjInfo.pstn = '';
                    $scope.workObjInfo.desc = '';
                    $scope.workObjInfo.fromTimeE = '';
                    $scope.workObjInfo.toTimeE = '';
                    $scope.workObjInfo.ft = '';
                    $scope.workObjInfo.tt = '';
                    $scope.isAddNewWork = true;
                    $scope.$rgDigest();
                }


                function cancelNewWork () {
                    if(tmpWork){
                        $scope.worklist[contentIndex] = tmpWork;
                    }
                    //$scope.workObjInfo.cnm = '';
                    //$scope.workObjInfo.pstn = '';
                    //$scope.workObjInfo.ct = '';
                    //$scope.workObjInfo.desc = '';
                    //$scope.workObjInfo.ft = '';
                    //$scope.workObjInfo.tt = '';
                    $scope.isAddNewWork = false;
                    $scope.$rgDigest();
                }

                function submitNewWork() {

                    if( !$scope.workObjInfo.cnm ){
                        $scope.workcnmerror = true;
                        $scope.$rgDigest();

                    }

                    if( !$scope.workObjInfo.pstn ) {
                        $scope.workpstnerror = true;
                        $scope.$rgDigest();

                    }

                    if( $scope.workcnmerror || $scope.workpstnerror ){
                        return;
                    }

                    $scope.processing = true;

                    if($scope.workObjInfo.fromTimeE && $scope.workObjInfo.toTimeE){
                        if($scope.workObjInfo.fromTimeE > $scope.workObjInfo.toTimeE){
                            Ringalert.show('Your end date can\'t be earlier than your start date. Please try again','info');
                            $scope.processing = false;
                            return;
                        }
                    }

                    //var fromTime = $scope.workObjInfo.ft;
                    //var toTime = $scope.workObjInfo.tt;

                    //var fDate = utilsFactory.profileVerbalDate(fromTime);
                    //$scope.workObjInfo.ft = new Date(fDate).getTime();//will alert something like 1330192800000

                    //to date
                    if($scope.workObjInfo.status === true){
                        $scope.workObjInfo.tt = '0';
                        $scope.workObjInfo.status = true;
                        $scope.workObjInfo.date_info = 'Present';
                        //toTime = 0;

                    }else{

                        if($scope.workObjInfo.toTimeE){
                            $scope.workObjInfo.tt = new Date($scope.workObjInfo.toTimeE).getTime();//will alert something like 1330192800000
                        }else{
                            $scope.workObjInfo.tt = 1;
                        }
                    }

                    if($scope.workObjInfo.fromTimeE){
                        $scope.workObjInfo.ft = new Date($scope.workObjInfo.fromTimeE).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.workObjInfo.ft = 1;
                    }

                    profileFactory.submitNewWork($scope.workObjInfo).then(function(data) {

                        if(data.sucs === true){
                            $scope.workObjInfo.id = data.id;
                            if($scope.workObjInfo.ft){
                                $scope.workObjInfo.fromTimeE = utilsFactory.profileVerbalDate($scope.workObjInfo.ft);
                            }else{
                                $scope.workObjInfo.ft = 1;
                            }
                            if($scope.workObjInfo.tt){
                                $scope.workObjInfo.toTimeE = utilsFactory.profileVerbalDate($scope.workObjInfo.tt);
                            }else{
                                $scope.workObjInfo.tt = 1;
                            }
                            var obj = angular.copy($scope.workObjInfo);
                            profileFactory.setProfileData('workList', obj, $scope.profileObj.getUtId());
                            Ringalert.show('Career info added successfully','success');
                            $scope.isAddNewWork = false;
                            $scope.isEditWork = -1;

                        }else{
                            Ringalert.show('Request did not process successfully','error');
                            $scope.isAddNewWork = false;
                            $scope.isEditWork = -1;
                        }
                        $scope.processing = false;
                        $scope.$rgDigest();

                    });
                }

                function actionWorkDropdown(actionObj) {

                    //actionObj.event.preventDefault();

                    switch(actionObj.action) {
                        case 'edit':
                            enableWorkEditMode( actionObj.data.index );
                            rgDropdownService.close(actionObj.event);
                            break;
                        case 'delete':
                            deleteWork(actionObj.data.index);
                            rgDropdownService.close(actionObj.event);
                            break;
                        default:
                    }
                }

                function enableWorkEditMode(index) {
                    contentIndex = index;
                    $scope.workObjInfo = $scope.worklist[index];
                    tmpWork =  angular.copy($scope.worklist[index]);


                    if ($scope.workObjInfo.tt === 1 || $scope.workObjInfo.tt === '0' || $scope.workObjInfo.tt === 0) {
                        $scope.workObjInfo.toTimeE = null;
                    }
                    if ($scope.workObjInfo.ft === 1) {
                        $scope.workObjInfo.fromTimeE = null;
                    }
                    $scope.isAddNewWork = false;
                    $scope.isEditWork = index;
                    $scope.$rgDigest();

                }

                function updateWork() {

                    if( !$scope.workObjInfo.cnm ){
                        $scope.workcnmerror = true;
                        $scope.$rgDigest();

                    }

                    if( !$scope.workObjInfo.pstn ) {
                        $scope.workpstnerror = true;
                        $scope.$rgDigest();

                    }

                    if( $scope.workcnmerror || $scope.workpstnerror ){
                        return;
                    }

                    $scope.processing = true;

                    if($scope.workObjInfo.fromTimeE && $scope.workObjInfo.toTimeE){
                        var workFromTime,workToTime;
                        workFromTime = $scope.workObjInfo.fromTimeE;
                        workToTime   = $scope.workObjInfo.toTimeE;

                        if(typeof(workFromTime)=='string'){
                            workFromTime = new Date(workFromTime);
                        }
                        if(typeof(workToTime)=='string'){
                            workToTime = new Date(workToTime);
                        }
                        if(workFromTime > workToTime){
                            Ringalert.show('Your end date can\'t be earlier than your start date. Please try again','info');
                            $scope.processing = false;
                            return;
                        }
                        $scope.$rgDigest();
                    }

                    if($scope.workObjInfo.fromTimeE){
                        $scope.workObjInfo.ft = new Date($scope.workObjInfo.fromTimeE).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.workObjInfo.ft = 1;
                    }
                    if($scope.workObjInfo.toTimeE){
                        $scope.workObjInfo.tt = new Date($scope.workObjInfo.toTimeE).getTime();//will alert something like 1330192800000
                    }else{
                        $scope.workObjInfo.tt = 1;
                    }
                    if($scope.workObjInfo.status === true){
                        $scope.workObjInfo.tt = '0';
                        $scope.workObjInfo.status = true;
                        $scope.workObjInfo.date_info = 'Present';

                    }

                    profileFactory.updateWork($scope.workObjInfo).then(function(data){
                        if(data.sucs === true){

                            if($scope.workObjInfo.ft){
                                $scope.workObjInfo.fromTimeE = utilsFactory.profileVerbalDate($scope.workObjInfo.ft);
                            }else{
                                $scope.workObjInfo.ft = 1;
                            }
                            if($scope.workObjInfo.tt){
                                $scope.workObjInfo.toTimeE = utilsFactory.profileVerbalDate($scope.workObjInfo.tt);
                            }else{
                                $scope.workObjInfo.tt = 1;
                            }
                            if( $scope.workObjInfo.status === true ) {
                                $scope.workObjInfo.tt = 0;
                                $scope.date_info = 'Present';
                            }
                            Ringalert.show('Updated successfully','success');
                            $scope.isEditWork = -1;
                        }else{
                            $scope.isEditWork = -1;
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.processing = false;
                        $scope.$rgDigest();

                    });
                }

                function cancelUpdateWork() {
                    $scope.worklist[contentIndex] = tmpWork;
                    $scope.isEditWork = -1;
                    $scope.$rgDigest();
                }

                function deleteWork(index) {
                    $scope.isEditWork = -1;
                    var workId = $scope.getProfileData('workList', $scope.profileObj.getUtId())[index].id;
                    profileFactory.deleteWork(workId).then(function(data){
                        if(data.sucs===true){
                            $scope.getProfileData('workList', $scope.profileObj.getUtId()).splice(index, 1);
                            Ringalert.show('Successfully deleted','success');
                        }else{
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.$rgDigest();
                    });
                }

                $scope.$on('$destroy', function() {
                    //profileFactory.setProfileData('workList', [], $scope.profileObj.getUtId());
                });

            } // END CONTROLLER FUNC

            var linkFunc = function() {
            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-work.html',
                controller: ProfileWorkController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileSkill', rgProfileSkill);


        function rgProfileSkill()  {

            ProfileSkillController.$inject = [ '$scope', 'profileFactory','$routeParams','rgDropdownService','Ringalert' ];
            function ProfileSkillController ( $scope, profileFactory, $routeParams,rgDropdownService,Ringalert ) { //jshint ignore:line


                if($scope.profileObj.isCurrentUser()){
                    $scope.isOwner = true;
                    //$scope.showAddButton = true;
                }else{
                    $scope.isOwner = false;
                }

                $scope.skillsklerror = false;
                $scope.skilldescerror = false;

                $scope.$watch('skillObjInfo.skl', function (newval,oldval) {
                    if(newval){
                        $scope.skillsklerror = false;
                    }
                });
                $scope.$watch('skillObjInfo.desc', function (newval,oldval) {
                    if(newval){
                        $scope.skilldescerror = false;
                    }
                });
                // initialize
                profileFactory.getUserProfileData({uId:$routeParams.uId}, $scope.profileObj.isCurrentUser());
                $scope.getProfileData = profileFactory.getProfileData;
                $scope.skilllist = $scope.getProfileData('skillList', $scope.profileObj.getUtId());
                var tmpSkill,contentIndex;

                $scope.addNewSkill = addNewSkill;
                $scope.submitNewSkill = submitNewSkill;
                $scope.cancelNewSkill = cancelNewSkill;
                $scope.updateSkill = updateSkill;
                $scope.cancelUpdateSkill = cancelUpdateSkill;
                $scope.skillObjInfo = {};

                $scope.ddActionHtml = 'pages/dropdowns/action-dropdown.html';
                $scope.actionSkillDropdown = function(actionObj) {
                    switch(actionObj.action) {
                        case 'edit':
                            enableSkillEditMode(actionObj.data.index);
                            break;
                        case 'delete':
                            deleteSkill(actionObj.data.index);
                            break;
                        default:
                    }
                    rgDropdownService.close(actionObj.event);
                };

                $scope.isAddNewSkill = false;

                function addNewSkill() {
                    if(tmpSkill){
                        $scope.skilllist[contentIndex] = tmpSkill;
                    }
                    $scope.isEditSkill = -1;
                    $scope.skillObjInfo.skl = '';
                    $scope.skillObjInfo.desc = '';
                    $scope.isAddNewSkill = true;
                    $scope.$rgDigest();
                }

                function submitNewSkill() {

                    if( !$scope.skillObjInfo.desc ){
                        $scope.skilldescerror = true;
                        $scope.$rgDigest();

                    }

                    if( !$scope.skillObjInfo.skl ) {
                        $scope.skillsklerror = true;
                        $scope.$rgDigest();

                    }

                    if( $scope.skillsklerror || $scope.skilldescerror ){
                        return;
                    }



                    $scope.processing = true;
                    profileFactory.submitNewSkill($scope.skillObjInfo).then(function(data) {
                        var obj;
                        if( data.sucs===true ) {
                            $scope.skillObjInfo.id = data.id;
                            obj = angular.copy($scope.skillObjInfo);
                            profileFactory.setProfileData('skillList', obj, $scope.profileObj.getUtId());
                            Ringalert.show('Skill info added successfully','success');
                            $scope.isAddNewSkill = false;
                        }else{
                            $scope.isAddNewSkill = false;
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.processing = false;
                        $scope.$rgDigest();

                    });
                }

                function cancelNewSkill() {
                    if(tmpSkill){
                        $scope.skilllist[contentIndex] = tmpSkill;
                    }
                    //$scope.skillObjInfo.skl = '';
                    //$scope.skillObjInfo.desc = '';
                    $scope.isAddNewSkill = false;
                    $scope.$rgDigest();
                }



                function updateSkill() {

                    if( !$scope.skillObjInfo.desc ){
                        $scope.skilldescerror = true;
                        $scope.$rgDigest();

                    }

                    if( !$scope.skillObjInfo.skl ) {
                        $scope.skillsklerror = true;
                        $scope.$rgDigest();

                    }

                    if( $scope.skillsklerror || $scope.skilldescerror ){
                        return;
                    }

                    $scope.processing = true;
                    profileFactory.updateSkill($scope.skillObjInfo).then(function(data){
                        if(data.sucs===true){
                            $scope.isEditSkill = -1;
                            Ringalert.show('Successfully updated','success');
                        }else{
                            $scope.isEditSkill = -1;
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.processing = false;
                        $scope.$rgDigest();
                    });
                }

                function deleteSkill(index) {
                    var sid = $scope.getProfileData('skillList', $scope.profileObj.getUtId())[index].id;
                    $scope.isEditSkill = -1;
                    profileFactory.deleteSkill(sid).then(function(data){
                        if(data.sucs===true){
                            $scope.getProfileData('skillList', $scope.profileObj.getUtId()).splice(index, 1);
                            Ringalert.show('Successfully deleted','success');
                        }else{
                            Ringalert.show('Request did not process successfully','error');
                        }
                        $scope.$rgDigest();
                    });
                }

                function enableSkillEditMode(index) {
                    contentIndex = index;
                    $scope.skillObjInfo = $scope.skilllist[index];
                    tmpSkill = angular.copy($scope.skilllist[index]);
                    $scope.isAddNewSkill = false;
                    $scope.isEditSkill = index;
                    $scope.$rgDigest();
                    //$scope.showAddButton = false;
                }

                function cancelUpdateSkill() {
                    $scope.skilllist[contentIndex] = tmpSkill;
                    $scope.isEditSkill = -1;
                    $scope.$rgDigest();
                    //$scope.isAddNewSkill = false;
                    //$scope.showAddButton = true;
                }


                $scope.$on('$destroy', function() {
                    //profileFactory.setProfileData('skillList', [], $scope.profileObj.getUtId());
                });

            } // END CONTROLLER FUNC

            var linkFunc = function() {

            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-skill.html',
                controller: ProfileSkillController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfilePassword', rgProfilePassword);


        function rgProfilePassword()  {

            ProfilePasswordController.$inject = [ '$scope','Ringalert', 'profileFactory'];
            function ProfilePasswordController ( $scope,Ringalert, profileFactory) { //jshint ignore:line

                $scope.enablePassEdit = enablePassEdit;
                $scope.updatePassword = updatePassword;
                $scope.cancelUpdatePassword = cancelUpdatePassword;
                $scope.showMessage = true;
                $scope.showPassEdit = false;
                $scope.IsMatch=false;
                $scope.oldError = false;

                function enablePassEdit(event) {
                    event.preventDefault();
                    if ($scope.showPassEdit === false) {
                        $scope.showPassEdit = true;
                        $scope.showMessage = false;
                    }
                    $scope.$rgDigest();
                }

                function cancelUpdatePassword() {
                    $scope.showPassEdit = false;
                    $scope.showMessage = true;
                    $scope.IsMatch=false;
                    $scope.$rgDigest();
                }

                function updatePassword(obj) {
                    if(obj.newpassword != obj.repassword){
                        $scope.IsMatch=true;
                    }else if(obj.newpassword == obj.repassword){
                        $scope.IsMatch=false;
                        $scope.oldError = false;
                        profileFactory.changePassword(obj.oldpassword, obj.newpassword).then(function(data) {
                            if(data.sucs===true) {
                                obj = {
                                    oldpassword : '',
                                    newpassword : '',
                                    repassword : ''
                                };
                                $scope.showPassEdit = false;
                                $scope.showMessage = true;
                                Ringalert.show('Password Changed Successfully', 'success');
                            }else{
                                Ringalert.show(data.mg, 'info');
                            }


                        },function(data){
                            $scope.oldError = true;
                        });
                    }
                    $scope.$rgDigest();
                }

            } // END CONTROLLER FUNC

            var linkFunc = function() {
            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-password.html',
                controller: ProfilePasswordController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileRecovery', rgProfileRecovery);


        function rgProfileRecovery()  {

            ProfileRecoveryController.$inject = [ 'rgDropdownService','countryListService', '$scope','Ringalert', 'profileFactory','$routeParams' , 'Auth'];
            function ProfileRecoveryController ( rgDropdownService, countryListService, $scope,Ringalert, profileFactory, $routeParams, Auth) { //jshint ignore:line

                $scope.emailVerified = false;
                $scope.phoneVerified = false;
                $scope.countryList = {};

                $scope.isAddEmail = false;
                $scope.isAddPhone = false;
                $scope.addEmail = addEmail;
                $scope.addPhone = addPhone;
                $scope.isAddCode = false;
                $scope.showAddEmailButton = true;
                $scope.showAddPhoneButton = true;
                $scope.cancelAddEmail = cancelAddEmail;
                $scope.cancelAddPhone = cancelAddPhone;
                $scope.sendCode = sendCode;
                $scope.sendCodeToPhn = sendCodeToPhn;
                $scope.verifyCode = verifyCode;
                $scope.verifyPhoneCode = verifyPhoneCode;

                //$scope.resendCodeToMailOption = false;
                //$scope.resendCodeToPhoneOption = false;

                var verifyEmail;
                var mblDc;
                var phoneNumber;
                var uid = $routeParams.uId;
                $scope.emailValue = 'Verify Email';
                $scope.emailTitle = 'Click here to verify your Email';
                $scope.phoneValue = 'Verify Phone';
                $scope.phoneTitle = 'Click here to verify your Phone';

                var countryList = [];
                //$scope.ddHtml = 'pages/dropdowns/country-list-dropdown.html';
                $scope.ddTemplate =
                         '<div class="country-wrapper" >' +
                            '<ul id="countrylist" class="ringdropdown" rg-scrollbar="scrollbar()">' +
                                '<div class="count-s">' +
                                '<input type="text" ng-model="countryName" placeholder="Search Country">' +
                                '</div>' +
                                '<a ng-repeat="item in ddControl.countryList() | filter:countryName" ><li class="flag {{item.flagcode}}" ng-click="ddAction()({event: $event, item: item})" > ' +
                                '<span> {{ item.country }}</span></li></a>' +
                            '</ul>' +
                          '</div>';
                $scope.ddControl = {
                    countryList: function() {
                        return countryList;
                    }
                };

                $scope.phone = {
                    countryCode     : Auth.getCountry().code, //'+93'
                };
                $scope.countryFlag   = Auth.getCountry().flagcode; //'a93';

                $scope.setPrefix = setPrefix;

                countryListService.getList().success(function (data) {
                    countryList = data;
                    $scope.$rgDigest();
                });


                // Auth.fetchPrivacy().then(function(data){
                //     if(data.sucs===true){
                //         $scope.emailVerified = data.iev;
                //         $scope.phoneVerified = data.imnv;
                //         $scope.vemail = data.el;
                //         $scope.vnumber = data.mblDc+data.mbl;

                //             if($scope.emailVerified){$scope.emailValue = 'Verified Email';$scope.emailTitle = 'Your Email is verified.';}
                //             if($scope.phoneVerified){$scope.phoneValue = 'Verified Phone';$scope.phoneTitle = 'Your Phone is verified.';}

                //         }
                //         $scope.$rgDigest();

                // });

                if($scope.profileObj.isEmailVerified()){
                    $scope.emailValue = 'Verified Email';
                    $scope.emailTitle = 'Your Email is verified.';
                    $scope.emailVerified = true;
                    $scope.vemail = $scope.profileObj.getEmail();
                }
                if($scope.profileObj.isMobileVerified()){
                    $scope.phoneValue = 'Verified Phone';
                    $scope.phoneTitle = 'Your Phone is verified.';
                    $scope.phoneVerified = true;
                    $scope.vnumber = $scope.profileObj.getMobileNumber();
                }


                $scope.cancelVerification = function(){
                    $scope.isAddCode = false;
                    $scope.isAddPhnCode  = false;
                    $scope.showAddEmailButton  = true;
                    $scope.showAddPhoneButton  = true;
                    $scope.$rgDigest();
                };

                $scope.resendCodeToMail = function () {
                    profileFactory.sendCode({email:verifyEmail}).then(function(data){
                        if(data.sucs===true){
                            verifyEmail = data.el;
                            Ringalert.show(data.mg,'info');
                        }else{
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();
                    });
                };

                $scope.resendCodeToPhone = function () {
                    profileFactory.sendCodeToPhn({phone:$scope.phoneNumber,countryCode:mblDc}).then(function(data){
                        if(data.sucs===true){
                            $scope.phoneNumber = data.mbl;
                            mblDc = data.mblDc;
                            Ringalert.show(data.mg,'info');
                        }else{
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();
                    });
                };

                function setPrefix(actionObj) { //jshint ignore:line
                    //actionObj.event.preventDefault();
                    $scope.phone.countryCode = actionObj.item.code;
                    $scope.countryFlag = actionObj.item.flagcode;
                    rgDropdownService.close(actionObj.event);
                }

                function addEmail(){
                    $scope.isAddEmail = true;
                    $scope.showAddEmailButton = false;
                    $scope.$rgDigest();
                }

                function addPhone(){
                    $scope.isAddPhone = true;
                    $scope.showAddPhoneButton = false;
                    $scope.$rgDigest();
                }

                function cancelAddEmail(){
                    $scope.isAddEmail = false;
                    $scope.showAddEmailButton = true;
                    $scope.$rgDigest();
                }

                function cancelAddPhone(){
                    $scope.isAddPhone = false;
                    $scope.showAddPhoneButton = true;
                    $scope.$rgDigest();
                }

                function sendCode(email) {
                    profileFactory.sendCode(email).then(function(data){
                        if(data.sucs===true){
                            verifyEmail = data.el;
                            $scope.isAddEmail = false;
                            $scope.isAddCode = true;
                            $scope.vemail = '';
                            $scope.emailVerified = false;
                            $scope.emailTitle = 'Click here to verify your Email';
                            email.email='';
                            //$scope.resendCodeToMailOption = true;
                        }else{
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();
                    });
                }

                function sendCodeToPhn(phone) {
                    var theNumber = '';
                    if(phone.countryCode === '+880' && phone.phone.charAt(0) === '0'){
                        theNumber = phone.phone.substr(1);
                    }else{
                        theNumber = phone.phone;
                    }
                    $scope.phone.phone = theNumber;
                    profileFactory.sendCodeToPhn($scope.phone).then(function(data){
                        if(data.sucs===true){
                            $scope.phoneNumber = data.mbl;
                            mblDc = data.mblDc;
                            $scope.isAddPhone = false;
                            $scope.isAddPhnCode = true;
                            $scope.phoneVerified = false;
                            $scope.phoneTitle = 'Click here to verify your Phone';
                            phone.phone='';
                            //$scope.resendCodeToPhoneOption = true;
                            Ringalert.show(data.mg,'info');
                        }else{
                            //$scope.isAddPhone = false;
                            //$scope.isAddPhnCode = false;
                            //$scope.showAddPhoneButton = true;
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();

                    });
                }

                function verifyCode(obj) {
                    obj.email = verifyEmail;
                    profileFactory.verifyCode(obj).then(function(data){
                        if(data.sucs===true){
                            $scope.isAddEmail = false;
                            $scope.isAddCode = false;
                            $scope.showAddEmailButton = true;
                            $scope.emailVerified = true;
                            $scope.emailValue = 'Verified Email';
                            $scope.emailTitle = 'Your Email is verified.';
                            $scope.vemail = data.el;
                            obj.code = '';
                            obj.email = '';
                            Ringalert.show(data.mg,'success');
                        }else{
                            $scope.isAddEmail = false;
                            $scope.isAddCode = false;
                            $scope.showAddEmailButton = true;
                            $scope.emailVerified = false;
                            $scope.vemail = '';
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();

                    });
                }

                function verifyPhoneCode(obj) {
                    var phnObj = {};
                    phnObj.phone = $scope.phoneNumber;
                    phnObj.uId = uid;
                    phnObj.mblDc = mblDc;
                    phnObj.code = obj.code;
                    profileFactory.verifyPhnCode(phnObj).then(function(data){
                        if(data.sucs===true){
                            $scope.isAddPhone = false;
                            $scope.isAddPhnCode = false;
                            $scope.showAddPhoneButton = true;
                            $scope.phoneVerified = true;
                            $scope.phoneValue = 'Verified Phone';
                            $scope.phoneTitle = 'Your Phone is verified.';
                            obj.code ='';
                            Ringalert.show(data.mg,'success');
                        }else{
                            $scope.isAddPhone = false;
                            $scope.isAddPhnCode = false;
                            $scope.showAddPhoneButton = true;
                            $scope.phoneVerified = false;
                            Ringalert.show(data.mg,'info');
                        }
                        $scope.$rgDigest();

                    });
                }

            } // END CONTROLLER FUNC

            var linkFunc = function() {
            };

            return {
                restrict: 'E',
                //scope: true,
                templateUrl: 'pages/profile/profile.about-recovery.html',
                controller: ProfileRecoveryController,
                link: linkFunc
            };

        }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileAchat', rgProfileAchat);


    function rgProfileAchat()  {

        ProfileAchatController.$inject = [ '$scope', 'profileFactory','Auth' ];
        function ProfileAchatController ( $scope, profileFactory,Auth ) {

            $scope.isEditAchat = false;

            $scope.chatsettings = {
                achat : Auth.getPermission().ancht
            };

            $scope.enableAchatEditMode = enableAchatEditMode;
            $scope.saveAchatSettings = saveAchatSettings;
            $scope.cancelAchatSettings = cancelAchatSettings;

            function  enableAchatEditMode ($event) {
                $event.preventDefault();
                $scope.isEditAchat = true;
                $scope.$rgDigest();
            }




            function saveAchatSettings(chatsettings) {
                $scope.isEditAchat = false;

                var achatobj;
                if($scope.profileObj.isCurrentUser()){
                    achatobj = {
                        sv:chatsettings.achat,
                        sn:10
                    };
                }
                $scope.chatsettings.achat = chatsettings.achat;
                profileFactory.saveAchatSetting(achatobj).then(function(data){
                    if(data.sucs===true){
                        $scope.chatsettings.achat = chatsettings.achat;
                        Auth.setAchatPermission(chatsettings.achat);
                    }else{
                        $scope.chatsettings.achat = 0;
                    }
                });
                $scope.$rgDigest();

            }

            function cancelAchatSettings() {
                $scope.isEditAchat = false;
                $scope.$rgDigest();
            }



        } // END CONTROLLER FUNC

        var linkFunc = function() {
        };

        return {
            restrict: 'E',
            //scope: true,
            templateUrl: 'pages/profile/profile.about-achat.html',
            controller: ProfileAchatController,
            link: linkFunc
        };

    }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileAinfndreq', rgProfileAinfndreq);


    function rgProfileAinfndreq()  {

        ProfileAinfndreqController.$inject = [ '$scope', 'profileFactory','Auth' ];
        function ProfileAinfndreqController ( $scope, profileFactory,Auth ) {

            $scope.isEditAinfndreq = false;

            $scope.incomingfndreqsettings = {
                ainfndreq : Auth.getPermission().aifr
            };

            $scope.enableAinfndreqEditMode = enableAinfndreqEditMode;
            $scope.saveAinfndreqSettings = saveAinfndreqSettings;
            $scope.cancelAinfndreqSettings = cancelAinfndreqSettings;

            function  enableAinfndreqEditMode ($event) {
                $event.preventDefault();
                $scope.isEditAinfndreq = true;
                $scope.$rgDigest();
            }

            function saveAinfndreqSettings(incomingfndreqsettings) {
                $scope.isEditAinfndreq = false;

                var ainfndreqobj;
                if($scope.profileObj.isCurrentUser()){
                    ainfndreqobj = {
                        sv:incomingfndreqsettings.ainfndreq,
                        sn:11
                    };
                }
                $scope.incomingfndreqsettings.ainfndreqobj = incomingfndreqsettings.ainfndreqobj;
                profileFactory.saveAinfndreqSettings(ainfndreqobj).then(function(data){
                    if(data.sucs===true){
                        $scope.incomingfndreqsettings.ainfndreq = incomingfndreqsettings.ainfndreq;
                        Auth.setAinfndreqPermission(incomingfndreqsettings.ainfndreq);
                    }else{
                        $scope.incomingfndreqsettings.ainfndreq = 0;
                    }
                });
                $scope.$rgDigest();
            }

            function cancelAinfndreqSettings() {
                $scope.isEditAinfndreq = false;
                $scope.$rgDigest();
            }

        } // END CONTROLLER FUNC

        var linkFunc = function() {
        };

        return {
            restrict: 'E',
            //scope: true,
            templateUrl: 'pages/profile/profile.about-incoming-frnd-req.html',
            controller: ProfileAinfndreqController,
            link: linkFunc
        };

    }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileAllowaddme', rgProfileAllowaddme);


    function rgProfileAllowaddme()  {

        ProfileAllowaddmeController.$inject = [ '$scope', 'profileFactory','Auth' ];
        function ProfileAllowaddmeController ( $scope, profileFactory,Auth ) {

            $scope.isEditAfam = false;

            $scope.afamsettings = {
                afam : Auth.getPermission().afam
            };

            $scope.enableAfamEditMode = enableAfamEditMode;
            $scope.saveAfamSettings   = saveAfamSettings;
            $scope.cancelAfamSettings = cancelAfamSettings;

            function  enableAfamEditMode ($event) {
                $event.preventDefault();
                $scope.isEditAfam = true;
                $scope.$rgDigest();
            }

            function saveAfamSettings(afamsettings) {
                $scope.isEditAfam = false;

                var afamobj;
                if($scope.profileObj.isCurrentUser()){
                    afamobj = {
                        sv:afamsettings.afam,
                        sn:12
                    };
                }
                $scope.afamsettings.afam = afamsettings.afam;
                profileFactory.saveAfamSettings(afamobj).then(function(data){
                    if(data.sucs===true){
                        $scope.afamsettings.afam = afamsettings.afam;
                        Auth.setAfamPermission(afamsettings.afam);
                    }else{
                        $scope.afamsettings.afam = 0;
                    }
                });
                $scope.$rgDigest();

            }

            function cancelAfamSettings() {
                $scope.isEditAfam = false;
                $scope.$rgDigest();
            }



        } // END CONTROLLER FUNC

        var linkFunc = function() {
        };

        return {
            restrict: 'E',
            //scope: true,
            templateUrl: 'pages/profile/profile.about-afam.html',
            controller: ProfileAllowaddmeController,
            link: linkFunc
        };

    }
})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.profile')
        .directive('rgProfileAutoaddfrnd', rgProfileAutoaddfrnd);


    function rgProfileAutoaddfrnd()  {

        ProfileAafController.$inject = [ '$scope', 'profileFactory','Auth' ];
        function ProfileAafController ( $scope, profileFactory,Auth ) {

            $scope.isEditAaf = false;

            $scope.aafsettings = {
                aaf : Auth.getPermission().aaf
            };

            $scope.enableAafEditMode = enableAafEditMode;
            $scope.saveAafSettings   = saveAafSettings;
            $scope.cancelAafSettings = cancelAafSettings;

            function enableAafEditMode ($event) {
                $event.preventDefault();
                $scope.isEditAaf = true;
                $scope.$rgDigest();
            }

            function saveAafSettings(aafsettings) {
                $scope.isEditAaf = false;

                var aafobj;
                if($scope.profileObj.isCurrentUser()){
                    aafobj = {
                        sv:aafsettings.aaf,
                        sn:13
                    };
                }
                $scope.aafsettings.aaf = aafsettings.aaf;
                profileFactory.saveAafSetting(aafobj).then(function(data){
                    if(data.sucs===true){
                        $scope.aafsettings.aaf = aafsettings.aaf;
                        Auth.setAafPermission(aafsettings.aaf);
                    }else{
                        $scope.aafsettings.aaf = 0;
                    }
                });
                $scope.$rgDigest();

            }

            function cancelAafSettings() {
                $scope.isEditAaf = false;
                $scope.$rgDigest();
            }

        } // END CONTROLLER FUNC

        var linkFunc = function() {
        };

        return {
            restrict: 'E',
            //scope: true,
            templateUrl: 'pages/profile/profile.about-aaf.html',
            controller: ProfileAafController,
            link: linkFunc
        };

    }
})();

(function(){
    'use strict';
    angular.module('ringid.profile')
        .directive('rgRelocateTemplate', function() {
            return {
                restrict: 'E',
                template: '<ng-include src="template"></ng-include>',
                link: function(scope, elem, attr) {
                    var twocol = attr.twocol;
                    var threecol = attr.threecol;
                    scope.template = threecol;


                    if (window.innerWidth > 1800 || window.innerWidth <1200 && scope.template != threecol) {
                        scope.template = threecol;
                    }
                    else if (window.innerWidth > 1200 && window.innerWidth <1800 && scope.template != twocol) {
                        scope.template = twocol;
                    }

                    window.onresize = function() {
                        if (window.innerWidth > 1800 || window.innerWidth <1200 && scope.template != threecol) {
                            scope.template = threecol;
                            scope.$apply();
                        }
                        else if (window.innerWidth > 1200 && window.innerWidth <1800 && scope.template != twocol) {
                            scope.template = twocol;
                            scope.$apply();
                        }
                    }
                }
            }
        });

})();







/*
 * © Ipvision
 */
(function() {
    'use strict';
    angular
        .module('ringid.profile')
        .service('profileFactory', profileFactory);

    profileFactory.$inject = ['$routeParams', 'Storage', 'Auth', '$$connector','$$q', 'Ringalert',
        'profileHttpService','userFactory','OPERATION_TYPES', 'fileUploadService', 'utilsFactory'];

    function profileFactory($routeParams, Storage, Auth, $$connector, $q, Ringalert, // jshint ignore:line
                            profileHttpService, userFactory,OPERATION_TYPES, fileUploadService, utilsFactory) {

        var OTYPES = OPERATION_TYPES.SYSTEM.PROFILE,
            _profile = Auth.currentUser(),
            _otherProfile = {},
            _profileData = {};


        function _addEducation(education, utId) {
            var educationObj = education;

            educationObj.fromTime = new Date(educationObj.ft);
            educationObj.toTime = new Date(educationObj.tt);

            educationObj.fromTimeE = utilsFactory.profileVerbalDate(educationObj.ft);

            educationObj.toTimeE = utilsFactory.profileVerbalDate(educationObj.tt);
            _profileData[utId].educationList.push(educationObj) ;
        }

        function _addWork(work, utId) {
            var workObj = work;
            workObj.fromTime = new Date(workObj.ft);
            workObj.toTime = new Date(workObj.tt);

            if(workObj.tt===0){
                workObj.status = true;
                workObj.date_info = 'Present';
            }else{
                workObj.toTimeE = utilsFactory.profileVerbalDate(workObj.tt);
            }
            workObj.fromTimeE = utilsFactory.profileVerbalDate(workObj.ft);
            _profileData[utId].workList.push(workObj);
        }

        function _addSkill(skill, utId) {
            var skillObj = skill;

            _profileData[utId].skillList.push(skillObj);

        }

        function _setProfileData(type, data, utId) {
            if (_profileData.hasOwnProperty(utId)) {
                switch(type) {
                    case 'educationList':
                        _addEducation(data, utId);
                         break;
                    case 'workList':
                        _addWork(data, utId);
                        break;
                    case 'skillList':
                        _addSkill(data, utId);
                        break;
                    default:
                }
                //_profileData[utId][type].push(data);
            }
        }

        function _getProfileData(whatData, utId) {
            if (_profileData.hasOwnProperty(utId)) {
                return _profileData[utId][whatData];
            } else {
                return [];
            }
        }

        function _removeProfileData(utId) {
            delete _profileData[utId];
        }


        var _processResponse = function(json) {
            var i;
            switch(json.actn) {
                case OTYPES.ACTION_USERS_PRESENCE_DETAILS_DATA:
                    // update user presence detail
                    if(json.sucs === true) {
                        userFactory.create(json); //{psnc: json.psnc, lot: json.lot, uId: json.uId, dvc: json.dvc};
                    }
                    break;
                case OTYPES.TYPE_ACTION_GET_WORK:
                    if (json.sucs === true) {
                        for(i=0; i<json.workList.length; i++) {
                            _addWork(json.workList[i], json.workList[i].utId);
                        }
                    } else {
                    }
                    break;
                case OTYPES.TYPE_ACTION_GET_EDUCATION:
                    if (json.sucs === true) {
                        for(i=0; i<json.educationList.length; i++) {
                            _addEducation(json.educationList[i], json.educationList[i].utId);
                        }
                    } else {
                    }
                    break;
                case OTYPES.TYPE_ACTION_GET_SKILL:
                    if (json.sucs === true) {
                        for(i=0; i<json.skillList.length; i++) {
                            _addSkill(json.skillList[i], json.skillList[i].utId);
                        }
                    } else {
                    }
                    break;
                default:
            }
        };

        $$connector.subscribe(_processResponse, {
            action: [
                //OTYPES.ACTION_USERS_PRESENCE_DETAILS,
                OTYPES.ACTION_USERS_PRESENCE_DETAILS_DATA,
                OTYPES.TYPE_ACTION_GET_WORK,
                OTYPES.TYPE_ACTION_GET_EDUCATION,
                OTYPES.TYPE_ACTION_GET_SKILL
            ]
        });

        function getProfile (uId) {
            if( !_profile ) {
                _profile = Auth.currentUser();
            }
            if (uId === _profile.getKey()) {
                return _profile;
            } else {
                _otherProfile = userFactory.create({uId: uId});
                return _otherProfile;
            }

        }

        function init(user) {

            var defer = $q.defer();

            //if (!user.isCurrentUser()) {
                // request for presence details
                //profileHttpService.fetchPresence([user.getKey()]);
            //}
            profileHttpService.basicAndPrivacy(user.getUtId(), user.isCurrentUser()).then(function(response) {
                if (response.sucs === true) {
                    if (user.isCurrentUser()) {
                        _profile = userFactory.create(angular.extend({}, response, {uId: user.getKey()}), true, true);
                    } else {
                        _otherProfile = userFactory.create(response.userDetails, true, false);
                        profileHttpService.fetchPresenceAndMood(user.getKey()).then(function(json) {
                            _otherProfile.updateUserObj(json);
                        });
                    }
                    defer.resolve();
                } else {
                    defer.reject();
                }
            });

            return defer.promise;
        }


        function getUserDetailsByUId (uId){
            var deferred = $q.defer(),
                user = userFactory.getUser(uId);
            uId = uId || $routeParams.uId;
            if( !user ){

                var userObj = userFactory.create({uId : uId});
                profileHttpService.getUserDetails({uId : uId}).then(function(response){
                    if(!!response.sucs){
                        userObj = userFactory.create(response.userDetails);
                        deferred.resolve(userObj);
                    }else{
                        //deferred.resolve(false);
                        deferred.reject(false);
                    }
                });

            }else{
                deferred.resolve(user);
            }

            return deferred.promise;
        }

        function getUserObjectByUId(uId, callback){

            var userObj = userFactory.getUser(uId);

            if( !userObj){

                userObj = userFactory.create({uId : uId});

                profileHttpService.getUserDetails({uId : uId}).then(function(response){
                    if(!!response.sucs){
                        userFactory.create(response.userDetails);
                        if( !!callback){
                            callback.call(this);
                        }
                    }
                });
            }


            return userObj;
        }

        function getMutualFriends(friendId) {
            profileHttpService.getMutualFriends(friendId).then(function(response) {
                if(response.sucs === true) {
                    _otherProfile.updateUserObj({nmf: response.mfIDs.length});
                    //for(var i=0;i< json.mfIDs.length;i++){
                        //friend = User.createByUtId({utId: json.mfIDs[i]});
                        //$scope.friends.add(friend.getKey(), friend);
                    //}
                }
            },function() {
            });
        }

        // get user profile details i.e. skill, work, edu etc
        function getUserProfileData(obj, isCurrent) {
            var user;
            if(isCurrent) {
                user = _profile;
            }else{
                user = userFactory.create(obj);
            }

            // only call for details if not called already
            if (!_profileData.hasOwnProperty(user.getUtId()) ) {
                _profileData[user.getUtId()] = {
                    workList: [],
                    educationList : [],
                    skillList: []
                };
                if (isCurrent) {
                    profileHttpService.getUserProfileData();
                } else {
                    profileHttpService.getUserProfileData(user.getUtId());
                }
            }
        }



        function changeProfilePicture  (obj) {
            var defer = $q.defer();
            if (!obj) {
                // existing image
                obj = {
                    iurl: _profile.avatar('iurl')
                };
            }
            // for getting cimx and cimy
            obj = angular.extend({}, obj, fileUploadService.getReposition('profilephoto'));
            profileHttpService.changeProfilePicture(obj).then(function (data) {
                if (data.sucs === true) {
                    Storage.updateLoginData('prIm', obj.iurl);
                    Storage.updateLoginData('prImId', data.imgId);
                    _profile.setProfileImage(obj.iurl, data.imgId);

                    defer.resolve(data);
                } else {
                    defer.reject(data);
                }
            }, function(errData) {
                defer.reject(errData);
            });
            return defer.promise;
        }

        function changeCoverPicture  (obj) {
            var defer = $q.defer();
            if (!obj) {
                // existing image
                obj = {
                    iurl: _profile.getCover('iurl')
                };
            }
            // for getting cimX and cimY
            obj = angular.extend({}, obj, fileUploadService.getReposition('coverphoto'));
            profileHttpService.changeCoverPicture(obj).then(function (data) {
                if (data.sucs) {
                    _profile.setCover(angular.extend(obj, {cImId: data.imgId}));
                    defer.resolve();
                } else {
                    defer.reject();
                }
            }, function(errData) {
                  defer.reject();
            });
            return defer.promise;
        }



        function removeProfilePicture  () {
            var deferred = $q.defer();
            _profile.resetAvatar();
            profileHttpService.removeProfilePicture(_profile.avatar('iurl')).then(function (data) {
                if (data.sucs) {
                    deferred.resolve();
                }
            }, function(errData) {
                deferred.reject('Profile picture removal failed');
            });
            return deferred.promise;
        }

        function removeCoverPicture  () {
            var deferred = $q.defer();
            _profile.resetCover();
            profileHttpService.removeCoverPicture(_profile.getCover('iurl')).then(function (data) {
                if (data.sucs) {
                    // reset cover to default cover
                    deferred.resolve();
                } else {
                    deferred.reject('Cover picture removal failed');
                }
            });
            return deferred.promise;
        }



        return {
            // api
            init: init,
            getProfile: getProfile,
            getUserDetailsByUId: getUserDetailsByUId,
            getUserObjectByUId : getUserObjectByUId,
            getMutualFriends: getMutualFriends,
            getUserProfileData: getUserProfileData,

            changeProfilePicture: changeProfilePicture,
            changeCoverPicture: changeCoverPicture,
            removeProfilePicture: removeProfilePicture,
            removeCoverPicture: removeCoverPicture,

            updateUserProfile: profileHttpService.updateProfile,
            savePvcEdit: profileHttpService.updateUserPrivacy,
            submitNewEducation: profileHttpService.submitNewEducation,

            saveAchatSetting:profileHttpService.saveAchatSetting,
            saveAinfndreqSettings:profileHttpService.saveAinfndreqSettings,
            saveAfamSettings:profileHttpService.saveAfamSettings,
            saveAafSetting:profileHttpService.saveAafSetting,

            getProfileData: _getProfileData,
            setProfileData: _setProfileData,
            removeProfileData: _removeProfileData,
            deleteEducation: profileHttpService.deleteEducation,
            getAllEducation: profileHttpService.getEducationData,
            updateEducation: profileHttpService.updateEducationById,

            submitNewSkill: profileHttpService.submitNewSkill,
            updateSkill: profileHttpService.updateSkill,
            deleteSkill: profileHttpService.deleteSkill,

            submitNewWork: profileHttpService.submitNewWork,
            updateWork: profileHttpService.updateWork,
            deleteWork: profileHttpService.deleteWork,

            changePassword: profileHttpService.changePassword,
            verifyCheck: profileHttpService.verifyCheck,
            sendCode: profileHttpService.sendCode,
            sendCodeToPhn: profileHttpService.sendCodeToPhn,
            verifyCode: profileHttpService.verifyCode,
            verifyPhnCode: profileHttpService.verifyPhnCode,

            changePrivacy: profileHttpService.changePrivacy,
            saveCallPvcEdit: profileHttpService.saveCallPvcEdit,
            saveChatPvcEdit: profileHttpService.saveChatPvcEdit,
            saveFeedPvcEdit: profileHttpService.saveFeedPvcEdit,
            moodChange: profileHttpService.moodChange,

            addSocialAccount: profileHttpService.addSocialAccount

        };

    }
})();

;(function(global){

    global.CHAT_APP = {
        GLOBALS           : {
            uId               : -1,
            appVersion        : -1
        },

        Constants               : {},
        PacketFormats           : {},
        PacketFormats           : {},
        AuthPacketSender        : {},
        AuthRequests            : {},
        AuthResponses           : {},
        ChatPacketSender        : {},
        Helpers                 : {},
        ResponseHelpers         : {},
        SharedHelpers           : {},
        ChatPacketParser        : {},
        PacketSendFlow          : {},
        ChatSessionPacketSender : {},
        ChatOnlinePacketSender  : {},
        ChatOfflinePacketSender : {},

        MODELS                  : {
            SESSION_OBJECT          : {}
        },

        CHAT_CLOCK              : {},
        REQUEST_CACHE           : {},
        RESPONSE_CACHE          : {},
        CHAT_SESSION            : {},
        BROKEN_PACKET_CACHE     : {},
        
        UTILS                   : {},
        ChatConnector           : {},
        AuthConnector           : {},

        getCurrentUserId : function(){
            return CHAT_APP.GLOBALS['uId'];
        },

        getAppVersion : function(){
          return CHAT_APP.GLOBALS['appVersion'];  
        },

        getOfflineIp : function(){
          return CHAT_APP.GLOBALS['oIpPort'].ip;
        },

        getOfflinePort : function(){
          return CHAT_APP.GLOBALS['oIpPort'].port;
        },

        Init : function(){}

        
    };

})(window)
;(function(global){
      //For Main App global == window
      //For Worker global == self

      /*************************************************  PACKET TYPES ****************************************************/
      var FRIEND_CHAT_PACKET_TYPE = {
            
            FRIEND_CHAT_REGISTER                           : 1,
            FRIEND_CHAT_UNREGISTER                         : 2,
            FRIEND_CHAT_REGISTER_CONFIRMATION              : 3,
            
            FRIEND_CHAT_IDLE                               : 4,
            FRIEND_CHAT_TYPING                             : 5,

            FRIEND_CHAT_MSG                                : 6,
            FRIEND_CHAT_MSG_EDIT                           : 7,
            FRIEND_CHAT_BROKEN_MSG                         : 8,
            FRIEND_CHAT_BROKEN_MSG_EDIT                    : 9,
            FRIEND_CHAT_MULTIPLE_MSG                       : 10,


            FRIEND_CHAT_DELIVERED                          : 15,
            FRIEND_CHAT_SENT                               : 16,
            FRIEND_CHAT_SEEN                               : 17,
            FRIEND_CHAT_SEEN_CONFIRMATION                  : 18,

            FRIEND_CHAT_MULTIPLE_MSG_DELETE                : 19,

            FRIEND_CHAT_MSG_DELETE_CONFIRMATION            : 20,

            FRIEND_BROKEN                                  : 24,
            FRIEND_BROKEN_CONFIRMATION                     : 25,

            FRIEND_CHAT_BLOCK                              : 27,
            FRIEND_CHAT_UNBLOCK                            : 28,
            FRIEND_CHAT_BLOCK_UNBLOCK_CONFIRMATION         : 29
      };

      var TAG_CHAT_PACKET_TYPE = {

            TAG_CHAT_TAG_REGISTER                          : 41,
            TAG_CHAT_TAG_UNREGISTER                        : 42,
            TAG_CHAT_TAG_REGISTER_CONFIRMATION             : 43,

            TAG_CHAT_TAG_INFORMATION                       : 46,
            TAG_CHAT_TAG_INFORMATION_CONFIRMATION          : 47,

            TAG_CHAT_TAG_MEMBER_ADD                        : 51,
            TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION           : 52,

            TAG_CHAT_MEMBER_REMOVE_LEAVE                   : 53,
            TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION      : 54,

            TAG_CHAT_TAG_MEMBER_TYPE_CHANGE                : 55,
            TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION   : 56,


            TAG_CHAT_IDLE                                  : 61,
            TAG_CHAT_TYPING                                : 62,

            TAG_CHAT_MSG                                   : 63,
            TAG_CHAT_MSG_EDIT                              : 64,
            TAG_CHAT_BROKEN_MSG                            : 65,
            TAG_CHAT_BROKEN_MSG_EDIT                       : 66,
            TAG_CHAT_MULTIPLE_MSG                          : 67,


            TAG_CHAT_DELIVERED                             : 68,
            TAG_CHAT_SENT                                  : 69,
            TAG_CHAT_SEEN                                  : 70,
            TAG_CHAT_SEEN_CONFIRMATION                     : 71,

            TAG_CHAT_MULTIPLE_MSG_DELETE                   : 72,

            TAG_CHAT_MSG_DELETE_CONFIRMATION               : 73,


            TAG_CHAT_GENERAL_BROKEN_PACKET                 : 74,
            TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION    : 75
      };

      var OFFLINE_PACKET_TYPE = {

            OFFLINE_FRIEND_INFORMATION                     : 91,
            OFFLINE_FRIEND_INFORMATION_CONFIRMATION        : 92,

            OFFLINE_GET_REQUEST                            : 93,
            OFFLINE_GET_REQUEST_CONFIRMATION               : 94,
            OFFLINE_FRIEND_UNREAD_MESSAGE                  : 95,
            OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION     : 96,
            OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST         : 97,
            OFFLINE_FRIEND_HISTORY_MESSAGE                 : 98,
            OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION    : 99,
            OFFLINE_GET_FRIEND_MESSAGE_STATUS              : 100,
            OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION : 101,

            OFFLINE_TAG_INFORMATION_ACTIVITY               : 104,

            OFFLINE_MY_TAG_LIST                            : 105,

            OFFLINE_TAG_UNREAD_MESSAGE                     : 106,
            OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION        : 107,

            OFFLINE_TAG_CREATE_TAG                         : 108,
            OFFLINE_TAG_CREATE_TAG_CONFIRMATION            : 109,

            OFFLINE_TAG_HISTORY_MESSAGE_REQUEST            : 110,
            OFFLINE_TAG_HISTORY_MESSAGE                    : 111,

            OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS       : 112,
            OFFLINE_TAG_INFORMATION_WITH_MEMBERS           : 113,

            OFFLINE_TAG_CONFIRMATION                       : 117,

            OFFLINE_BROKEN_HISTORY_PACKET                  : 118,
            OFFLINE_BROKEN_PACKET                          : 119,
            OFFLINE_BROKEN_PACKET_CONFIRMATION             : 120
      };


      var PACKET_TYPES = Object.assign( {}, FRIEND_CHAT_PACKET_TYPE, TAG_CHAT_PACKET_TYPE, OFFLINE_PACKET_TYPE );
      
      /*************************************************  CONFIRAMATION MAPS **********************************************/
      var CONFIRMATION_MAP = {};

      //FRIEND CHAT PACKET CONFIRMATION MAP

      CONFIRMATION_MAP
      [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_REGISTER]                 = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_REGISTER_CONFIRMATION;

      CONFIRMATION_MAP
      [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG]                      = [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN];

      CONFIRMATION_MAP
      [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG_EDIT]                 = [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN ];

      CONFIRMATION_MAP
      [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG]               = [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN ];

      CONFIRMATION_MAP
      [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG_EDIT]          = [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN ];

      CONFIRMATION_MAP
      [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED]                = [ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN, FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN_CONFIRMATION ];

      CONFIRMATION_MAP
      [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN]                     = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN_CONFIRMATION;

      CONFIRMATION_MAP
      [FRIEND_CHAT_PACKET_TYPE.FRIEND_BROKEN]                        = FRIEND_CHAT_PACKET_TYPE.FRIEND_BROKEN_CONFIRMATION;

      CONFIRMATION_MAP
      [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MULTIPLE_MSG_DELETE]      = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG_DELETE_CONFIRMATION;


      //CONFIRMATION_MAP
      //    [FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BLOCK]              = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BLOCK_CONFIRMATION;

      CONFIRMATION_MAP
      [OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_INFORMATION]               = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_INFORMATION_CONFIRMATION;

      CONFIRMATION_MAP
      [OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE]            = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION;

      CONFIRMATION_MAP
      [OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST]   = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION;

      CONFIRMATION_MAP
      [OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE]           = OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION;

      CONFIRMATION_MAP
      [OFFLINE_PACKET_TYPE.OFFLINE_GET_FRIEND_MESSAGE_STATUS]        = OFFLINE_PACKET_TYPE.OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION;

      //TAG CHAT PACKET CONFIRMATION MAP

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER]                   = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER_CONFIRMATION;

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION]                = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION_CONFIRMATION;

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD]                 = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION;

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_MULTIPLE_MSG_DELETE]            = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_DELETE_CONFIRMATION;

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE]            = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION;

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE]         = TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION;

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET]          = TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION;

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG]                            = [ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT, TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED, TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN ];

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_EDIT]                       = [ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT, TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED, TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN ];

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG]                     = [ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT, TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED, TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN ];

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG_EDIT]                = [ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT, TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED, TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN ];

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED]                      = [TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN, TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN_CONFIRMATION];

      CONFIRMATION_MAP
      [TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN]                           = TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN_CONFIRMATION;

      //OFFLINE PACKET CONFIRMATION MAP

      CONFIRMATION_MAP
      [OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG]                   = OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG_CONFIRMATION;

      CONFIRMATION_MAP
      [OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST]                      = OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST_CONFIRMATION;
      CONFIRMATION_MAP

      [OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE]               = OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION;

      CONFIRMATION_MAP
      [OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET]                    = OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET_CONFIRMATION;
      CONFIRMATION_MAP

      [OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_HISTORY_PACKET]            = OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET_CONFIRMATION;

      CONFIRMATION_MAP
      [OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE_REQUEST]      = OFFLINE_PACKET_TYPE.OFFLINE_TAG_CONFIRMATION;

      CONFIRMATION_MAP
      [OFFLINE_PACKET_TYPE.OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS] = OFFLINE_PACKET_TYPE.OFFLINE_TAG_CONFIRMATION;


      /*************************************************  PACKET CONSTANTS **********************************************/

      var PACKET_CONSTANTS = {
            
            PACKET_IP_SIZE                  :  4,
            PACKET_PORT_SIZE                :  2,

            PACKET_DYNAMIC_ATTRIBUTE        : -1,
            PACKET_RAW_BYTE_ATTRIBUTE       : -2,

            ONE_BYTE_SIZE                   :  1,
            TWO_BYTE_SIZE                   :  2,
            FOUR_BYTE_SIZE                  :  4,
            EIGHT_BYTE_SIZE                 :  8,

            PACKET_MAX_SIZE                 : 512,

            TAG_ID_NO_OF_TIME_DIGIT         : 10,
            TAG_ID_NO_OF_USER_ID_DIGIT      : 6,

            OFFLINE_PACKET_TYPE_START       : 91,


            ATTRIBUTE_TYPE                  : { INTEGER : 1, STRING : 2, BYTE : 3 }

      }

      /*************************************************  GENERAL CONSTANTS **********************************************/

      var GENERAL_CONSTANTS = {


           //Debug
            LOCAL_CHAT                      : false,
            LOCAL_CHAT_REG_IP               : '192.168.1.125',
            LOCAL_CHAT_REG_PORT             : 1500,
            LOCAL_CHAT_OFFLINE_IP           : '192.168.1.125',
            LOCAL_CHAT_OFFLINE_PORT         : 1200,


            API_VERSION                     : 3,
            API_VERSION_PORT_OFFSET         : 0,
      
            AUTH_UID_LIST_LIMIT             : 15,

            /*** Timing Variables ***/


            ACTUAL_TAG_REGISTER_TIMEOUT     : 180,
            TAG_REGISTER_TIMEOUT            : 160,                // 180 seconds actual value, giving some space
            API_FETCH_RETRY_COUNT           : 5,
            API_FETCH_RETRY_DELAY           : 3000 ,              // 3000 miliseconds
            RETRY_COUNT                     : 5,
            AUTH_REQUEST_TIMEOUT            : 2000,
            REQUEST_TIMEOUT                 : 3000 * 5,

            BOX_WAITING_TIME                : 180,                // seconds

            UDP_SERVER_KEEP_ALIVE_INTERVAL  : 10000,              // miliseconds

            REQUEST_CACHE_VALIDITY          : 15000,              // miliseconds
            RESPONSE_CACHE_VALIDITY         : 4000,               // miliseconds

            BROKEN_CACHE_VALIDITY           : 300000,             //miliseconds
            TEMP_MESSAGE_CACHE_VALIDITY     : 2*60*1000,       //miliseconds

            /** MAPS **/

            SESSION_TYPES                   : { FRIEND : 1, TAG : 2 },
            REQUEST_TYPES                   : { FRIEND : 1, TAG : 2 },

            MEMBER_STATUS                   : { MEMBER : 1, ADMIN : 2,  OWNER   : 3, REMOVED : 4, LEAVE : 5 },

            MEMBER_MOODS                    : { ONLINE : 1, AWAY  : 2,  OFFLINE : 3, DO_NOT_DISTURB : 4 },

            REGISTRATION_TYPES              : { CREATE : 1, ONLY_REGISTER : 2, CHAT_INVITE : 3 },

            MESSAGE_STATUS                  : { UNREAD : -1, DELETED : 0, SENT : 1, DELIVERED  : 2,  SEEN : 3, VIEWED : 4, PLAYED : 4 },

            MESSAGE_TYPES                   : {
                DELETE_MESSAGE              : 0,
                BLANK_MESSAGE               : 1,
                TEXT                        : 2,
                EMOTICON_MESSAGE            : 3,
                LOCATION_SHARE              : 4,
                LINK_SHARE                  : 5,
                STICKER                     : 6,
                IMAGE                       : 7,
                AUDIO                       : 8,
                VIDEO                       : 9,
                CAMERA_IMAGE                : 10,
                FILE_STREAM                 : 11,
                HISTORY_RE_FETCH            : 14,
                GROUP_ACTIVITY              : 20,                                              
                TYPING                      : 101
            },
           


            STATUS_MESSAGE_TYPES            : { TAG_MEMBER_ADD : 1,
                                                TAG_MEMBER_DELETE : 2,
                                                TAG_MEMBER_LEAVE : 3,
                                                TAG_MEMBER_STATUS_CHANGE_OWNER : 4,
                                                TAG_MEMBER_STATUS_CHANGE_ADMIN : 5,
                                                TAG_MEMBER_STATUS_CHANGE_MEMBER : 6,
                                                TAG_NAME_CHANGE : 7,
                                                TAG_PICTURE_CHANGE : 8,
                                                TAG_INFO_UPDATED : 9,
                                                TAG_ADMIN_ADD : 10  },

            PAGE_DIRECTION                  : { UP : 1, DOWN : 2 },
            PAGE_LIMIT                      : 10,

            ONLINE_STATUS                   : { OFFLINE : 1, ONLINE : 2, AWAY : 3},
            ONLINE_MOOD                     : { ALIVE : 1, DONT_DISTURB : 2, BUSY : 3, INVISIBLE: 4},
            SECRET_VISIBILITY               : { NON_VISIBLE : 0, VISIBLE : 1 },

            TAG_ACTIVITY_TYPE               : { DELETED : 0, ADDED : 1, LEAVE : 2, TAG_RENAME: 3, MEMBER_TYPE_CHANGE : 4, TAG_URL_RENAME : 5, TAG_CREATED : 6},

            USER_PRESENCE : {
                OFFLINE : 1,
                ONLINE  : 2,
                AWAY    : 3
            },

            HISTORY_MAX_MESSAGE             :  10,
            

            /* Internal */
            TAB_SYNC_MAX_TIME               : 180 * 1000,
            TAB_SYNC_ACTIONS                : { AUTH_REQUEST            : 0,
                                                CHAT_REQUEST            : 1,
                                                GENERAL_INFO_UPDATE     : 3,
                                                CHAT_BOX_INFO_UPDATE    : 4,
                                                SECRET_CHAT_TIMER       : 5,
                                                CHAT_HISTORY_REFRESH    : 6,
                                                CHAT_MSESSAGE_UPDATE    : 7
                                              },

            MAX_TASK_RETRY_COUNT            : 15,

            SHARED_WORKER_PATH              : 'js/worker/chat/shared.js',
            CHAT_WORKER_PATH                : '/js/worker/chat/chat.worker.js'
      
      }

      var AUTH_REQUEST_TYPE  = {
            
            KEEP_ALIVE     : 1,
            CONFIRMATION   : 2,
            AUTHENTICATION : 3,
            UPDATE         : 4,
            REQUEST        : 5,
            CALL           : 6,
            CHAT           : 7
      }

      var AUTH_SERVER_ACTIONS = {
            START_F2F_CHAT          : 175,
            RECEIVED_F2F_CHAT       : 375,
            START_TAG_CHAT          : 134,
            RECEIVED_TAG_CHAT       : 334,
            ADD_TAG_CHAT_MEMBERS    : 135,
            GET_USER_MOOD_PRESENCE  : 199, 
            GET_OFFLINE_IP_PORT     : 83,

      };

      var AUTH_SERVER_REQUEST_UPDATE_MAP = {};
      AUTH_SERVER_REQUEST_UPDATE_MAP[ AUTH_SERVER_ACTIONS.RECEIVED_F2F_CHAT ] = 
            AUTH_SERVER_ACTIONS.START_TAG_CHAT;

      AUTH_SERVER_REQUEST_UPDATE_MAP[ AUTH_SERVER_ACTIONS.RECEIVED_TAG_CHAT ] = 
            AUTH_SERVER_ACTIONS.START_TAG_CHAT;

      var WORKER_NOTIFIER_TYPES = {
            DEBUG                 : 0,
            AUTH_REQUEST_RESPONSE : 1,
            CHAT_REQUEST_RESPONSE : 2,
            CHAT_DATA_RECEIVED    : 3,
            AUTH_DATA_RECEIVED    : 4,
            EXCEPTION             : 5 
            
      };


      var CHAT_GLOBAL_VALUES = {
          serverTimeDiff : 0,
          offlineUpdateTime : 0
      };

      var CHAT_VERSION_INFO = {
            version        : '2.1',            
      }

      var PLATFORM = {
            DESKTOP : 1,
            ANDROID : 2,
            IPHONE : 3,
            WINDOWS : 4,
            WEB : 5
      };

      var CHAT_SERVER_TYPES = {
            OFFLINE : 1,
            ONLINE : 2
      };

      var CHAT_STATES = {
            MESSAGE_SENDING: {

                ONLINE_IP_PORT_REQUEST              : 0,
                FIRST_ONLINE                        : 1,
                PRESENCE_REFRESH                    : 2,
                SECOND_ONLINE                       : 3,
                ONLINE_IP_PORT_REFRESH              : 4,
                THIRD_ONLINE                        : 5,
                ONLINE_SUCCESS                      : 6,
                ONLINE_FAILED                       : 7,


                FIRST_OFFLINE                       : 101,
                OFFLINE_IP_PORT_REFRESH             : 102,
                SECOND_OFFLINE                      : 102,
                OFFLINE_FAILED                      : 104,
                OFFLINE_SUCCESS                     : 105,

                SUCCESS                             : 201,
                FAILED                              : 202

            }
      };

      var RESPONSE_REASON_CODES = {
            PERMISSION_DENIED : 1, // reason code 1
      }

      var CHAT_FLOWS = {
            SEND_MESSAGE : [
                CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REQUEST,
                CHAT_STATES.MESSAGE_SENDING.FIRST_ONLINE,
                CHAT_STATES.MESSAGE_SENDING.PRESENCE_REFRESH,
                CHAT_STATES.MESSAGE_SENDING.ONLINE_IP_PORT_REFRESH,
                CHAT_STATES.MESSAGE_SENDING.ONLINE_FAILED,

                CHAT_STATES.MESSAGE_SENDING.FIRST_OFFLINE,
                CHAT_STATES.MESSAGE_SENDING.OFFLINE_IP_PORT_REFRESH
            ]
      };

      var CHAT_STATE_INFO = {};


      /******** Generate Reverse Maps **********/
      (function(GENERAL_CONSTANTS, CHAT_STATES, CHAT_STATE_INFO){

            var isObject = (global.angular && angular.isObject) || global.isObject;
            
            var itemKey, itemValue, itemPropKey, itemPropValue;
            for(itemKey in GENERAL_CONSTANTS){
                  itemValue = GENERAL_CONSTANTS[itemKey]
                  if(isObject(itemValue)){
                      GENERAL_CONSTANTS[itemKey +'_VALUE'] = [];
                      for( itemPropKey in itemValue){
                          itemPropValue = itemValue[itemPropKey];
                          GENERAL_CONSTANTS[itemKey +'_VALUE'][itemPropValue] = itemPropKey
                      }
                  }
            }

            var chatStates = Object.keys(CHAT_STATES.MESSAGE_SENDING);

            for(var index = 0, length = chatStates.length; index < length; index++){
                  var aChatStateIndex = CHAT_STATES['MESSAGE_SENDING'][ chatStates[index] ];
                  try{
                      CHAT_STATE_INFO [ aChatStateIndex ]['NAME'] = chatStates[index];
                  }catch(e) {

                      CHAT_STATE_INFO [ aChatStateIndex ] = {};
                      CHAT_STATE_INFO [ aChatStateIndex ]['NAME'] = chatStates[index];
                  }
            }


      })(GENERAL_CONSTANTS, CHAT_STATES, CHAT_STATE_INFO)

    

      //Export To global      
      global.CHAT_APP['Constants'] = {
            FRIEND_CHAT_PACKET_TYPE        : FRIEND_CHAT_PACKET_TYPE,
            TAG_CHAT_PACKET_TYPE           : TAG_CHAT_PACKET_TYPE,
            OFFLINE_PACKET_TYPE            : OFFLINE_PACKET_TYPE,
            PACKET_TYPES                   : PACKET_TYPES,
            CONFIRMATION_MAP               : CONFIRMATION_MAP,
            GENERAL_CONSTANTS              : GENERAL_CONSTANTS,
            PACKET_CONSTANTS               : PACKET_CONSTANTS,
            WORKER_NOTIFIER_TYPES          : WORKER_NOTIFIER_TYPES,
            AUTH_SERVER_ACTIONS            : AUTH_SERVER_ACTIONS,
            AUTH_SERVER_REQUEST_UPDATE_MAP : AUTH_SERVER_REQUEST_UPDATE_MAP,
            CHAT_STATES                    : CHAT_STATES,
            CHAT_STATE_INFO                : CHAT_STATE_INFO,
            CHAT_GLOBAL_VALUES             : CHAT_GLOBAL_VALUES,
            AUTH_REQUEST_TYPE              : AUTH_REQUEST_TYPE,
            PLATFORM                       : PLATFORM,
            CHAT_VERSION_INFO              : CHAT_VERSION_INFO,
            RESPONSE_REASON_CODES          : RESPONSE_REASON_CODES,
            CHAT_SERVER_TYPES              : CHAT_SERVER_TYPES
      }


})(window);

;(function(global){

    var Constants = global.CHAT_APP.Constants;
    var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;
    var CHAT_GLOBAL_VALUES = Constants.CHAT_GLOBAL_VALUES

    function _getUUIDPacketId(packetTime, isPacketIdStamp){
        var timestamp;

        var serverTimeDiff = CHAT_GLOBAL_VALUES.serverTimeDiff;
        var currentUserId = global.CHAT_APP.getCurrentUserId();

        if( !isPacketIdStamp && !packetTime){
            packetTime = new Date().getTime();
            timestamp =  parseInt(packetTime + serverTimeDiff);

        }else{
            timestamp = packetTime;
        }

        if( !timestamp){
            Logger.debug('alert', 'Invalid Timestamp', 'CHAT');
        }

        return PacketIDGenerator.create(currentUserId, timestamp, isPacketIdStamp);
    }

    function _callXTimeAfterYIntervalStopOnSuccess(callback, successChecker, onFailCallback, maxExecutionCount, interval){
        var currentExecutionCount = 0;

        var doExecute = function(){
            if( !currentExecutionCount || ( currentExecutionCount < maxExecutionCount && !successChecker.call(null, currentExecutionCount) ) ){

                callback.call();
                currentExecutionCount++;
                setTimeout(doExecute, interval);

            }else{

                if(!successChecker.call(null, currentExecutionCount)){
                    onFailCallback.call();
                }
            }
        };

        doExecute();
    }


    function _getCurrentChatServerTime(){

        var chatServerTime = CHAT_GLOBAL_VALUES.serverTimeDiff;
        var lcoalTimeInServerTime = new Date().getTime() - chatServerTime;
        return lcoalTimeInServerTime;

    }

    function _hasChatSession(serverReceivedTime){

        var serverTime = _getCurrentChatServerTime();
        return ( serverTime - serverReceivedTime ) < GENERAL_CONSTANTS.ACTUAL_TAG_REGISTER_TIMEOUT;

    }

    function ChatClock(){
        /***
         * Clock for Implementing Chat Timers
         * Only Use for wait time multiple of 1sec
         *
         * ***/

        var self = this;
        var _callbacks = {};
        var _timers = {};
        var _listeners = {};
        var _listenersCount = 0;
        var _defaultEvents = ['TICK', 'REGISTERED', 'CLEARED'];

        var __systemIntervalId = null;

        function _registerTimer(cb, wait, maxIteration){
            var timerId = getUniqueId('ctr');
            _callbacks[timerId] = cb;
            _timers[timerId] = { delay : wait, count : wait, maxIteration : maxIteration};
            return timerId;
        }

        function _unRegisterTimer(timerId){
            delete _callbacks[timerId];
            delete _timers[timerId];
            Logger.debug('debug', 'TIMER DELETED FOR ID ' + timerId, 'CHAT_TIMER_DEBUG');
        }

        function _registerListeners(eventName, cb){

            if(!_listeners[eventName]){
                _listeners[eventName] = {};
            }

            var listenerId = getUniqueId('ccl');
            _listeners[eventName][listenerId] = cb;
            //_listenersCount++;

            return listenerId;
        }

        function _unRegisterListener(eventName, listenerId){
            delete _listeners[eventName][listenerId];
            //_listenersCount--;
        }

        self.setTimeout = function(cb, wait){
            if( wait > 999){

                var hasTimer = self.hasTimer();

                var timerId = _registerTimer(cb, wait, 1);

                !hasTimer ? self.start() : void 0;

                Logger.debug('debug', 'TIMETOUT SET FOR ID ' + timerId, 'CHAT_TIMER_DEBUG');

                return timerId;

            }else{
                Logger.debug('error', 'USE CHAT CLOCK TIMER FOR WAIT TIME > 1000msc, Use Default Timeout/Interval for < 1000msc.', 'CHAT_TIMER_DEBUG')
                return 0;
            }

        };

        self.setInterval = function(cb, wait, maxIteration){
            if( wait > 999){

                var hasTimer = self.hasTimer();

                var timerId = _registerTimer(cb, wait, maxIteration || -1);

                !hasTimer ? self.start() : void 0;

                Logger.debug('debug', 'INTERVAL SET FOR ID ' + timerId, 'CHAT_TIMER_DEBUG');

                return timerId;
            }else {
                Logger.debug('error', 'USE CHAT CLOCK TIMER FOR WAIT TIME > 1000msc, Use Default Timeout/Interval for < 1000msc.', 'CHAT_TIMER_DEBUG')
                return 0;
            }
        };

        self.clearTimeout =  function(timerId){
            _unRegisterTimer(timerId)
        };

        self.clearInterval = function(timerId){
            _unRegisterTimer(timerId)
        };

        self.hasTimer = function(){
            return Object.keys(_timers).length > 0;
        };

        self.on = function(eventName, cb){
            return _registerListeners(eventName, cb);
        };

        self.off = function(eventName, listenerId){
            _unRegisterListener(eventName, listenerId);
        };

        self.trigger = function(eventName, data){
            if(!_listeners[eventName]){
                return;
            }

            var listenerIds = Object.keys(_listeners[eventName]);
            listenerIds.forEach(function(aListenerId){
                _listeners[aListenerId].call(this, data);
            });

        };

        self.stop = function(){
            clearInterval(__systemIntervalId);
        };

        self.start = function(){
            __systemIntervalId = setInterval(function(){
                self.trigger('TICK');

                !self.hasTimer() ? self.stop() : void 0;

                var allTimerIds = Object.keys(_timers);
                //Logger.debug('debug', allTimerIds, _timers, 'CHAT_TIMER_DEBUG')
                for(var index = 0; index < allTimerIds.length; index++){
                    var aTimerId = allTimerIds[index];
                    var aTimer = _timers[aTimerId];

                    if(!!aTimer){
                        //Logger.debug('debug', allTimerIds, _timers, aTimerId, 'CHAT_TIMER_DEBUG')
                        if( aTimer.maxIteration == 0 ){
                            _unRegisterTimer(aTimerId);
                        }else {

                            if( aTimer.count == 0 || aTimer.maxIteration == -1){
                                _callbacks[aTimerId].call();
                                aTimer.maxIteration != -1 ? aTimer.count = aTimer.delay : void 0;

                            }else{
                                aTimer.count--;
                                aTimer.maxIteration != -1 ? aTimer.maxIteration-- : void 0

                            }
                        }
                    }

                }



            }, 1000)
        };

    }

    global.CHAT_APP['UTILS'] = {
        _hasChatSession : _hasChatSession,
        getUUIDPacketId : _getUUIDPacketId,
        callXTimeAfterYIntervalStopOnSuccess : _callXTimeAfterYIntervalStopOnSuccess,
        ChatClock : ChatClock
    }

})(window);


;(function(global){

	var CHAT_APP 		   = global.CHAT_APP;
    var Constants          = CHAT_APP.Constants;
    var GENERAL_CONSTANTS  = Constants.GENERAL_CONSTANTS;
    var CHAT_GLOBAL_VALUES = Constants.CHAT_GLOBAL_VALUES;    
    var ChatConnector	   = CHAT_APP.ChatConnector;

	function _getChatServerCurrentTime() {
        return parseInt(Date.now() + CHAT_GLOBAL_VALUES.serverTimeDiff);
    };

    global.CHAT_APP['SharedHelpers'] = {     	
     	getChatServerCurrentTime             : _getChatServerCurrentTime,

    }

})(window);





;(function(global){
      //For Main App global == window
      //For Worker global == self

      //Dependencies 
      //- app/chat/shared/chat.constans.js

      var ChatConstants           = global.CHAT_APP.Constants;
      var FRIEND_CHAT_PACKET_TYPE = ChatConstants.FRIEND_CHAT_PACKET_TYPE;
      var TAG_CHAT_PACKET_TYPE    = ChatConstants.TAG_CHAT_PACKET_TYPE;
      var OFFLINE_PACKET_TYPE     = ChatConstants.OFFLINE_PACKET_TYPE;
      var PACKET_CONSTANTS        = ChatConstants.PACKET_CONSTANTS

      /*************************************************  PACKET ATTRIBUTES **********************************************/


      var CHAT_PACKET_ATTRIBUTE = {
            PACKET_TYPE                       : 1,
            USER_ID                           : 2,
            FRIEND_ID                         : 3,
            PACKET_ID_LENGTH                  : 4,
            PACKET_ID                         : 5,
            PLATFORM                          : 6,
            CHAT_BINDING_PORT                 : 7,
            TAG_ID                            : 8,
            ONLINE_STATUS                     : 9,
            USER_MOOD                         : 10,
            MESSAGE_TYPE                      : 11,
            TIMEOUT                           : 12,
            LATITUDE                          : 13,
            LONGITUDE                         : 14,
            MESSAGE_LENGTH                    : 15,
            MESSAGE                           : 16,
            MESSAGE_DATE                      : 17,
            NO_OF_MESSAGE                     : 18,
            FULL_NAME_LENGTH                  : 19,
            FULL_NAME                         : 20,
            NO_OF_PACKET                      : 21,
            SEQUENCE_NO                       : 22,
            NO_OF_MEMBERS                     : 23,
            UPDATE_TIME                       : 24,
            SERVER_DATE                       : 25,
            LAST_ONLINE_TIME                  : 26,
            NO_OF_ITEMS                       : 27,
            BLOCK_UNBLOCK_DATE                : 28,
            MESSAGE_STATUS                    : 29,
            IS_ADD_TO_DB                      : 30,

            TAG_NAME_LENGTH                   : 31,
            TAG_NAME                          : 32,
            TAG_PICTURE_URL_LENGTH            : 33,
            TAG_PICTURE_URL                   : 34,
            TAG_MEMBER_TYPE                   : 35,
            TAG_MEMBER_ADDED_BY               : 36,
            TAG_NO_OF_MEMBERS                 : 37,
            TAG_NO_OF_BROKEN_PKT              : 38,
            TAG_INFORMATION_UPDATE_FLAG       : 39,
            TAG_INFORMATION_TAG_NO_OF_MEMBERS : 40,

            REGISTRATION_TYPE                 : 41,
            PAGE_DIRECTION                    : 42,
            PAGE_LIMIT                        : 43,
            ACTIVITY_TYPE                     : 45,
            ACTIVITY_VALUE_LENGTH             : 46,
            ACTIVITY_VALUE                    : 47,
            CHANGED_BY_USER_ID                : 48,

            FRIEND_APP_TYPE                   : 60,
            FRIEND_DEVICE_TOKEN_LENGTH        : 61,
            FRIEND_DEVICE_TOKEN               : 62,
            IS_SECRET_VISIBLE                 : 63,

            APP_VERSION                       : 64,

            RAW_DATA_BYTE                     : 80

      };

      /*************************************************  PACKET ATTRIBUTES DEFINATION ***********************************/
      
      var CHAT_PACKET_ATTRIBUTE_INFO                                                      = {};

      //ATTRIBUTE NO(1) : PACKET_TYPE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.PACKET_TYPE]                       = {
            ATTRIBUTE_NAME     : "PACKET_TYPE",            
            VAR_NAME           : "packetType",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(2) : USER_ID
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.USER_ID]                           = {
            ATTRIBUTE_NAME     : "USER_ID",            
            VAR_NAME           : "userId",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 8    
      };

      //ATTRIBUTE NO(3) : FRIEND_ID
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.FRIEND_ID]                         = {
            ATTRIBUTE_NAME     : "FRIEND_ID",            
            VAR_NAME           : "friendId",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 8    
      };

      //ATTRIBUTE NO(4) : PACKET_ID_LENGTH
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH]                  = {
            ATTRIBUTE_NAME     : "PACKET_ID_LENGTH",            
            VAR_NAME           : "packetIdLength",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(5) : PACKET_ID
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.PACKET_ID]                         = {
            ATTRIBUTE_NAME     : "PACKET_ID",            
            VAR_NAME           : "packetId",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE               : -1    
      };

      //ATTRIBUTE NO(6) : PLATFORM
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.PLATFORM]                          = {
            ATTRIBUTE_NAME     : "PLATFORM",            
            VAR_NAME           : "platform",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(7) : CHAT_BINDING_PORT
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.CHAT_BINDING_PORT]                 = {
            ATTRIBUTE_NAME     : "CHAT_BINDING_PORT",            
            VAR_NAME           : "chatBindingPort",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 4    
      };

      //ATTRIBUTE NO(8) : TAG_ID
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TAG_ID]                            = {
            ATTRIBUTE_NAME     : "TAG_ID",            
            VAR_NAME           : "tagId",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 8    
      };

      //ATTRIBUTE NO(9) : ONLINE_STATUS
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.ONLINE_STATUS]                     = {
            ATTRIBUTE_NAME     : "ONLINE_STATUS",            
            VAR_NAME           : "onlineStatus",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(10) : USER_MOOD
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.USER_MOOD]                         = {
            ATTRIBUTE_NAME     : "USER_MOOD",            
            VAR_NAME           : "userMood",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(11) : MESSAGE_TYPE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE]                      = {
            ATTRIBUTE_NAME     : "MESSAGE_TYPE",            
            VAR_NAME           : "messageType",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(12) : TIMEOUT
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TIMEOUT]                           = {
            ATTRIBUTE_NAME     : "TIMEOUT",            
            VAR_NAME           : "timeout",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 2    
      };

      //ATTRIBUTE NO(13) : LATITUDE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.LATITUDE]                          = {
            ATTRIBUTE_NAME     : "LATITUDE",            
            VAR_NAME           : "latitude",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 4    
      };

      //ATTRIBUTE NO(14) : LONGITUDE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.LONGITUDE]                         = {
            ATTRIBUTE_NAME     : "LONGITUDE",            
            VAR_NAME           : "longitude",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 4    
      };

      //ATTRIBUTE NO(15) : MESSAGE_LENGTH
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH]                    = {
            ATTRIBUTE_NAME     : "MESSAGE_LENGTH",            
            VAR_NAME           : "messageLength",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 2    
      };

      //ATTRIBUTE NO(16) : MESSAGE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.MESSAGE]                           = {
            ATTRIBUTE_NAME     : "MESSAGE",            
            VAR_NAME           : "message",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE               : -1    
      };

      //ATTRIBUTE NO(17) : MESSAGE_DATE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE]                      = {
            ATTRIBUTE_NAME     : "MESSAGE_DATE",            
            VAR_NAME           : "messageDate",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 8    
      };

      //ATTRIBUTE NO(18) : NO_OF_MESSAGE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE]                     = {
            ATTRIBUTE_NAME     : "NO_OF_MESSAGE",            
            VAR_NAME           : "messagesLength",
            VAR_CONTAINER_NAME : "messages",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(19) : FULL_NAME_LENGTH
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH]                  = {
            ATTRIBUTE_NAME     : "FULL_NAME_LENGTH",            
            VAR_NAME           : "fullNameLength",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(20) : FULL_NAME
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.FULL_NAME]                         = {
            ATTRIBUTE_NAME     : "FULL_NAME",            
            VAR_NAME           : "fullName",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE               : -1    
      };

      //ATTRIBUTE NO(21) : NO_OF_PACKET
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET]                      = {
            ATTRIBUTE_NAME     : "NO_OF_PACKET",            
            VAR_NAME           : "packetsLength",
            VAR_CONTAINER_NAME : "packets",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(22) : SEQUENCE_NO
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO]                       = {
            ATTRIBUTE_NAME     : "SEQUENCE_NO",            
            VAR_NAME           : "sequenceNo",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(23) : NO_OF_MEMBERS
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.NO_OF_MEMBERS]                     = {
            ATTRIBUTE_NAME     : "NO_OF_MEMBERS",            
            VAR_NAME           : "membersLength",
            VAR_CONTAINER_NAME : "members",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 2    
      };

      //ATTRIBUTE NO(24) : UPDATE_TIME
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.UPDATE_TIME]                       = {
            ATTRIBUTE_NAME     : "UPDATE_TIME",            
            VAR_NAME           : "updateTime",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 8    
      };

      //ATTRIBUTE NO(25) : SERVER_DATE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.SERVER_DATE]                       = {
            ATTRIBUTE_NAME     : "SERVER_DATE",            
            VAR_NAME           : "serverDate",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 8    
      };

      //ATTRIBUTE NO(26) : LAST_ONLINE_TIME
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.LAST_ONLINE_TIME]                  = {
            ATTRIBUTE_NAME     : "LAST_ONLINE_TIME",            
            VAR_NAME           : "lastOnlineTime",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 8    
      };

      //ATTRIBUTE NO(27) : NO_OF_ITEMS
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.NO_OF_ITEMS]                       = {
            ATTRIBUTE_NAME     : "NO_OF_ITEMS",            
            VAR_NAME           : "noOfItems",
            VAR_CONTAINER_NAME : "items",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 2    
      };

      //ATTRIBUTE NO(28) : BLOCK_UNBLOCK_DATE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.BLOCK_UNBLOCK_DATE]                = {
            ATTRIBUTE_NAME     : "BLOCK_UNBLOCK_DATE",            
            VAR_NAME           : "blockUnblockDate",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 8    
      };

      //ATTRIBUTE NO(29) : MESSAGE_STATUS
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.MESSAGE_STATUS]                    = {
            ATTRIBUTE_NAME     : "MESSAGE_STATUS",            
            VAR_NAME           : "status",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(30) : IS_ADD_TO_DB
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.IS_ADD_TO_DB]                      = {
            ATTRIBUTE_NAME     : "IS_ADD_TO_DB",            
            VAR_NAME           : "isAddToDb",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(31) : TAG_NAME_LENGTH
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH]                   = {
            ATTRIBUTE_NAME     : "TAG_NAME_LENGTH",            
            VAR_NAME           : "tagNameLength",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 2    
      };

      //ATTRIBUTE NO(32) : TAG_NAME
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TAG_NAME]                          = {
            ATTRIBUTE_NAME     : "TAG_NAME",            
            VAR_NAME           : "tagName",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE               : -1    
      };

      //ATTRIBUTE NO(33) : TAG_PICTURE_URL_LENGTH
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH]            = {
            ATTRIBUTE_NAME     : "TAG_PICTURE_URL_LENGTH",            
            VAR_NAME           : "tagPictureUrlLength",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(34) : TAG_PICTURE_URL
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL]                   = {
            ATTRIBUTE_NAME     : "TAG_PICTURE_URL",            
            VAR_NAME           : "tagPictureUrl",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE               : -1    
      };

      //ATTRIBUTE NO(35) : TAG_MEMBER_TYPE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE]                   = {
            ATTRIBUTE_NAME     : "TAG_MEMBER_TYPE",            
            VAR_NAME           : "status",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(36) : TAG_MEMBER_ADDED_BY
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_ADDED_BY]               = {
            ATTRIBUTE_NAME     : "TAG_MEMBER_ADDED_BY",            
            VAR_NAME           : "addedBy",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 8    
      };

      //ATTRIBUTE NO(37) : TAG_NO_OF_MEMBERS
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS]                 = {
            ATTRIBUTE_NAME     : "TAG_NO_OF_MEMBERS",            
            VAR_NAME           : "tagMembersLength",
            VAR_CONTAINER_NAME : "tagMembers",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 2    
      };

      //ATTRIBUTE NO(38) : TAG_NO_OF_BROKEN_PKT
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_BROKEN_PKT]              = {
            ATTRIBUTE_NAME     : "TAG_NO_OF_BROKEN_PKT",            
            VAR_NAME           : "brokenPacketsLength",
            VAR_CONTAINER_NAME : "brokenPackets",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(39) : TAG_INFORMATION_UPDATE_FLAG
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TAG_INFORMATION_UPDATE_FLAG]       = {
            ATTRIBUTE_NAME     : "TAG_INFORMATION_UPDATE_FLAG",            
            VAR_NAME           : "updateFlag",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(40) : TAG_INFORMATION_TAG_NO_OF_MEMBERS
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.TAG_INFORMATION_TAG_NO_OF_MEMBERS] = {
            ATTRIBUTE_NAME     : "TAG_INFORMATION_TAG_NO_OF_MEMBERS",            
            VAR_NAME           : "tagMembersCount",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 2    
      };

      //ATTRIBUTE NO(41) : REGISTRATION_TYPE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.REGISTRATION_TYPE]                 = {
            ATTRIBUTE_NAME     : "REGISTRATION_TYPE",            
            VAR_NAME           : "registrationType",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(42) : PAGE_DIRECTION
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.PAGE_DIRECTION]                    = {
            ATTRIBUTE_NAME     : "PAGE_DIRECTION",            
            VAR_NAME           : "pageDirection",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(43) : PAGE_LIMIT
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.PAGE_LIMIT]                        = {
            ATTRIBUTE_NAME     : "PAGE_LIMIT",            
            VAR_NAME           : "pageLimit",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(45) : ACTIVITY_TYPE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.ACTIVITY_TYPE]                     = {
            ATTRIBUTE_NAME     : "ACTIVITY_TYPE",
            VAR_NAME           : "activityType",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1,
            CONDITIONAL        : true,    
      };

      //ATTRIBUTE NO(46) : ACTIVITY_VALUE_LENGTH
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.ACTIVITY_VALUE_LENGTH]             = {
            ATTRIBUTE_NAME     : "ACTIVITY_VALUE_LENGTH",            
            VAR_NAME           : "activityValueLength",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 2    
      };

      //ATTRIBUTE NO(47) : ACTIVITY_VALUE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.ACTIVITY_VALUE]                    = {
            ATTRIBUTE_NAME     : "ACTIVITY_VALUE",            
            VAR_NAME           : "activityValue",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE               : -1    
      };

      //ATTRIBUTE NO(48) : CHANGED_BY_USER_ID
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.CHANGED_BY_USER_ID]                = {
            ATTRIBUTE_NAME     : "CHANGED_BY_USER_ID",            
            VAR_NAME           : "changedByUserId",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 8    
      };

      //ATTRIBUTE NO(60) : FRIEND_APP_TYPE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.FRIEND_APP_TYPE]                   = {
            ATTRIBUTE_NAME     : "FRIEND_APP_TYPE",            
            VAR_NAME           : "friendAppType",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(61) : FRIEND_DEVICE_TOKEN_LENGTH
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.FRIEND_DEVICE_TOKEN_LENGTH]        = {
            ATTRIBUTE_NAME     : "FRIEND_DEVICE_TOKEN_LENGTH",            
            VAR_NAME           : "friendDeviceTokenLength",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 2    
      };

      //ATTRIBUTE NO(62) : FRIEND_DEVICE_TOKEN
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.FRIEND_DEVICE_TOKEN]               = {
            ATTRIBUTE_NAME     : "FRIEND_DEVICE_TOKEN",            
            VAR_NAME           : "friendDeviceToken",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.STRING,
            SIZE               : -1    
      };

      //ATTRIBUTE NO(63) : IS_SECRET_VISIBLE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE]                 = {
            ATTRIBUTE_NAME     : "IS_SECRET_VISIBLE",            
            VAR_NAME           : "isSecretVisible",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 1    
      };

      //ATTRIBUTE NO(64) : APP_VERSION
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.APP_VERSION]                       = {
            ATTRIBUTE_NAME     : "APP_VERSION",            
            VAR_NAME           : "appVersion",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.INTEGER,
            SIZE               : 2    
      };

      //ATTRIBUTE NO(80) : RAW_DATA_BYTE
      CHAT_PACKET_ATTRIBUTE_INFO[CHAT_PACKET_ATTRIBUTE.RAW_DATA_BYTE]                     = {
            ATTRIBUTE_NAME     : "RAW_DATA_BYTE",            
            VAR_NAME           : "bytes",
            VAR_TYPE           : PACKET_CONSTANTS.ATTRIBUTE_TYPE.BYTE,
            SIZE               : -2    
      };


      /*************************************************  PACKET FORMAT DEFINATION ***********************************/


      var CHAT_PACKET_INFO = {};

      //PACKET TYPE(1) : FRIEND_CHAT_REGISTER
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_REGISTER ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_REGISTER",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(2) : FRIEND_CHAT_UNREGISTER
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_UNREGISTER ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_UNREGISTER",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM, 
                CHAT_PACKET_ATTRIBUTE.ONLINE_STATUS, 
                CHAT_PACKET_ATTRIBUTE.USER_MOOD 

            ]
      };

      //PACKET TYPE(3) : FRIEND_CHAT_REGISTER_CONFIRMATION
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_REGISTER_CONFIRMATION ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_REGISTER_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.CHAT_BINDING_PORT, 
                CHAT_PACKET_ATTRIBUTE.SERVER_DATE 

            ]
      };

      //PACKET TYPE(4) : FRIEND_CHAT_IDLE
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_IDLE ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_IDLE",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(5) : FRIEND_CHAT_TYPING
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_TYPING ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_TYPING",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(6) : FRIEND_CHAT_MSG
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_MSG",
            BROKEN_CONTAINER    : "message",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TIMEOUT, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE, 
                CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(7) : FRIEND_CHAT_MSG_EDIT
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG_EDIT ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_MSG_EDIT",
            BROKEN_CONTAINER    : "message",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TIMEOUT, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE, 
                CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(8) : FRIEND_CHAT_BROKEN_MSG
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_BROKEN_MSG",
            BROKEN_CONTAINER    : "message",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TIMEOUT, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE, 
                CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(9) : FRIEND_CHAT_BROKEN_MSG_EDIT
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG_EDIT ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_BROKEN_MSG_EDIT",
            BROKEN_CONTAINER    : "message",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TIMEOUT, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE, 
                CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(10) : FRIEND_CHAT_MULTIPLE_MSG
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MULTIPLE_MSG ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_MULTIPLE_MSG",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                  CHAT_PACKET_ATTRIBUTE.TIMEOUT,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                  CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE
                ]

            ]
      };

      //PACKET TYPE(15) : FRIEND_CHAT_DELIVERED
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_DELIVERED",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(16) : FRIEND_CHAT_SENT
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_SENT",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(17) : FRIEND_CHAT_SEEN
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_SEEN",
            BROKEN_CONTAINER    : "messages",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_STATUS
                ],
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(18) : FRIEND_CHAT_SEEN_CONFIRMATION
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN_CONFIRMATION ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_SEEN_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(19) : FRIEND_CHAT_MULTIPLE_MSG_DELETE
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MULTIPLE_MSG_DELETE ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_MULTIPLE_MSG_DELETE",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID
                ]

            ]
      };

      //PACKET TYPE(20) : FRIEND_CHAT_MSG_DELETE_CONFIRMATION
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG_DELETE_CONFIRMATION ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_MSG_DELETE_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(24) : FRIEND_CHAT_BROKEN
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_BROKEN",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO, 
                CHAT_PACKET_ATTRIBUTE.RAW_DATA_BYTE 

            ]
      };

      //PACKET TYPE(25) : FRIEND_CHAT_BROKEN_CONFIRMATION
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_CONFIRMATION ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_BROKEN_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO 

            ]
      };

      //PACKET TYPE(27) : FRIEND_CHAT_BLOCK
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BLOCK ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_BLOCK",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.BLOCK_UNBLOCK_DATE, 
                CHAT_PACKET_ATTRIBUTE.IS_ADD_TO_DB 

            ]
      };

      //PACKET TYPE(28) : FRIEND_CHAT_UNBLOCK
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_UNBLOCK ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_UNBLOCK",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.BLOCK_UNBLOCK_DATE 

            ]
      };

      //PACKET TYPE(29) : FRIEND_CHAT_BLOCK_UNBLOCK_CONFIRMATION
      CHAT_PACKET_INFO[ FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BLOCK_UNBLOCK_CONFIRMATION ] =
      {
            PACKET_NAME         : "FRIEND_CHAT_BLOCK_UNBLOCK_CONFIRMATION",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(41) : TAG_CHAT_TAG_REGISTER
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER ] =
      {
            PACKET_NAME         : "TAG_CHAT_TAG_REGISTER",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(42) : TAG_CHAT_TAG_UNREGISTER
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_UNREGISTER ] =
      {
            PACKET_NAME         : "TAG_CHAT_TAG_UNREGISTER",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.ONLINE_STATUS, 
                CHAT_PACKET_ATTRIBUTE.USER_MOOD 

            ]
      };

      //PACKET TYPE(43) : TAG_CHAT_TAG_REGISTER_CONFIRMATION
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_REGISTER_CONFIRMATION ] =
      {
            PACKET_NAME         : "TAG_CHAT_TAG_REGISTER_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.CHAT_BINDING_PORT, 
                CHAT_PACKET_ATTRIBUTE.SERVER_DATE 

            ]
      };

      //PACKET TYPE(46) : TAG_CHAT_TAG_INFORMATION
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION ] =
      {
            PACKET_NAME         : "TAG_CHAT_TAG_INFORMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.ACTIVITY_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.TAG_NAME, 
                CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL 

            ]
      };

      //PACKET TYPE(47) : TAG_CHAT_TAG_INFORMATION_CONFIRMATION
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_INFORMATION_CONFIRMATION ] =
      {
            PACKET_NAME         : "TAG_CHAT_TAG_INFORMATION_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(51) : TAG_CHAT_TAG_MEMBER_ADD
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD ] =
      {
            PACKET_NAME         : "TAG_CHAT_TAG_MEMBER_ADD",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS, 
                [
                  CHAT_PACKET_ATTRIBUTE.USER_ID,
                  CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.FULL_NAME,
                  CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE
                ]

            ]
      };

      //PACKET TYPE(52) : TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION ] =
      {
            PACKET_NAME         : "TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(53) : TAG_CHAT_MEMBER_REMOVE_LEAVE
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE ] =
      {
            PACKET_NAME         : "TAG_CHAT_MEMBER_REMOVE_LEAVE",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS, 
                [
                  CHAT_PACKET_ATTRIBUTE.USER_ID,
        
                ]

            ]
      };

      //PACKET TYPE(54) : TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION ] =
      {
            PACKET_NAME         : "TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(55) : TAG_CHAT_TAG_MEMBER_TYPE_CHANGE
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE ] =
      {
            PACKET_NAME         : "TAG_CHAT_TAG_MEMBER_TYPE_CHANGE",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS, 
                [
                  CHAT_PACKET_ATTRIBUTE.USER_ID,
                  CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE
                ]

            ]
      };

      //PACKET TYPE(56) : TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION ] =
      {
            PACKET_NAME         : "TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(61) : TAG_CHAT_IDLE
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_IDLE ] =
      {
            PACKET_NAME         : "TAG_CHAT_IDLE",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(62) : TAG_CHAT_TYPING
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_TYPING ] =
      {
            PACKET_NAME         : "TAG_CHAT_TYPING",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(63) : TAG_CHAT_MSG
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG ] =
      {
            PACKET_NAME         : "TAG_CHAT_MSG",
            BROKEN_CONTAINER    : "message",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE 

            ]
      };

      //PACKET TYPE(64) : TAG_CHAT_MSG_EDIT
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_EDIT ] =
      {
            PACKET_NAME         : "TAG_CHAT_MSG_EDIT",
            BROKEN_CONTAINER    : "message",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE 

            ]
      };

      //PACKET TYPE(65) : TAG_CHAT_BROKEN_MSG
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG ] =
      {
            PACKET_NAME         : "TAG_CHAT_BROKEN_MSG",
            BROKEN_CONTAINER    : "message",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE 

            ]
      };

      //PACKET TYPE(66) : TAG_CHAT_BROKEN_MSG_EDIT
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG_EDIT ] =
      {
            PACKET_NAME         : "TAG_CHAT_BROKEN_MSG_EDIT",
            BROKEN_CONTAINER    : "message",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE 

            ]
      };

      //PACKET TYPE(67) : TAG_CHAT_MULTIPLE_MSG
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MULTIPLE_MSG ] =
      {
            PACKET_NAME         : "TAG_CHAT_MULTIPLE_MSG",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE, 
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE, 
                CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE 

            ]
      };

      //PACKET TYPE(68) : TAG_CHAT_DELIVERED
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED ] =
      {
            PACKET_NAME         : "TAG_CHAT_DELIVERED",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(69) : TAG_CHAT_SENT
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SENT ] =
      {
            PACKET_NAME         : "TAG_CHAT_SENT",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(70) : TAG_CHAT_SEEN
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN ] =
      {
            PACKET_NAME         : "TAG_CHAT_SEEN",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(71) : TAG_CHAT_SEEN_CONFIRMATION
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_SEEN_CONFIRMATION ] =
      {
            PACKET_NAME         : "TAG_CHAT_SEEN_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(72) : TAG_CHAT_MULTIPLE_MSG_DELETE
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MULTIPLE_MSG_DELETE ] =
      {
            PACKET_NAME         : "TAG_CHAT_MULTIPLE_MSG_DELETE",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID
                ]

            ]
      };

      //PACKET TYPE(73) : TAG_CHAT_MSG_DELETE_CONFIRMATION
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_DELETE_CONFIRMATION ] =
      {
            PACKET_NAME         : "TAG_CHAT_MSG_DELETE_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(74) : TAG_CHAT_GENERAL_BROKEN_PACKET
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET ] =
      {
            PACKET_NAME         : "TAG_CHAT_GENERAL_BROKEN_PACKET",
            BROKEN_CONTAINER    : "bytes",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO, 
                CHAT_PACKET_ATTRIBUTE.RAW_DATA_BYTE 

            ]
      };

      //PACKET TYPE(75) : TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION
      CHAT_PACKET_INFO[ TAG_CHAT_PACKET_TYPE.TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION ] =
      {
            PACKET_NAME         : "TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO 

            ]
      };

      //PACKET TYPE(91) : OFFLINE_FRIEND_INFORMATION
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_INFORMATION ] =
      {
            PACKET_NAME         : "OFFLINE_FRIEND_INFORMATION",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.FULL_NAME, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM, 
                CHAT_PACKET_ATTRIBUTE.ONLINE_STATUS, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_APP_TYPE, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_DEVICE_TOKEN_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_DEVICE_TOKEN, 
                CHAT_PACKET_ATTRIBUTE.USER_MOOD 

            ]
      };

      //PACKET TYPE(92) : OFFLINE_FRIEND_INFORMATION_CONFIRMATION
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_INFORMATION_CONFIRMATION ] =
      {
            PACKET_NAME         : "OFFLINE_FRIEND_INFORMATION_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(93) : OFFLINE_GET_REQUEST
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST ] =
      {
            PACKET_NAME         : "OFFLINE_GET_REQUEST",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.UPDATE_TIME, 
                CHAT_PACKET_ATTRIBUTE.BLOCK_UNBLOCK_DATE, 
                CHAT_PACKET_ATTRIBUTE.APP_VERSION, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(94) : OFFLINE_GET_REQUEST_CONFIRMATION
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_GET_REQUEST_CONFIRMATION ] =
      {
            PACKET_NAME         : "OFFLINE_GET_REQUEST_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.SERVER_DATE 

            ]
      };

      //PACKET TYPE(95) : OFFLINE_FRIEND_UNREAD_MESSAGE
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE ] =
      {
            PACKET_NAME         : "OFFLINE_FRIEND_UNREAD_MESSAGE",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                  CHAT_PACKET_ATTRIBUTE.USER_ID,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                  CHAT_PACKET_ATTRIBUTE.TIMEOUT,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                  CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE
                ]

            ]
      };

      //PACKET TYPE(96) : OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION ] =
      {
            PACKET_NAME         : "OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION",
            BROKEN_CONTAINER    : "packets",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID
                ]

            ]
      };

      //PACKET TYPE(97) : OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST ] =
      {
            PACKET_NAME         : "OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.PAGE_DIRECTION, 
                CHAT_PACKET_ATTRIBUTE.PAGE_LIMIT, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(98) : OFFLINE_FRIEND_HISTORY_MESSAGE
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE ] =
      {
            PACKET_NAME         : "OFFLINE_FRIEND_HISTORY_MESSAGE",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                  CHAT_PACKET_ATTRIBUTE.USER_ID,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                  CHAT_PACKET_ATTRIBUTE.TIMEOUT,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE,
                  CHAT_PACKET_ATTRIBUTE.IS_SECRET_VISIBLE,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_STATUS
                ],
                CHAT_PACKET_ATTRIBUTE.PAGE_DIRECTION 

            ]
      };

      //PACKET TYPE(99) : OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION ] =
      {
            PACKET_NAME         : "OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(100) : OFFLINE_GET_FRIEND_MESSAGE_STATUS
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_GET_FRIEND_MESSAGE_STATUS ] =
      {
            PACKET_NAME         : "OFFLINE_GET_FRIEND_MESSAGE_STATUS",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID
                ],
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(101) : OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION ] =
      {
            PACKET_NAME         : "OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.FRIEND_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID
                ]

            ]
      };

      //PACKET TYPE(104) : OFFLINE_TAG_INFORMATION_ACTIVITY
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_INFORMATION_ACTIVITY ] =
      {
            PACKET_NAME         : "OFFLINE_TAG_INFORMATION_ACTIVITY",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_ITEMS, 
                [
                  CHAT_PACKET_ATTRIBUTE.ACTIVITY_TYPE,
                  CHAT_PACKET_ATTRIBUTE.USER_ID,
                  CHAT_PACKET_ATTRIBUTE.ACTIVITY_VALUE_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.ACTIVITY_VALUE,
                  CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE,
                  CHAT_PACKET_ATTRIBUTE.CHANGED_BY_USER_ID,
                  CHAT_PACKET_ATTRIBUTE.UPDATE_TIME
                ]

            ]
      };

      //PACKET TYPE(105) : OFFLINE_MY_TAG_LIST
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_MY_TAG_LIST ] =
      {
            PACKET_NAME         : "OFFLINE_MY_TAG_LIST",
            BROKEN_CONTAINER    : "items",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_ITEMS, 
                [
                  CHAT_PACKET_ATTRIBUTE.TAG_ID,
                  CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.TAG_NAME,
                  CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL,
                  CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_ADDED_BY,
                  CHAT_PACKET_ATTRIBUTE.TAG_INFORMATION_TAG_NO_OF_MEMBERS
                ]

            ]
      };

      //PACKET TYPE(106) : OFFLINE_TAG_UNREAD_MESSAGE
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE ] =
      {
            PACKET_NAME         : "OFFLINE_TAG_UNREAD_MESSAGE",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                  CHAT_PACKET_ATTRIBUTE.USER_ID,
                  CHAT_PACKET_ATTRIBUTE.TAG_ID,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE
                ]

            ]
      };

      //PACKET TYPE(107) : OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION ] =
      {
            PACKET_NAME         : "OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION",
            BROKEN_CONTAINER    : "packets",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID
                ]

            ]
      };

      //PACKET TYPE(108) : OFFLINE_TAG_CREATE_TAG
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG ] =
      {
            PACKET_NAME         : "OFFLINE_TAG_CREATE_TAG",
            CONFIRMATION        : true,
            BROKEN              : true,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.TAG_NAME, 
                CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL, 
                CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS, 
                [
                  CHAT_PACKET_ATTRIBUTE.USER_ID,
                  CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.FULL_NAME,
                  CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE
                ],
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(109) : OFFLINE_TAG_CREATE_TAG_CONFIRMATION
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_CREATE_TAG_CONFIRMATION ] =
      {
            PACKET_NAME         : "OFFLINE_TAG_CREATE_TAG_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(110) : OFFLINE_TAG_HISTORY_MESSAGE_REQUEST
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE_REQUEST ] =
      {
            PACKET_NAME         : "OFFLINE_TAG_HISTORY_MESSAGE_REQUEST",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.PAGE_DIRECTION, 
                CHAT_PACKET_ATTRIBUTE.PAGE_LIMIT, 
                CHAT_PACKET_ATTRIBUTE.APP_VERSION, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(111) : OFFLINE_TAG_HISTORY_MESSAGE
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_HISTORY_MESSAGE ] =
      {
            PACKET_NAME         : "OFFLINE_TAG_HISTORY_MESSAGE",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_MESSAGE, 
                [
                  CHAT_PACKET_ATTRIBUTE.PACKET_TYPE,
                  CHAT_PACKET_ATTRIBUTE.USER_ID,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.PACKET_ID,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_TYPE,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE,
                  CHAT_PACKET_ATTRIBUTE.MESSAGE_DATE
                ],
                CHAT_PACKET_ATTRIBUTE.PAGE_DIRECTION 

            ]
      };

      //PACKET TYPE(112) : OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS ] =
      {
            PACKET_NAME         : "OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(113) : OFFLINE_TAG_INFORMATION_WITH_MEMBERS
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_INFORMATION_WITH_MEMBERS ] =
      {
            PACKET_NAME         : "OFFLINE_TAG_INFORMATION_WITH_MEMBERS",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.TAG_NAME_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.TAG_NAME, 
                CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.TAG_PICTURE_URL, 
                CHAT_PACKET_ATTRIBUTE.TAG_NO_OF_MEMBERS, 
                [
                  CHAT_PACKET_ATTRIBUTE.USER_ID,
                  CHAT_PACKET_ATTRIBUTE.FULL_NAME_LENGTH,
                  CHAT_PACKET_ATTRIBUTE.FULL_NAME,
                  CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_TYPE,
                  CHAT_PACKET_ATTRIBUTE.TAG_MEMBER_ADDED_BY
                ]

            ]
      };

      //PACKET TYPE(117) : OFFLINE_TAG_CONFIRMATION
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_TAG_CONFIRMATION ] =
      {
            PACKET_NAME         : "OFFLINE_TAG_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.TAG_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID 

            ]
      };

      //PACKET TYPE(118) : OFFLINE_BROKEN_HISTORY_PACKET
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_HISTORY_PACKET ] =
      {
            PACKET_NAME         : "OFFLINE_BROKEN_HISTORY_PACKET",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO, 
                CHAT_PACKET_ATTRIBUTE.RAW_DATA_BYTE 

            ]
      };

      //PACKET TYPE(119) : OFFLINE_BROKEN_PACKET
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET ] =
      {
            PACKET_NAME         : "OFFLINE_BROKEN_PACKET",
            BROKEN_CONTAINER    : "bytes",
            CONFIRMATION        : true,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.NO_OF_PACKET, 
                CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO, 
                CHAT_PACKET_ATTRIBUTE.RAW_DATA_BYTE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.PLATFORM 

            ]
      };

      //PACKET TYPE(120) : OFFLINE_BROKEN_PACKET_CONFIRMATION
      CHAT_PACKET_INFO[ OFFLINE_PACKET_TYPE.OFFLINE_BROKEN_PACKET_CONFIRMATION ] =
      {
            PACKET_NAME         : "OFFLINE_BROKEN_PACKET_CONFIRMATION",
            CONFIRMATION        : false,
            BROKEN              : false,
            FORMAT:[
                CHAT_PACKET_ATTRIBUTE.PACKET_TYPE, 
                CHAT_PACKET_ATTRIBUTE.USER_ID, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID_LENGTH, 
                CHAT_PACKET_ATTRIBUTE.PACKET_ID, 
                CHAT_PACKET_ATTRIBUTE.SEQUENCE_NO 

            ]
      };




      //Export To global
      global.CHAT_APP['PacketFormats'] = {
          CHAT_PACKET_ATTRIBUTE      : CHAT_PACKET_ATTRIBUTE,
          CHAT_PACKET_ATTRIBUTE_INFO : CHAT_PACKET_ATTRIBUTE_INFO,
          CHAT_PACKET_INFO           : CHAT_PACKET_INFO
      }


})(window);

(function(global){
  'use strict';
  //For Main App global == window
  //For Worker global == self

  function ChatRequests(){
        
    var PACKET_TYPES     = global.CHAT_APP.Constants.PACKET_TYPES;
    var platform         = global.CHAT_APP.Constants.PLATFORM.WEB;
    var getAppVersion    = global.CHAT_APP.getAppVersion;

    var getCurrentUserId = global.CHAT_APP.getCurrentUserId;
    var getUUIDPacketId  = global.CHAT_APP.UTILS.getUUIDPacketId;

    //PACKET TYPE(1) : FRIEND_CHAT_REGISTER
    this.getFriendChatRegisterObject = function(friendId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_REGISTER,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(2) : FRIEND_CHAT_UNREGISTER
    this.getFriendChatUnregisterObject = function(friendId, onlineStatus, userMood, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_UNREGISTER,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          platform                : platform,
          onlineStatus            : onlineStatus,
          userMood                : userMood,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(3) : FRIEND_CHAT_REGISTER_CONFIRMATION
    this.getFriendChatRegisterConfirmationObject = function(friendId, chatBindingPort, serverDate, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_REGISTER_CONFIRMATION,

          /* SPECIFIC PARAMS */
          friendId                : friendId,
          chatBindingPort         : chatBindingPort,
          serverDate              : serverDate,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(4) : FRIEND_CHAT_IDLE
    this.getFriendChatIdleObject = function(friendId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_IDLE,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          platform                : platform,     

      }

      return requestObject;

    }

    //PACKET TYPE(5) : FRIEND_CHAT_TYPING
    this.getFriendChatTypingObject = function(friendId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_TYPING,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          platform                : platform,     

      }

      return requestObject;

    }

    //PACKET TYPE(6) : FRIEND_CHAT_MSG
    this.getFriendChatMsgObject = function(friendId, messageType, timeout, message, messageDate, isSecretVisible, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_MSG,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          messageType             : messageType,
          timeout                 : timeout,
          message                 : message,
          messageDate             : messageDate,
          isSecretVisible         : isSecretVisible,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(7) : FRIEND_CHAT_MSG_EDIT
    this.getFriendChatMsgEditObject = function(friendId, messageType, timeout, message, messageDate, isSecretVisible, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_MSG_EDIT,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          messageType             : messageType,
          timeout                 : timeout,
          message                 : message,
          messageDate             : messageDate,
          isSecretVisible         : isSecretVisible,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(8) : FRIEND_CHAT_BROKEN_MSG
    this.getFriendChatBrokenMsgObject = function(friendId, sequenceNo, messageType, timeout, message, messageDate, isSecretVisible, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_BROKEN_MSG,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          sequenceNo              : sequenceNo,
          messageType             : messageType,
          timeout                 : timeout,
          message                 : message,
          messageDate             : messageDate,
          isSecretVisible         : isSecretVisible,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(9) : FRIEND_CHAT_BROKEN_MSG_EDIT
    this.getFriendChatBrokenMsgEditObject = function(friendId, sequenceNo, messageType, timeout, message, messageDate, isSecretVisible, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_BROKEN_MSG_EDIT,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          sequenceNo              : sequenceNo,
          messageType             : messageType,
          timeout                 : timeout,
          message                 : message,
          messageDate             : messageDate,
          isSecretVisible         : isSecretVisible,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(10) : FRIEND_CHAT_MULTIPLE_MSG
    this.getFriendChatMultipleMsgObject = function(friendId, messages, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_MULTIPLE_MSG,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          messages                : messages,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(15) : FRIEND_CHAT_DELIVERED
    this.getFriendChatDeliveredObject = function(friendId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_DELIVERED,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(16) : FRIEND_CHAT_SENT
    this.getFriendChatSentObject = function(friendId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_SENT,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(17) : FRIEND_CHAT_SEEN
    this.getFriendChatSeenObject = function(friendId, messages, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_SEEN,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          messages                : messages,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(18) : FRIEND_CHAT_SEEN_CONFIRMATION
    this.getFriendChatSeenConfirmationObject = function(friendId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_SEEN_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(19) : FRIEND_CHAT_MULTIPLE_MSG_DELETE
    this.getFriendChatMultipleMsgDeleteObject = function(friendId, packets, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_MULTIPLE_MSG_DELETE,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          packets                 : packets,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(20) : FRIEND_CHAT_MSG_DELETE_CONFIRMATION
    this.getFriendChatMsgDeleteConfirmationObject = function(friendId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_MSG_DELETE_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(24) : FRIEND_CHAT_BROKEN
    this.getFriendChatBrokenObject = function(friendId, sequenceNo, bytes, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_BROKEN,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          sequenceNo              : sequenceNo,
          bytes                   : bytes,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(25) : FRIEND_CHAT_BROKEN_CONFIRMATION
    this.getFriendChatBrokenConfirmationObject = function(friendId, sequenceNo, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_BROKEN_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          sequenceNo              : sequenceNo,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(27) : FRIEND_CHAT_BLOCK
    this.getFriendChatBlockObject = function(friendId, blockUnblockDate, isAddToDb, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_BLOCK,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          blockUnblockDate        : blockUnblockDate,
          isAddToDb               : isAddToDb,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(28) : FRIEND_CHAT_UNBLOCK
    this.getFriendChatUnblockObject = function(friendId, blockUnblockDate, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_UNBLOCK,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          blockUnblockDate        : blockUnblockDate,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(29) : FRIEND_CHAT_BLOCK_UNBLOCK_CONFIRMATION
    this.getFriendChatBlockUnblockConfirmationObject = function(friendId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.FRIEND_CHAT_BLOCK_UNBLOCK_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(41) : TAG_CHAT_TAG_REGISTER
    this.getTagChatTagRegisterObject = function(tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_TAG_REGISTER,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(42) : TAG_CHAT_TAG_UNREGISTER
    this.getTagChatTagUnregisterObject = function(tagId, onlineStatus, userMood, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_TAG_UNREGISTER,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          onlineStatus            : onlineStatus,
          userMood                : userMood,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(43) : TAG_CHAT_TAG_REGISTER_CONFIRMATION
    this.getTagChatTagRegisterConfirmationObject = function(tagId, chatBindingPort, serverDate, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_TAG_REGISTER_CONFIRMATION,

          /* SPECIFIC PARAMS */
          tagId                   : tagId,
          chatBindingPort         : chatBindingPort,
          serverDate              : serverDate,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(46) : TAG_CHAT_TAG_INFORMATION
    this.getTagChatTagInformationObject = function(tagId, activityType, tagName, tagPictureUrl, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_TAG_INFORMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          activityType            : activityType,
          tagName                 : tagName,
          tagPictureUrl           : tagPictureUrl,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(47) : TAG_CHAT_TAG_INFORMATION_CONFIRMATION
    this.getTagChatTagInformationConfirmationObject = function(tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_TAG_INFORMATION_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(51) : TAG_CHAT_TAG_MEMBER_ADD
    this.getTagChatTagMemberAddObject = function(tagId, tagMembers, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_TAG_MEMBER_ADD,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          tagMembers              : tagMembers,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(52) : TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION
    this.getTagChatTagMemberAddConfirmationObject = function(tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(53) : TAG_CHAT_MEMBER_REMOVE_LEAVE
    this.getTagChatMemberRemoveLeaveObject = function(tagId, tagMembers, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_MEMBER_REMOVE_LEAVE,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          tagMembers              : tagMembers,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(54) : TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION
    this.getTagChatMemberRemoveLeaveConfirmationObject = function(tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(55) : TAG_CHAT_TAG_MEMBER_TYPE_CHANGE
    this.getTagChatTagMemberTypeChangeObject = function(tagId, tagMembers, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          tagMembers              : tagMembers,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(56) : TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION
    this.getTagChatTagMemberTypeChangeConfirmationObject = function(tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(61) : TAG_CHAT_IDLE
    this.getTagChatIdleObject = function(tagId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_IDLE,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          platform                : platform,     

      }

      return requestObject;

    }

    //PACKET TYPE(62) : TAG_CHAT_TYPING
    this.getTagChatTypingObject = function(tagId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_TYPING,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          platform                : platform,     

      }

      return requestObject;

    }

    //PACKET TYPE(63) : TAG_CHAT_MSG
    this.getTagChatMsgObject = function(tagId, messageType, message, messageDate, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_MSG,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          messageType             : messageType,
          message                 : message,
          messageDate             : messageDate,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(64) : TAG_CHAT_MSG_EDIT
    this.getTagChatMsgEditObject = function(tagId, messageType, message, messageDate, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_MSG_EDIT,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          messageType             : messageType,
          message                 : message,
          messageDate             : messageDate,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(65) : TAG_CHAT_BROKEN_MSG
    this.getTagChatBrokenMsgObject = function(tagId, sequenceNo, messageType, message, messageDate, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_BROKEN_MSG,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          sequenceNo              : sequenceNo,
          messageType             : messageType,
          message                 : message,
          messageDate             : messageDate,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(66) : TAG_CHAT_BROKEN_MSG_EDIT
    this.getTagChatBrokenMsgEditObject = function(tagId, sequenceNo, messageType, message, messageDate, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_BROKEN_MSG_EDIT,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          sequenceNo              : sequenceNo,
          messageType             : messageType,
          message                 : message,
          messageDate             : messageDate,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(67) : TAG_CHAT_MULTIPLE_MSG
    this.getTagChatMultipleMsgObject = function(tagId, messageType, message, messageDate, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_MULTIPLE_MSG,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          messageType             : messageType,
          message                 : message,
          messageDate             : messageDate,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(68) : TAG_CHAT_DELIVERED
    this.getTagChatDeliveredObject = function(friendId, tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_DELIVERED,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          tagId                   : tagId,
          packetId                : packetId || getUUIDPacketId(),
          boxId                   : tagId,      

      }

      return requestObject;

    }

    //PACKET TYPE(69) : TAG_CHAT_SENT
    this.getTagChatSentObject = function(tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_SENT,

          /* SPECIFIC PARAMS */
          tagId                   : tagId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(70) : TAG_CHAT_SEEN
    this.getTagChatSeenObject = function(friendId, tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_SEEN,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          tagId                   : tagId,
          packetId                : packetId || getUUIDPacketId(),
          boxId                   : tagId,      

      }

      return requestObject;

    }

    //PACKET TYPE(71) : TAG_CHAT_SEEN_CONFIRMATION
    this.getTagChatSeenConfirmationObject = function(tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_SEEN_CONFIRMATION,

          /* SPECIFIC PARAMS */
          tagId                   : tagId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(72) : TAG_CHAT_MULTIPLE_MSG_DELETE
    this.getTagChatMultipleMsgDeleteObject = function(tagId, packets, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_MULTIPLE_MSG_DELETE,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          packets                 : packets,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(73) : TAG_CHAT_MSG_DELETE_CONFIRMATION
    this.getTagChatMsgDeleteConfirmationObject = function(tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_MSG_DELETE_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(74) : TAG_CHAT_GENERAL_BROKEN_PACKET
    this.getTagChatGeneralBrokenPacketObject = function(tagId, sequenceNo, bytes, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_GENERAL_BROKEN_PACKET,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          sequenceNo              : sequenceNo,
          bytes                   : bytes,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(75) : TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION
    this.getTagChatGeneralBrokenPacketConfirmationObject = function(tagId, sequenceNo, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          sequenceNo              : sequenceNo,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(91) : OFFLINE_FRIEND_INFORMATION
    this.getOfflineFriendInformationObject = function(friendId, fullName, onlineStatus, friendAppType, friendDeviceToken, userMood, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_FRIEND_INFORMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          fullName                : fullName,
          platform                : platform,
          onlineStatus            : onlineStatus,
          friendAppType           : friendAppType,
          friendDeviceToken       : friendDeviceToken,
          userMood                : userMood,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(92) : OFFLINE_FRIEND_INFORMATION_CONFIRMATION
    this.getOfflineFriendInformationConfirmationObject = function(friendId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_FRIEND_INFORMATION_CONFIRMATION,

          /* SPECIFIC PARAMS */
          friendId                : friendId,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(93) : OFFLINE_GET_REQUEST
    this.getOfflineGetRequestObject = function(updateTime, blockUnblockDate, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_GET_REQUEST,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          updateTime              : updateTime,
          blockUnblockDate        : blockUnblockDate,
          appVersion              : getAppVersion(),
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(94) : OFFLINE_GET_REQUEST_CONFIRMATION
    this.getOfflineGetRequestConfirmationObject = function(serverDate, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_GET_REQUEST_CONFIRMATION,

          /* SPECIFIC PARAMS */
          serverDate              : serverDate,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(95) : OFFLINE_FRIEND_UNREAD_MESSAGE
    this.getOfflineFriendUnreadMessageObject = function(messages, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_FRIEND_UNREAD_MESSAGE,

          /* SPECIFIC PARAMS */
          messages                : messages,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(96) : OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION
    this.getOfflineFriendUnreadMessageConfirmationObject = function(packets, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          packets                 : packets,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(97) : OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST
    this.getOfflineFriendHistoryMessageRequestObject = function(friendId, pageDirection, pageLimit, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          pageDirection           : pageDirection,
          pageLimit               : pageLimit,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(98) : OFFLINE_FRIEND_HISTORY_MESSAGE
    this.getOfflineFriendHistoryMessageObject = function(friendId, messages, pageDirection, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_FRIEND_HISTORY_MESSAGE,

          /* SPECIFIC PARAMS */
          friendId                : friendId,
          messages                : messages,
          pageDirection           : pageDirection,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(99) : OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION
    this.getOfflineFriendHistoryMessageConfirmationObject = function(friendId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION,

          /* SPECIFIC PARAMS */
          friendId                : friendId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(100) : OFFLINE_GET_FRIEND_MESSAGE_STATUS
    this.getOfflineGetFriendMessageStatusObject = function(friendId, packets, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_GET_FRIEND_MESSAGE_STATUS,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          friendId                : friendId,
          packets                 : packets,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(101) : OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION
    this.getOfflineGetFriendMessageStatusConfirmationObject = function(friendId, packets, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION,

          /* SPECIFIC PARAMS */
          friendId                : friendId,
          packets                 : packets,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(104) : OFFLINE_TAG_INFORMATION_ACTIVITY
    this.getOfflineTagInformationActivityObject = function(tagId, noOfItems, items, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_TAG_INFORMATION_ACTIVITY,

          /* SPECIFIC PARAMS */
          tagId                   : tagId,
          noOfItems               : noOfItems,
          items                   : items,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(105) : OFFLINE_MY_TAG_LIST
    this.getOfflineMyTagListObject = function(noOfItems, items, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_MY_TAG_LIST,

          /* SPECIFIC PARAMS */
          noOfItems               : noOfItems,
          items                   : items,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(106) : OFFLINE_TAG_UNREAD_MESSAGE
    this.getOfflineTagUnreadMessageObject = function(messages, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_TAG_UNREAD_MESSAGE,

          /* SPECIFIC PARAMS */
          messages                : messages,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(107) : OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION
    this.getOfflineTagUnreadMessageConfirmationObject = function(packets, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          packets                 : packets,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(108) : OFFLINE_TAG_CREATE_TAG
    this.getOfflineTagCreateTagObject = function(tagId, tagName, tagPictureUrl, tagMembers, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_TAG_CREATE_TAG,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          tagName                 : tagName,
          tagPictureUrl           : tagPictureUrl,
          tagMembers              : tagMembers,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(109) : OFFLINE_TAG_CREATE_TAG_CONFIRMATION
    this.getOfflineTagCreateTagConfirmationObject = function(tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_TAG_CREATE_TAG_CONFIRMATION,

          /* SPECIFIC PARAMS */
          tagId                   : tagId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(110) : OFFLINE_TAG_HISTORY_MESSAGE_REQUEST
    this.getOfflineTagHistoryMessageRequestObject = function(tagId, pageDirection, pageLimit, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_TAG_HISTORY_MESSAGE_REQUEST,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          pageDirection           : pageDirection,
          pageLimit               : pageLimit,
          appVersion              : getAppVersion(),
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(111) : OFFLINE_TAG_HISTORY_MESSAGE
    this.getOfflineTagHistoryMessageObject = function(tagId, messages, pageDirection, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_TAG_HISTORY_MESSAGE,

          /* SPECIFIC PARAMS */
          tagId                   : tagId,
          messages                : messages,
          pageDirection           : pageDirection,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(112) : OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS
    this.getOfflineGetTagInformationWithMembersObject = function(tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          tagId                   : tagId,
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(113) : OFFLINE_TAG_INFORMATION_WITH_MEMBERS
    this.getOfflineTagInformationWithMembersObject = function(tagId, tagName, tagPictureUrl, tagMembers, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_TAG_INFORMATION_WITH_MEMBERS,

          /* SPECIFIC PARAMS */
          tagId                   : tagId,
          tagName                 : tagName,
          tagPictureUrl           : tagPictureUrl,
          tagMembers              : tagMembers,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(117) : OFFLINE_TAG_CONFIRMATION
    this.getOfflineTagConfirmationObject = function(tagId, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_TAG_CONFIRMATION,

          /* SPECIFIC PARAMS */
          tagId                   : tagId,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(118) : OFFLINE_BROKEN_HISTORY_PACKET
    this.getOfflineBrokenHistoryPacketObject = function(sequenceNo, bytes, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_BROKEN_HISTORY_PACKET,

          /* SPECIFIC PARAMS */
          sequenceNo              : sequenceNo,
          bytes                   : bytes,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(119) : OFFLINE_BROKEN_PACKET
    this.getOfflineBrokenPacketObject = function(sequenceNo, bytes, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_BROKEN_PACKET,

          /* SPECIFIC PARAMS */
          sequenceNo              : sequenceNo,
          bytes                   : bytes,
          userId                  : getCurrentUserId(),
          platform                : platform,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }

    //PACKET TYPE(120) : OFFLINE_BROKEN_PACKET_CONFIRMATION
    this.getOfflineBrokenPacketConfirmationObject = function(sequenceNo, packetId){
 
      var requestObject = {

          /* GENERAL PARAMS */
          packetType              : PACKET_TYPES.OFFLINE_BROKEN_PACKET_CONFIRMATION,

          /* SPECIFIC PARAMS */
          userId                  : getCurrentUserId(),
          sequenceNo              : sequenceNo,
          packetId                : packetId || getUUIDPacketId(),      

      }

      return requestObject;

    }


  }

  global.CHAT_APP['ChatRequests'] = new ChatRequests();

})(window);

(function(global){
	'use strict';
	//For Main App global == window
    //For Worker global == self

    //Dependencies 
    //- app/chat/shared/chat.constans.js

    var CHAT_APP = global.CHAT_APP;
    var AUTH_REQUEST_TYPE = CHAT_APP.AUTH_REQUEST_TYPE;
	var getCurrentUserId = CHAT_APP.getCurrentUserId;

    function AuthRequests(){


    	var REQUEST_TYPE = CHAT_APP.Constants.AUTH_REQUEST_TYPE;
    	var AUTH_SERVER_ACTIONS = CHAT_APP.Constants.AUTH_SERVER_ACTIONS;

        //ACTION ID(83) : GET_OFFLINE_IP_PORT
		this.getOfflineIpPort = function( packetId ){
 
			

            var requestObject = {
                actn: AUTH_SERVER_ACTIONS.GET_OFFLINE_IP_PORT,
                rid : getCurrentUserId()
            };

            if( !!packetId ){
				requestObject['pckId'] = packetId;
			}


            return requestObject;

		};

		//ACTION ID(134) : START_TAG_CHAT
		this.getTagChatRegisterIpPort = function( tagId, uIds, packetId ){
 
            var requestObject = {
                actn  : AUTH_SERVER_ACTIONS.START_TAG_CHAT,
                tid   : tagId,
                uIds  : uIds                
            };

            if( !!packetId ){
				requestObject['pckId'] = packetId;
			}

            return requestObject;

		};

		//ACTION ID(175) : START_F2F_CHAT
		this.getFriendChatRegisterIpPort = function( friendId, packetId ){			

            var requestObject = {
                actn            : AUTH_SERVER_ACTIONS.START_F2F_CHAT,
                fndId           : friendId,
                uId             : getCurrentUserId()
            };

            if( !!packetId ){
				requestObject['pckId'] = packetId;
			}

            return requestObject;

		};


		//ACTION ID(135) : ADD_TAG_CHAT_MEMBERS
		this.getTagChatMembersAddObject = function(tagId, uIds, registerIp, registerPort, packetId){
 
			var requestObject = {

			    actn : AUTH_SERVER_ACTIONS.ADD_TAG_CHAT_MEMBERS,
			    tid  : tagId,			    
			    uIds : uIds,
			    chIp : registerIp,
			    chRp : registerPort,
			};

			if( !!packetId ){
				requestObject['pckId'] = packetId;
			}

			return requestObject;

		};

		//ACTION ID(83) : GET_OFFLINE_IP_PORT
		this.getOfflineIpPort = function(){
			var requestObject = {
                actn        : AUTH_SERVER_ACTIONS.GET_OFFLINE_IP_PORT,
                rid         : getCurrentUserId(),
                requestType : AUTH_REQUEST_TYPE.REQUEST
            };

            return requestObject;
		}


		//ACTION ID(199) : GET_FRIEND_PRESENCE
		this.getFriendPresenceObject = function(friendId){
			var requestObject = {
                actn        : AUTH_SERVER_ACTIONS.GET_USER_MOOD_PRESENCE,
                fndId       :friendId
            };

            return requestObject;
		}

    }
    
    global.CHAT_APP['AuthRequests'] = new AuthRequests();

})(window);

/*jslint bitwise:true */

;(function(PacketIDGenerator){


    var lastTimestamp = 0;
    var LOOP_MAX = 50;
    var START_EPOCH = makeEpoch();
    var GREGORIAN_OFFSET = 122192928000000000;

    function makeEpoch(){
        return Date.UTC(1582, 9, 15);
    }

    function getTimeFieldValues(time) {    
        var ts = fromUnixTimeStamp(time);    
        var hm = ((ts / 0x100000000) * 10000) & 0xFFFFFFF;
        return { low: ((ts & 0xFFFFFFF) * 10000) % 0x100000000,
            mid: hm & 0xFFFF, hi: hm >>> 16, timestamp: ts };
    }

    function fromUnixTimeStamp(currentTime){
        return currentTime - START_EPOCH;
    }

    function getNowTimestamp(){
        //return Date.UTC(2001, 10,10)
         return new Date().getTime();
        // return 1005350400000;
    }

    function getPacketIdTimestampFromCurrentTime(currentTime){
        var now, candidate;

        var index = 0;

        while(index++ < LOOP_MAX){

            now = currentTime;
            //console.log('Now ', now, makeEpoch());

            if( now > lastTimestamp ){
                lastTimestamp = now;
                return now;
            }else{

                if( now < lastTimestamp ){
                    return lastTimestamp + 1;
                }

                candidate = lastTimestamp + 1;

                if( candidate == lastTimestamp ){
                    lastTimestamp = candidate;
                    return candidate;
                }
            }
        }

        return candidate;
    }

    function create(userId, timestamp, isPacketIdStamp) {
        try{
            userId = parseInt(userId);
        }catch(e){
            console.error('Invalid User Id Provided for PacketIDGenerator');
            return "";
        }

        var packetIdTimeStamp;
        if(!isPacketIdStamp){
            if(!timestamp){
                timestamp = getNowTimestamp();
            }

            packetIdTimeStamp = getPacketIdTimestampFromCurrentTime(timestamp);

        }else{
            packetIdTimeStamp = timestamp;
        }

        var tf = getTimeFieldValues(packetIdTimeStamp);

        tf.hi = (tf.hi | 0x1000);

        //console.log(tf);
        
        return fromParts(tf.low, tf.mid, tf.hi, userId);
    }

    function paddedString(string, length, z) {
        string = String(string);
        z = (!z) ? '0' : z;
        var i = length - string.length;
        for (; i > 0; i >>>= 1, z += z) {
            if (i & 1) {
                string = z + string;
            }
        }
        return string;
    }

    function fromParts(timeLow, timeMid, timeHiAndVersion, userId) {
        if( timeLow < 0 ){
            console.error('Invalid time in packetIdgen');
        }

        var uuid =  paddedString(timeLow.toString(16), 8) +
            '-' + paddedString(timeMid.toString(16), 4) +
            '-' + paddedString(timeHiAndVersion.toString(16), 4) +
            '-' + paddedString((0x0000).toString(16), 4) +
            '-' + paddedString(userId.toString(16), 12);

        //console.log('Time Low ' + timeLow);
        //console.log('Time Mid ' + timeMid);
        //console.log('Time timeHiAndVersion ' + timeHiAndVersion);
        //console.log('UUID', uuid);

        return uuid;
    }

    function getTimestamp(uuidString){
        var uuidArr = uuidString.split( '-' ),
            timeStr = [
                uuidArr[ 2 ].substring( 1 ),
                uuidArr[ 1 ],
                uuidArr[ 0 ]
            ].join( '' );

        var timeInt = parseInt( timeStr, 16 );
        timeInt -= GREGORIAN_OFFSET;

        var timeIntMill = Math.floor(timeInt/10000);
        return timeIntMill;

    }

    function _PacketIDGenerator(){}
    _PacketIDGenerator.prototype.create = create;
    _PacketIDGenerator.prototype.getTimestamp = getTimestamp;

    PacketIDGenerator = PacketIDGenerator || new _PacketIDGenerator();

    window['PacketIDGenerator'] = PacketIDGenerator;

})(window.PacketIDGenerator);

//var timestamp = new Date().getTime();
//console.log(timestamp);
//var id = PacketIDGenerator.create(2110010524, timestamp, true);
//console.log(id);
//timestamp1 = PacketIDGenerator.getTimestamp(id);
//console.log(timestamp1);

/***

var id = PacketIDGenerator.create(2110010524);
console.log(id);

13224643200000
e22c4000-d56d-11d5-0000-00007dc4349c


13671783478602
78e19aa0-b825-11e5-0000-00007dc4349c


13671783503417
87ac1290-b825-11e5-0000-00007dc4349c


13671783517819
9041a4b0-b825-11e5-0000-00007dc4349c

13671783594580
be027140-b825-11e5-0000-00007dc4349c

***/

(function() {
	'use strict';

	angular
		.module('ringid.chat', [
            'ringid.config',
            'ngWebSocket',
            'ringid.utils',
            'ringid.common.rgemoticon_directive',
            'ringid.connector',
            'ringid.common.rgupload_directive',
            'angularAudioRecorder'
        ])
        .config(['recorderServiceProvider', function(recorderServiceProvider){
            //configure here
        }])
        .filter('prettyJSON', function () {
            function prettyPrintJson(json) {
                return JSON ? JSON.stringify(json, null, '  ') : 'your browser doesnt support JSON so cant pretty print';
            }
            return prettyPrintJson;
        });

})();


/*
 * Md. Ibrahim Rashid
 * © Ipvision
 */

(function() {
	'use strict';

        var TAG_CHAT_LANG = {

            STATUS_MESSAGES : {

                SELF_ADD_MEMBER                                 : 'You added {new_member_name} as Group {new_member_type}.',
                SELF_ADD_MULTIPLE_MEMBER                        : 'You added {new_member_name} and {rest_count} as Group {new_member_type}.',

                SELF_REMOVE_MEMBER                              : 'You removed {old_member_name} from the group.',
                SELF_REMOVE_MULTIPLE_MEMBER                     : 'You removed {old_member_name} and {rest_count} from the group.',

                OTHER_ADD_MEMBER                                : '{member_name} added {new_member_name} as Group {new_member_type}.',
                OTHER_ADD_MULTIPLE_MEMBER                       : '{member_name} added {new_member_name} and {rest_count} as Group {new_member_type}.',

                OTHER_REMOVE_MEMBER                             : '{member_name} removed {old_member_name} from the group.',
                OTHER_REMOVE_MULTIPLE_MEMBER                    : '{member_name} removed {old_member_name} and {rest_count} from the group.',

                SELF_LEAVE_GROUP                                : 'You left this conversation.',
                OTHER_LEAVE_GROUP                               : '{member_name} left this conservation.',

                SELF_RENAME_GROUP                               : 'You named the group {group_name}.',
                OTHER_RENAME_GROUP                              : '{member_name} named the group {group_name}.',

                SELF_CHANGE_GROUP_PIC                           : 'You changed the group photo.',
                OTHER_CHANGE_GROUP_PIC                          : '{member_name} changed the group photo.',

                SELF_UPDATE_GROUP_INFO                          : 'You named the group {group_name} and changed the group photo.',
                OTHER_UPDATE_GROUP_INFO                         : '{member_name} named the group {group_name} and changed the group photo.',

                SELF_MEMBER_CHANGE_TO_ADMIN                     : 'You made {old_member_name} Group Admin.',
                OTHER_MEMBER_CHANGE_TO_ADMIN                    : '{member_name} made {old_member_name} as Admin.',

                SELF_MULTIPLE_MEMBER_CHANGE_TO_ADMIN            : 'You made {old_member_name} and {rest_count} as Group admin.',
                OTHER_MULTIPLE_MEMBER_CHANGE_TO_ADMIN           : '{member_name} made {old_member_name} and {rest_count} as Group admin.',


                SELF_ADMIN_CHANGE_TO_MEMBER                     : 'You removed {old_admin_name} from Admin.',
                OTHER_ADMIN_CHANGE_TO_MEMBER                    : '{admin_name} removed {old_admin_name} from Group Admin.',

                SELF_MULTIPLE_ADMIN_CHANGE_TO_MEMBER            : 'You removed {old_admin_name} and {rest_count} as Group admin.',
                OTHER_MULTIPLE_ADMIN_CHANGE_TO_MEMBER           : '{admin_name} removed {old_admin_name} and {rest_count} from Group Admin.',

                SELF_REMOVED_FROM_ADMIN_BY_SELF                 : 'You removed yourself from Admin',

                OTHER_REMOVED_FROM_ADMIN_BY_SELF                : '{admin_name} removed himself/herself from Admin',

                SELF_USER_ADDED_AS_OWNER                        : '{member_name} made you owner.',
                OTHER_USER_ADDED_AS_OWNER                       : '{member_name} made {admin_name} Owner. ',

                SELF_NOT_GROUP_MEMBER                           : 'You are no longer member of this group'

            },

            DEFAULT_FAILURE_MESSAGE : 'Request has not been processed successfully. Please try again',
            DEFAULT_SUCCESS_MESSAGE : 'Request has been processed successfully.'

        };

        var CHAT_LANG = {

            MESSAGE_DELETE_TEXT : 'This message has been deleted'            
        };


        var ChatApp = angular.module('ringid.chat');
        ChatApp.constant('CHAT_LANG', {
            'TAG' : TAG_CHAT_LANG,
            'CHAT' : CHAT_LANG
        });


})();

(function(global){
    'use strict';

    var chatApp;
    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {
      console.log(e);
    }

    chatApp.factory('ChatResponses', ChatResponses);

    ChatResponses.$inject = ['$rootScope', 'chatHistoryFactory', 'SystemEvents',
    'Auth', 'tagChatFactory', 'ChatFactory',  'tagChatManager', 'utilsFactory',
    'profileFactory',
    'ChatResponseProcessor', 'ChatSeenSend', 'ChatHelper']

    function ChatResponses($rootScope, chatHistoryFactory, SystemEvents,
      Auth, tagChatFactory, ChatFactory, tagChatManager, utilsFactory, 
      profileFactory,
      ChatResponseProcessor, ChatSeenSend, ChatHelper) {

        var PACKET_TYPES = global.CHAT_APP.Constants.PACKET_TYPES;
        var Constants = global.CHAT_APP.Constants;
        var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;
        var CHAT_GLOBAL_VALUES = Constants.CHAT_GLOBAL_VALUES;
        var ChatRequests = CHAT_APP.ChatRequests;
        var responseMethodMap = {};

        function getPacketProcessorInfo(packetType){
            return responseMethodMap[packetType];
        }

        function processUpdates(responseObject) {

            var packetType = responseObject.packetType;

            var packetProcessorInfo = getPacketProcessorInfo(packetType);

            if( !packetProcessorInfo ){
                return false;
            }

            try{
               packetProcessorInfo.processor.call(this, responseObject);
            }catch(e){
            }

            return true;

        }

        
      //PACKET TYPE(1) : FRIEND_CHAT_REGISTER
      function onFriendChatRegister(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(2) : FRIEND_CHAT_UNREGISTER
      function onFriendChatUnregister(responseObject){      
        var userId       = responseObject.userId,
            friendId     = responseObject.friendId,
            onlineStatus = responseObject.onlineStatus,
            userMood     = responseObject.userMood,
            packetId     = responseObject.packetId;
        
        /* method body */

        var box = ChatFactory.getBoxByUId(userId);
        if(userId === box.getKey()){
            ChatFactory.closeChatBox(box.getKey());
        }

      }

      //PACKET TYPE(3) : FRIEND_CHAT_REGISTER_CONFIRMATION
      function onFriendChatRegisterConfirmation(responseObject){      
        var friendId        = responseObject.friendId,
            chatBindingPort = responseObject.chatBindingPort,
            serverDate      = responseObject.serverDate,
            packetId        = responseObject.packetId;
        
        /* method body */
        
        CHAT_GLOBAL_VALUES.serverTimeDiff = serverDate - Date.now();

        var box = ChatFactory.getBoxByUId(friendId);
        if(!box){
          box = ChatFactory.creatNonDomBox(friendId, false); 
        }

      }

      //PACKET TYPE(4) : FRIEND_CHAT_IDLE
      function onFriendChatIdle(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId;
        
        /* method body */
        
        var box = ChatFactory.getBoxByUId(userId);                                
        if(box) box.setFriendTypingBool(false); 

      }

      //PACKET TYPE(5) : FRIEND_CHAT_TYPING
      function onFriendChatTyping(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId;
        
        /* method body */

        var boxId;
        if( responseObject.userId == Auth.currentUser().getKey() ){
            boxId = responseObject.friendId;
        }else{
            boxId = responseObject.userId;
        }

        var box = ChatFactory.getBoxByUId(boxId);
        
        if(box){ // no need to open box for typing, if box is closed; and for this scenario no need to update box
            box.setFriendTypingBool(true);
            setTimeout(function () {
                box.setFriendTypingBool(false);
                utilsFactory.triggerCustomEvent(SystemEvents.CHAT.BOX_UPDATED, {boxId : boxId});
            },3000);
        }

      }

      //PACKET TYPE(6) : FRIEND_CHAT_MSG
      function onFriendChatMsg(responseObject){      
        var userId          = responseObject.userId,
            friendId        = responseObject.friendId,
            messageType     = responseObject.messageType,
            timeout         = responseObject.timeout,
            message         = responseObject.message,
            messageDate     = responseObject.messageDate,
            isSecretVisible = responseObject.isSecretVisible,
            packetId        = responseObject.packetId;
        
        /* method body */

          var boxId = responseObject.boxId;
          var currentUserId = Auth.currentUser().getKey();

          var scrollType;
          
          if( !boxId ){
              boxId = userId;
          }

          if( boxId == currentUserId){
              boxId = friendId;
          }

          boxId = boxId.toString(); 

          if( chatHistoryFactory.isInLocalStorageChatMsgMap(boxId, packetId) ){
              return;
          }

          var chatBox = ChatFactory.getBoxByUId(boxId);

          if( !responseObject.fromHistory 
            && messageType === GENERAL_CONSTANTS.MESSAGE_TYPES.DELETE_MESSAGE ){

              ChatResponseProcessor.doOnMessageTypeDeleteMessage(boxId, userId, packetId, chatBox );

          }else if( responseObject.messageType > GENERAL_CONSTANTS.MESSAGE_TYPES.BLANK_MESSAGE ){

              if( !chatBox){

                  ChatFactory.openChatBox(boxId);

              }else if( !responseObject.fromHistory){

                  if( !chatBox.nonDomBox ){
                    chatBox.nonDomBox = true;
                    chatBox.loadHistoryMessages();
                    utilsFactory.triggerCustomEvent(SystemEvents.CHAT.BOX_OPENNED, {boxId : boxId });  
                  }                  
              }

              chatBox = ChatFactory.getBoxByUId(boxId);

              chatBox.setFriendTypingBool(false);

              if(responseObject.fromHistory){
                  responseObject.seenSent = true;
              }else{
                  scrollType = 'bottom'    
              }


              if( !responseObject.fromHistory || !responseObject.fromOffline){

                  if( !!chatBox && !chatBox.isFocused ){
                      responseObject.status = 'Unread';
                      scrollType = 'unread'
                  }else{
                      responseObject.status = responseObject.status || 'Received';
                  }
              }
          
              responseObject.tag_chat = false;

              var friendId = chatBox.getKey();

              if (responseObject.status == 'Edited' || !chatBox.isSamePacketId(packetId) ) {

                  responseObject.user = profileFactory.getUserObjectByUId(userId);

                  if(responseObject.status == 'Unread') {
                      ChatFactory.increaseUnreadMessageCount(boxId, responseObject.packetId);
                      chatBox.updateUnreadCount();
                  }

                  chatBox.pushMessage(responseObject, chatBox.getKey());

                  if(!responseObject.fromHistory) {
                      
                      if(chatBox.isFocused ){//for sending seen packet if box is on focused
                          var filteredMessages = [{key: responseObject.packetId, value:chatBox.getMessage(responseObject.packetId)}];
                          ChatSeenSend.sendSeenPacket(chatBox, filteredMessages);
                          
                          utilsFactory.triggerCustomEvent(SystemEvents.CHAT.WAS_FOCUSED, {box: chatBox, filteredMessages: filteredMessages});
                      }                      
                  }

                  chatHistoryFactory.updateBox(chatBox);

              }

              if(!responseObject.fromHistory){
                  utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED, { boxId : boxId, scroll : scrollType });
              }


          }
      }

      //PACKET TYPE(7) : FRIEND_CHAT_MSG_EDIT
      function onFriendChatMsgEdit(responseObject){      
        var userId          = responseObject.userId,
            friendId        = responseObject.friendId,
            messageType     = responseObject.messageType,
            timeout         = responseObject.timeout,
            message         = responseObject.message,
            messageDate     = responseObject.messageDate,
            isSecretVisible = responseObject.isSecretVisible,
            packetId        = responseObject.packetId;
        
        /* method body */

        responseObject.status = 'Edited';
        onFriendChatMsg( responseObject );

      }

      //PACKET TYPE(8) : FRIEND_CHAT_BROKEN_MSG
      function onFriendChatBrokenMsg(responseObject){      
        var userId          = responseObject.userId,
            friendId        = responseObject.friendId,
            sequenceNo      = responseObject.sequenceNo,
            messageType     = responseObject.messageType,
            timeout         = responseObject.timeout,
            message         = responseObject.message,
            messageDate     = responseObject.messageDate,
            isSecretVisible = responseObject.isSecretVisible,
            packetId        = responseObject.packetId;
        
        /* method body */

        /*** Packets are merged in worker, it will received the merged packet ***/
        
        onFriendChatMsg(responseObject)

      }

      //PACKET TYPE(9) : FRIEND_CHAT_BROKEN_MSG_EDIT
      function onFriendChatBrokenMsgEdit(responseObject){      
        var userId          = responseObject.userId,
            friendId        = responseObject.friendId,
            sequenceNo      = responseObject.sequenceNo,
            messageType     = responseObject.messageType,
            timeout         = responseObject.timeout,
            message         = responseObject.message,
            messageDate     = responseObject.messageDate,
            isSecretVisible = responseObject.isSecretVisible,
            packetId        = responseObject.packetId;
        
        /* method body */
        
        /*** Packets are merged in worker, it will received the merged packet ***/
        onFriendChatMsgEdit( responseObject )

      }

      //PACKET TYPE(10) : FRIEND_CHAT_MULTIPLE_MSG
      function onFriendChatMultipleMsg(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            messages = responseObject.messages,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(15) : FRIEND_CHAT_DELIVERED
      function onFriendChatDelivered(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            packetId = responseObject.packetId;
        
        /* method body */

        var boxId = ChatResponseProcessor.getFriendBoxId( userId, friendId )
        var box = ChatResponseProcessor.getFriendBox( boxId );

        var msgObj    = box.getMessage( packetId );
        if(!!msgObj){
            ChatResponseProcessor.updateMessageStatusToDelivered( boxId, msgObj );
            box.sendTabUpdate( msgObj );
        }

      }

      //PACKET TYPE(16) : FRIEND_CHAT_SENT
      function onFriendChatSent(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            packetId = responseObject.packetId;
        
        /* method body */

        var boxId = ChatResponseProcessor.getFriendBoxId( userId, friendId )
        var box = ChatResponseProcessor.getFriendBox( boxId );

        var msgObj    = box.getMessage( packetId );
        if(!!msgObj){
            ChatResponseProcessor.updateMessageStatusToDelivered( box.getKey(), msgObj );
            box.sendTabUpdate( msgObj );
        }

      }

      //PACKET TYPE(17) : FRIEND_CHAT_SEEN
      function onFriendChatSeen(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            messages = responseObject.messages,
            packetId = responseObject.packetId;
        
        /* method body */
        var boxId = ChatResponseProcessor.getFriendBoxId( userId, friendId )
        var box = ChatResponseProcessor.getFriendBox( boxId );

        for(var index = 0; index < responseObject.messages.length; index++){
            var aBoxMessage = box.getMessage(responseObject.messages[index].packetId);
            if(!!aBoxMessage){
                var doUpdateMessage = false;
                if(responseObject.messages[index].status == GENERAL_CONSTANTS.MESSAGE_STATUS.DELETED){
                  /* Skipping If Message is Deleted */
                }else if(responseObject.messages[index].status == GENERAL_CONSTANTS.MESSAGE_STATUS.SEEN){
                    aBoxMessage.status = 'Seen';                    
                    utilsFactory.triggerCustomEvent('DO_START_SECRET_TIMER', {boxId : boxId, others: false, messages: [{key:responseObject.messages[index].packetId, value: aBoxMessage}] })
                    doUpdateMessage = true;                    
                }
                else if (responseObject.messages[index].status == GENERAL_CONSTANTS.MESSAGE_STATUS.VIEWED){
                    aBoxMessage.status = 'Viewed';
                    utilsFactory.triggerCustomEvent('DO_START_SECRET_TIMER', {boxId : boxId, others: true, messages: [{key:responseObject.messages[index].packetId, value: aBoxMessage}] })                    
                    doUpdateMessage = true;
                }

                if( doUpdateMessage ){
                  chatHistoryFactory.updateMessage(aBoxMessage, box.getKey());
                  box.sendTabUpdate(aBoxMessage);  
                }
                
            }

        }
      }

      //PACKET TYPE(18) : FRIEND_CHAT_SEEN_CONFIRMATION
      function onFriendChatSeenConfirmation(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(19) : FRIEND_CHAT_MULTIPLE_MSG_DELETE
      function onFriendChatMultipleMsgDelete(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            packets  = responseObject.packets,
            packetId = responseObject.packetId;
        
        /* method body */

        var boxId = ChatResponseProcessor.getFriendBoxId( userId, friendId );
        var box = ChatResponseProcessor.getFriendBox( boxId );

        for (var k = 0; k < packets.length; k++) {
            var msgKey = packets[k].packetId;
            var msgObj    = box.getMessage(msgKey);
            if(!!msgObj){

                if( userId != Auth.currentUser().getKey() ){
                    msgObj.text   = 'This message has been deleted';
                    msgObj.setTextPartition();
                    msgObj.status = 'Deleted';

                }else{
                    box.removeMessage(msgKey);
                }

                chatHistoryFactory.updateMessage(msgObj, box.getKey());
                box.sendTabUpdate(msgObj);
            }
        }

      }

      //PACKET TYPE(20) : FRIEND_CHAT_MSG_DELETE_CONFIRMATION
      function onFriendChatMsgDeleteConfirmation(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            packetId = responseObject.packetId;
        
        /* method body */
          var boxId = ChatResponseProcessor.getFriendBoxId( userId, friendId );
          var box = ChatResponseProcessor.getFriendBox( boxId );

      }

      //PACKET TYPE(24) : FRIEND_CHAT_BROKEN
      function onFriendChatBroken(responseObject){      
        var userId      = responseObject.userId,
            friendId    = responseObject.friendId,
            sequenceNo  = responseObject.sequenceNo,
            rawDataByte = responseObject.rawDataByte,
            packetId    = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(25) : FRIEND_CHAT_BROKEN_CONFIRMATION
      function onFriendChatBrokenConfirmation(responseObject){      
        var userId     = responseObject.userId,
            friendId   = responseObject.friendId,
            sequenceNo = responseObject.sequenceNo,
            packetId   = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(27) : FRIEND_CHAT_BLOCK
      function onFriendChatBlock(responseObject){      
        var userId           = responseObject.userId,
            friendId         = responseObject.friendId,
            blockUnblockDate = responseObject.blockUnblockDate,
            isAddToDb        = responseObject.isAddToDb,
            packetId         = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(28) : FRIEND_CHAT_UNBLOCK
      function onFriendChatUnblock(responseObject){      
        var userId           = responseObject.userId,
            friendId         = responseObject.friendId,
            blockUnblockDate = responseObject.blockUnblockDate,
            packetId         = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(29) : FRIEND_CHAT_BLOCK_UNBLOCK_CONFIRMATION
      function onFriendChatBlockUnblockConfirmation(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(41) : TAG_CHAT_TAG_REGISTER
      function onTagChatTagRegister(responseObject){      
        var userId   = responseObject.userId,
            tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(42) : TAG_CHAT_TAG_UNREGISTER
      function onTagChatTagUnregister(responseObject){      
        var userId       = responseObject.userId,
            tagId        = responseObject.tagId,
            onlineStatus = responseObject.onlineStatus,
            userMood     = responseObject.userMood,
            packetId     = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(43) : TAG_CHAT_TAG_REGISTER_CONFIRMATION
      function onTagChatTagRegisterConfirmation(responseObject){      
        var tagId           = responseObject.tagId,
            chatBindingPort = responseObject.chatBindingPort,
            serverDate      = responseObject.serverDate,
            packetId        = responseObject.packetId;
        
        /* method body */
        
        CHAT_GLOBAL_VALUES.serverTimeDiff = serverDate - Date.now();

        var box = ChatFactory.getBoxByUId(tagId);
        if(!box){
          box = ChatFactory.creatNonDomBox(tagId, true); 
        }
      
      }

      //PACKET TYPE(46) : TAG_CHAT_TAG_INFORMATION
      function onTagChatTagInformation(responseObject){      
        var userId        = responseObject.userId,
            tagId         = responseObject.tagId,
            activityType  = responseObject.activityType,
            tagName       = responseObject.tagName,
            tagPictureUrl = responseObject.tagPictureUrl,
            packetId      = responseObject.packetId;
        
        /* method body */
        ChatResponseProcessor.processTagInformation( responseObject );

      }

      //PACKET TYPE(47) : TAG_CHAT_TAG_INFORMATION_CONFIRMATION
      function onTagChatTagInformationConfirmation(responseObject){      
        var userId   = responseObject.userId,
            tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(51) : TAG_CHAT_TAG_MEMBER_ADD
      function onTagChatTagMemberAdd(responseObject){      
        var userId     = responseObject.userId,
            tagId      = responseObject.tagId,
            tagMembers = responseObject.tagMembers,
            packetId   = responseObject.packetId;
        
        /* method body */
        ChatResponseProcessor.processTagMemberAddUpdate( responseObject );

        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED);

        
      }

      //PACKET TYPE(52) : TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION
      function onTagChatTagMemberAddConfirmation(responseObject){      
        var userId   = responseObject.userId,
            tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(53) : TAG_CHAT_MEMBER_REMOVE_LEAVE
      function onTagChatMemberRemoveLeave( responseObject ){      
        var userId     = responseObject.userId,
            tagId      = responseObject.tagId,
            tagMembers = responseObject.tagMembers,
            packetId   = responseObject.packetId;
        
        /* method body */
        ChatResponseProcessor.processTagMemberRemoveLeave( responseObject );
        
        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED);

      }

      //PACKET TYPE(54) : TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION
      function onTagChatMemberRemoveLeaveConfirmation(responseObject){      
        var userId   = responseObject.userId,
            tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */
        if( userId === Auth.currentUser().getKey() ){
            ChatResponseProcessor.doTagUnregisterTask( tagId );
        }

        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED);

      }

      //PACKET TYPE(55) : TAG_CHAT_TAG_MEMBER_TYPE_CHANGE
      function onTagChatTagMemberTypeChange(responseObject){      
        var userId     = responseObject.userId,
            tagId      = responseObject.tagId,
            tagMembers = responseObject.tagMembers,
            packetId   = responseObject.packetId;
        
        /* method body */
        ChatResponseProcessor.processTagMemberStatusChange( responseObject );

        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED);

      }

      //PACKET TYPE(56) : TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION
      function onTagChatTagMemberTypeChangeConfirmation(responseObject){      
        var userId   = responseObject.userId,
            tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(61) : TAG_CHAT_IDLE
      function onTagChatIdle(responseObject){      
        var userId = responseObject.userId,
            tagId  = responseObject.tagId;
        
        /* method body */
        var box = ChatFactory.getBoxByUId(tagId);                                
        if(box) box.setFriendTypingBool(false); 

      }

      //PACKET TYPE(62) : TAG_CHAT_TYPING
      function onTagChatTyping(responseObject){      
        var userId = responseObject.userId,
            tagId  = responseObject.tagId;
        
        /* method body */

        var chatBox, tagObject;

        chatBox = ChatFactory.getBoxByUId(tagId);
        if( !!chatBox ){
            
            tagObject = tagChatFactory.getTag(tagId);
            
            if (!!tagObject) {

                chatBox.showTypingText(userId)

                setTimeout(function () {
                    chatBox.hideTypingText();
                    utilsFactory.triggerCustomEvent(SystemEvents.CHAT.BOX_UPDATED,{ boxId : tagId });

                }, 3000);                
            }
        }

      }

      //PACKET TYPE(63) : TAG_CHAT_MSG
      function onTagChatMsg(responseObject){      
        var userId      = responseObject.userId,
            tagId       = responseObject.tagId,
            messageType = responseObject.messageType,
            message     = responseObject.message,
            messageDate = responseObject.messageDate,
            packetId    = responseObject.packetId;
        
        /* method body */
        
        tagId = tagId.toString(); 

        if( !responseObject.fromHistory && chatHistoryFactory.isInLocalStorageChatMsgMap( tagId, packetId ) ){
            return;
        }
        
        var tagObject = tagChatFactory.getTag( tagId );

        if(!tagObject){
            
            var requestObject = ChatRequests.getOfflineGetTagInformationWithMembersObject( tagId );
            ChatConnector.send(requestObject);

            tagObject = tagChatFactory.getOrCreateTag(tagId);
        }

        var chatBox = ChatFactory.getBoxByUId(tagId);
        var scrollType;

        if( messageType === GENERAL_CONSTANTS.MESSAGE_TYPES.DELETE_MESSAGE ){

            ChatResponseProcessor.doOnMessageTypeDeleteMessage(boxId, userId, packetId, chatBox );

        }else if( messageType > GENERAL_CONSTANTS.MESSAGE_TYPES.BLANK_MESSAGE ){

            chatBox = tagChatManager.openTagChatBoxIfClosed( tagId, chatBox);
            
            if( !responseObject.fromHistory ){
                    scrollType = 'bottom'    
            }
            
            if( !responseObject.fromHistory || !responseObject.fromOffline){
                
                if( !!chatBox && !chatBox.isFocused ){
                    
                    responseObject.status = 'Unread';
                    scrollType = 'unread'

                }else{
                    
                    responseObject.status = responseObject.status || 'Received';
                }
            }

            responseObject.tag_chat = true;

            var tagId = chatBox.getKey();

            if ( !chatBox.isSamePacketId( packetId ) ) {

                responseObject.user = profileFactory.getUserObjectByUId( userId );

                if(!responseObject.fromHistory && !!tagObject && tagObject.isTagSafeToShow()){
                    if( !chatBox.nonDomBox ){
                      chatBox.nonDomBox = true;  
                      chatBox.loadHistoryMessages();
                      utilsFactory.triggerCustomEvent(SystemEvents.CHAT.BOX_OPENNED, {boxId : tagId });
                    }
                    
                }

                // var tagMessageModelObject = tagChatFactory.getOrCreateMessage( tagId, responseObject );
                // tagMessageModelObject.setStatus( status );

                if(responseObject.fromHistory){
                    responseObject.seenSent = true;
                }
                else{

                    if( responseObject.status == 'Unread'){
                        ChatFactory.increaseUnreadMessageCount( tagId, packetId );
                        chatBox.updateUnreadCount();
                    }
                }

                chatBox.pushMessage(responseObject, chatBox.getKey());

                chatHistoryFactory.updateBox(chatBox);

                if(!responseObject.fromHistory){
                  utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED, { boxId : tagId, scroll : scrollType } );
                }

            }

        }

      }

      //PACKET TYPE(64) : TAG_CHAT_MSG_EDIT
      function onTagChatMsgEdit(responseObject){      
        var userId      = responseObject.userId,
            tagId       = responseObject.tagId,
            messageType = responseObject.messageType,
            message     = responseObject.message,
            messageDate = responseObject.messageDate,
            packetId    = responseObject.packetId;
        
        /* method body */
        responseObject.status = 'Edited';
        onTagChatMsg( responseObject );

      }

      //PACKET TYPE(65) : TAG_CHAT_BROKEN_MSG
      function onTagChatBrokenMsg(responseObject){      
        var userId      = responseObject.userId,
            tagId       = responseObject.tagId,
            sequenceNo  = responseObject.sequenceNo,
            messageType = responseObject.messageType,
            message     = responseObject.message,
            messageDate = responseObject.messageDate,
            packetId    = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(66) : TAG_CHAT_BROKEN_MSG_EDIT
      function onTagChatBrokenMsgEdit(responseObject){      
        var userId      = responseObject.userId,
            tagId       = responseObject.tagId,
            sequenceNo  = responseObject.sequenceNo,
            messageType = responseObject.messageType,
            message     = responseObject.message,
            messageDate = responseObject.messageDate,
            packetId    = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(67) : TAG_CHAT_MULTIPLE_MSG
      function onTagChatMultipleMsg(responseObject){      
        var userId      = responseObject.userId,
            tagId       = responseObject.tagId,
            messageType = responseObject.messageType,
            message     = responseObject.message,
            messageDate = responseObject.messageDate,
            packetId    = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(68) : TAG_CHAT_DELIVERED
      function onTagChatDelivered(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */

        var chatBox = ChatResponseProcessor.getTagChatBox( tagId )

        var boxMessageObject = chatBox.getMessage( packetId);
        if (!!boxMessageObject) {

            if( boxMessageObject.status !== 'Seen' ){
                boxMessageObject.status = 'Delivered';
            }
            
            chatHistoryFactory.updateMessage(boxMessageObject, chatBox.getKey());
        }

        // if(!!tagObject){
        //     var tagMessageObject = tagObject.getMessage( packetId);
        //     if( !!tagMessageObject ){
        //         if( tagMessageObject.getStatus() !== 'Seen'){
        //             tagMessageObject.setStatus('Delivered');
        //         }

        //         //tagMessageObject.addDeliveredUserId( userId);
        //     }    
        // }
        

        chatHistoryFactory.updateBox(chatBox);

      }

      //PACKET TYPE(69) : TAG_CHAT_SENT
      function onTagChatSent(responseObject){      
        var tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */

        var chatBox = ChatResponseProcessor.getTagChatBox( tagId );

        var boxMessageObject = chatBox.updateMessageStatus( packetId, 'Sent');
        if (!!boxMessageObject) {
            chatHistoryFactory.updateMessage(boxMessageObject, chatBox.getKey());
        }

        // if(!!tagObject){
        //     var tagMessageObject = tagObject.getMessage( packetId );
        //     if (!!tagMessageObject) {
        //         tagMessageObject.setStatus('Sent');
        //     }    
        // }
            
        chatHistoryFactory.updateBox(chatBox);

      }

      //PACKET TYPE(70) : TAG_CHAT_SEEN
      function onTagChatSeen(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */
    
        var chatBox = ChatResponseProcessor.getTagChatBox( tagId );

        var boxMessageObject = chatBox.updateMessageStatus( packetId, 'Seen');
        if (!!boxMessageObject) {
            chatHistoryFactory.updateMessage(boxMessageObject, chatBox.getKey());
        }

        // if( !!tagObject){
        //     var tagMessageObject = tagObject.getMessage( packetId );
        //     if (!!tagMessageObject) {
        //         tagMessageObject.setStatus('Seen');
        //     }    
        // }        

        chatHistoryFactory.updateBox(chatBox);

      }

      //PACKET TYPE(71) : TAG_CHAT_SEEN_CONFIRMATION
      function onTagChatSeenConfirmation(responseObject){      
        var tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(72) : TAG_CHAT_MULTIPLE_MSG_DELETE
      function onTagChatMultipleMsgDelete(responseObject){      
        var userId   = responseObject.userId,
            tagId    = responseObject.tagId,
            packets  = responseObject.packets,
            packetId = responseObject.packetId;
        
        /* method body */
        if( !angular.isArray( packets ) ){
            return;
        }

        var chatBox = ChatResponseProcessor.getTagChatBox( tagId );

        for(var index = 0 ; index < packets.length; index++){                
            ChatResponseProcessor.doOnMessageTypeDeleteMessage( tagId, userId, packets[index].packetId, chatBox )
        }

      }

      //PACKET TYPE(73) : TAG_CHAT_MSG_DELETE_CONFIRMATION
      function onTagChatMsgDeleteConfirmation(responseObject){      
        var userId   = responseObject.userId,
            tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */
        // var deleteRequestObject = REQUSET_CACHE.getChatCache(packetId, { packetType : PACKET_TYPES.TAG_CHAT_MULTIPLE_MSG_DELETE })
        // if(!!deleteRequestObject){
        //   var chatBox = ChatResponseProcessor.getTagChatBox( tagId );
        //   for(var index = 0 ; index < deleteRequestObject.packets.length; index++){                
        //       ChatResponseProcessor.doOnMessageTypeDeleteMessage( tagId, userId, packets[index].packetId, chatBox )
        //   }
        // }
      }

      //PACKET TYPE(74) : TAG_CHAT_GENERAL_BROKEN_PACKET
      function onTagChatGeneralBrokenPacket(responseObject){      
        var userId      = responseObject.userId,
            tagId       = responseObject.tagId,
            sequenceNo  = responseObject.sequenceNo,
            rawDataByte = responseObject.rawDataByte,
            packetId    = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(75) : TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION
      function onTagChatGeneralBrokenPacketConfirmation(responseObject){      
        var userId     = responseObject.userId,
            tagId      = responseObject.tagId,
            sequenceNo = responseObject.sequenceNo,
            packetId   = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(91) : OFFLINE_FRIEND_INFORMATION
      function onOfflineFriendInformation(responseObject){      
        var userId            = responseObject.userId,
            friendId          = responseObject.friendId,
            fullName          = responseObject.fullName,
            onlineStatus      = responseObject.onlineStatus,
            friendAppType     = responseObject.friendAppType,
            friendDeviceToken = responseObject.friendDeviceToken,
            userMood          = responseObject.userMood,
            packetId          = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(92) : OFFLINE_FRIEND_INFORMATION_CONFIRMATION
      function onOfflineFriendInformationConfirmation(responseObject){      
        var friendId = responseObject.friendId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(93) : OFFLINE_GET_REQUEST
      function onOfflineGetRequest(responseObject){      
        var userId           = responseObject.userId,
            updateTime       = responseObject.updateTime,
            blockUnblockDate = responseObject.blockUnblockDate,
            packetId         = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(94) : OFFLINE_GET_REQUEST_CONFIRMATION
      function onOfflineGetRequestConfirmation(responseObject){      
        var serverDate = responseObject.serverDate,
            packetId   = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(95) : OFFLINE_FRIEND_UNREAD_MESSAGE
      function onOfflineFriendUnreadMessage(responseObject){      
        var messages = responseObject.messages,
            packetId = responseObject.packetId;
        
        /* method body */
        var boxIds = {};            

        for(var index = 0; index < messages.length; index++){
            var anUnreadMessage = messages[index];

            if( anUnreadMessage.messageType != GENERAL_CONSTANTS.MESSAGE_TYPES.DELETED ){
              
              anUnreadMessage.fromOffline = true;
              anUnreadMessage.status = 'Unread';
              onFriendChatMsg(anUnreadMessage);
              boxIds[anUnreadMessage.userId] = true;              

            }else{

            }            
        }

        var boxIdList = Object.keys(boxIds);
        boxIdList.forEach(function( aBoxId ){
          utilsFactory.triggerCustomEvent('NEW_MESSAGE_PUSHED', { boxId : aBoxId });
        });

      }

      //PACKET TYPE(96) : OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION
      function onOfflineFriendUnreadMessageConfirmation(responseObject){      
        var userId   = responseObject.userId,
            packets  = responseObject.packets,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(97) : OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST
      function onOfflineFriendHistoryMessageRequest(responseObject){      
        var userId        = responseObject.userId,
            friendId      = responseObject.friendId,
            pageDirection = responseObject.pageDirection,
            pageLimit     = responseObject.pageLimit,
            packetId      = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(98) : OFFLINE_FRIEND_HISTORY_MESSAGE
      function onOfflineFriendHistoryMessage(responseObject){      
        var friendId      = responseObject.friendId,
            messages      = responseObject.messages,
            pageDirection = responseObject.pageDirection,
            packetId      = responseObject.packetId;
        
        /* method body */
        var currentUserId = Auth.currentUser().getKey();
        var packetIds = [];

        var chatBox = ChatFactory.getBoxByUId( friendId );
        if( !chatBox ){
            chatBox = ChatFactory.creatNonDomBox( friendId );
        }

        if(!messages.length && pageDirection != GENERAL_CONSTANTS.PAGE_DIRECTION.DOWN){
            chatBox.hasHistoryMessage = false;

        }else{
              
            var processed = false, hasMoreMessage = false;

            // if( messages.length > GENERAL_CONSTANTS.HISTORY_MAX_MESSAGE ){
            //   chatBox.hasHistoryMessage = true;  
            //   hasMoreMessage = true;

            // }
            
            // messages.splice(GENERAL_CONSTANTS.HISTORY_MAX_MESSAGE);

            

            for(var index = 0; index < messages.length; index++){
                var aHistoryMessage = messages[index];

                if(aHistoryMessage.messageType != GENERAL_CONSTANTS.MESSAGE_TYPES.HISTORY_RE_FETCH 
                  && aHistoryMessage.messageType != GENERAL_CONSTANTS.MESSAGE_TYPES.DELETE_MESSAGE )
                {      
                    processed = true;

                    if( aHistoryMessage.userId.toString() == currentUserId ){

                        aHistoryMessage.status = ChatResponseProcessor.getMessageStatus( aHistoryMessage.status ) || 'Delivered';

                        aHistoryMessage.friendId = friendId;

                    }else{

                        if( pageDirection ==  GENERAL_CONSTANTS.PAGE_DIRECTION.UP){
                            aHistoryMessage.status = 'Received';

                        }else{

                          if( aHistoryMessage.status < GENERAL_CONSTANTS.MESSAGE_STATUS.SEEN ){
                            aHistoryMessage.status = 'Unread';
                          }
                          
                        }

                        aHistoryMessage.friendId = currentUserId;
                    }

                    aHistoryMessage.boxId = friendId;
                    aHistoryMessage.fromOffline = true;
                    aHistoryMessage.fromHistory = true;

                    onFriendChatMsg( aHistoryMessage );

                }

                packetIds.push(aHistoryMessage.packetId);

            }

            if( processed ) {
                chatBox.hasHistoryMessage = true;
                utilsFactory.triggerCustomEvent('NEW_MESSAGE_PUSHED', {boxId: friendId, noScroll : true})
            }
        }

      }

      //PACKET TYPE(99) : OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION
      function onOfflineFriendHistoryMessageConfirmation(responseObject){      
        var friendId = responseObject.friendId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(100) : OFFLINE_GET_FRIEND_MESSAGE_STATUS
      function onOfflineGetFriendMessageStatus(responseObject){      
        var userId   = responseObject.userId,
            friendId = responseObject.friendId,
            packets  = responseObject.packets,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(101) : OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION
      function onOfflineGetFriendMessageStatusConfirmation(responseObject){      
        var friendId = responseObject.friendId,
            packets  = responseObject.packets,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(104) : OFFLINE_TAG_INFORMATION_ACTIVITY
      function onOfflineTagInformationActivity(responseObject){      
        var tagId     = responseObject.tagId,
            noOfItems = responseObject.noOfItems,
            items     = responseObject.items,
            packetId  = responseObject.packetId;
        
        /* method body */
        
        items.forEach(function(anItem){
          ChatResponseProcessor.processAGroupActivity(tagId, packetId, anItem);  
        });
        
      }

      //PACKET TYPE(105) : OFFLINE_MY_TAG_LIST
      function onOfflineMyTagList(responseObject){      
        var noOfItems = responseObject.noOfItems,
            items     = responseObject.items,
            packetId  = responseObject.packetId;
        
        /* method body */

        var aTagObject;

        for(var index = 0; index < responseObject.items.length; index++){
            aTagObject = tagChatFactory.createNewTag(responseObject.items[index]);
            tagChatFactory.addTagObject(aTagObject);
        }

        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MY_TAG_LIST_RECEIVED);

      }

      //PACKET TYPE(106) : OFFLINE_TAG_UNREAD_MESSAGE
      function onOfflineTagUnreadMessage(responseObject){      
        var messages = responseObject.messages,
            packetId = responseObject.packetId;
        
        /* method body */

        for(var index = 0; index < responseObject.messages.length; index++){
            var anUnreadMessage = responseObject.messages[index];
            anUnreadMessage.status = 'Unread';
            anUnreadMessage.fromUnread = true;
            anUnreadMessage.fromOffline = true;

            if( anUnreadMessage.messageType == GENERAL_CONSTANTS.MESSAGE_TYPES.GROUP_ACTIVITY){
                ChatResponseProcessor.processGroupActivityMessage( anUnreadMessage );
            }else{
                onTagChatMsg( anUnreadMessage );
            }  

        }

      }

      //PACKET TYPE(107) : OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION
      function onOfflineTagUnreadMessageConfirmation(responseObject){      
        var userId   = responseObject.userId,
            packets  = responseObject.packets,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(108) : OFFLINE_TAG_CREATE_TAG
      function onOfflineTagCreateTag(responseObject){      
        var userId        = responseObject.userId,
            tagId         = responseObject.tagId,
            tagName       = responseObject.tagName,
            tagPictureUrl = responseObject.tagPictureUrl,
            tagMembers    = responseObject.tagMembers,
            packetId      = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(109) : OFFLINE_TAG_CREATE_TAG_CONFIRMATION
      function onOfflineTagCreateTagConfirmation(responseObject){      
        var tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(110) : OFFLINE_TAG_HISTORY_MESSAGE_REQUEST
      function onOfflineTagHistoryMessageRequest(responseObject){      
        var userId        = responseObject.userId,
            tagId         = responseObject.tagId,
            pageDirection = responseObject.pageDirection,
            pageLimit     = responseObject.pageLimit,
            packetId      = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(111) : OFFLINE_TAG_HISTORY_MESSAGE
      function onOfflineTagHistoryMessage(responseObject){      
        var tagId         = responseObject.tagId,
            messages      = responseObject.messages,
            pageDirection = responseObject.pageDirection,
            packetId      = responseObject.packetId;
        
        /* method body */

        var chatBox = ChatResponseProcessor.getTagChatBox( tagId );

        if(!messages.length && pageDirection != GENERAL_CONSTANTS.PAGE_DIRECTION.DOWN){

            chatBox.hasHistoryMessage = false;

        }else{
  
            var processed, hasMoreMessage = false;

            // if( messages.length > GENERAL_CONSTANTS.HISTORY_MAX_MESSAGE ){
            //   chatBox.hasHistoryMessage = true;  
            //   hasMoreMessage = true;
            // }
            
            // messages.splice(GENERAL_CONSTANTS.HISTORY_MAX_MESSAGE);


            for(var index = 0; index < messages.length; index++){
                var aHistoryMessage = messages[index];
                aHistoryMessage.tagId = tagId;
                aHistoryMessage.fromHistory = true;
                aHistoryMessage.fromOffline = true;

                if( aHistoryMessage.messageType == GENERAL_CONSTANTS.MESSAGE_TYPES.GROUP_ACTIVITY){
                    
                    processed = true;
                    ChatResponseProcessor.processGroupActivityMessage(aHistoryMessage);

                }else if( aHistoryMessage.messageType != GENERAL_CONSTANTS.MESSAGE_TYPES.DELETE_MESSAGE ) {
                    
                    processed = true;
                    if (aHistoryMessage.userId === Auth.currentUser().getKey() ) {
                        aHistoryMessage.status = 'Seen';
                    } else {
                      
                      aHistoryMessage.status = 'Received';
                     
                    }

                    onTagChatMsg( aHistoryMessage );

                }
            }

            if( processed ){

                chatBox.hasHistoryMessage = true;
                utilsFactory.triggerCustomEvent('NEW_MESSAGE_PUSHED', { boxId : tagId, noScroll: true});
            }

        }

      }

      //PACKET TYPE(112) : OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS
      function onOfflineGetTagInformationWithMembers(responseObject){      
        var userId   = responseObject.userId,
            tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(113) : OFFLINE_TAG_INFORMATION_WITH_MEMBERS
      function onOfflineTagInformationWithMembers(responseObject){      
        var tagId         = responseObject.tagId,
            tagName       = responseObject.tagName,
            tagPictureUrl = responseObject.tagPictureUrl,
            tagMembers    = responseObject.tagMembers,
            packetId      = responseObject.packetId;
        
        /* method body */

        
        var tagObject = tagChatFactory.getOrCreateTag(tagId, responseObject);
        ChatResponseProcessor.addMembersToTagObject(tagObject, responseObject.tagMembers);
 
        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED);

      }

      //PACKET TYPE(117) : OFFLINE_TAG_CONFIRMATION
      function onOfflineTagConfirmation(responseObject){      
        var tagId    = responseObject.tagId,
            packetId = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(118) : OFFLINE_BROKEN_HISTORY_PACKET
      function onOfflineBrokenHistoryPacket(responseObject){      
        var sequenceNo  = responseObject.sequenceNo,
            rawDataByte = responseObject.rawDataByte,
            packetId    = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(119) : OFFLINE_BROKEN_PACKET
      function onOfflineBrokenPacket(responseObject){      
        var sequenceNo  = responseObject.sequenceNo,
            rawDataByte = responseObject.rawDataByte,
            userId      = responseObject.userId,
            packetId    = responseObject.packetId;
        
        /* method body */

      }

      //PACKET TYPE(120) : OFFLINE_BROKEN_PACKET_CONFIRMATION
      function onOfflineBrokenPacketConfirmation(responseObject){      
        var userId     = responseObject.userId,
            sequenceNo = responseObject.sequenceNo,
            packetId   = responseObject.packetId;
        
        /* method body */

      }

      
      //PACKET TYPE(1) : FRIEND_CHAT_REGISTER
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_REGISTER]                           = {
          processor : onFriendChatRegister
      };

      //PACKET TYPE(2) : FRIEND_CHAT_UNREGISTER
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_UNREGISTER]                         = {
          processor : onFriendChatUnregister
      };

      //PACKET TYPE(3) : FRIEND_CHAT_REGISTER_CONFIRMATION
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_REGISTER_CONFIRMATION]              = {
          processor : onFriendChatRegisterConfirmation
      };

      //PACKET TYPE(4) : FRIEND_CHAT_IDLE
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_IDLE]                               = {
          processor : onFriendChatIdle
      };

      //PACKET TYPE(5) : FRIEND_CHAT_TYPING
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_TYPING]                             = {
          processor : onFriendChatTyping
      };

      //PACKET TYPE(6) : FRIEND_CHAT_MSG
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_MSG]                                = {
          processor : onFriendChatMsg
      };

      //PACKET TYPE(7) : FRIEND_CHAT_MSG_EDIT
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_MSG_EDIT]                           = {
          processor : onFriendChatMsgEdit
      };

      //PACKET TYPE(8) : FRIEND_CHAT_BROKEN_MSG
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_BROKEN_MSG]                         = {
          processor : onFriendChatBrokenMsg
      };

      //PACKET TYPE(9) : FRIEND_CHAT_BROKEN_MSG_EDIT
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_BROKEN_MSG_EDIT]                    = {
          processor : onFriendChatBrokenMsgEdit
      };

      //PACKET TYPE(10) : FRIEND_CHAT_MULTIPLE_MSG
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_MULTIPLE_MSG]                       = {
          processor : onFriendChatMultipleMsg
      };

      //PACKET TYPE(15) : FRIEND_CHAT_DELIVERED
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_DELIVERED]                          = {
          processor : onFriendChatDelivered
      };

      //PACKET TYPE(16) : FRIEND_CHAT_SENT
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_SENT]                               = {
          processor : onFriendChatSent
      };

      //PACKET TYPE(17) : FRIEND_CHAT_SEEN
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_SEEN]                               = {
          processor : onFriendChatSeen
      };

      //PACKET TYPE(18) : FRIEND_CHAT_SEEN_CONFIRMATION
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_SEEN_CONFIRMATION]                  = {
          processor : onFriendChatSeenConfirmation
      };

      //PACKET TYPE(19) : FRIEND_CHAT_MULTIPLE_MSG_DELETE
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_MULTIPLE_MSG_DELETE]                = {
          processor : onFriendChatMultipleMsgDelete
      };

      //PACKET TYPE(20) : FRIEND_CHAT_MSG_DELETE_CONFIRMATION
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_MSG_DELETE_CONFIRMATION]            = {
          processor : onFriendChatMsgDeleteConfirmation
      };

      //PACKET TYPE(24) : FRIEND_CHAT_BROKEN
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_BROKEN]                             = {
          processor : onFriendChatBroken
      };

      //PACKET TYPE(25) : FRIEND_CHAT_BROKEN_CONFIRMATION
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_BROKEN_CONFIRMATION]                = {
          processor : onFriendChatBrokenConfirmation
      };

      //PACKET TYPE(27) : FRIEND_CHAT_BLOCK
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_BLOCK]                              = {
          processor : onFriendChatBlock
      };

      //PACKET TYPE(28) : FRIEND_CHAT_UNBLOCK
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_UNBLOCK]                            = {
          processor : onFriendChatUnblock
      };

      //PACKET TYPE(29) : FRIEND_CHAT_BLOCK_UNBLOCK_CONFIRMATION
      responseMethodMap[PACKET_TYPES.FRIEND_CHAT_BLOCK_UNBLOCK_CONFIRMATION]         = {
          processor : onFriendChatBlockUnblockConfirmation
      };

      //PACKET TYPE(41) : TAG_CHAT_TAG_REGISTER
      responseMethodMap[PACKET_TYPES.TAG_CHAT_TAG_REGISTER]                          = {
          processor : onTagChatTagRegister
      };

      //PACKET TYPE(42) : TAG_CHAT_TAG_UNREGISTER
      responseMethodMap[PACKET_TYPES.TAG_CHAT_TAG_UNREGISTER]                        = {
          processor : onTagChatTagUnregister
      };

      //PACKET TYPE(43) : TAG_CHAT_TAG_REGISTER_CONFIRMATION
      responseMethodMap[PACKET_TYPES.TAG_CHAT_TAG_REGISTER_CONFIRMATION]             = {
          processor : onTagChatTagRegisterConfirmation
      };

      //PACKET TYPE(46) : TAG_CHAT_TAG_INFORMATION
      responseMethodMap[PACKET_TYPES.TAG_CHAT_TAG_INFORMATION]                       = {
          processor : onTagChatTagInformation
      };

      //PACKET TYPE(47) : TAG_CHAT_TAG_INFORMATION_CONFIRMATION
      responseMethodMap[PACKET_TYPES.TAG_CHAT_TAG_INFORMATION_CONFIRMATION]          = {
          processor : onTagChatTagInformationConfirmation
      };

      //PACKET TYPE(51) : TAG_CHAT_TAG_MEMBER_ADD
      responseMethodMap[PACKET_TYPES.TAG_CHAT_TAG_MEMBER_ADD]                        = {
          processor : onTagChatTagMemberAdd
      };

      //PACKET TYPE(52) : TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION
      responseMethodMap[PACKET_TYPES.TAG_CHAT_TAG_MEMBER_ADD_CONFIRMATION]           = {
          processor : onTagChatTagMemberAddConfirmation
      };

      //PACKET TYPE(53) : TAG_CHAT_MEMBER_REMOVE_LEAVE
      responseMethodMap[PACKET_TYPES.TAG_CHAT_MEMBER_REMOVE_LEAVE]                   = {
          processor : onTagChatMemberRemoveLeave
      };

      //PACKET TYPE(54) : TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION
      responseMethodMap[PACKET_TYPES.TAG_CHAT_MEMBER_REMOVE_LEAVE_CONFIRMATION]      = {
          processor : onTagChatMemberRemoveLeaveConfirmation
      };

      //PACKET TYPE(55) : TAG_CHAT_TAG_MEMBER_TYPE_CHANGE
      responseMethodMap[PACKET_TYPES.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE]                = {
          processor : onTagChatTagMemberTypeChange
      };

      //PACKET TYPE(56) : TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION
      responseMethodMap[PACKET_TYPES.TAG_CHAT_TAG_MEMBER_TYPE_CHANGE_CONFIRMATION]   = {
          processor : onTagChatTagMemberTypeChangeConfirmation
      };

      //PACKET TYPE(61) : TAG_CHAT_IDLE
      responseMethodMap[PACKET_TYPES.TAG_CHAT_IDLE]                                  = {
          processor : onTagChatIdle
      };

      //PACKET TYPE(62) : TAG_CHAT_TYPING
      responseMethodMap[PACKET_TYPES.TAG_CHAT_TYPING]                                = {
          processor : onTagChatTyping
      };

      //PACKET TYPE(63) : TAG_CHAT_MSG
      responseMethodMap[PACKET_TYPES.TAG_CHAT_MSG]                                   = {
          processor : onTagChatMsg
      };

      //PACKET TYPE(64) : TAG_CHAT_MSG_EDIT
      responseMethodMap[PACKET_TYPES.TAG_CHAT_MSG_EDIT]                              = {
          processor : onTagChatMsgEdit
      };

      //PACKET TYPE(65) : TAG_CHAT_BROKEN_MSG
      responseMethodMap[PACKET_TYPES.TAG_CHAT_BROKEN_MSG]                            = {
          processor : onTagChatBrokenMsg
      };

      //PACKET TYPE(66) : TAG_CHAT_BROKEN_MSG_EDIT
      responseMethodMap[PACKET_TYPES.TAG_CHAT_BROKEN_MSG_EDIT]                       = {
          processor : onTagChatBrokenMsgEdit
      };

      //PACKET TYPE(67) : TAG_CHAT_MULTIPLE_MSG
      responseMethodMap[PACKET_TYPES.TAG_CHAT_MULTIPLE_MSG]                          = {
          processor : onTagChatMultipleMsg
      };

      //PACKET TYPE(68) : TAG_CHAT_DELIVERED
      responseMethodMap[PACKET_TYPES.TAG_CHAT_DELIVERED]                             = {
          processor : onTagChatDelivered
      };

      //PACKET TYPE(69) : TAG_CHAT_SENT
      responseMethodMap[PACKET_TYPES.TAG_CHAT_SENT]                                  = {
          processor : onTagChatSent
      };

      //PACKET TYPE(70) : TAG_CHAT_SEEN
      responseMethodMap[PACKET_TYPES.TAG_CHAT_SEEN]                                  = {
          processor : onTagChatSeen
      };

      //PACKET TYPE(71) : TAG_CHAT_SEEN_CONFIRMATION
      responseMethodMap[PACKET_TYPES.TAG_CHAT_SEEN_CONFIRMATION]                     = {
          processor : onTagChatSeenConfirmation
      };

      //PACKET TYPE(72) : TAG_CHAT_MULTIPLE_MSG_DELETE
      responseMethodMap[PACKET_TYPES.TAG_CHAT_MULTIPLE_MSG_DELETE]                   = {
          processor : onTagChatMultipleMsgDelete
      };

      //PACKET TYPE(73) : TAG_CHAT_MSG_DELETE_CONFIRMATION
      responseMethodMap[PACKET_TYPES.TAG_CHAT_MSG_DELETE_CONFIRMATION]               = {
          processor : onTagChatMsgDeleteConfirmation
      };

      //PACKET TYPE(74) : TAG_CHAT_GENERAL_BROKEN_PACKET
      responseMethodMap[PACKET_TYPES.TAG_CHAT_GENERAL_BROKEN_PACKET]                 = {
          processor : onTagChatGeneralBrokenPacket
      };

      //PACKET TYPE(75) : TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION
      responseMethodMap[PACKET_TYPES.TAG_CHAT_GENERAL_BROKEN_PACKET_CONFIRMATION]    = {
          processor : onTagChatGeneralBrokenPacketConfirmation
      };

      //PACKET TYPE(91) : OFFLINE_FRIEND_INFORMATION
      responseMethodMap[PACKET_TYPES.OFFLINE_FRIEND_INFORMATION]                     = {
          processor : onOfflineFriendInformation
      };

      //PACKET TYPE(92) : OFFLINE_FRIEND_INFORMATION_CONFIRMATION
      responseMethodMap[PACKET_TYPES.OFFLINE_FRIEND_INFORMATION_CONFIRMATION]        = {
          processor : onOfflineFriendInformationConfirmation
      };

      //PACKET TYPE(93) : OFFLINE_GET_REQUEST
      responseMethodMap[PACKET_TYPES.OFFLINE_GET_REQUEST]                            = {
          processor : onOfflineGetRequest
      };

      //PACKET TYPE(94) : OFFLINE_GET_REQUEST_CONFIRMATION
      responseMethodMap[PACKET_TYPES.OFFLINE_GET_REQUEST_CONFIRMATION]               = {
          processor : onOfflineGetRequestConfirmation
      };

      //PACKET TYPE(95) : OFFLINE_FRIEND_UNREAD_MESSAGE
      responseMethodMap[PACKET_TYPES.OFFLINE_FRIEND_UNREAD_MESSAGE]                  = {
          processor : onOfflineFriendUnreadMessage
      };

      //PACKET TYPE(96) : OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION
      responseMethodMap[PACKET_TYPES.OFFLINE_FRIEND_UNREAD_MESSAGE_CONFIRMATION]     = {
          processor : onOfflineFriendUnreadMessageConfirmation
      };

      //PACKET TYPE(97) : OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST
      responseMethodMap[PACKET_TYPES.OFFLINE_FRIEND_HISTORY_MESSAGE_REQUEST]         = {
          processor : onOfflineFriendHistoryMessageRequest
      };

      //PACKET TYPE(98) : OFFLINE_FRIEND_HISTORY_MESSAGE
      responseMethodMap[PACKET_TYPES.OFFLINE_FRIEND_HISTORY_MESSAGE]                 = {
          processor : onOfflineFriendHistoryMessage
      };

      //PACKET TYPE(99) : OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION
      responseMethodMap[PACKET_TYPES.OFFLINE_FRIEND_HISTORY_MESSAGE_CONFIRMATION]    = {
          processor : onOfflineFriendHistoryMessageConfirmation
      };

      //PACKET TYPE(100) : OFFLINE_GET_FRIEND_MESSAGE_STATUS
      responseMethodMap[PACKET_TYPES.OFFLINE_GET_FRIEND_MESSAGE_STATUS]              = {
          processor : onOfflineGetFriendMessageStatus
      };

      //PACKET TYPE(101) : OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION
      responseMethodMap[PACKET_TYPES.OFFLINE_GET_FRIEND_MESSAGE_STATUS_CONFIRMATION] = {
          processor : onOfflineGetFriendMessageStatusConfirmation
      };

      //PACKET TYPE(104) : OFFLINE_TAG_INFORMATION_ACTIVITY
      responseMethodMap[PACKET_TYPES.OFFLINE_TAG_INFORMATION_ACTIVITY]               = {
          processor : onOfflineTagInformationActivity
      };

      //PACKET TYPE(105) : OFFLINE_MY_TAG_LIST
      responseMethodMap[PACKET_TYPES.OFFLINE_MY_TAG_LIST]                            = {
          processor : onOfflineMyTagList
      };

      //PACKET TYPE(106) : OFFLINE_TAG_UNREAD_MESSAGE
      responseMethodMap[PACKET_TYPES.OFFLINE_TAG_UNREAD_MESSAGE]                     = {
          processor : onOfflineTagUnreadMessage
      };

      //PACKET TYPE(107) : OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION
      responseMethodMap[PACKET_TYPES.OFFLINE_TAG_UNREAD_MESSAGE_CONFIRMATION]        = {
          processor : onOfflineTagUnreadMessageConfirmation
      };

      //PACKET TYPE(108) : OFFLINE_TAG_CREATE_TAG
      responseMethodMap[PACKET_TYPES.OFFLINE_TAG_CREATE_TAG]                         = {
          processor : onOfflineTagCreateTag
      };

      //PACKET TYPE(109) : OFFLINE_TAG_CREATE_TAG_CONFIRMATION
      responseMethodMap[PACKET_TYPES.OFFLINE_TAG_CREATE_TAG_CONFIRMATION]            = {
          processor : onOfflineTagCreateTagConfirmation
      };

      //PACKET TYPE(110) : OFFLINE_TAG_HISTORY_MESSAGE_REQUEST
      responseMethodMap[PACKET_TYPES.OFFLINE_TAG_HISTORY_MESSAGE_REQUEST]            = {
          processor : onOfflineTagHistoryMessageRequest
      };

      //PACKET TYPE(111) : OFFLINE_TAG_HISTORY_MESSAGE
      responseMethodMap[PACKET_TYPES.OFFLINE_TAG_HISTORY_MESSAGE]                    = {
          processor : onOfflineTagHistoryMessage
      };

      //PACKET TYPE(112) : OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS
      responseMethodMap[PACKET_TYPES.OFFLINE_GET_TAG_INFORMATION_WITH_MEMBERS]       = {
          processor : onOfflineGetTagInformationWithMembers
      };

      //PACKET TYPE(113) : OFFLINE_TAG_INFORMATION_WITH_MEMBERS
      responseMethodMap[PACKET_TYPES.OFFLINE_TAG_INFORMATION_WITH_MEMBERS]           = {
          processor : onOfflineTagInformationWithMembers
      };

      //PACKET TYPE(117) : OFFLINE_TAG_CONFIRMATION
      responseMethodMap[PACKET_TYPES.OFFLINE_TAG_CONFIRMATION]                       = {
          processor : onOfflineTagConfirmation
      };

      //PACKET TYPE(118) : OFFLINE_BROKEN_HISTORY_PACKET
      responseMethodMap[PACKET_TYPES.OFFLINE_BROKEN_HISTORY_PACKET]                  = {
          processor : onOfflineBrokenHistoryPacket
      };

      //PACKET TYPE(119) : OFFLINE_BROKEN_PACKET
      responseMethodMap[PACKET_TYPES.OFFLINE_BROKEN_PACKET]                          = {
          processor : onOfflineBrokenPacket
      };

      //PACKET TYPE(120) : OFFLINE_BROKEN_PACKET_CONFIRMATION
      responseMethodMap[PACKET_TYPES.OFFLINE_BROKEN_PACKET_CONFIRMATION]             = {
          processor : onOfflineBrokenPacketConfirmation
      };


      return {
          processUpdates : processUpdates
      }
   
    }
    
})(window);

 

(function(global){
    'use strict';

    var chatApp;
    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}

    chatApp.factory('ChatAuthResponses', ChatAuthResponses);

    ChatAuthResponses.$inject = ['$rootScope', 'tagChatFactory', 'ChatFactory',
     'ChatPacketSenderService', 'userFactory', 'friendsFactory', 'chatRequestProcessor',
     'chatHistoryFactory', 'ChatWorkerCommands', 'Auth', 'ChatConnector'];

    function ChatAuthResponses($rootScope, tagChatFactory, ChatFactory, 
    	ChatPacketSenderService, userFactory, friendsFactory, chatRequestProcessor,
    	chatHistoryFactory, ChatWorkerCommands, Auth, ChatConnector) {

		var Constants 		      = CHAT_APP.Constants;
		var SESSION_TYPES 	      = Constants.GENERAL_CONSTANTS.SESSION_TYPES;
		var RESPONSE_REASON_CODES = Constants.RESPONSE_REASON_CODES;
		var AUTH_SERVER_ACTIONS   = CHAT_APP.Constants.AUTH_SERVER_ACTIONS;
		var USER_PRESENCE         = Constants.GENERAL_CONSTANTS.USER_PRESENCE;

		var ChatRequests 		  = CHAT_APP.ChatRequests;

    	var _getBox = function(friendId){
            var box = ChatFactory.getBoxByUId(friendId);

            if(!box){
                box = ChatFactory.creatNonDomBox(friendId, false);
                box.loadHistoryMessages();
            }

            return box;
        };

        var responseMethodMap = {};    
    
	    function getPacketProcessorInfo(packetType){
	        return responseMethodMap[packetType];
	    }

      	
		function processUpdates(responseObject) {

			if( responseObject.rc == 1111 ){
                return;
            }	

		    var actionId = responseObject.actn;

		    var packetProcessorInfo = getPacketProcessorInfo(actionId);

		    if( !packetProcessorInfo ){
		        return false;
		    }

		    try{
		       packetProcessorInfo.processor.call(this, responseObject);
		    }catch(e){
		    }

		    return true;

		}

    
		//PACKET TYPE(334) : RECEIVED_TAG_CHAT
		function onReceivedTagChat(responseObject){
			 /* method body */

			var boxId = responseObject.tid;

			var tagObject = tagChatFactory.getTag(boxId);
			
            if( !tagObject ){

				var openedBox = ChatFactory.getBoxByUId(boxId);
				if( !openedBox){
					openedBox = ChatFactory.creatNonDomBox(boxId, true);
				}				

				var requestObject = ChatRequests.getOfflineGetTagInformationWithMembersObject( boxId );
				ChatConnector.request(requestObject).then(function(response){				
					if( response.sucs ){
						var tagObject = tagChatFactory.getTag(boxId);
                        if( !!tagObject){ 
                    	    ChatWorkerCommands.startChatSession(boxId, SESSION_TYPES.TAG, tagObject.getMemberUserIds())
                        }
					}
				});

			}else{
				
				tagObject = tagChatFactory.getOrCreateTag(boxId);
				ChatWorkerCommands.startChatSession(boxId, SESSION_TYPES.TAG)				
			}



		}

		//PACKET TYPE(335) : TAG_CHAT_UPDATE_ADD_MEMBER
		function onReceivedTagMemeberAdd(responseObject){
			 /* method body */			

			var tagId = responseObject.tid;
			var boxId = tagId;
		
			var tagObject = tagChatFactory.getTag(tagId);

			if( !tagObject ){

				var openedBox = ChatFactory.getBoxByUId(tagId);
				if( !openedBox){
					openedBox = ChatFactory.creatNonDomBox(tagId, true);
				}

				var requestObject = ChatRequests.getOfflineGetTagInformationWithMembersObject( tagId );
				ChatConnector.request(requestObject, 10).then(function(response){				
					if( response.sucs ){
						var tagObject = tagChatFactory.getTag(tagId);
                    	ChatWorkerCommands.startChatSession(boxId, SESSION_TYPES.TAG, tagObject.getMemberUserIds())
					}
				});

			}else{

				tagObject = tagChatFactory.getOrCreateTag(tagId);
				ChatWorkerCommands.startChatSession(tagId, SESSION_TYPES.TAG)				

				if( !!responseObject.uIds ){
					angular.forEach(responseObject.uIds, function(aMessageUId){

						tagObject.addMember(tagChatFactory.createNewTagMember(tagObject.getTagId(),
							{ userId : aMessageUId }, true
						));
					});

				}else{
				}
			}

		}

		//PACKET TYPE(375) : RECEIVED_F2F_CHAT
		function onReceivedF2FChat(responseObject){
			 /* method body */

            var friendId 	= responseObject.fndId;
            var boxId = friendId;

            if( boxId == Auth.currentUser().getKey() ){
            	return;
            }

            var box 		= _getBox(boxId);
            box.platform 	= responseObject.dvc;          

            var friendObject = userFactory.create({
                uId  : responseObject.fndId,
                utId : responseObject.utId,
                fn   : responseObject.nm
            });

            friendsFactory.getContactDetailsByUtIds([responseObject.utId]);// this is for getting the userobject with detail info and push it in contactlist

            var friendPreviousOnlineStatus = friendObject.getOnlineStatus();

            friendObject.setOnlineStatus(responseObject.psnc);

            if(!!responseObject.mood){
                friendObject.setUserMood(responseObject.mood);
            }
            if(!!responseObject.dt ){
                friendObject.setDeviceToken(responseObject.dt);
            }
            if(!!responseObject.apt){
                friendObject.setAppType(responseObject.apt);
            }
            if(!!responseObject.dvc){
                friendObject.setPlatform(responseObject.dvc);
            }


            if( friendPreviousOnlineStatus != friendObject.getOnlineStatus() ){
                chatRequestProcessor.sendFriendInformation(friendObject);
            }

            if(responseObject.sucs === true && responseObject.psnc == USER_PRESENCE.ONLINE){ // if this sucs is false then user is not logged in with whom user is trying to chat                
                box.offlineStatus = false;                                
            }
            else{ // when responseObject.sucs !== true

                // if the user isn't logged in with whom user is trying to chat
                if(responseObject.rc == RESPONSE_REASON_CODES.PERMISSION_DENIED){                   
                    // this is the case where user is blocked(either by him or by friend), permission is denied
                    box.blocked = true;
                }else{                    
                    box.offlineStatus = true;                    
                }                
            }

            chatHistoryFactory.updateBox(box);

		}

		//PACKET TYPE(175) : START_F2F_CHAT
		function onReceivedStartF2FChat(responseObject){
			/* method body */
			onReceivedF2FChat( responseObject );
		}

		function onReceivedStartTagChat(responseObject){

		}

		//PACKET TYPE(199) : GET_USER_MOOD_PRESENCE
		function onReceivedFriendMoodPresence(responseObject){
			

			if( responseObject.fndId ){
				var friendObject = userFactory.getUser(responseObject.fndId);

				if( !!friendObject ){

					if( !!responseObject.psnc ){
						friendObject.setOnlineStatus(responseObject.psnc);	
					}            

		            if(!!responseObject.mood){
		                friendObject.setUserMood(responseObject.mood);
		            }

		            if(!!responseObject.dvc){
		                friendObject.setPlatform(responseObject.dvc);
		            }	
				}				
			
			}else{
			}
			

		}


		//PACKET TYPE(175) : START_F2F_CHAT
		responseMethodMap[AUTH_SERVER_ACTIONS.START_F2F_CHAT] = {
		    processor : onReceivedStartF2FChat
		};


		//PACKET TYPE(199) : GET_USER_MOOD_PRESENCE
		responseMethodMap[AUTH_SERVER_ACTIONS.GET_USER_MOOD_PRESENCE] = {
		    processor : onReceivedFriendMoodPresence
		};


		//PACKET TYPE(134) : START_TAG_CHAT
		responseMethodMap[AUTH_SERVER_ACTIONS.START_TAG_CHAT] = {
		    processor : onReceivedStartTagChat
		};

		
		//PACKET TYPE(334) : RECEIVED_TAG_CHAT
		responseMethodMap[AUTH_SERVER_ACTIONS.RECEIVED_TAG_CHAT] = {
		    processor : onReceivedTagChat
		};

		//PACKET TYPE(335) : ADD_TAG_CHAT_MEMBERS
		responseMethodMap[AUTH_SERVER_ACTIONS.ADD_TAG_CHAT_MEMBERS] = {
		    processor : onReceivedTagMemeberAdd
		};

		//PACKET TYPE(375) : RECEIVED_F2F_CHAT
		responseMethodMap[AUTH_SERVER_ACTIONS.RECEIVED_F2F_CHAT] = {
		    processor : onReceivedF2FChat
		};



		return {
			processUpdates : processUpdates
		}
	}

})(window);

(function() {
	'use strict';
	angular
		.module('ringid.chat')
        .controller('ChatController', ChatController);

        ChatController.$inect = ['$scope', '$rootScope', 'ChatFactory','ChatHelper',
            'chatRequestProcessor', 'ChatUtilsFactory', 'ChatResponses', 'ChatAuthResponses',
            'settings','SystemEvents', 'friendsFactory', 'ChatPacketSenderService',
            'chatTabSync', 'utilsFactory',
             'chatHistoryFactory', '$ringhttp', 
             '$$connector', 'Auth', 'tagChatManager', '$location', 'ChatConnector', 'ChatWorkerCommands'];
        
        function ChatController($scope, $rootScope, ChatFactory, ChatHelper,
                                chatRequestProcessor, ChatUtilsFactory, ChatResponses, ChatAuthResponses,
                                settings,SystemEvents,friendsFactory, ChatPacketSenderService,
                                chatTabSync, utilsFactory, 
                                chatHistoryFactory, $ringhttp, 
                                $$connector, Auth, tagChatManager, $location, ChatConnector, ChatWorkerCommands) {



                var Constants = CHAT_APP.Constants;
                var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;

                var SESSION_TYPES = GENERAL_CONSTANTS.SESSION_TYPES;

                var SharedHelpers = CHAT_APP.SharedHelpers;
                var friendUtIdListReceivedRef;
                var myTagListReceivedRef;

                var  chatAppInitiated = false;
                $scope.boxes = ChatFactory.getBoxes();

                $scope.$on('chatDataReceived', function (event, data) {
                    ChatResponses.processUpdates(data.jsonData);
                    utilsFactory.safeDigest($scope);

                });

                $scope.$on('authDataReceived', function (event, data) {
                    ChatAuthResponses.processUpdates(data.jsonData);
                    utilsFactory.safeDigest($scope);

                });

                $scope.domBoxLength = function () {
                    var count = 0 ;
                    for(var i=0; i< $scope.boxes.length; i++){
                        if($scope.boxes[i].value.nonDomBox == true){
                            count++;
                        }
                    }
                    if(count>10){
                        return 10;
                    }else{
                        return count;
                    }
                };

                $scope.availableNo = ChatFactory.getNumberOfAvailableChatBox();

                $scope.getProfileLink = settings.baseUrl + '/#/profile/';

                //$scope.previousDate = {timestamp:1,date:''};
                $scope.goToProfile = function(event, profileLink){
                    //$location.path('/profile/2110010128');
                    $location.path(profileLink);
                    event.stopPropagation();
                };

            


                $scope.contactListAction = function(actionObj) {
                    if (!actionObj.friend.isLoading()) {
                        friendsFactory.friendAction(actionObj,true).then(function() {
                            $scope.$rgDigest();
                        }, function() {
                            $scope.$rgDigest();
                        });
                        $scope.$rgDigest();
                    }
                };

                $scope.$on(SystemEvents.COMMON.WINDOW_RESIZED, function(event, viewport){
                    $scope.availableNo = ChatFactory.getNumberOfAvailableChatBox(viewport.x);
                    utilsFactory.safeDigest($scope);
                });


                var tabSyncNewData = utilsFactory.onCustomEvent(SystemEvents.CHAT.TAB_SYNC_NEW_DATA, function(data){

                    if( data.type == GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.CHAT_BOX_INFO_UPDATE ){
                        ChatFactory.refreshBox(data.boxId);

                    }else if ( data.type == GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.CHAT_MSESSAGE_UPDATE){

                        chatHistoryFactory.loadChatBoxes();
                        ChatFactory.openAndAddMessage(data.boxId, data.msg);
                        //ChatHelper.loadHistoryMessageForF2FChat(data.boxId);
                    }

                });


                var startChatHearBeatInterval = function(){
                    window.addEventListener("online", function(e) {
                        if( window.navigator.onLine){
                            chatRequestProcessor.getUnreadMessagesMultipleTimes();
                        }
                    });

                    var counter = 0;
                    var state = "online";
                    setInterval(function(){

                        $ringhttp.get(settings.chatHeartBeatUrl).success(function(response){

                            if(!!response){
                                if( state == "offline"){
                                    state = "online";
                                    utilsFactory.triggerCustomEvent('online');
                                }
                            }
                        }).error(function(response){
                            if(counter > 3){
                                counter = 0;
                                state = "offline";
                            }else{
                                counter++;
                            }

                        });
                    }, 10000);
                };

                var registerOnNetErrorHandler = function(){
                    
                    $scope.$on('NET_SUCCESS', function(){

                        chatRequestProcessor.getUnreadMessagesMultipleTimes();

                    });

                    window.addEventListener("online", function(e) {
                        if( window.navigator.onLine){
                            
                            chatRequestProcessor.getUnreadMessagesMultipleTimes();
                        }
                    });

                }

               var sendOfflineGetRequest = function(){

                    if( !ChatUtilsFactory.hasOfflineIpPort()){

                        ChatPacketSenderService.doUpdateOfflineIpPort().then(function(response){
                            chatRequestProcessor.getUnreadMessagesMultipleTimes();
                        });

                    }else{
                        chatRequestProcessor.getUnreadMessagesMultipleTimes();
                    }
                };

                var openPreviouslyOpenedFriendChatBoxes = function(){
                    var storageBoxes = chatHistoryFactory.getAllOpenBoxes();// previously this was an array but now it is an object
                    if(!!storageBoxes){
                        Object.keys(storageBoxes).forEach(function(anOpenBoxId, key){
                            var box,
                                anOpenBoxInfo = storageBoxes[anOpenBoxId];

                            if(!anOpenBoxInfo.isTagChat){

                                ChatFactory.openChatBox(anOpenBoxInfo.boxId);
                                box = ChatFactory.getBoxByUId(anOpenBoxInfo.boxId);
                                var historyBox = chatHistoryFactory.getBox(anOpenBoxInfo.boxId);
                                angular.extend(box, historyBox);
                                
                                ChatWorkerCommands.startChatSession(anOpenBoxInfo.boxId, SESSION_TYPES.FRIEND);                                         
                                                                    

                                if(!!box){
                                    box.loadHistoryMessages();
                                }
                            }                                    
                        });

                    } // end of if(storageBoxes)
                };

                var openPreviouslyOpenedTagChatBoxes = function(){
                    var storageBoxes = chatHistoryFactory.getAllOpenBoxes();// previously this was an array but now it is an object
                    if(!!storageBoxes){
                        Object.keys(storageBoxes).forEach(function(anOpenBoxId, key){
                            var box, anOpenBoxInfo = storageBoxes[anOpenBoxId];

                            if(!!anOpenBoxInfo.isTagChat){
                                tagChatManager.openPreviouslyOpenedBoxes(anOpenBoxInfo.boxId);
                            }

                        });

                    }
                };

                function initChatApp(){
                    
                    try{
                        
                        ChatConnector.initiate();    

                        chatHistoryFactory.init();
                        chatTabSync.init();

                        sendOfflineGetRequest();
                        // startChatHearBeatInterval();
                        registerOnNetErrorHandler();


                        friendUtIdListReceivedRef = utilsFactory.onCustomEvent(SystemEvents.FRIEND.UTID_LIST_RECEIVED, function(){
                            openPreviouslyOpenedFriendChatBoxes();
                        });


                        myTagListReceivedRef = utilsFactory.onCustomEvent(SystemEvents.CHAT.MY_TAG_LIST_RECEIVED, function(){
                            openPreviouslyOpenedTagChatBoxes();
                        });

                    }catch(e){

                    }
                    
                }

                var registerChatAppInitEvent = function(){
                     $rootScope.$on('FIRST_FEED_RECEIVED', function(){
                        if( !chatAppInitiated){
                            chatAppInitiated = true;
                            initChatApp();
                        }

                    });

                    setTimeout(function(){
                        if( !chatAppInitiated){
                            chatAppInitiated = true;
                            initChatApp();
                        }
                    }, 6000);

                };

                if( Auth.isLoggedIn() ){

                   registerChatAppInitEvent();

                }else{
                    $scope.$on(SystemEvents.AUTH.LOGIN, function (event, data) {
                        if (data === true) {
                            registerChatAppInitEvent();
                        }
                    });
                }


                $scope.$on('$destroy', function(){

                    utilsFactory.removeCustomEvent(SystemEvents.CHAT.TAB_SYNC_NEW_DATA, tabSyncNewData);
                    utilsFactory.removeCustomEvent(SystemEvents.FRIEND.UTID_LIST_RECEIVED, friendUtIdListReceivedRef);
                    utilsFactory.removeCustomEvent(SystemEvents.CHAT.MY_TAG_LIST_RECEIVED, myTagListReceivedRef);                    

                });




        }
        ChatController.$inject = ['$scope', '$rootScope', 'ChatFactory', 'ChatHelper', 'chatRequestProcessor', 'ChatUtilsFactory', 'ChatResponses', 'ChatAuthResponses', 'settings', 'SystemEvents', 'friendsFactory', 'ChatPacketSenderService', 'chatTabSync', 'utilsFactory', 'chatHistoryFactory', '$ringhttp', '$$connector', 'Auth', 'tagChatManager', '$location', 'ChatConnector', 'ChatWorkerCommands'];


})();

/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.chat')
        .controller('ChatHistoryController', ChatHistoryController);

    ChatHistoryController.$inject = ['$scope', '$rootScope', 'ChatFactory', 'Storage',
        'Auth', 'profileFactory', 'tagChatFactory', 'userFactory', 'utilsFactory',
        'chatHistoryFactory',
        '$$stackedMap', 'SystemEvents', 'rgScrollbarService'];
    function ChatHistoryController($scope, $rootScope, ChatFactory, Storage,
                                   Auth, profileFactory, tagChatFactory, userFactory, utilsFactory,
                                   chatHistoryFactory,
                                   $$stackedMap, SystemEvents, rgScrollbarService) {

        var Constants = CHAT_APP.Constants;
        var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;
        var CHAT_GLOBAL_VALUES = Constants.CHAT_GLOBAL_VALUES;

        $scope.selectedLeftBox = {key: 0, messages : []};

        $scope.boxes = $$stackedMap.createNew(true);

        $scope.recentMessages = $$stackedMap.createNew(true);

        $scope.ready = $rootScope.chatHistoryReady || false;

        $scope.selectLeftBox = function(box){
            $scope.selectedLeftBox = box;
        };

        var getMessageTime  = function(messageDate) {
            var localTime = messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff;
            var localFormatedTime = utilsFactory.verbalDate(localTime);
            return localFormatedTime;
        };

        $scope.getMessageTime = getMessageTime;


        var updateMessageObject = function(messageObject){
            profileFactory.getUserDetailsByUId(messageObject.userId || messageObject.user).then(function(userObj){
                if(!!userObj){
                    messageObject.user =  userObj;

                    $scope.$rgDigest();
                }

            });
        };

        var updateUserObject = function(msgObject, userId){
            if( !!userId){
                msgObject.user = profileFactory.getUserObjectByUId(userId, function(){
                    $scope.$rgDigest();
                });
            }
        };



        var initABox = function(aBox){
            if(!aBox.messages.length){
                return;
            }

            var aBoxObject = {
                key :  aBox.key,
                boxImg : '',
                boxTitle : '',
                boxUser  : '',
                boxLastMessage : '',
                messages : [],
                isTagChat : false,
                sortBy : function(){
                    return this.getLastMessage().messageDate;
                },
                getBoxTitle : function(){
                    return this.boxTitle;
                },
                getLastMessage : function(){
                    if( this.messages.length > 0){
                        return this.messages[this.messages.length-1];
                    }
                },

                getLastMessageText : function(){
                    var lastMessage = this.getLastMessage();
                    if( lastMessage.messageType == 2){
                        return lastMessage.text;
                    }else{
                        return "[MEDIA]";
                    }

                }
            };

            aBoxObject.messages = aBox.messages;

            for(var index = 0, length = aBox.messages.length; index < length; index++){
                aBox.messages[index].userId = aBox.messages[index].user;
                delete aBox.messages[index].user;

                updateUserObject(aBoxObject.messages[index], aBox.messages[index].userId);
            }

            aBoxObject.boxTitle = aBox.key;

            if( !aBox.isTagChat){

                var boxUser = userFactory.getUser(aBox.key);
                if(!!boxUser){

                    aBoxObject.boxTitle = boxUser.getName();
                    aBoxObject.boxImg = boxUser.avatar('thumb');

                }else{

                    profileFactory.getUserDetailsByUId(aBox.key).then(function(userObj){
                        if(!!userObj){
                            aBoxObject.boxTitle = userObj.getName();
                            aBoxObject.boxImg = userObj.avatar();
                        }

                    });
                }


            }else{

                aBoxObject.isTagChat = true;

                var aTag = tagChatFactory.getOrCreateTag(aBox.key);
                aBoxObject.tag = aTag;
                aBoxObject.boxTitle = aTag.getTagName();
                aBoxObject.boxImg = aTag.getPictureUrl();
            }


            $scope.boxes.save(aBoxObject.key, aBoxObject);

        };


        var getMessageText = function(message){
            if (!!message.statusType){
                return "Activity message.";
            }
            else if( message.messageType == GENERAL_CONSTANTS.MESSAGE_TYPES.PLAIN_MESSAGE){
                return message.text;

            } else {
                return "Received media message.";
            }
        };

        var getUnreadStatus = function(message){

            if( message.status == 'Unread' ){
                return true;
            }else if ( message.status == "Received" && !message.seenSent){
                return true;
            }else{
                return false;
            }

        };

        var getBoxUnreadCount = function(aBox){

            return chatHistoryFactory.getUnreadMessageCountByBoxId(aBox.key);
        };

        var getMessageAdaptorObject = function(aHistoryMessageObject){

            var aMessageObject              = angular.copy(aHistoryMessageObject);
            aMessageObject['date']          = getMessageTime(aMessageObject.messageDate);
            aMessageObject['isUnread']      = function(){ return getUnreadStatus(aMessageObject) };
            aMessageObject['messageText']   = function(){ return getMessageText(aMessageObject) };

            if( !!aMessageObject.user.getKey ){
                updateUserObject(aMessageObject, aMessageObject.user);
            }

            aMessageObject['isSelf'] = function() { return aHistoryMessageObject.userId == Auth.currentUser().getKey() };


            return aMessageObject;
        };

        var getBoxLastMessage = function(aBoxObject){
            var lastMessage = false;
            if( !!aBoxObject.messages && aBoxObject.messages.length > 0){
                
                aBoxObject.messages.sort(function(a, b){
                    if( a.messageDate > b.messageDate ){
                        return 1
                    }else if( a.messageDate < b.messageDate){
                        return -1
                    }
                    return 0;
                });

                lastMessage = aBoxObject.messages[aBoxObject.messages.length-1];
            }
            return lastMessage;
        };

        var updateBoxLastMessageByBoxId = function(boxId){

            var currentUserBoxes = chatHistoryFactory.getChatBoxes();
            var aHistoryBoxObject =  currentUserBoxes[boxId];

            var aBox = $scope.boxes.get(boxId);
            if( !!aBox){
                aBox.messages = aHistoryBoxObject.messages;

                var lastMessage = getBoxLastMessage(aBox);

                if( lastMessage ){
                    aBox['lastMessage'] = getMessageAdaptorObject(lastMessage);
                }
            }

        };

        var getBoxObject = function(aHistoryBoxObject){

            var aBoxObject = angular.copy(aHistoryBoxObject);

            var lastMessage = getBoxLastMessage(aBoxObject);

            if( lastMessage ){
                aBoxObject['lastMessage'] = getMessageAdaptorObject(lastMessage);
            }

            aBoxObject['unreadCount'] = function(){ return getBoxUnreadCount(aHistoryBoxObject); }

            aBoxObject['sortBy'] = function(){ return this.lastMessage.messageDate; };

            if( aBoxObject.isTagChat ){
                var tagId = aHistoryBoxObject.key;

                var tagObject = tagChatFactory.getTag(tagId);

                aBoxObject['getTitle'] = function() {
                    var tagObject = tagChatFactory.getTag(tagId);
                    return !tagObject ? "" : tagObject.getTagName();
                };

                aBoxObject['getCover']= function(){
                    var tagObject = tagChatFactory.getTag(tagId);
                    return !tagObject ? "" : tagObject.getPictureFullUrl()
                };

                aBoxObject['shouldVisible'] = function(){
                    var tagObject = tagChatFactory.getTag(tagId);
                    return !tagObject ? false : tagObject.isTagSafeToShow();
                };


            }else{

                updateUserObject(aBoxObject, aBoxObject.key);

                aBoxObject['getTitle'] = function(){
                    return aBoxObject.user.getName();
                };

                aBoxObject['getCover']= function(){
                    return aBoxObject.user.avatar('thumb') ;
                };

                aBoxObject['shouldVisible'] = function(){ return true; };

            }


            return aBoxObject;
        };


        $scope.initBoxMessages = function(aBox){
            if( !!aBox.messages ){
                angular.forEach(aBox.messages, function(aBoxMessage, index){
                    var aBoxMessage = getMessageAdaptorObject(aBoxMessage);
                    $scope.recentMessages.add(aBoxMessage.key, aBoxMessage );
                });
            }
        };


        $scope.initRecentMessages = function(){

            var currentUserId = Auth.currentUser().getKey();

            var currentUserBoxes = chatHistoryFactory.getChatBoxes();
            if(!!currentUserBoxes){
                angular.forEach( currentUserBoxes, function(aBox, key){

                    var aBoxObject = getBoxObject(aBox);

                    if( aBoxObject.lastMessage ){
                        $scope.boxes.add(aBox.key, aBoxObject);
                    }

                });
            }

        };

        $scope.clearRecentMessages = function(){
            $scope.recentMessages.clear();
        };

        $scope.openChatBox = function(boxId, isTagChat){

            utilsFactory.triggerCustomEvent(SystemEvents.CHAT.UNREAD_MESSAGE_INFO_UPDATED);

            if( !!isTagChat ){
                ChatFactory.openTagChatBox(boxId);
            }else{
                ChatFactory.openChatBox(boxId);
            }

        };

        $scope.initRecentMessages();

        if(!$rootScope.chatHistoryReady){
            setTimeout(function(){
                $scope.ready = true;
                $rootScope.chatHistoryReady = true;
                $scope.$rgDigest();
                rgScrollbarService.recalculate($scope);
            }, 3000);
        }

        var myTagListReceivedEventListener = utilsFactory.onCustomEvent('MY_TAG_LIST_RECEIVED', function(){
            utilsFactory.safeDigest($scope);            
        });

        var taglistupdatedEventListener = utilsFactory.onCustomEvent('taglistupdated', function(){
            utilsFactory.safeDigest($scope);
        });

        var messageReceivedEventListener = utilsFactory.onCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED, function(data){
            updateBoxLastMessageByBoxId(data.boxId);
            utilsFactory.safeDigest($scope);
        });


        var newMessageSubmittedEventListener = utilsFactory.onCustomEvent( SystemEvents.CHAT.MESSAGE_SUBMITTED , function(data){
            updateBoxLastMessageByBoxId(data.boxId);
            utilsFactory.safeDigest($scope);
        });


        $scope.$on("$destroy", function(){

            utilsFactory.removeCustomEvent('MY_TAG_LIST_RECEIVED', myTagListReceivedEventListener);
            utilsFactory.removeCustomEvent('taglistupdated', taglistupdatedEventListener);
            
            utilsFactory.removeCustomEvent(SystemEvents.CHAT.MESSAGE_SUBMITTED, newMessageSubmittedEventListener);
            utilsFactory.removeCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED, messageReceivedEventListener);

        });



    }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.chat')
		.controller('ChatMediaUploadController', ChatMediaUploadController);

    ChatMediaUploadController.$inject = ['$scope', 'fileUploadService', 'utilsFactory', '$boxInstance', 'localData'];
        function ChatMediaUploadController($scope, fileUploadService, utilsFactory, $boxInstance, localData){

            $scope.navSection = 0;

            $scope.sendMedia = function(){

                if( !!$scope.capturedMedia && !!localData.boxId){

                    var uploadFile = fileUploadService.queueFile('chatimage', utilsFactory.dataURLToBlob($scope.capturedMedia));

                    utilsFactory.triggerCustomEvent('BOX_CAM_UPLOAD', { uploadFile : uploadFile, boxId : localData.boxId })

                    $boxInstance.close();

                }
            };


        }



})();

/*
 * © Ipvision
 */

(function () {
    'use strict';
    angular
        .module('ringid.chat')
        .controller('TagChatController', TagChatController);

    TagChatController.$inject = [
        '$scope', '$templateCache', '$timeout', 'settings',
        '$$connector',
        'Auth', 'Ringalert',
        'rgDropdownService', 'ChatFactory', 'utilsFactory', 'tagChatStorage',
        'friendsFactory', 'tagChatFactory', 'tagChatManager',
        'chatRequestProcessor', 'ChatHelper', 'SystemEvents'];

    function TagChatController($scope, $templateCache, $timeout, settings,
                               $$connector,
                               Auth, Ringalert,
                               rgDropdownService, ChatFactory, utilsFactory, tagChatStorage,
                               friendsFactory, tagChatFactory, tagChatManager,
                               chatRequestProcessor, ChatHelper, SystemEvents) {

        var viewModel = this;

        viewModel.memberDDHtml = 'pages/partials/tag-chat/member-actions-dropdown.html';//$templateCache.get('tag-chat-dropdown.html');
        viewModel.memberDDActions = memberDDActions;
        viewModel.getTagDDControl = getTagDDControl;

        viewModel.ready = false;

        viewModel.groupFilter = "groups";

        try {
        } catch (e) {
            viewModel.debug = false;
        }


        var currentUser = Auth.currentUser();
        
        var CHAT_GLOBAL_VALUES = CHAT_APP.Constants.CHAT_GLOBAL_VALUES;


        viewModel.isCurrentUserOwner = function (tagObj) {
            return tagObj.getOwnerUserId() == currentUser.getKey();
        };

        viewModel.isCurrentUserMember = function (tagObj) {
            return tagObj.isUserMember(currentUser.getKey());
        };


        viewModel.allTags = tagChatFactory.getTags();

        viewModel.changeGroupFilter = function (filterName) {
            viewModel.groupFilter = filterName || 'groups';
        };

        viewModel.showGroupLogs = function (filterName) {
            return viewModel.groupFilter === 'logs';
        };

        viewModel.showGroups = function (filterName) {
            return viewModel.groupFilter === 'groups';
        };

        viewModel.getTagPictureImageByMemberAvatars = getTagPictureImageByMemberAvatars;
        viewModel.getLastMessageOnATag = getLastMessageOnATag;

        viewModel.imageBase = settings.imBase;

        viewModel.getUserAvatar = function (user) {
            if (!user || !user.avatar()) {
                return 'images/prof.png';
            } else {
                return user.avatar();
            }
        };

        viewModel.getLastMessageText = function (boxMessageObject) {

            if (boxMessageObject.messageType === 2) {
                return boxMessageObject.text;
            } else if ([6, 7, 8, 9].indexOf(boxMessageObject.messageType) !== -1) {
                return 'Media';
            }

            return false;
        };


        var restoreLocalData = function () {

            var packets = tagChatStorage.getAllPackets();
            var keys = Object.keys(packets);
            for (var index = 0; index < keys.length; index++) {
                if (packets.hasOwnProperty(keys[index])) {
                    var aPacket = packets[keys[index]];
                    tagChatSubscriber.processPacketData(utilsFactory.string2ArrayBuffer(aPacket));
                }
            }
        };



        $scope.shouldShow = function () {
            return viewModel.ready;
        };

        var tagListUpdatedFuncRef = utilsFactory.onCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED, function(){
            viewModel.ready = true;
            viewModel.allTags = tagChatFactory.getTags();
            utilsFactory.safeDigest($scope);
        });
        


        $timeout(function () {
            viewModel.ready = true;
        }, 8000);

        // for listing

        function getTagDDControl(aTagObj) {
            return {

                tagId: aTagObj.getTagId(),
                isOwner: viewModel.isCurrentUserOwner(aTagObj)
            };

        }

        function getTagPictureImageByMemberAvatars(aTag) {
            var images = [];
            var allMembersObjects = aTag.getMembersObjectMap().all();
            var imageCount = 0;

            for (var index = 0; ( index < allMembersObjects.length && imageCount < 3); index++) {
                var aMemberObject = allMembersObjects[index].value;
                var pictureUrl = aMemberObject.getPictureUrl();
                if (pictureUrl !== '') {
                    images.push(pictureUrl);
                    imageCount++;
                }
            }

            return images;

        }

        function getLastMessageOnATag(aTag) {
            //var box = ChatFactory.getBoxByUId(aTag.getTagId());
            //if( !box || !box.messages.length){
            //	return false;
            //}

            var message = tagChatStorage.getLastMessageByTag(aTag.getTagId());
            if (!message) {
                return false;
            }

            //var message = box.messages[box.messages.length - 1];
            return message.value;
        }

        // edit, view or delete
        function memberDDActions(actionObj) {
            switch (actionObj.action) {
                case 'edit':
                case 'view':
                    rgDropdownService.close();

                    return function () {
                        return {tagId: actionObj.tagId};
                    };
                    break;
                case 'delete':

                    rgDropdownService.close();

                    var tagObject = tagChatFactory.getTag(actionObj.tagId);
                    tagObject.setObjectLock();
                    tagChatManager.leaveFromTag(actionObj.tagId, currentUser.getKey()).then(function (response) {

                        tagObject.removeObjectLock();
                        Ringalert.show(response, 'info');


                    }, function (response) {

                        tagObject.removeObjectLock();
                        Ringalert.show(response, 'error');

                    });

                    break;
                default:
                    console.log('Err. no matching action');
            }
        }

        $scope.$on('$destroy', function(){
            utilsFactory.removeCustomEventListener(SystemEvents.CHAT.TAG_LIST_UPDATED, tagListUpdatedFuncRef );
        });

    }


})();




/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.chat')
		.controller('TagChatPopupController', TagChatPopupController);

		TagChatPopupController.$inject = [
			'$timeout', '$scope', '$boxInstance', '$$stackedMap',
			'Auth', 'fileUploadService',
			'tagChatFactory', 'tagChatManager', 'friendsFactory',
			'localData', 'Ringalert', 'utilsFactory', 'settings',			
			'profileFactory', 'rgScrollbarService', 'CHAT_LANG'
		];

		function TagChatPopupController(
			$timeout, $scope, $boxInstance, $$stackedMap,
			Auth, fileUploadService,
			tagChatFactory, tagChatManager, friendsFactory,
			localData, Ringalert, utilsFactory, settings,			
			profileFactory, rgScrollbarService, CHAT_LANG
		) {

			var TAG_CHAT_LANG = CHAT_LANG.TAG;
			var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;

            $scope.state = {
                loading: false,
                noData: false,
            };
			var oldMemberList = {},
				apiParams = {},
				utId = '',
				memberUtIds = '';

			//$scope.friends = friendsFactory.friends.copy();
            $scope.friends = friendsFactory.getFriends('friends');
            $scope.friendName = '';
			$scope.editMode = false;

			$scope.addToTag = addToTag;
			$scope.removeMember= removeMember;
			$scope.createChatTag = createChatTag;
			$scope.updateChatTag = updateChatTag;
			$scope.loadMoreFriends = loadMoreFriends;
			$scope.cancel = cancel;
			$scope.validateTag = validateTag;

			$scope.newOwnerTagMember = false;

			$scope.models = {
				popupTitle: 'Create New Group Chat',
				tagName: '',
				pictureUrl : '',
				pictureFileName : '',
				tagId : tagChatFactory.generateNewTagId(),
			};

			$scope.uploading = false;

			$scope.selectNewOwner = selectNewOwner;

			$scope.setNewOwner = setNewOwner;

			$scope.isMemberSelected = isMemberSelected;

			$scope.canRemoveMember = canRemoveMember;

			$scope.canUpdateTagInfo = canUpdateTagInfo;

			$scope.getPicturePreviewUrl = function(){
				return settings.tagChatImBase + $scope.models.pictureUrl;
			};

			$scope.contactListAction = function(actionObj) {
                if (!actionObj.friend.isLoading()) {
                    friendsFactory.friendAction(actionObj,true).then(function() {
                        $scope.$rgDigest();
                    }, function() {
                        $scope.$rgDigest();
                    });
                    $scope.$rgDigest();
                }
            };


			$scope.uploadAction = function (actionObj) {
				console.log(actionObj);

				actionObj.uploadFile.fetchMeta(function(){

					$scope.models.pictureUrl = actionObj.uploadFile.getPreview();
					$scope.uploading = true;

					utilsFactory.safeDigest($scope);

					utilsFactory.safeDigest($scope);

					actionObj.uploadFile.initUpload().then(function(imgData){
						$scope.uploading = false;
						console.info("chat image uploaded:" + imgData);
						$scope.models.pictureFileName = imgData.iurl;
						$scope.models.pictureUrl = settings.imBase + imgData.url;

						utilsFactory.safeDigest($scope);

					}, function(response){
						console.log(response);
						$scope.uploading = false;
					});

				});
			};

			var currentUserUId = Auth.currentUser().getKey();

			function initAdminMemberOwnerList(){
				$scope.memberList = $$stackedMap.createNew();
				$scope.adminList = $$stackedMap.createNew();
				//$scope.ownerList = $$stackedMap.createNew();
			}

			if (localData && localData.tagId) {


				//get tag data
				$scope.tag = tagChatFactory.getTag(localData.tagId);

                //take backup
				oldMemberList = $scope.memberList;

				var memberObjectMap = $scope.tag.getMembersObjectMap();

				if( !!memberObjectMap ){
                	$scope.memberAdminList = memberObjectMap.copy();
					initAdminMemberOwnerList();

					$scope.tag.initMemberObjects();

					angular.forEach($scope.memberAdminList.all(), function(aMemberList){

						//if( aMemberList.value.isAdmin() ){
						//
						//}else
						if( aMemberList.value.isMember() ){
							$scope.memberList.add(aMemberList.key, aMemberList.value);
						}else{
							$scope.adminList.add(aMemberList.key, aMemberList.value);
							//$scope.ownerList.add(aMemberList.key, aMemberList.value);
						}

					});

				}else{
					initAdminMemberOwnerList();

				}

				$scope.models.tagName = $scope.tag.getTagName();
				$scope.models.popupTitle = 'Update Group chat';
				$scope.models.pictureUrl = $scope.tag.getPictureFullUrl();
				$scope.models.pictureFileName = $scope.tag.getPictureUrl();

				// show an existing tag for view/edit
				$scope.editMode = true;

			} else {
				// create new stack
				initAdminMemberOwnerList();
			}


            function reInitFriends() {
                $timeout(function() {
			        $scope.friends = friendsFactory.friends.copy();
					utilsFactory.safeDigest($scope);
				}, 2000);

            }


            // search for friend
            $scope.$watch('friendName', function(newVal, oldVal) {
                console.log('search contact: ' + newVal);
                if(newVal != '') {
                    friendsFactory.searchContact({schPm: newVal}, true);
                    reInitFriends();
                }
            });

			$scope.$watch(function(){
				return ($scope.friends.length() - $scope.adminList.length() - $scope.memberList.length());
			}, function(newVal, oldVal){
				if(newVal < 10){
					loadMoreFriends();
				}
			});



			function isCurrentUserOwner(tagObj){

				return !!tagObj && tagObj.getOwnerUserId() === Auth.currentUser().getKey();
			}

			function canAddMember(tagMemberObject){

				return true;
			}

			function canRemoveMember(tagMemberObject){

				if( tagMemberObject.getId() === currentUserUId ){
					return false;
				}

				if( !!$scope.tag && !isCurrentUserOwner($scope.tag)){

					var isAddedByCurrentUser = tagMemberObject.getAddedBy() !== Auth.currentUser().getKey();

					if( $scope.tag.isCurrentUserStatusAdmin(currentUserUId) ){
						if(tagMemberObject.isAdmin() && isAddedByCurrentUser ){

						}else if(!tagMemberObject.isMember()){
							return false;
						}

					}

					if( $scope.tag.isCurrentUserStatusMember(currentUserUId) && isAddedByCurrentUser ){
						return false;
					}
				}

				return true;

			}

			function canUpdateTagInfo(){

				if( !!$scope.editMode && $scope.tag.isCurrentUserStatusMember(currentUserUId) ){
					return false;
				}

				return true;
			}



            $scope.$watch('friendName', function(newVal) {
                if (newVal && newVal.length >1) {
                    toggleLoading(true);
                    friendsFactory.searchContact({schPm: newVal}, true).then(function() {
                        $scope.friends = friendsFactory.getFriends('friends');
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                    });
                }
            });

            function loadMoreFriends() {
                // no request in progress
                if (!$scope.state.loading && $scope.friends.length() !== friendsFactory.totalFriends('friends')) {
                    toggleLoading(true);
                    friendsFactory.getContactDetails().then(function() {
                        $scope.friends = friendsFactory.getFriends('friends');
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                    });

                    // in case the promise never resolves or rejects
                    setTimeout(function() {
                        $scope.state.loading = false;
                    }, 3000);
                }
            }

			function createChatTag() {
				if(!validateTag()) {
					utilsFactory.safeDigest($scope);
					return
				}


				var tagName = $scope.models.tagName;

				var memberUIds = $scope.memberList.keys();
				var adminUIds = $scope.adminList.keys();

				var tagId = $scope.models.tagId;
				var pictureFileName = $scope.models.pictureFileName;

				tagChatManager.createTag({ tagName :tagName, memberUIds : memberUIds, adminUIds : adminUIds, tagId : tagId, tagPictureUrl: pictureFileName })
					.then(function(data){
						if( !!data.sucs){
							Ringalert.show('Group Created.', 'success');
						}

					}, function(response){

						Ringalert.show(TAG_CHAT_LANG.DEFAULT_FAILURE_MESSAGE, 'error');


					}, function(response){


					});



				$boxInstance.close();

			}

			function removeTagObjectLock(tagId){
				var oldTagObj = tagChatFactory.getTag($scope.tag.getTagId());
				oldTagObj.removeObjectLock();
			}


			function updateChatTag() {
				if(!validateTag()) {
					utilsFactory.safeDigest($scope);
					return;
				}

				var oldTagObj = tagChatFactory.getTag($scope.tag.getTagId());
				var newTagName = $scope.models.tagName;
				var pictureFileName = $scope.models.pictureFileName;

				var memberUIdsToSet = $scope.memberList.keys();
				var adminUIdsToSet = $scope.adminList.keys();

				$scope.tag.setObjectLock();


				tagChatManager.updateTag(oldTagObj,
					newTagName,
					pictureFileName,
					memberUIdsToSet,
					adminUIdsToSet
				).then(function(response){
						removeTagObjectLock($scope.tag.getTagId());

						if(!!response.sucs){
							Ringalert.show(response, 'success');
						}

				}, function(response){
						removeTagObjectLock($scope.tag.getTagId());

						Ringalert.show(TAG_CHAT_LANG.DEFAULT_FAILURE_MESSAGE, 'error');


				}, function(response){
						if(!!response.sucs){

							removeTagObjectLock($scope.tag.getTagId());
							Ringalert.show(response, 'success');
						}

				});


				$scope.editMode = false;
				utilsFactory.triggerCustomEvent('MY_TAG_LIST_RECEIVED');

				$boxInstance.close();


			}

            function toggleLoading(bool) {
                $timeout(function() {
                    $scope.state.loading = bool;
                    if (!bool) {
                        rgScrollbarService.recalculate($scope);
                    }
                });
                //$scope.$digest();
            }

			function addToTag( member, type) {
                if ( ($scope.memberList.length() + $scope.adminList.length()) > $scope.friends.length() - 10) {
                    loadMoreFriends();
                }

				var tagId = !$scope.tag ? $scope.models.tagId : $scope.tag.getTagId();

				var aTagMemberObject = tagChatFactory.createNewTagMember(
					tagId,
					{ status : type == 'member' ? GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER : GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN, addedBy : currentUserUId },
					false
				);

				if( !canAddMember(aTagMemberObject) ){
					Ringalert.show('Permission Denied', 'error');
					return;
				}


				if( !!$scope.tag ){
					aTagMemberObject.setTagId( $scope.tag.getTagId() );
				}

				aTagMemberObject.initWithUserMapObject( member );

				if( type === 'admin'){
					$scope.adminList.add( aTagMemberObject.getId(), aTagMemberObject);
				}else{
					$scope.memberList.add( aTagMemberObject.getId(), aTagMemberObject);
				}
				utilsFactory.safeDigest($scope);


			}

			function removeMember(tagMemberObj) {

				if(  canRemoveMember(tagMemberObj) ){

					if( tagMemberObj.isAdmin() ){
						$scope.adminList.remove(tagMemberObj.getId());
					}else{
						$scope.memberList.remove(tagMemberObj.getId());
					}
					utilsFactory.safeDigest($scope);


				}else{
					Ringalert.show('Permission Denied', 'error');
				}
			}


			function isMemberSelected(tagMember){
				return ($scope.newOwnerTagMember && tagMember.getId() === $scope.newOwnerTagMember.getId());
			}

			function setNewOwner(tagMember){
				$scope.newOwnerTagMember = tagMember;

				utilsFactory.safeDigest($scope);

			}

			function selectNewOwner(){

				var tagMember = $scope.newOwnerTagMember;
				var tag = $scope.tag;

				$scope.newOwnerTagMember = false;


				var oldTagMemberStatus = tagMember.getStatus();

				tagMember.makeOwner();

				var currentOwner = tag.getMember(Auth.currentUser().getKey());
				currentOwner.makeMember();

				var revertChanges = function(){
					tagMember.setStatus(oldTagMemberStatus);
					currentOwner.makeOwner();
					tag.removeObjectLock();
				};

				var tagMembersStatusToChange = [tagMember.serialize(), currentOwner.serialize()];

				var membersAdminToUpdateOnSuccess = [tagMember, currentOwner];

				tag.setObjectLock();

				tagChatManager.changeTagMemberStatus(tag.getTagId(), tagMembersStatusToChange, membersAdminToUpdateOnSuccess).then(function(){

					tagChatManager.leaveFromTag( tag.getTagId()).then(function(memberLeaveResponse){

						tag.removeObjectLock();
						Ringalert.show(memberLeaveResponse, 'info');


					}, function(){
						Ringalert.show(TAG_CHAT_LANG.DEFAULT_FAILURE_MESSAGE, 'error');
						revertChanges();
					});


				}, function(){
					Ringalert.show(TAG_CHAT_LANG.DEFAULT_FAILURE_MESSAGE, 'error');
					revertChanges();
				});

				utilsFactory.safeDigest($scope);
				$boxInstance.close();

			}



			function cancel() {
				$scope.newOwnerTagMember = false;
				$boxInstance.close();

				utilsFactory.safeDigest($scope);

			}


			function validateTag() {
                if ($scope.models.tagName.length > 100 ) {
                    $scope.models.errTagName = 'Maximum 100 alpha numeric characters';
                } else {
                    $scope.models.errTagName = '';
                }
				$scope.models.errMemberList = ( ( $scope.memberList.length() + $scope.adminList.length() ) < 2 ) ? true : false;

				if ( !!$scope.models.errMemberList  || !!$scope.models.errTagName) {
					return false;
				} else {
					return true;
				}


			}

		}

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.chat')
		.controller('TagChatDebugInfoController', TagChatDebugInfoController);

	TagChatDebugInfoController.$inject = [
			'$scope', '$boxInstance',
			'Auth', 'ChatFactory',
			'tagChatFactory', 'tagChatManager', 'friendsFactory',
			'localData', 'Ringalert', 'utilsFactory', 'settings',
			'profileFactory'
		];

		function TagChatDebugInfoController(
			$scope, $boxInstance,
			Auth, ChatFactory,
			tagChatFactory, tagChatManager, friendsFactory,
			localData, Ringalert, utilsFactory, settings,
			profileFactory
		) {

			var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;

			$scope.currentUserUId = Auth.currentUser().getKey();

			$scope.registerTag = registerTag;
			$scope.unregisterTag = unregisterTag;


			if (localData && localData.tagId) {

				//get tag data
				$scope.tag = tagChatFactory.getTag(localData.tagId);


				//set Debug Infos Start

				$scope.tagDebugInfo = {};
				$scope.tagDebugInfo.isTagRegistered = tagChatFactory.isTagRegistered(localData.tagId);
				$scope.chatBox = ChatFactory.getBoxByUId(localData.tagId);

			}

			function cancel() {
				$boxInstance.close();
			}

			function registerTag(){
				tagChatManager.registerTag($scope.tag.getTagId());
			}

			function unregisterTag(){
				// tagChatApiService.unRegisterFromChatServer($scope.tag);
			}



		}

})();

(function(){
    'use strict';

    var chatApp;

    chatApp = angular.module('ringid.chat');
    
    chatApp.factory('ChatUtilsFactory', ChatUtilsFactory);

    ChatUtilsFactory.$inject = ['Auth', 'utilsFactory'];

    function ChatUtilsFactory(Auth , utilsFactory){

        var Constants = CHAT_APP.Constants;        
        var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;
        var CHAT_GLOBAL_VALUES = Constants.CHAT_GLOBAL_VALUES;

        var textParseForLinkAndEmo = function(text){
             text = utilsFactory.parseForLE(text, 0);
            return text;
        };


        function ChatUtilsFactory(){
            var timestamp;

            if( !isPacketIdStamp && !packetTime){
                packetTime = new Date().getTime();
                timestamp =  parseInt(packetTime + CHAT_GLOBAL_VALUES.serverTimeDiff);

            }else{
                timestamp = packetTime;
            }

            if( !timestamp){
            }

            return PacketIDGenerator.create(Auth.currentUser().getKey(), timestamp, isPacketIdStamp);
        }

        var _getOfflineIpPort = function(){
            var loginData = Auth.loginData, ip, port;

            var oIpPort = {
                ip : '',
                port : ''
            };

            if( !!loginData ){
                oIpPort.ip = loginData.oIP;
                oIpPort.port = loginData.oPrt;
            }

            return oIpPort;
        };

        var _hasOfflineIpPort = function(){
            var ipPort = _getOfflineIpPort();
            return !(!ipPort || !ipPort.ip  || !ipPort.port);
        };

        var getChatServerCurrentTime = function () {
            return parseInt(new Date().getTime() + CHAT_GLOBAL_VALUES.serverTimeDiff);
        };


        function _getUUIDPacketId(packetTime, isPacketIdStamp){
            var timestamp;

            if( !isPacketIdStamp && !packetTime){
                packetTime = new Date().getTime();
                timestamp =  parseInt(packetTime + CHAT_GLOBAL_VALUES.serverTimeDiff);

            }else{
                timestamp = packetTime;
            }

            if( !timestamp){
            }

            return PacketIDGenerator.create(Auth.currentUser().getKey(), timestamp, isPacketIdStamp);
        }


        return {

            parseForLE : textParseForLinkAndEmo,
            getUUIDPacketId : _getUUIDPacketId,
            getChatServerCurrentTime : getChatServerCurrentTime,
            getOfflineIpPort : _getOfflineIpPort,
            hasOfflineIpPort : _hasOfflineIpPort,

        }

    }

})();
(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}

    chatApp
        .factory('ChatMap', [ '$$stackedMap','$interval', '$websocket','$rootScope','$sce',
            'Auth', 'ChatConnector', 
            'userFactory', 'utilsFactory', 'tagChatFactory', 'profileFactory',
            'chatHistoryFactory' ,'settings',
            'tagChatHelper', 'tagChatStorage',
            'ChatUtilsFactory', 'rgScrollbarService', 'chatTabSync',

        function ( $$stackedMap, $interval, $websocket, $rootScope,$sce,
            Auth, ChatConnector, userFactory, utilsFactory, tagChatFactory, profileFactory,
            chatHistoryFactory, settings,
            tagChatHelper, tagChatStorage,
            ChatUtilsFactory, rgScrollbarService, chatTabSync

        ) {

                var Constants =  CHAT_APP.Constants;
                var CHAT_GLOBAL_VALUES = Constants.CHAT_GLOBAL_VALUES;
                var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;
                var SharedHelpers = CHAT_APP.SharedHelpers;
                var getChatServerCurrentTime = SharedHelpers.getChatServerCurrentTime;


                var getBasicMessageObject = function(message){

                    var key = message.key || message.packetId;
                    var mdate = message.messageDate || new Date().getTime();

                    var basicMsgObj = {
                        key: key.toString(),
                        packetId: key.toString(),
                        text: message.message || message.mg || message.text,
                        hrtime: utilsFactory.chatVerbalDate(mdate),
                        status: message.status || 0,
                        fullName : message.fullName,
                        tagName : message.tagName || '',
                        messageDate: mdate,
                        isDeleted: false,
                        messageDateString: message.messageDateString || '',
                        timeout: message.timeout,
                        messageType: message.messageType,
                        tag_chat: message.tag_chat || false,
                        seenSent : message.seenSent || false,
                        isSecretVisible: message.isSecretVisible,
                        secretTimedOut : message.secretTimedOut ? message.secretTimedOut : false,
                        lastUpdateTime : new Date().getTime(),
                        platform: 5
                    };
                    if(!!message.tag_chat){
                        basicMsgObj.packetType = message.packetType || 63;
                        basicMsgObj.brokenPacketType = message.brokenPacketType;
                    }else{
                        basicMsgObj.packetType = message.packetType || 6;
                        basicMsgObj.brokenPacketType = message.brokenPacketType;
                    }

                    return basicMsgObj;

                };

                return {

                    create: function (userId,isTagChat) {
                        var chat, returnob, intervalVar,
                            tagItem, tagId, user,
                            boxId = userId;

                        if(isTagChat){
                            tagId = userId;
                            tagItem = tagChatFactory.getTag(tagId);//pass groupId which is coming here as userId
                        }
                        else{
                            user = userFactory.create({uId: userId});
                        }

                        var isTyping = false,
                        isFriendTyping = false,

                        typingUserIds = {},
                        typingText = "",
                        messages = $$stackedMap.createNew(true, 'asc');

                        var pushMessage = function (message, user, sendToTab) {

                            var tempmesg;
                            if (!!message.type && message.type === 101) { // user is typing
                                isTyping = true;
                                return;
                            }
                            if (message.type == 0 && message.status === 0) { // when message is deleted// set only property to zero
                                tempmesg = messages.get(messages.packetId);
                                tempmesg.isDeleted = true;
                                return;

                            }

                            var parsedMessageText = "";

                            var basicMsgObj = getBasicMessageObject(message);

                            if( !angular.isObject(user)  ){

                                user = profileFactory.getUserObjectByUId(message.userId, function(){
                                    utilsFactory.triggerCustomEvent('SINGLE_MESSAGE_UPDATED', { message : basicMsgObj });
                                });
                            }

                            var msgObj = {

                                locationInfo     : {},
                                ogData           : {},
                                seenUserIds      : {},
                                deliveredUserIds : {},
                                user             : user,

                                sortBy: function () {
                                    return message.messageDate;
                                },
                                getTextPartition: function () {
                                    return parsedMessageText;
                                },
                                setTextPartition: function () {
                                    parsedMessageText = ChatUtilsFactory.parseForLE(msgObj.text);
                                    parsedMessageText = $sce.trustAsHtml(parsedMessageText);
                                },
                                getMessageTime: function () {
                                    var localTime = message.messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff;
                                    var localFormatedTime = utilsFactory.chatVerbalDate(localTime);
                                    return localFormatedTime;
                                },
                                seenUsersCount : function(){
                                    return Object.keys(msgObj.seenUserIds).length;
                                },
                                deliveredUsersCount : function(){
                                    return Object.keys(msgObj.deliveredUserIds).length;
                                },
                                addSeenUserId : function(userId){
                                    msgObj.seenUserIds[userId] = true;
                                },
                                addDeliveredUserId : function(userId){
                                    msgObj.deliveredUserIds[userId] = true;
                                },
                                updateLocationInfo : function(){
                                    var locationInfo, latitude, longitude;
                                    try{
                                        locationInfo = angular.fromJson(msgObj.text);
                                        latitude = locationInfo.la; //PacketDataParse.Bytes2Float32
                                        longitude = locationInfo.lo; //PacketDataParse.Bytes2Float32
                                        msgObj.locationInfo = { lat : latitude, long : longitude, description : locationInfo.loc };
                                        msgObj.plainText = locationInfo.loc;
                                    }catch(e){
                                    }
                                },
                                updateLinkShareInfo : function(){
                                    msgObj.ogData = {};
                                    try {
                                        var messageLinkJson = angular.fromJson(msgObj.text);
                                        msgObj.ogData = {
                                            lnkDmn: messageLinkJson.u,
                                            description: messageLinkJson.d,
                                            title: messageLinkJson.t,
                                            url: messageLinkJson.u,
                                            image: messageLinkJson.i,
                                            message : messageLinkJson.m
                                        };
                                        msgObj.plainText = messageLinkJson.m;
                                    }catch (e){
                                    }
                                },
                                updateMediaInfo : function(){
                                    var mediaInfo;
                                    try{
                                        mediaInfo = angular.fromJson(msgObj.text);
                                        msgObj.mediaInfo = { url : mediaInfo.u, caption : mediaInfo.c, width: mediaInfo.w, height: mediaInfo.h };
                                        msgObj.plainText = mediaInfo.c;
                                    }catch(e){
                                    }
                                }
                            };//end of msgObj

                            angular.extend(msgObj, basicMsgObj);

                            message.userId = msgObj.userId = msgObj.user.getKey();

                            if( !!message.usersToChange ){
                                msgObj.usersToChange = message.usersToChange;
                            }

                            if( !!message.statusType){
                                msgObj.statusType = message.statusType;
                            }

                            if( message.status !== 'status_update'){

                                if(!(message.secretTimedOut == true) && message.status === "Deleted") {
                                    //only for non secret delete messages
                                    //we're making them forcefully type text otherwise it won't show 'this message has been deleted'
                                    msgObj.messageType = 2;
                                    parsedMessageText = ChatUtilsFactory.parseForLE(msgObj.text);
                                }
                                else{
                                    switch (message.messageType){
                                        case GENERAL_CONSTANTS.MESSAGE_TYPES.TEXT:
                                            parsedMessageText = ChatUtilsFactory.parseForLE(msgObj.text);
                                            break;

                                        case GENERAL_CONSTANTS.MESSAGE_TYPES.LOCATION_SHARE:
                                            msgObj.updateLocationInfo();
                                            var latitude = msgObj.locationInfo.lat,
                                                longitude = msgObj.locationInfo.long,
                                                mapUrl;

                                            if(latitude !=0 && longitude !=0){

                                                msgObj.mapStaticUrl =  utilsFactory.getGoogleMapStaticUrl(latitude, longitude) ;
                                                msgObj.mapJsUrl = utilsFactory.getGoogleMapJSUrl(latitude, longitude);

                                            }else{

                                                parsedMessageText = ChatUtilsFactory.parseForLE(msgObj.text);

                                            }
                                            break;

                                        case GENERAL_CONSTANTS.MESSAGE_TYPES.LINK_SHARE:
                                            msgObj.updateLinkShareInfo();
                                            break;

                                        case GENERAL_CONSTANTS.MESSAGE_TYPES.STICKER:
                                            //parsedMessageText = utilsFactory.parseForLE(settings.imBase + msgObj.text);
                                            msgObj.stickerUrl = settings.stickerBase + msgObj.text;
                                            break;

                                        case GENERAL_CONSTANTS.MESSAGE_TYPES.IMAGE:
                                        case GENERAL_CONSTANTS.MESSAGE_TYPES.CAMERA_IMAGE:
                                            msgObj.updateMediaInfo();

                                            try{
                                                
                                                msgObj.mediaUrl = settings.imBase + msgObj.mediaInfo.url;    

                                            }catch(e){
                                                msgObj.mediaUrl = ""
                                            }

                                            parsedMessageText = "";

                                            break;

                                        case GENERAL_CONSTANTS.MESSAGE_TYPES.AUDIO:
                                            msgObj.updateMediaInfo();
                                            msgObj.isVideo = false;

                                            try{
                                                msgObj.mediaUrl = settings.mediaBase + msgObj.mediaInfo.url;    
                                            }catch(e){
                                                msgObj.mediaUrl = "";
                                            }
                                            

                                            break;

                                        case GENERAL_CONSTANTS.MESSAGE_TYPES.VIDEO:
                                            msgObj.updateMediaInfo();
                                            msgObj.isVideo = true;

                                            try{
                                                
                                                msgObj.mediaUrl = settings.mediaBase + msgObj.mediaInfo.url;    

                                            }catch(e){
                                                msgObj.mediaUrl = ""
                                            }
                                            
                                            break;

                                        default:
                                            parsedMessageText = ChatUtilsFactory.parseForLE(msgObj.text);
                                            break;
                                    }
                                }
                            }else{
                                if( !!message.usersToChange){
                                    parsedMessageText = tagChatHelper.getTagChatStatusMessage(message);
                                    if(!parsedMessageText){
                                        return;
                                    }
                                }
                            }

                            parsedMessageText = $sce.trustAsHtml(parsedMessageText);
                            messages.save(msgObj.key, msgObj);

                            if( !message.fromLocalHistory ){
                                updateBoxMessageMinMaxPacketId(msgObj);
                            }

                            var boxId = userId.toString();//here userId contains the boxId
                            chatHistoryFactory.addMessage(msgObj, boxId);//here we have to pass the boxId, and user contains box.getKey() from the different calling portion
                
                            if(!!sendToTab){
                                chatTabSync.sendData(GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.CHAT_MSESSAGE_UPDATE, {boxId : boxId, msg : basicMsgObj, isTagChat : message.tag_chat});
                            }

                        };

                        var pushDummyMessage = function(message, user){
                            var key = message.key || message.packetId;

                            var mdate = message.messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff || new Date().getTime();
                            var parsedMessageText = [];

                            var msgObj = {
                                key               : key,
                                text              : message.message || message.mg || message.text,
                                hrtime            : utilsFactory.chatVerbalDate(mdate),
                                status            : message.status || 0,
                                //status          : message.status || 'Received',
                                messageType       : message.messageType,
                                uploading         : message.uploading,
                                uploadProgress    : message.uploadProgress,
                                messageDate       : mdate,
                                isDeleted         : false,
                                messageDateString : message.messageDateString || '',
                                mediaUrl          : message.mediaUrl,
                                timeout           : message.timeout,
                                isSecretVisible   : message.isSecretVisible,
                                //progressValue   : message.progressValue,
                                //tempImage       : message.tempImage,
                                //user            : angular.isObject(user) ? user : userFactory.getUser(message.uId),
                                user              : angular.isObject(user) ? user : userFactory.getUser(message.userId),
                                lastUpdateTime    : new Date().getTime(),

                                sortBy: function () {
                                    return message.messageDate;
                                },
                                getTextPartition: function () {
                                    return parsedMessageText;
                                },
                                setTextPartition: function () {
                                    parsedMessageText = ChatUtilsFactory.parseForLE(msgObj.text);
                                    parsedMessageText = $sce.trustAsHtml(parsedMessageText);
                                }
                            };


                            parsedMessageText = ChatUtilsFactory.parseForLE(msgObj.text);
                            parsedMessageText = $sce.trustAsHtml(parsedMessageText);

                            messages.save(msgObj.key, msgObj);
                        };
                        var processMessage = function (message, friendId) {
                            //TODO need to process the message both messages that the user sending for show status pending/send/typing and the incoming from server for updating
                            //
                        };

                        var updateBoxMessageMinMaxPacketId = function(aMessageObject){

                            var box = returnob;
                            var packetId = aMessageObject.key || aMessageObject.packetId;

                            if( aMessageObject.status == 'status_update'){
                                try{
                                    packetId = packetId.split('_')[0];
                                }catch(e){
                                }

                            }

                            if( box.messageMaxDate < aMessageObject.messageDate ){
                                box.messageMaxDate = aMessageObject.messageDate;
                                box.messageMaxPacketId = packetId;
                            }

                            if( !box.messageMinDate || box.messageMinDate >= aMessageObject.messageDate ){
                                box.messageMinDate = aMessageObject.messageDate;
                                box.messageMinPacketId = packetId;
                            }

                        };


                        returnob = {
                            isTagChat             : false,
                            boxTitle              : "",
                            unreadCount           : 0,

                            messageMaxPacketId    : '',
                            messageMinPacketId    : '',
                            messageMaxDate        : 0,
                            messageMinDate        : 0,

                            hasHistoryMessage     : false,
                            messages              : messages.all(),

                            getTitleString : function(){

                                var box = returnob;
                                //var title = box.getTitle().slice(0, 15);
                                var title = box.getTitle();

                                if( !isTagChat && !title ){
                                    title = box.getKey();
                                }

                                if( box.unreadCount > 0 ){
                                    title = title + ' ('+ box.unreadCount +')';
                                }

                                return title;

                            },
                            updateUnreadCount : function(){
                                var box = returnob;
                                box.unreadCount = chatHistoryFactory.getUnreadMessageCountByBoxId(boxId)
                            },
                            getProfileLink : function () {
                                var box = returnob;
                                if(box.isTagChat){
                                    false;
                                }else{
                                    //return box.getUser().link();
                                    return '/profile/'+box.getUser().getKey();
                                }
                            },
                            checkWaitingTimePassed: function(){
                                var currentTime = Math.floor(Date.now()/1000);
                                if(currentTime - this.lastCommunicationTime > this.waitingTime){
                                    return true;
                                }else {
                                    return false;
                                }
                            },
                            
                           
                            pushMessage: function (message, user, sendToTab) {

                                pushMessage(message, user, sendToTab);
                            },
                            pushDummyMessage: function (message, user) {

                                pushDummyMessage(message, user);
                            },
                            sendTabUpdate : function(message){

                                var basicMsgObj = getBasicMessageObject(message);

                                chatTabSync.sendData(GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.CHAT_MSESSAGE_UPDATE, {boxId : boxId, msg : basicMsgObj, isTagChat : message.tag_chat});
                            },
                            processMessage: function (message, friendId) {
                                processMessage(message, friendId);
                            },
                            getKey: function () {
                                return userId.toString();//this contains either userId or tagId
                            },
                            getTagItem : function(){
                              return tagItem || tagChatFactory.getTag( returnob.getKey());
                            },
                            getUser: function () {
                                if(tagItem)
                                    return tagItem;
                                return user;
                            },
                            getTitle: function () {
                                if(tagItem){
                                    this.boxTitle =  tagItem.getTagName();
                                }else if(user){
                                    this.boxTitle = user.getName();
                                }

                                return this.boxTitle;
                            },
                            setTitle: function(tagTitleForNonInitingUser){
                                this.boxTitle = tagTitleForNonInitingUser;
                            },
                            isConsicutive: function (messageKey) {
                                var currentMessage = messages.get(messageKey);
                                var previousMessage = messages.previous(messageKey);

                                if (previousMessage && previousMessage.status != 'status_update' && previousMessage.user.getKey() === currentMessage.user.getKey()) {
                                    return true;
                                }
                                return false;
                            },
                            isSamePacketId: function (messageKey) {
                                return !!messages.get(messageKey.toString());
                            },
                            getMessages: function () {
                                return messages.all();
                            },
                            getMessage : function(key){
                                return messages.get(key.toString());
                            },
                            getBottomMessage : function(){
                                return messages.bottom();
                            },
                            getTopMessage : function(){
                                return messages.top();
                            },
                            removeMessage: function (key) {
                                messages.remove(key.toString());
                            },
                            updateMessageStatus : function( messageKey, status){
                                var messageObject = messages.get(messageKey);

                                if(!!messageObject){
                                    messageObject.status = status;
                                    return messageObject;
                                }
                                return false;
                            },
                            isTyping: function () {
                                return isTyping;
                            },
                            setTypingBool: function (bool) {
                                isTyping = bool;
                            },
                            isFriendTyping: function () {
                                return isFriendTyping;
                            },
                            
                            showTypingText: function(userId){
                                typingUserIds[userId] = true;
                                isTyping = isFriendTyping = true;
                            },
                            hideTypingText : function(userId){
                                delete typingUserIds[userId];
                                isTyping = isFriendTyping = false;
                            },
                            getTypingText : function(){                                
                                
                                typingText = "is typing ...";

                                if( isTagChat ){
                                    var tagItem = tagChatFactory.getTag( returnob.getKey());
                                    var userIdsToShow = Object.keys(typingUserIds);         
                                    var postfix = "is typing ..."                                                               
                                    
                                    if (typingUserIds.length > 3){
                                        userIdsToShow = typingUserIds.slice(0, 3);                                            
                                        psotfix = " and " + typingUserIds.length - 3 + " others are typing...";
                                    }

                                    var usersNamesToShow = [];
                                    userIdsToShow.forEach(function(anUserId){
                                        var user = tagItem.getMember(anUserId)
                                        usersNamesToShow.push(user.getName()) 
                                    })

                                    typingText = usersNamesToShow.join(",") + postfix                                    
                                }else{
                                    typingText = returnob.getUser().getName() + ' ' + typingText; 
                                }

                                return typingText;
                            }, 
                            setFriendTypingBool: function (bool) {
                                isFriendTyping = bool;
                            },
                                                       
                            
                            startTimer: function () {//need to recheck what the problem is, right now we're going with previous way where timer was started from different places
                                var box = returnob;
                                var messages = box.getMessages();
                                if(angular.isArray(messages) && messages.length>0) {
                                    for(var m = 0; m< messages.length; m++) {
                                        if (messages[m].value.timeout > 0 && box.isMinimized == false && box.isHidden == false && !messages[m].value.timerStartFlag) {
                                            switch (messages[m].value.messageType){
                                                case 2:
                                                case 3:
                                                case 4:
                                                case 5:
                                                case 6:
                                                    var timeoutCount = messages[m].value.timeout;
                                                    var mes = messages[m].value;
                                                    mes.key = mes.packetId;
                                                    messages[m].value.timerStartFlag = true;
                                                    var testTimeoutDeleteFunc = function (me, timeoutCount) {
                                                        $rootScope.$broadcast('timeoutDelete', me.key, timeoutCount);
                                                    };//this fucking semicolon(;) caused me "TypeError: (intermediate value)(...) is not a function" ggrgrrrrrrr...
                                                    (function (mes, timeoutCount) {
                                                        $interval(function () {
                                                            testTimeoutDeleteFunc(mes, timeoutCount--);
                                                        }, 1000, timeoutCount + 1);
                                                    })(mes, timeoutCount);
                                                    break;
                                            }//end of messageType switch

                                        }// end of conditions for starting timer
                                    } // end of for loop for all messages
                                }// end of isArray(messaged)
                            },
                            
                            updateBoxMessageMinMaxPacketId : updateBoxMessageMinMaxPacketId,

                            loadHistoryMessages : function(){
                                var box = returnob;

                                var minDate, maxDate, statsuChanged = false;

                                var historyMessages = chatHistoryFactory.getMessages(boxId);
                                if(historyMessages){
                                    for(var h=0; h<historyMessages.length; h++){
                                        var aHistoryMessage = historyMessages[h];

                                        updateBoxMessageMinMaxPacketId(aHistoryMessage);

                                        aHistoryMessage.fromLocalHistory = true;
                                        
                                        var retrySendMessage = false;

                                        if( aHistoryMessage.status == 0){ 
                                            if( (getChatServerCurrentTime() - aHistoryMessage.messageDate)  >  120*1000   ){

                                                aHistoryMessage.status = 'Failed';
                                                statsuChanged = true;
                                            }else{
                                                retrySendMessage=true; 
                                                
                                            }
                                            
                                        }

                                        pushMessage(aHistoryMessage, profileFactory.getUserObjectByUId(aHistoryMessage.user));
                                        if(retrySendMessage){
                                           
                                           //ChatPacketSenderService.retryMessage(box, aHistoryMessage.text, aHistoryMessage.messageData );
                                           
                                        }
                                    }
                                }

                                if( statsuChanged ){
                                    chatHistoryFactory.updateMessages( historyMessages, boxId )
                                }



                                box.updateUnreadCount();

                                utilsFactory.triggerCustomEvent('CHAT_HISTORY_LOADED', { boxId : boxId});
                            }




                        };

                        return returnob;

                    }
                };
            }
        ]);
})();

(function(){
    'use strict';

    var ChatWorker;
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}

    chatApp.factory('ChatConnector', ChatConnector);

    ChatConnector.$inject = [
        '$rootScope', '$q', 'Auth',        
        'ChatUtilsFactory', 'settings'];

    
    function _updateGobal(key, value){
        CHAT_APP.GLOBALS[key] = value;
    }

    function ChatConnector($rootScope, $q, Auth, ChatUtilsFactory, settings ) {


        var Constants = CHAT_APP.Constants;
        var CHAT_PACKET_INFO = CHAT_APP.PacketFormats.CHAT_PACKET_INFO;
        var WORKER_NOTIFIER_TYPES = Constants.WORKER_NOTIFIER_TYPES;
        var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;

		var _callbacks = {};

        ChatWorker = new Worker(window.location.origin + GENERAL_CONSTANTS.CHAT_WORKER_PATH );

        var _logRequest = function(data, type){
            try{
                var packetName = CHAT_PACKET_INFO[data.packetType]['PACKET_NAME'];
            }catch(e){
                
            }
            

        };

        var _addCallback = function(packetId, fn, fnContext){
            
            if(!_callbacks[packetId]){
                _callbacks[packetId] = [];
            }
            fnContext = fnContext || null;
            _callbacks[packetId] = { ctx: fnContext, fn : fn, ct : Date.now() }
        };
         
        var _init = function(){

            var aMessage = {
                command : 'SETTINGS',
                url : settings.socketProtocol + window.location.host +'/ChatSocket/' + window._cti,
                tabId : window._cti,
                salt : Cookies.get('sId'),//auth server sId
                sKey : Cookies.get('sessionID'),//session id webserver                                
                appVersion : settings.apiVersion,
                CLIENT_DATA_SIZE : 512
            }

            try{
                
                var currentUserId = Auth.currentUser().getKey();
                if( currentUserId ){
                    aMessage['uId']  = Auth.currentUser().getKey();
                }    

                aMessage['oIpPort'] = ChatUtilsFactory.getOfflineIpPort();

            }catch(e){
            }
                        
            try{
                
                ChatWorker.postMessage(aMessage, [RingMessageChannel.port2]);    

            }catch(e){

            }
            
            _updateGobal('uId', currentUserId);
            _updateGobal('appVersion', settings.apiVersion);

            
        };

        var _send = function(data,packId,port){
            
            if(port && data){
                ChatWorker.postMessage({
                    command : 'SEND',
                    packetId : packId,
                    data : data,
                    port : port,
                    action : data.actn
                });
            }else{
                throw new Error("You must sent data and port");
            }

        };

        ChatWorker.addEventListener('error',function(e){
        });

        ChatWorker.addEventListener('message',function(messageEvent){

            switch (messageEvent.data.notifier){

                case WORKER_NOTIFIER_TYPES.DEBUG:
                    
                    try{

                    }catch(e){

                    }
                    break;

                case WORKER_NOTIFIER_TYPES.CHAT_DATA_RECEIVED:
                    
                    if( !!messageEvent.data.object){
                        $rootScope.$broadcast("chatDataReceived",{ 'jsonData' : messageEvent.data.object });

                    }
                    break;

                case WORKER_NOTIFIER_TYPES.AUTH_DATA_RECEIVED:

                    if( !!messageEvent.data.object){
                        $rootScope.$broadcast("authDataReceived",{ 'jsonData' : messageEvent.data.object });

                    }
                    break;                    

                case WORKER_NOTIFIER_TYPES.CHAT_REQUEST_RESPONSE:
                    
                    var packetId = messageEvent.data.object.packetId;
                    var response = messageEvent.data.object;
                    var callbackObject = _callbacks[packetId];

                    if( !!packetId && !!callbackObject ){
                        if( !!response.notify){
                            callbackObject.fn.notify.call(callbackObject.ctx, response);
                            
                        }else if( response.sucs){
                            callbackObject.fn.resolve.call(callbackObject.ctx, response);

                        }else if ( response.error ){
                            callbackObject.fn.resolve.call(callbackObject.ctx, response);

                        }else if ( !response.sucs ){
                            callbackObject.fn.resolve.call(callbackObject.ctx, response);
                        }
                    }
                    
                    delete _callbacks[packetId]
                    break;

                case WORKER_NOTIFIER_TYPES.AUTH_REQUEST_RESPONSE:                    
                    break;

                case WORKER_NOTIFIER_TYPES.EXCEPTION:                    
                    try{

                    }catch(e){

                    }                    
                    break;
                                
            }

        });
    
        return {
            initiate: _init,
            sendCommand : function(commandName, params){
                var baseParams = { 'command' : commandName, tabId   : window._cti };
                var message = angular.extend({}, params, baseParams);
                ChatWorker.postMessage(message);

            },
            sendGlobal : function(key, value){
                _updateGobal(key, value);
                
                var message     = {
                    command : 'UPDATE_GLOBALS',
                    tabId   : window._cti,
                };
                
                message[key]    = value;
                ChatWorker.postMessage(message);

            },
            rawSend: function ( data ) {

                ChatWorker.postMessage({
                    command : 'RAW_SEND',
                    tabId : window._cti,
                    object : data
                });

            },            
            send: function ( data, retryCount ) {
                //todo below line should be deleted in prod
                _logRequest(data, 'send');

                ChatWorker.postMessage({
                    command : 'SEND',
                    tabId : window._cti,
                    object : data,
                    retryCount : retryCount
                });

            },
            request: function ( data, retryCount ) {
                //todo below line should be deleted in prod
                _logRequest(data, 'request');

                var defer = $q.defer();

                if( !data.packetId ){
                    data.packetId = ChatUtilsFactory.getUUIDPacketId()
                }

                _addCallback(data.packetId, defer, this);

                ChatWorker.postMessage({
                    command : 'REQUEST',
                    tabId : window._cti,
                    object : data,
                    retryCount : retryCount

                });

                return defer.promise;

            }
        }
    }

})();

/*
 * Md. Ibrahim Rashid
 * © Ipvision
 */

(function() {
    'use strict';

    var ChatApp = angular.module('ringid.chat');

    ChatApp.factory('ChatExceptions', ChatExceptions);

    ChatExceptions.$inject = [];

    function ChatExceptions(){

        function ChatPacketException(msg, code){
            if(!code){
            }else{
            }
        }

        return {
            ChatPacketException : ChatPacketException

        }

    }


})();

/**
 * Created by mahbubul on 3/5/15.
 */
(function () {
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {

    }

    chatApp
        //box
        .factory('ChatFactory', ['settings',
            'Storage', '$$stackedMap',
            'ChatMap', 'Auth', 'utilsFactory', 
            'ChatConnector',
            'chatHistoryFactory', 'profileHttpService','userFactory','friendsFactory',
            'tagChatFactory', '$interval', 'SystemEvents', 'OPERATION_TYPES',
            
            'profileFactory',

            function (settings,
                      Storage,  $$stackedMap,
                      ChatMap, Auth, utilsFactory,
                      ChatConnector,
                      chatHistoryFactory,profileHttpService,userFactory, friendsFactory,
                      tagChatFactory, $interval, SystemEvents, OPERATION_TYPES,
                      profileFactory

            ) {

                // var Constants = CHAT_APP.Constants;

                var getUUIDPacketId = tagChatFactory.getUUIDPacketId;

                var SESSION_TYPES = CHAT_APP.Constants.GENERAL_CONSTANTS.SESSION_TYPES;

                var boxes = $$stackedMap.createNew();


                var getNumberOfAvailableChatBox = function (viewportXValue) { //return 4;

                    // left panel   : 200 px
                    // right panel  : 200 px
                    // hidden list  : 165 px
                    // box width    : 300 px
                    // padding      :  10 px
                    //var avaiable_width = utilsFactory.viewport.x - 400 - 100;
                    if(!!viewportXValue){
                        var avaiable_width = viewportXValue - 400 - 165;
                    }else{
                        var avaiable_width = utilsFactory.viewport.x - 400 - 165;
                    }
                    var box_counter = parseInt(avaiable_width / 310);
                    return box_counter;
                };

                //var numberOfAvailableChatBox = getNumberOfAvailableChatBox();

                var processInMessage = function (message) {// right now it may not in action

                    var friendId = message.friendName.split(",")[0];

                    var box = getBox(friendId);
                    // boxes.add(friendId,box);
                    if (angular.isArray(message.messageList)) {
                        for (var i = 0; i < message.messageList.length; i++) {
                            box.pushMessage(message.messageList[i]);
                        }
                    }
                };

                var getBoxObjectClass = function(userId){
                    var chatBoxClass = {
                        key                 : userId,
                        isMinimized         : false,
                        isHidden            : false,
                        isFocused           : false,
                        blinkOn             : false,
                        timeout             : 5,
                        secretChat          : false,
                        nonDomBox           : false,
                        closedBox           : false,
                        offlineStatus       : false,
                        blocked             : false,
                        blockedByUtId       : [],
                        isSecretVisible     : true,
                        singlePage          : false,
                        lastSeenBar         : true,
                        unreadCount         : 0,
                        chatBoxClass        : 'chat-body-opened'
                    };

                    return chatBoxClass;

                };


                var getNewBoxObject = function(userId, isTagChat, boxInfo){
                    userId = userId.toString();

                    if(!boxInfo){
                        boxInfo = {};
                    }

                    var box = boxes.get(userId);
                    if (box !== false) {
                        return box;
                    } else {
                        box = ChatMap.create(userId, isTagChat);
                    }

                    if(!isTagChat){

                        profileFactory.getUserObjectByUId(userId);
                        profileHttpService.fetchPresence([userId]);
                    }

                    var boxChatBoxObject = getBoxObjectClass(userId);
                    boxChatBoxObject.isFocused = true;
                    boxChatBoxObject.nonDomBox = true;
                    boxChatBoxObject.isTagChat = isTagChat;
                    boxChatBoxObject.lastLogin = (!!box.getUser() && box.getUser().lastOnline) ? box.getUser().lastOnline() : '';


                    boxChatBoxObject = angular.extend(box, boxChatBoxObject, boxInfo);

                    return boxChatBoxObject;
                };

                var getBox = function (userId, isTagChat) {

                    var box = getNewBoxObject(userId, isTagChat);

                    boxes.save(userId, box);

                    chatHistoryFactory.addBox(box);    //for adding box to localStorage for saving chatHistory

                    return box;
                };

                var openChatBox = function (userId, sendToTab) {
                    userId = userId.toString();

                    var box = boxes.get(userId);
                    if (box === false) {

                        box = getBox(userId, false);
                        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.BOX_OPENNED, {boxId: userId, sendToTab : sendToTab} )
                        
                    } else {

                        if( !box.nonDomBox ){
                            utilsFactory.triggerCustomEvent(SystemEvents.CHAT.BOX_OPENNED, {boxId: userId, sendToTab : sendToTab} )                            
                        }

                        box.isFocused = true;
                        box.nonDomBox = true;
                        box.blinkOn   = false;
                        chatHistoryFactory.updateBox(box);
                    }
                };
                var openTagChatBox = function (groupId, sendToTab) {
                    groupId = groupId.toString();

                    var box = boxes.get(groupId);
                    if (box === false) {
                        box = getBox(groupId, true);

                        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.BOX_OPENNED, {boxId: groupId, sendToTab : sendToTab} )  

                    } else {

                        if( !box.nonDomBox ){
                            utilsFactory.triggerCustomEvent(SystemEvents.CHAT.BOX_OPENNED, {boxId: groupId, sendToTab : sendToTab} )                            
                        }

                        box.isFocused = true;
                        box.nonDomBox = true;
                        box.blinkOn   = false;
                        chatHistoryFactory.updateBox(box);
                    }
                
                    return box;
                };
                var createNonDomBox = function (userId, isTagChat) {
                    userId = userId.toString();

                    var box = ChatMap.create(userId, isTagChat);

                    var boxChatBoxObject = getBoxObjectClass(userId);
                    boxChatBoxObject.closedBox = true;
                    boxChatBoxObject.isTagChat = isTagChat;

                    boxChatBoxObject = angular.extend(box, boxChatBoxObject);
                    boxes.save(userId, boxChatBoxObject);

                    chatHistoryFactory.addBox(boxChatBoxObject);//for adding box to localStorage for saving chatHistory

                    return box;
                };


                /*
                 * Description: to make the hidden chatbox visible
                 * param: userId (which is the key for the stackmap)
                 * Date: 04-04-15
                 * Developed By: rabbi
                 * */                //
                var makeVisibleChatBox = function (userId) {
                    userId = userId.toString();

                    var boxObject = boxes.get(userId);// get the box object from boxes using key(userId), which returns the only value not the key
                    if (boxObject !== false) {
                        boxes.remove(userId); //remove from the boxes with the key (userId)
                        boxes.save(userId, boxObject);// reAdd the same box object into boxes using key(userId), so it would add at the end of the stack
                    }
                };
                var closeChatBox = function (userId) {
                    /* to make the box closed we'll need to change the box close property
                     instead of removing it from the stackMap
                     box.closedBox = false;// will always be true and only be false when user closes box
                     need to send unregister packet only for online users
                     offline box will have no ip/port so in that case we won't send unregister packet */

                    userId = userId.toString();
                    var box = boxes.get(userId);
                    box.closedBox = true;
                    chatHistoryFactory.updateBox(box);

                    // if(!!box.getIp()){
                    //     ChatWorkerCommands.endChatSession(userId, SESSION_TYPES.FRIEND)                        
                    // }

                    // box.stopInterval();
                    
                    boxes.remove(userId);
                };

                var closeTagChatBox = function (tagId) {
                    tagId = tagId.toString();
                    var box = boxes.get(tagId);
                    box.closedBox = true;
                    chatHistoryFactory.updateBox(box);

                    // box.stopInterval();

                    boxes.remove(tagId);
                };

                var minimizeBox = function (userId) {
                    userId = userId.toString();
                    var box = boxes.get(userId);
                    //if(!!box.blinkOn && !box.isMinimized){//true false: if blinking is on then it won't minimize
                    //
                    //} else if(!!box.blinkOn && !!box.isMinimized){//true true:
                    //
                    //} else if(!box.blinkOn && !box.isMinimized){// false true:
                    //    box.chatBoxClass = 'chat-body';
                    //    box.isMinimized = !box.isMinimized;
                    //} else if(!box.blinkOn && !!box.isMinimized){ // false false:
                    //    box.chatBoxClass = 'chat-body-opened';
                    //    box.isMinimized = !box.isMinimized;
                    //}
                    box.isMinimized = !box.isMinimized;
                    // might need to handle the case where if box is minimized then it will be isFocus false(but will not need 'cause it is handle in chatFocus onclick)
                    if (box.isMinimized){
                        box.isFocused = false;
                        box.chatBoxClass = 'chat-body';
                    }else{
                        box.isFocused = true;
                        box.chatBoxClass = 'chat-body-opened';
                    }
                    chatHistoryFactory.updateBox(box);
                };

                var refreshBox = function(boxId){

                    chatHistoryFactory.loadChatBoxes();

                    var historyBox = chatHistoryFactory.getBox(boxId);

                    var chatbox = boxes.get(boxId);

                    if( !chatbox){

                        if( !historyBox.closedBox ){
                            var boxChatBoxObject = getNewBoxObject(boxId, historyBox.isTagChat, historyBox);
                            boxes.save(boxId, boxChatBoxObject);

                            boxChatBoxObject.loadHistoryMessages();

                        }


                    }else{

                        if( !historyBox.closedBox ){

                            angular.extend(chatbox, historyBox);
                            chatbox.loadHistoryMessages();

                        }else {
                            boxes.remove(boxId);
                        }
                    }

                };

                var openAndAddMessage = function(boxId, message){
                    if(!message){
                        return;
                    }

                    var currentUser = Auth.currentUser();

                    var box = boxes.get(boxId);

                    if(!box){

                        if(!!message.tag_chat){
                            var tag = tagChatFactory.getTag(boxId);
                            if( tag.isTagSafeToShow()){
                                openTagChatBox(boxId);
                            }
                        }else{
                            openChatBox(boxId);
                        }

                        box = getBox(boxId, message.tag_chat);
                        box.loadHistoryMessages();

                    }else{
                        box.nonDomBox = true;
                        box.pushMessage(message, currentUser);
                    }

                    utilsFactory.triggerCustomEvent('NEW_MESSAGE_PUSHED', {boxId : boxId, scroll : 'bottom'});

                };


                return {
                    openChatBox        : openChatBox,
                    openTagChatBox     : openTagChatBox,
                    closeTagChatBox    : closeTagChatBox,
                    creatNonDomBox     : createNonDomBox,
                    makeVisibleChatBox : makeVisibleChatBox,
                    processInMessage   : processInMessage,
                    closeChatBox       : closeChatBox,
                    refreshBox         : refreshBox,
                    minimizeBox        : minimizeBox,
                    getUUIDPacketId    : getUUIDPacketId,
                    openAndAddMessage  : openAndAddMessage,

                    getBoxes: function () {
                        return boxes.all();
                    },

                    ggg: function () {
                        return boxes.nonClosedLength();
                    },
                    
                    getBoxByUId : function(uId){
                        return boxes.get(uId);
                    },

                    getNumberOfAvailableChatBox: function (viewportXValue) {
                        //return numberOfAvailableChatBox;
                        return getNumberOfAvailableChatBox(viewportXValue);
                    },

                    getNonClosedLength: function () {
                        return boxes.nonClosedLength();
                    },

                    increaseUnreadMessageCount : function(boxId, messageId){
                        chatHistoryFactory.addUnreadMessageInfo(boxId, messageId);
                        chatHistoryFactory.updateUnreadMessageInfos();
                    },

                    decreaseUnreadMessageCount : function(boxId, messageId){
                        chatHistoryFactory.removeUnreadMessageInfo(boxId, messageId);
                        chatHistoryFactory.updateUnreadMessageInfos()
                    },

                    getUnreadMessageCount : function(){
                        return chatHistoryFactory.getUnreadMessageCount();
                    },

                    getUnreadConversationCount : function(){
                        return chatHistoryFactory.getUnreadConversationCount();
                    }

                  

                };
            }
        ]);



})();


(function() {
    'use strict';
    angular
        .module('ringid.chat')
        .factory('ChatHelper', ChatHelper);

    ChatHelper.$inject = ['SystemEvents', 'ChatFactory', 'OPERATION_TYPES',
                          'ChatConnector', 'ChatWorkerCommands',
                          'Auth', '$interval', 
                          'utilsFactory', 'chatHistoryFactory', 'profileFactory'];

    function ChatHelper ( SystemEvents, ChatFactory, OPERATION_TYPES,
                          ChatConnector, ChatWorkerCommands,
                          Auth, $interval, 
                          utilsFactory, chatHistoryFactory, profileFactory

    ) {

        var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;

        return {
            sendChatSeenConfirmation    : _sendChatSeenConfirmation,
            startTimerText              : _startTimerText,
            startTimerOthers            : _startTimerOthers,
            decreaseUnreadCount         : _decreaseUnreadCount,
            increaseUnreadCount         : _increaseUnreadCount,
            deleteMessageFromOwn        : _deleteMessageFromOwn,
            loadHistoryMessageForF2FChat: _loadHistoryMessageForF2FChat

        };


        ///////////////////

       

        function _decreaseUnreadCount(box,number){
            if(!number){
                _resetUnreadCount(box);
                
            }else{
                if((box.unreadCount - number)> 0){
                    box.unreadCount -= number;
                }
                else if ((box.unreadCount - number) < 0){
                    box.unreadCount = 0;
                } else{
                    box.unreadCount = 0;
                }    
            }
            
            chatHistoryFactory.updateBox(box);
            chatHistoryFactory.removeUnreadMessageInfoByBoxId(box.getKey());

            utilsFactory.triggerCustomEvent(SystemEvents.CHAT.BOX_UPDATED, { boxId: box.getKey() });
        }

        function _resetUnreadCount(box){
            box.unreadCount = 0;
        }

        function _increaseUnreadCount(box,number){
            if(!!box && box.isFocused === false){
                box.unreadCount += number;
            }
        }

        function _deleteMessageFromOwn(box,message){
            if(!!box){
                if(!!message.key){
                    //if(message.user.getKey().toString() === Auth.loginData.uId.toString())
                    box.removeMessage(message.key);
                    chatHistoryFactory.removeMessage(message.key, box.getKey());
                    var messages = box.getMessages();
                    for(var k=0,length=messages.length; k<length; k++){
                        messages[k].value.showDate = messages[k].value.takeDecisionForShowingDate();
                        messages[k].value.showAvator = messages[k].value.takeDecisionForShowingMessageUserAvator();
                    }
                    utilsFactory.triggerCustomEvent("SINGLE_BOX_UPDATED", { boxId: box.getKey() });
                }
            }
        }

        function _startTimerText(scope, messages) {
            /*start timer for incoming secret message automatically if box is opened and not minimized: starts*/
            //scope.box.value.startTimer();
            if(messages.length <1){
                return;
            }
            for(var m= 0, l= messages.length; m < l; m++) {
                if (messages[m].value.timeout > 0 && !messages[m].value.timerStartFlag) {
                    switch (messages[m].value.messageType) {
                        case 2:
                        case 3:
                        case 4://this is for location
                        case 5://this is for url
                        case 6:
                            //messages[m].value.text = "Removed...";
                            var timeoutCount = messages[m].value.timeout;
                            var mes = messages[m].value;
                            messages[m].value.timerStartFlag = true;
                            //messages[m].value.timeout = 0;
                            var timoutDeleteFunc = function (me, scope, timeoutCount) {
                                scope.$broadcast('timeoutDelete', me.key, timeoutCount);
                            };
                            var testTimeoutDeleteFunc = function (me, timeoutCount) {
                                scope.$broadcast('timeoutDelete', me.key, timeoutCount);
                            };//this fucking semicolon(;) caused me "TypeError: (intermediate value)(...) is not a function" ggrgrrrrrrr...
                            //$timeout( timoutDeleteFunc.bind(null,messages[m].value,scope), tT * 1000, true);
                            //$interval( function(){ testTimeoutDeleteFunc(mes, timeoutCount--)}, 1000, timeoutCount+1);
                            (function (mes, timeoutCount) {
                                $interval(function () {
                                    testTimeoutDeleteFunc(mes, timeoutCount--);
                                }, 1000, timeoutCount + 1);
                            })(mes, timeoutCount);
                            break;
                    }// end of switch for mesaggetype
                }//end of if timeout>0
            }
            /*start timer for incoming secret message automatically if box is opened and not minimized: ends*/
        }

        function _startTimerOthers(scope, message) {
            // this function will only be called if user clicks on secret image/audio/video
            // so this will always get single messageObject
            /*start timer for incoming secret message automatically if box is opened and not minimized: starts*/
            //scope.box.value.startTimer();
            if (!message[0].value) {
                return;
            }
            if (message[0].value.timeout > 0 && !message[0].value.timerStartFlag) {
                switch (message[0].value.messageType) {
                    case 7://IMAGE_FILE_FROM_GALLERY
                    case 8://AUDIO_FILE
                    case 9://VIDEO_FILE
                    case 10://IMAGE_FILE_FROM_CAMERA
                        //messages[m].value.text = "Removed...";
                        //todo need to reset timeout according to audio/video length
                        var timeoutCount = message[0].value.timeout;
                        var mes = message[0].value;
                        message[0].value.timerStartFlag = true;
                        //messages[m].value.timeout = 0;
                        var timoutDeleteFunc = function (me, scope, timeoutCount) {
                            scope.$broadcast('timeoutDelete', me.key, timeoutCount);
                        };
                        var testTimeoutDeleteFunc = function (me, timeoutCount) {
                            scope.$broadcast('timeoutDelete', me.key, timeoutCount);
                        };//this fucking semicolon(;) caused me "TypeError: (intermediate value)(...) is not a function" ggrgrrrrrrr...
                        //$timeout( timoutDeleteFunc.bind(null,messages[m].value,scope), tT * 1000, true);
                        //$interval( function(){ testTimeoutDeleteFunc(mes, timeoutCount--)}, 1000, timeoutCount+1);
                        (function (mes, timeoutCount) {
                            $interval(function () {
                                testTimeoutDeleteFunc(mes, timeoutCount--);
                            }, 1000, timeoutCount + 1);
                        })(mes, timeoutCount);
                        break;
                }// end of switch for mesaggetype
            }//end of if timeout>0
            /*start timer for incoming secret message automatically if box is opened and not minimized: ends*/
        }

     

        function _sendChatSeenConfirmation(ip, port, userId, friendId, packetId){

            var seendConfirmationObject = CHAT_APP.ChatRequests.getFriendChatSeenConfirmationObject(friendId, packetType );            
            ChatConnector.send(seenConfirmationObject);
        }
     
        function _loadHistoryMessageForF2FChat(boxId, box){

            if( !box){
                box = ChatFactory.getBoxByUId(boxId);
            }

            if(!box){
                return;
            }

            box.loadHistoryMessages();
        }

    

    }
})();

(function() {
    'use strict';
    angular
        .module('ringid.chat')
        .service('ChatPacketSenderService', ChatPacketSenderService);

    ChatPacketSenderService.$inject = ['Auth', 'utilsFactory',
        'ChatFactory',
        'tagChatFactory',        
        "ChatUtilsFactory", 
        "$q",
        "chatHistoryFactory", "chatTabSync", "ChatConnector", "ChatWorkerCommands", "SystemEvents"

    ];
    function ChatPacketSenderService (Auth, utilsFactory,
                               ChatFactory, 
                               tagChatFactory,
                               ChatUtilsFactory, 
                               $q, 
                               chatHistoryFactory, chatTabSync, ChatConnector, ChatWorkerCommands, SystemEvents

    ) {

        var self = this;

        var Constants = CHAT_APP.Constants;

        var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;
        var TAG_CHAT_PACKET_TYPE = Constants.TAG_CHAT_PACKET_TYPE;
        var FRIEND_CHAT_PACKET_TYPE = Constants.FRIEND_CHAT_PACKET_TYPE;
        var OFFLINE_PACKET_TYPE = Constants.OFFLINE_PACKET_TYPE;
        var CHAT_STATES = Constants.CHAT_STATES;

        var PLATFORM = Constants.PLATFORM;
        var SESSION_TYPES = GENERAL_CONSTANTS.SESSION_TYPES;


        var getUUIDPacketId = tagChatFactory.getUUIDPacketId;


        var processMsgForLinkShare = function(msgObj, ogData){
            if(!!ogData && !!ogData.url){
                var plainText = msgObj.message;

                var jsonMessage = {
                    u : ogData.url,
                    d: ogData.description,
                    t: ogData.title,
                    i: ogData.image,
                    m : plainText
                };

                msgObj.message = angular.toJson(jsonMessage);

            }
            return msgObj;
        };

        var processMsgForLocationShare = function(msgObj, locationData){
            if( !!locationData && !!locationData.lat){

                msgObj.la = locationData.lat; // PacketDataParse.Float32ToInt();
                msgObj.lo = locationData.lng; //PacketDataParse.Float32ToInt();
                msgObj.loc = locationData.description;

                var jsonMessage = {
                    lo : msgObj.lo,
                    la : msgObj.la,
                    loc : msgObj.loc
                };

                msgObj.message = angular.toJson(jsonMessage);

            }
            return msgObj;
        };

        var processMsgForMedia = function(msgObj, mediaData){
            if( !!mediaData && !!mediaData.url){

                var jsonMessage = {
                    u : mediaData.url,
                    c : mediaData.caption,
                    w : mediaData.width,
                    h : mediaData.height
                };

                msgObj.message = angular.toJson(jsonMessage);

                msgObj.mediaUrl = mediaData.url;

                msgObj.plainText = mediaData.caption;

            }
            return msgObj;
        };

        var getMessageObject = function(box, message, messageType, messageData){
            var msgObj, keyOrPacketId,
                isEditedMessage = false,
                packetType, brokenPacketType,
                currentUser = Auth.currentUser(),
                currentUserId = Auth.currentUser().getKey(),
                messageDate = ChatUtilsFactory.getChatServerCurrentTime(),
                isTagChat = box.isTagChat;

                // ip = box.getIp(),
                // port = box.getPort();


            if(box.editMessageKey){
                keyOrPacketId = box.editMessageKey;
                box.editMessageKey = undefined;
                messageDate = box.editMessageDate;
                box.editMessageDate = undefined;

                isEditedMessage = true;

                if( !!isTagChat ){

                    packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG_EDIT;
                    brokenPacketType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG_EDIT;
                }else{

                    packetType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG_EDIT;
                    brokenPacketType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG_EDIT;
                }


            }else{
                keyOrPacketId = getUUIDPacketId(messageDate);

                if( !!isTagChat ){

                    packetType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_MSG;
                    brokenPacketType = TAG_CHAT_PACKET_TYPE.TAG_CHAT_BROKEN_MSG;
                }else{

                    packetType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_MSG;
                    brokenPacketType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_BROKEN_MSG;
                }

            }

            msgObj = {
                isEdit              : isEditedMessage,
                tag_chat            : false,            
                packetType          : packetType,
                brokenPacketType    : brokenPacketType,
                fullName            : currentUser.getName(),
                userId              : currentUserId,                                     // used to construct packetData for sending
                messageType         : messageType,                                      // 2 for plain text message
                messageDate         : messageDate,                                      //in second instead of millisecond, need to * with 1000 in the receiver end
                message             : message,                                          // used to construct packetData for sending
                key                 : keyOrPacketId,                                    // added "ring" later
                packetId            : keyOrPacketId,                                    // used to construct packetData for sending
                isSecretVisible     : box.isSecretVisible ? 1 : 0,
                timeout             : 0,
                platform            : PLATFORM.WEB
            };

            if( isTagChat ){//for tagChat
                var tagId = box.getKey();
                msgObj.tag_chat = true;
                msgObj.tagId = tagId;

            }else{ //for individual chat
                msgObj.friendId  = box.getUser().getKey();
                if(box.secretChat){
                    msgObj.timeout = box.timeout;
                }else{
                    msgObj.timeout = 0;
                }
            }

            return msgObj;

        };

        var messagePreSendProcess = function(msgObj, messageData){

            if( utilsFactory.hasEmoticon(msgObj.message) ){
                msgObj.messageType = 3;
            }

            switch (msgObj.messageType){
                case GENERAL_CONSTANTS.MESSAGE_TYPES.LOCATION_SHARE:
                    processMsgForLocationShare(msgObj, messageData.locationData);
                    break;
                case GENERAL_CONSTANTS.MESSAGE_TYPES.LINK_SHARE:
                    processMsgForLinkShare(msgObj, messageData.ogData);
                    break;
                case GENERAL_CONSTANTS.MESSAGE_TYPES.IMAGE:
                case GENERAL_CONSTANTS.MESSAGE_TYPES.CAMERA_IMAGE:
                case GENERAL_CONSTANTS.MESSAGE_TYPES.VIDEO:
                    processMsgForMedia(msgObj, messageData.mediaData);
                    break;
            }

        };

        var updateBoxMessageStatus = function(box, msgObj, status){

            var boxMessageObject = box.getMessage(msgObj.packetId);
            if(!!boxMessageObject){
                boxMessageObject.status = status;

                chatHistoryFactory.updateMessage(boxMessageObject, box.getKey());
                utilsFactory.triggerCustomEvent(SystemEvents.CHAT.BOX_UPDATED, { boxId: box.getKey() });
            }
        };

        var pushMessageToBox = function(box, msgObj){
            var currentUser = Auth.currentUser();
            box.pushMessage(msgObj, currentUser, true);
        }

        var getSendMessageObject = function(box, message, messageType, messageData){
            
            var msgObj = getMessageObject(box, message, messageType, messageData);                
            messagePreSendProcess(msgObj, messageData);

            return msgObj;

        }

        function _handleFailedMessageSend( response ){

            var boxId = response.boxId;
            var packetId = response.packetId;

            if( !!boxId && !!packetId){
                var box = ChatFactory.getBoxByUId( boxId );
                if( !box ){
                    var message = chatHistoryFactory.getMessage( boxId, packetId);
                    message.status = 'Failed';
                    chatHistoryFactory.updateMessage( message, boxId );
                }else{

                    updateBoxMessageStatus(box, {packetId : packetId }, 'Failed')
                }                

            }else{
            }
        }

        var sendMessage = function(box, message, messageType, messageData){
        
            var messageObject = getSendMessageObject( box, message, messageType, messageData);

            pushMessageToBox(box, messageObject);

            messageObject.message =  messageObject.message.utf8Encode();

            setTimeout(function(){
                ChatConnector.request(messageObject).then(function(response){
                    if( !response.sucs ){
                        response.boxId = box.getKey();
                        _handleFailedMessageSend( response );
                    }
                });    
            });
            
            
        };
    
        var retryMessage = function(box, boxMessageObject, messageData){
            
            if(!!boxMessageObject.tag_chat){
                boxMessageObject.tagId = box.getKey();
            }else {
                boxMessageObject.friendId = box.getKey();
            }

            var messageObject = getSendMessageObject( box, boxMessageObject.text, boxMessageObject.messageType, boxMessageObject.messageData);

            messageObject.message =  messageObject.message.utf8Encode();

            messageObject.packetId = boxMessageObject.packetId;

            messageObject.key = boxMessageObject.packetId;

            boxMessageObject.status = 'Pending';

            setTimeout(function(){
                ChatConnector.request(messageObject).then(function(response){
                    if( !response.sucs ){
                        response.boxId = box.getKey();
                        _handleFailedMessageSend( response );
                    }
                }); 
            });

        };

        var sendTypingPacket = function (box) {
            var requestObject;
            if(box.isTagChat){
                requestObject = CHAT_APP.ChatRequests.getTagChatTypingObject(box.getKey())            
            }else{
                requestObject = CHAT_APP.ChatRequests.getFriendChatTypingObject(box.getKey())
            }

            ChatConnector.rawSend(requestObject);

        };

       

        var sendChatUnRegisterPacket = function(box){

            var requestObject,
                onilneStatus = 0
                userMood = 0;
            if(box.isTagChat){
                requestObject = CHAT_APP.ChatRequests.getFriendChatUnregisterObject(box.getKey(), onilneStatus, userMood);           
            }else{
                requestObject = CHAT_APP.ChatRequests.getTagChatTagUnregisterObject(box.getKey(), onilneStatus, userMood);
            }

            ChatConnector.send(requestObject);

        };

        var getMessageType = function( messageData ){
            var messageType = GENERAL_CONSTANTS.MESSAGE_TYPES.TEXT;

            if(!!messageData.locationData.lat){
                messageType =  GENERAL_CONSTANTS.MESSAGE_TYPES.LOCATION_SHARE;
            }else if(!!messageData.ogData.url){
                messageType =  GENERAL_CONSTANTS.MESSAGE_TYPES.LINK_SHARE;
            }  

            return messageType;
        }


        self.sendMessage = sendMessage;
        self.retryMessage = retryMessage;

        self.sendTypingPacket = sendTypingPacket;
        self.sendChatUnRegisterPacket = sendChatUnRegisterPacket;

        self.getSendMessageObject = getSendMessageObject;

        self.pushMessageToBox = pushMessageToBox;

        self.getMessageType = getMessageType;

    }
})();

(function() {
    'use strict';
    angular
        .module('ringid.chat')
        .factory('ChatSeenSend', ChatSeenSend);

    ChatSeenSend.$inject = ['ChatWorkerCommands','ChatFactory', 'chatHistoryFactory','utilsFactory', 'Auth',
                            'tagChatFactory', 'tagChatManager', 'ChatHelper', 'tagChatHelper', '$q', 
                            'ChatUtilsFactory', 'ChatConnector'];

    function ChatSeenSend ( ChatWorkerCommands, ChatFactory, chatHistoryFactory, utilsFactory, Auth,
                            tagChatFactory, tagChatManager, ChatHelper, tagChatHelper, $q, 
                            ChatUtilsFactory, ChatConnector
    ) {
        
                
        var Constants = CHAT_APP.Constants;
        var ChatRequests = CHAT_APP.ChatRequests;
        var CHAT_GLOBAL_VALUES = Constants.CHAT_GLOBAL_VALUES;
        var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;
        var TAG_CHAT_PACKET_TYPE = Constants.TAG_CHAT_PACKET_TYPE;        
        var FRIEND_CHAT_PACKET_TYPE = Constants.FRIEND_CHAT_PACKET_TYPE;
        var USER_PRESENCE = GENERAL_CONSTANTS.USER_PRESENCE;

        var MESSAGE_STATUS_VALUE = GENERAL_CONSTANTS.MESSAGE_STATUS_VALUE;
        
        ///////////////////

        var _sendFriendChatSeenPackets = function( boxId, seenPartialMsgObjects, defer ){

            var requestObject = ChatRequests.getFriendChatSeenObject(boxId, seenPartialMsgObjects)
            requestObject.brokenPacketType = FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SEEN;
            
            var messageDate = parseInt(new Date().getTime() + CHAT_GLOBAL_VALUES.serverTimeDiff);

            for(var index = 0; index < seenPartialMsgObjects.length; index++){
                requestObject.messages[index]['packetId'] = seenPartialMsgObjects[index].key;
                requestObject.messages[index]['messageDate'] = messageDate;
                requestObject.messages[index]['status'] = getStatusByMessageType(seenPartialMsgObjects[index].messageType);                
            }

            ChatConnector.request(requestObject).then(function(response){
                if(!!response.sucs){
                    _updateMessageSeenSentProperty(boxId, seenPartialMsgObjects);
                    defer.resolve('success');
                }

            }, function(){
                defer.reject('failed');
            })

        };

        var _sendSeenPacket = function (box, messages){
            if(messages.length <1){
                return;
            }

            var defer = $q.defer();

            //todo store messages reference
            var seenPartialMsgObjects = getSeenPartialMsgObjects(messages);

            var  boxId = box.getKey();

            var requestObject;
            if(box.isTagChat){
                sendTagChatSeenPackets(boxId, seenPartialMsgObjects);                        
                return defer.resolve({sucs: true})

            }else{                
                _sendFriendChatSeenPackets(boxId, seenPartialMsgObjects, defer)
            }
        
            return defer.promise;
            
        };

        var _updateMessageSeenSentProperty = function (boxId, seenPartialMsgObjects) {
            var box = ChatFactory.getBoxByUId(boxId);
            var messagesToUpdate = [];
            for(var index = 0; index < seenPartialMsgObjects.length; index++){
                if( !!box){
                    var aMessage = box.getMessage(seenPartialMsgObjects[index].key);
                    if(!!aMessage){
                        aMessage.seenSent = true;
                        messagesToUpdate.push(aMessage);
                    }

                }
            }            

            chatHistoryFactory.updateMessages(messagesToUpdate, boxId);

        };
   
        var sendTagChatSeenPackets = function(tagId, seenPartialMsgObjects){
            var tagObject = tagChatFactory.getTag(tagId);
            var currentUserId = Auth.loginData.uId;
            if(!!tagObject){
                for(var index =0; index < seenPartialMsgObjects.length; index++){
                    var packetId = seenPartialMsgObjects[index].key;
                    var friendId = seenPartialMsgObjects[index].senderId;

                    var requestObject = ChatRequests.getTagChatSeenObject(friendId, tagId, packetId);                    
                    ChatConnector.send(requestObject);
                    
                }

                _updateMessageSeenSentProperty(tagId,seenPartialMsgObjects);

            }else{

            }
        };

        
        

        var getSeenPartialMsgObjects = function (messages){
            var seenPartialMsgObjects = [];
            for(var index = 0; index < messages.length; index++){
                seenPartialMsgObjects.push({
                    key: messages[index].key, 
                    messageType: messages[index].value.messageType, 
                    senderId : messages[index].value.user.getKey()
                });
            }
            return seenPartialMsgObjects;
        };
       
        var getStatusByMessageType = function(messageType){
            var messageStatus = 0;
            switch (messageType){
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    messageStatus = GENERAL_CONSTANTS.MESSAGE_STATUS.SEEN;
                    break;
                case 7:
                case 8:
                case 9:
                case 10:
                    messageStatus = GENERAL_CONSTANTS.MESSAGE_STATUS.VIEWED;
                    break;
            }
            return messageStatus;
        };
        

        return {
            sendSeenPacket : _sendSeenPacket
        };

    }
})();

(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}

    chatApp
        .factory('chatTabSync', chatTabSync);


    function CrossTab(){
        var self;

        var callbacks = {},
            lastNewValue,
            lastOldValue,
            tabId;

        function NotSupported() {
            var errorMsg = 'CrossTab not supported';
            var reasons = [];
            if (!localStorage) {
                reasons.push('localStorage not available');
            }
            if (!window.addEventListener) {
                reasons.push('addEventListener not available');
            }

            if (reasons.length > 0) {
                errorMsg += ': ' + reasons.join(', ');
            }

            throw new Error(errorMsg);
        }

        function now(){
            return new Date().getTime();
        }


        function onStorageEvent(event) {
            // Only handle crosstab events
            if (!event || (event.key != '__CROSSTAB') ) {
                return;
            }

            var eventValue;
            try {
                eventValue = event.newValue ? JSON.parse(event.newValue) : {};
            } catch (e) {
                eventValue = {};
            }
            if (!eventValue || !eventValue.id || eventValue.id === CrossTab.id) {
                // This is to force IE to behave properly
                return;
            }
            if (event.newValue === lastNewValue && event.oldValue === lastOldValue) {
                // Fix bug in IE11 where StorageEvents in iframes are sent twice.
                return;
            }
            lastNewValue = event.newValue;
            lastOldValue = event.oldValue;

            if(!!callbacks['message']){
                callbacks['message'].call(this, eventValue.data);
            }else{
            }
        }

        function setLocalStorageItem(key, data) {
            var storageItem = {
                id: tabId,
                data: data,
                timestamp: now()
            };

            localStorage.setItem(key, JSON.stringify(storageItem));
        }

        function getLocalStorageRaw(key) {
            var json = localStorage ? localStorage.getItem(key) : null;
            var item = json ? JSON.parse(json) : {};
            return item;
        }


        function swapUnloadEvents() {
            // `beforeunload` replaced by `unload` (IE11 will be smart now)
            window.removeEventListener('beforeunload', unload, false);
            window.addEventListener('unload', unload, false);
        }

        function unload() {

        }

        function pad(num, width, padChar) {
            padChar = padChar || '0';
            var numStr = (num.toString());

            if (numStr.length >= width) {
                return numStr;
            }

            return new Array(width - numStr.length + 1).join(padChar) + numStr;
        }

        var generateId = function () {
            /*jshint bitwise: false*/
            return now().toString() + pad((Math.random() * 0x7FFFFFFF) | 0, 10);
        };


        function broadcast(data) {
            if (!CrossTab.supported) {
                NotSupported();
            }

            var message = {
                data: data,
                origin: tabId
            };

            setLocalStorageItem('__CROSSTAB', message);

        }

        this.on = function(name, callback){
            callbacks[name] = callback;
        };

        this.setId = function(id){
            tabId = id;
        };

        this.getId = function(){
            return tabId;
        };

        this.broadcast = broadcast;

        this.init = function(){
            // --- Check if crosstab is supported ---
            CrossTab.supported = !!localStorage && window.addEventListener;

            if (!CrossTab.supported) {
                CrossTab.broadcast = NotSupported;
            } else {

                tabId = generateId();
                // ---- Setup Storage Listener
                window.addEventListener('storage', onStorageEvent, false);
                // start with the `beforeunload` event due to IE11
                window.addEventListener('beforeunload', unload, false);
                // swap `beforeunload` to `unload` after DOM is loaded
                window.addEventListener('DOMContentLoaded', swapUnloadEvents, false);
            }
        };


    }


    chatTabSync.$inejct = ['Storage', 'utilsFactory', 'SystemEvents'];

        function chatTabSync(Storage, utilsFactory, SystemEvents) {

            var CHAT_GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;

            var isSharedWorkerSupported = !!window.SharedWorker;
            var isLocalStorageSupported = !!window.localStorage;
            var myTabId, worker, corssTab, tabSender;

            var sendViaSharedWorker = function(type, data){
                try{
                    worker.port.postMessage({origin : myTabId, data : angular.extend(data, { type : type})});
                }catch(e){
                }

            };

            var sendViaLocalStorage = function(type, data){
                try {
                    corssTab.broadcast(angular.extend(data, {type: type}));
                }catch(e){
                }
            };

            var initSharedWorker = function(){
                myTabId = utilsFactory.getUniqueID('t');

                worker = new SharedWorker(CHAT_GENERAL_CONSTANTS.SHARED_WORKER_PATH);

                worker.port.addEventListener('message', function(event) {
                    var message = event.data;
                    if (message.origin !== myTabId) {

                        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAB_SYNC_NEW_DATA, message.data);
                    }

                }.bind(this), false);

                worker.port.start();

            };


            var initShareViaLocalStorage = function(){
                corssTab = new CrossTab();
                corssTab.init();

                myTabId = corssTab.getId();

                corssTab.on('message', function (message) {
                    if (message.origin !== myTabId) {


                        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAB_SYNC_NEW_DATA, message.data );
                    }
                });
            };

            var _sendData = function(type, data){

                if(!!tabSender ){
                    tabSender.call(this, type, data);
                }

            };

            var _init = function(){

                if( isSharedWorkerSupported ){
                    initSharedWorker();
                    tabSender = sendViaSharedWorker;

                }
                else if( isLocalStorageSupported) {
                    initShareViaLocalStorage();
                    tabSender = sendViaLocalStorage;

                }else{
                    tabSender = function(){};
                }
            };

            return {

                init : _init,
                sendData : _sendData
            }
        }
        chatTabSync.$inject = ['Storage', 'utilsFactory', 'SystemEvents'];

})();

(function(){

    'use strict';
    
    var chatApp;
    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}

    chatApp.service('ChatWorkerCommands', ChatWorkerCommands);

    ChatWorkerCommands.$inject = ['ChatConnector'];

    function ChatWorkerCommands( ChatConnector ) {

        var _validateChatSessionType = function(type){
            
            if( !type){
                Ringlogger.alert('Invalid Chat Session Type', type, Ringlogger.tags.CHAT );
                return false;
            }
            return true;
        }


        this.startChatSession = function(boxId, type, uIds){
            //type == 'friend|tag'
            if(!_validateChatSessionType(type)) return

            ChatConnector.sendCommand('START_CHAT_SESSION', { id : boxId, type : type, uIds : uIds })

        };

        this.endChatSession = function(boxId, type){
            //type == 'friend|tag'
            if(!_validateChatSessionType(type)) return

            ChatConnector.sendCommand('END_CHAT_SESSION', { id : boxId, type : type })

        };

        this.sendAuthRequest = function(requestObject){

           ChatConnector.sendCommand('SEND_AUTH_REQUSET', {object : requestObject, type : 'send'} );
        };

        this.sendTagChatMemberAddAuthRequest = function(requestObject){
            ChatConnector.sendCommand('SEND_TAG_CHAT_MEMBER_ADD_AUTH_REQUEST', {object : requestObject, type : 'send'} );
        };

        this.doGetChatHistoryMessages = function(boxId, pageDirection, limit, type, packetId ){

            ChatConnector.sendCommand('FETCH_HISTORY_MESSAGE', 
            { 
                id : boxId, type : type, pageDirection : pageDirection,
                limit : limit, packetId : packetId
            });

        };

    }

})();
(function(global) {
	'use strict';

	angular
        .module('ringid.chat')
		.factory('tagChatFactory', tagChatFactory);

		tagChatFactory.$inject = [
			'$$stackedMap', '$$connector',			
			'userFactory', 'friendsFactory', 'profileFactory',
			'Auth', 'utilsFactory',			
			'tagChatModels'

		];

		function tagChatFactory(
			$$stackedMap, $$connector,			
			userFactory, friendsFactory, profileFactory,
			Auth, utilsFactory,		
			tagChatModels

		) {

			var Constants               = CHAT_APP.Constants;
			
			var GENERAL_CONSTANTS       = Constants.GENERAL_CONSTANTS;
			var PACKET_CONSTANTS       = Constants.PACKET_CONSTANTS;
			
			var CHAT_GLOBAL_VALUES      = Constants.CHAT_GLOBAL_VALUES;
			var AUTH_SERVER_ACTIONS     = Constants.AUTH_SERVER_ACTIONS;

			var TAG_CHAT_PACKET_TYPE    = Constants.TAG_CHAT_PACKET_TYPE;
			var FRIEND_CHAT_PACKET_TYPE = Constants.FRIEND_CHAT_PACKET_TYPE;
			var CONFIRMATION_MAP        = Constants.CONFIRMATION_MAP;				

			var registeredTags          = {};
			var tagInitiator            = {};
			var tagChatRequestCache     = {};
			var tagChatResponseCache    = {};
			var tagIdleIntervals        = {};

			var tagChatTags             = $$stackedMap.createNew(true);
			var _startProcessRequest    = true;

			return {
				createNewTag: _createNewTag,
				createNewTagMember : _createNewTagMember,
				createNewTagMessage : _createNewTagMessage,
				createTagStatusMessage : _createTagStatusMessage,

				addTagObject : _addTagObject,
				removeTagObject : _removeTagObject,

				getTags : _getTags,
				getTag : _getTag,
				generateNewTagId : getTagId,

				getOrCreateTag : _getOrCreateTag,
				getOrCreateMessage : _getOrCreateMessage,

				updateTag : _updateTag,

				getTagLastMessageObject : _getTagLastMessageObject,

                isTagRegistered : _isTagRegistered,
                markTagAsRegistered : _markTagAsRegistered,
				unRegisterTag : _unRegisterTag,
				updateTagRegisteredTime : _updateTagRegisteredTime,

				setTagChatInitiator : _setTagChatInitiator,
				resetTagChatInitiator : _resetTagChatInitiator,
				isTagChatInitiator : _isTagChatInitiator,

				setInTagChatRequestCache : _setInTagChatRequestCache,
				resetInTagChatRequestCache : _resetInTagChatRequestCache,
				resetInTagChatRequestCacheForAuth :_resetInTagChatRequestCacheForAuth,
				getFromTagChatRequestCache : _getFromTagChatRequestCache,
				getAuthRequestKey : _getAuthRequestKey,
				isInRequestCacheForAuth : _isInRequestCacheForAuth,
				isInRequestCacheForChat : _isInRequestCacheForChat,

				setInTagChatResponseCache : _setInTagChatResponseCache,
				resetFromTagChatResponseCache : _resetFromTagChatResponseCache,
				getFromTagChatResponseCache : _getFromTagChatResponseCache,

				setInTagChatResponseCacheForAuth :_setInTagChatResponseCacheForAuth,
				isInTagChatResponseCacheForAuth: _isInTagChatResponseCacheForAuth,

				getIdleIntervalIdByTagId : _getIdleIntervalIdByTagId,
				setIdleIntervalIdByTagId : _setIdleIntervalIdByTagId,
				resetIdleIntervalIdByTagId : _resetIdleIntervalIdByTagId,

				hasReceivedConfirmation : _hasReceivedConfirmation,

				shouldProcessRequest : _shouldProcessRequest,


				startProcessingRequest : _startProcessRequest,

				getUUIDPacketId : _getUUIDPacketId


				/*** Temp Usages For Testing ***/

			};

			///////////////////////////  ///////////////////////////

			function getTagId(){

				var userId = Auth.currentUser().getKey().toString();

				var currentTime = new Date().getTime().toString();

				var tagId = currentTime.substr(0, PACKET_CONSTANTS.TAG_ID_NO_OF_TIME_DIGIT );

				tagId += userId.substr(userId.length - PACKET_CONSTANTS.TAG_ID_NO_OF_USER_ID_DIGIT );

				return tagId;
			}

			function _getTags(){
				return tagChatTags;
			}

			function _getTag(key){
				return tagChatTags.get(key);
			}

			function _removeTagObject(key){
				return tagChatTags.remove(key);
			}

			function _createNewTag(object, tagObject){

				if( !tagObject){
					tagObject = new tagChatModels.TagObject();
				}

				if( !object.tagId ){
					tagObject.setTagId( getTagId() );
				}else{
					tagObject.setTagId( object.tagId );
				}

				if(!!object.packetId){
					tagObject.setPacketId( object.packetId );
				}

				if(!!object.userId){
				 tagObject.setUserId( object.userId );
				}

				if(!!object.tagName){
					tagObject.setTagName( object.tagName );
				}

				if(!!object.tagPictureUrl){
					tagObject.setPictureUrl( object.tagPictureUrl );
				}


				if(!!object.serverDate){
					tagObject.setServerDate(object.serverDate);
				}

				if(!!object.tagMembersCount){
					tagObject.setMembersCount(object.tagMembersCount);
				}

				return tagObject;
			}

			function _createNewTagMember(tagId, object, userObjectInit){
				var tagMemberObject = new tagChatModels.TagMember();

                if( !!tagId){
				    tagMemberObject.setTagId( tagId );
                }

                if(!!object){

                    if(!!object.userId){
                        tagMemberObject.setId( object.userId );
                    }

                    if(!!object.fullName){
                        tagMemberObject.setFullName( object.fullName );
                    }

                    if(!!object.addedBy){
                        tagMemberObject.setAddedBy( object.addedBy );

                    }

                    if(!!object.status){
                        tagMemberObject.setStatus( object.status );
                    }else{
                        tagMemberObject.setStatus( GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER );
                    }

                    //if(!!userObjectInit){
                    //    tagMemberObject.initUserObjects();
                    //}
                }

				return tagMemberObject;

			}

			function _createNewTagMessage(tagId, object, userObjectInit){

				var tagMessageObject = new tagChatModels.TagMessage();

                if( !!tagId){
				    tagMessageObject.setTagId( tagId );
                }

                if(!!object){

                    if(!!object.userId){
                        tagMessageObject.setUserId( object.userId );
                    }

					if(!!object.user){
						tagMessageObject.setUserId( object.user );
					}

					if(!!object.fullName){
						tagMessageObject.setFullName( object.fullName );
					}

                    if(!!object.message){
                        tagMessageObject.setMessageText( object.message );
                    }

                    if(!!object.hrtime){
                        tagMessageObject.setHumanReadableTime( object.hrtime );
                    }

					if(!!object.messageDate){
                        tagMessageObject.setMessageDate( object.messageDate );
                    }

					if(!!object.isDeleted){
                        tagMessageObject.markAsDeleted( object.isDeleted );
                    }

					if(!!object.messageDateString){
                        tagMessageObject.setMessageDateString( object.messageDateString );
                    }

					if(!!object.timeout){
                        tagMessageObject.setTimeout( object.timeout );
                    }

					if(!!object.messageType){
                        tagMessageObject.setMessageType( object.messageType );
                    }

                    if(!!object.status){
                        tagMessageObject.setStatus( object.status );
                    }

					if(!!object.packetId){
						tagMessageObject.setPacketId( object.packetId );
					}

					if(!!object.usersToChange){
						tagMessageObject.setUsersToChange( object.usersToChange );
					}

					if(!!object.statusType){
						tagMessageObject.setStatusType( object.statusType );
					}

					if(!!object.tagName){
						tagMessageObject.setTagName( object.tagName );
					}


					/**** ****/

                    //if(!!userObjectInit){
                    //    tagMessageObject.initUserObjects();
                    //}
                }

				return tagMessageObject;

			}

			function _createTagStatusMessage(packetId, tagId, userId, messageType, usersToChangeArray, restInfo){

				var statusMessageObject = {};

				var tagObject = _getTag(tagId);

				if(!!tagObject){
					var messageDate;
					if( !restInfo.messageDate ){

						messageDate = parseInt(new Date().getTime()) + tagObject.getServerDateDiff();
					}else{
						messageDate = restInfo.messageDate;
					}


					profileFactory.getUserDetailsByUId(userId);
					var userObject = userFactory.getUser(userId);

					statusMessageObject = {
						message: '',
						fullName : userObject.getName(),
						status: 'status_update',
						statusType : messageType,
						tagName : !!restInfo ? restInfo.tagName : '',
						messageDate: messageDate,
						messageType : 2,
						tag_chat: true,
						userId : userId,
						user : userId,
						packetId : packetId

					};

					statusMessageObject.usersToChange = {};

					if( usersToChangeArray.length > 0) {

						for (var index = 0; index < usersToChangeArray.length; index++) {

							var changedUserObject = usersToChangeArray[index];
							var tagMemberObject = _createNewTagMember(tagObject.getTagId(), changedUserObject, true);
							statusMessageObject.usersToChange[tagMemberObject.getName()] = true;
						}
					}

					var tagMessage = _createNewTagMessage(tagId, statusMessageObject);

					return tagMessage;

				}

				return false;

			}

			function _getTagLastMessageObject(messageObject){

				var tagLastMessageObject = {
					key : messageObject.key,
					text : messageObject.text,
					messageType : messageObject.messageType,
					messageDate : messageObject.messageDate

				};

				return tagLastMessageObject;

			}

			function _addTagObject(aNewTagObject){

				if( !(aNewTagObject instanceof tagChatModels.TagObject ) ){
					console.error('Please provide tagChatModels.TagObject() Instance');
					return false;
				}

                var aFactoryTagObj = tagChatTags.get(aNewTagObject.getTagId());
                if( !!aFactoryTagObj ){

                    aFactoryTagObj.update( aNewTagObject );

                }else{
    				tagChatTags.add(aNewTagObject.getTagId(), aNewTagObject);
                }

				return true;

			}

			function _getOrCreateTag(tagId, newTagInfo ){

				if(!newTagInfo){
					newTagInfo = {tagId : tagId};
				}

				var tagObj = _getTag( tagId );
				if( !tagObj ){
					tagObj = _createNewTag(newTagInfo);
				}else{
					tagObj = _createNewTag(newTagInfo, tagObj);
				}

				tagChatTags.save(tagId, tagObj);
				return tagObj;
			}

			function _updateTag(tagId, newTagInfo, oldTagObj ){

				if(!oldTagObj){
					oldTagObj = _getTag( tagId );
				}

				oldTagObj = _createNewTag(newTagInfo, oldTagObj);
				tagChatTags.save(tagId, oldTagObj);

				return oldTagObj;
			}

			function _getOrCreateMessage(tagId, newTagMessageInfo ){

				var newTagInfo = {tagId : tagId};

				if(!newTagMessageInfo){
					newTagMessageInfo = {tagId : tagId};
				}

				var tagObj = _getTag( tagId );

				if( !tagObj ){
					tagObj = _createNewTag(newTagInfo);
					tagChatTags.save(tagId, tagObj);
				}

				var newTagMessageObj = _createNewTagMessage(tagId, newTagMessageInfo, true);

				var oldTagMessageObj = tagObj.getMessage(newTagMessageInfo.packetId);

				if( !oldTagMessageObj){
					oldTagMessageObj = newTagMessageObj;

					tagObj.addMessage(oldTagMessageObj);

				}else{
					oldTagMessageObj.update(newTagMessageObj);
				}

				return oldTagMessageObj;
				//
				//var event = document.createEvent('Event');
				//event.initEvent('tagmessageupdated', true, true);
				//document.dispatchEvent(event);
                //
				//return tagObj;
			}


            function _updateTagRegisteredTime(tagId, updateTime){
                registeredTags[tagId] = updateTime || new Date().getTime()/1000;

            }

			function _isTagRegisteredValid(tagId){

				if( !registeredTags[tagId] ){
					return false;
				}

				if( ( (new Date().getTime()/1000) - registeredTags[tagId] )  > GENERAL_CONSTANTS.TAG_REGISTER_TIMEOUT  ){
					return false;
				}

				return true;
			}

            function _isTagRegistered(tagId){
                return !!registeredTags[tagId] && _isTagRegisteredValid(tagId);
            }

			function _unRegisterTag(tagId){
				delete registeredTags[tagId];
			}

            function _markTagAsRegistered(tagId){

                _updateTagRegisteredTime(tagId);

				utilsFactory.triggerCustomEvent('tagregistered', { tagId : tagId });

                //var timeout = setTimeout(function(){
                //    if( !_isTagRegisteredValid(tagId)  ){
					//	clearTimeout(timeout);
                //        delete registeredTags[tagId];
                //
                //        console.log(tagId, ' deleted from registered tag');
                //
                //        var tagObject = tagChatTags.get(tagId);
                //        if(!!tagObject){
					//		tagObject.resetChatIp();
					//		tagObject.resetChatRegisterPort();
                //            tagObject.resetChatBindingPort();
					//		tagObject.resetLastCommunicationTime();
                //        }
                //
					//	utilsFactory.triggerCustomEvent('tagunregistered', { tagId : tagId });
                //
                //    }else{
					//	console.log('tag valid', tagId);
					//}
                //}, GENERAL_CONSTANTS.TAG_REGISTER_TIMEOUT);
            }

			function _setTagChatInitiator(tagId){
				tagInitiator[tagId] = true;

				// todo need to check race condition
				setTimeout(function(){
					console.log();

					tagInitiator[tagId] = false;
				}, GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY);
			}

			function _resetTagChatInitiator(tagId){
				tagInitiator[tagId] = false;
			}

			function _isTagChatInitiator(tagId){
				return !!tagInitiator[tagId];
			}


			/****************************** TagChat Request Cache Start *******************************/

			function _getAuthRequestKey(tagId, actionId){
				return tagId + '-' + actionId;
			}

			function _setInTagChatRequestCache(packetId, requestObject){
				if(!_startProcessRequest){ return; }

				tagChatRequestCache[packetId] = requestObject;
				_initTagChatRequestCacheClearInterval(packetId);
			}

			function _resetInTagChatRequestCache(packetId){
				delete tagChatRequestCache[packetId];
			}

			function _getFromTagChatRequestCache(key){
				return tagChatRequestCache[key];
			}

			function _isInRequestCacheForChat(packetId){
				return !!_getFromTagChatRequestCache(packetId);
			}

			function _isInRequestCacheForAuth(tagId, actn){
				var key = _getAuthRequestKey(tagId, actn);
				return !!_getFromTagChatRequestCache(key);
			}

			function _resetInTagChatRequestCacheForAuth(tagId, actn){
				var key = _getAuthRequestKey(tagId, actn);
				_resetInTagChatRequestCache(key);
			}

			function _initTagChatRequestCacheClearInterval(key){
			 	setTimeout(function(){


					_resetInTagChatRequestCache(key);
				}, GENERAL_CONSTANTS.REQUEST_CACHE_VALIDITY);
			}

			/****************************** TagChat Request Cache End *******************************/

			/****************************** TagChat Response Cache Start *******************************/

			function _getTagChatResponseCacheKey(packetId, responseObject){

				if( responseObject.packetType == TAG_CHAT_PACKET_TYPE.TAG_CHAT_DELIVERED ||
					responseObject.packetType == FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_DELIVERED ||
					responseObject.packetType == FRIEND_CHAT_PACKET_TYPE.TAG_CHAT_SENT ||
					responseObject.packetType == FRIEND_CHAT_PACKET_TYPE.FRIEND_CHAT_SENT
				){
					var packetIdParts = packetId.split('_');
					if( packetIdParts.length == 2){
						responseObject.packetId = packetIdParts[0];
						responseObject.sequenceNo = packetIdParts[1];
					}
				}


				if(!responseObject.sequenceNo){
					responseObject.sequenceNo = 0;
				}

				return packetId + '_' + responseObject.sequenceNo +'_' + responseObject.packetType;
			}

			function _setInTagChatResponseCache(packetId, responseObject){
				var key = _getTagChatResponseCacheKey(packetId, responseObject);

				tagChatResponseCache[key] = responseObject;
				_initTagChatResponseCacheClearInterval(key);
			}

			function __doResetFromTagChatResponseCache(key){
				delete tagChatResponseCache[key];
			}

			function _resetFromTagChatResponseCache(packetId, packetType){
				var key = _getTagChatResponseCacheKey(packetId, { packetType : packetType});
				__doResetFromTagChatResponseCache(key);
			}

			function _getFromTagChatResponseCache(responseObject){
				var key = _getTagChatResponseCacheKey(responseObject.packetId, responseObject);
				return tagChatResponseCache[key];
			}

			function _initTagChatResponseCacheClearInterval(key){
			 	setTimeout(function(){
					// console.log('Response Cache Cleared for ', key);
					__doResetFromTagChatResponseCache(key);
				}, GENERAL_CONSTANTS.RESPONSE_CACHE_VALIDITY);
			}


			function _setInTagChatResponseCacheForAuth(tagId, actnId){
				_setInTagChatResponseCache(tagId, { packetType : actnId} );
			}

			function _isInTagChatResponseCacheForAuth(tagId, actnId){
				return !!_getFromTagChatResponseCache({ packetId : tagId, packetType : actnId});
			}

			/****************************** TagChat Response Cache End *******************************/

			/****************************** TagChat Confirmation Methods Start *******************************/


			function __hasReceivedConfirmationByConfirmationPacketType(confirmationPacketType, packetId, sequenceNo){
				var responseObject = {
					packetId : packetId,
					packetType : confirmationPacketType,
					sequenceNo : sequenceNo
				};

				return !!_getFromTagChatResponseCache(responseObject);
			}
			function _hasReceivedConfirmation(packetId, packetType, sequenceNo){

				if(!sequenceNo){
					sequenceNo = 0;
				}

				var confirmationPacketType = CONFIRMATION_MAP[packetType];
				if( !confirmationPacketType ){
					console.warn('Confirmation Packet Type Not Defined');
				}else{
					var receivedConfirmation = false;
					if( angular.isArray(confirmationPacketType)){
						for(var index = 0, length = confirmationPacketType.length; index < length; index++){
							if( __hasReceivedConfirmationByConfirmationPacketType(confirmationPacketType[index], packetId, sequenceNo)){
								receivedConfirmation = true;
								break;
							}
						}
					}else{
						receivedConfirmation = __hasReceivedConfirmationByConfirmationPacketType(confirmationPacketType, packetId, sequenceNo);
					}
				}

				return receivedConfirmation;
			}

			/****************************** TagChat Confirmation Methods End *******************************/


			function _getIdleIntervalIdByTagId(tagId){
				return tagIdleIntervals[tagId];
			}

			function _setIdleIntervalIdByTagId(tagId, intervalId){
				tagIdleIntervals[tagId] = intervalId;
			}

			function _resetIdleIntervalIdByTagId(tagId){
				delete tagIdleIntervals[tagId];
			}


			/****************************** TagChat Should Process Request *******************************/

			function _shouldProcessRequest(request){

				if(!request.actn){
					//Chat Request

				}else{
					//Auth Request
					var tagId = request.tid || request.tagId;

					var isInRequestCache = _isInRequestCacheForAuth(tagId, request.actn);

					return !isInRequestCache;

				}

			}

			function _getRingPacketId(){
				return utilsFactory.getUniqueID('tagc');
			}

			function _getUUIDPacketId(packetTime, isPacketIdStamp){
				var timestamp;

				if( !isPacketIdStamp && !packetTime){
					packetTime = new Date().getTime();
					timestamp =  parseInt(packetTime + CHAT_GLOBAL_VALUES.serverTimeDiff);

				}else{
					timestamp = packetTime;
				}

				if( !timestamp){
				}

				return PacketIDGenerator.create(Auth.currentUser().getKey(), timestamp, isPacketIdStamp);
			}

		}
})(window);

(function() {
    'use strict';

    angular
        .module('ringid.chat')
        .factory('tagChatHelper', tagChatHelper);

    tagChatHelper.$inject = [
            'CHAT_LANG',
            'Auth',
            'tagChatFactory', 'profileFactory', 'Storage'

        ];

    function tagChatHelper (

            CHAT_LANG,
            Auth,
            tagChatFactory, profileFactory, Storage

    ) {

        var Constants = CHAT_APP.Constants;
        
        var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;
        var CHAT_GLOBAL_VALUES = Constants.CHAT_GLOBAL_VALUES;

        var TAG_CHAT_LANG = CHAT_LANG.TAG;

        return {
            getTagChatStatusMessage : _getTagChatStatusMessage,

            getTagEmptyMessageObject : _getTagEmptyMessageObject,

            getCurrentChatServerTime : _getCurrentChatServerTime,

            hasChatSession : _hasChatSession,

            executeAfterTagRegisterEvent : _executeAfterTagRegisterEvent

        };

        ///////////////////

        function _getLanguageTemplate(selfUser, messageUser, memberShipType){


        }

        function __getMemberType(statusType){
            var memberType;

            if( statusType === GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_ADD){

                memberType = 'member';

            }else if(  statusType === GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_ADMIN_ADD){

                memberType = 'admin';
            }
            return memberType;
        }

        function _getTagChatStatusMessage(chatMessageObject){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey(),
                statusMessage = "",
                firstName = chatMessageObject.usersToChange[0],
                allNameJoined = chatMessageObject.usersToChange.slice(1).join(', '),
                totalMinusOne = chatMessageObject.usersToChange.length - 1,
                senderFullName = chatMessageObject.fullName,
                groupNewName = chatMessageObject.tagName,
                tagId,  tagObject,  isSelf;


            tagId = chatMessageObject.tagId;
            tagObject =tagChatFactory.getOrCreateTag(tagId);
            isSelf = currentUser.getKey() === chatMessageObject.userId.toString();

            if(!tagObject){
                return;
            }

            if( !senderFullName){
                var sendMemberObject = tagObject.getMember(chatMessageObject.userId);
                if(!!sendMemberObject){
                    senderFullName = sendMemberObject.getName()
                }else{
                    senderFullName = chatMessageObject.userId;
                }
            }

            var templateParams = {};
            var langTemplate = TAG_CHAT_LANG.STATUS_MESSAGES;
            var langTemplateString, memberType;

            switch (chatMessageObject.statusType){

                case GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_ADD:

                case GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_ADMIN_ADD:

                    memberType = __getMemberType(chatMessageObject.statusType);

                    templateParams.member_name = senderFullName;
                    templateParams.new_member_name = (firstName == currentUser.getName() ) ? 'you' : firstName;
                    templateParams.new_member_type = memberType;
                    templateParams.rest_count = "<a href='javascript:void(0);' title='{0}'>{1} others</a>".format(allNameJoined, totalMinusOne);

                    if( isSelf ){

                        if(!totalMinusOne){
                            langTemplateString = langTemplate.SELF_ADD_MEMBER;
                        }else{
                            langTemplateString = langTemplate.SELF_ADD_MULTIPLE_MEMBER;
                        }

                    }else{

                        if(!totalMinusOne){
                            langTemplateString = langTemplate.OTHER_ADD_MEMBER;
                        }else{
                            langTemplateString = langTemplate.OTHER_ADD_MULTIPLE_MEMBER;
                        }
                    }


                    break;

                case GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_DELETE:

                    templateParams.member_name = senderFullName;
                    templateParams.old_member_name = (firstName == currentUser.getName() ) ? 'you' : firstName;;
                    templateParams.rest_count = "<a href='javascript:void(0);' title='{0}'>{1} others</a>".format(allNameJoined, totalMinusOne);

                    if( isSelf ){

                        if(!totalMinusOne){

                            if( firstName === senderFullName ){
                                langTemplateString = langTemplate.SELF_LEAVE_GROUP;
                            }else{
                                langTemplateString = langTemplate.SELF_REMOVE_MEMBER;
                            }

                        }else{
                            langTemplateString = langTemplate.SELF_REMOVE_MULTIPLE_MEMBER;
                        }

                    }else{

                        if(!totalMinusOne){

                            if( firstName === senderFullName ){
                                langTemplateString = langTemplate.OTHER_LEAVE_GROUP;
                            }else{
                                langTemplateString = langTemplate.OTHER_REMOVE_MEMBER;
                            }

                        }else{
                            langTemplateString = langTemplate.OTHER_REMOVE_MULTIPLE_MEMBER;
                        }
                    }


                    break;

                case GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_LEAVE:

                    templateParams.member_name = senderFullName;

                    if( isSelf ){

                        langTemplateString = langTemplate.SELF_LEAVE_GROUP;

                    }else{

                       langTemplateString = langTemplate.OTHER_LEAVE_GROUP;
                    }



                    break;

                case GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_ADMIN:

                    templateParams.member_name = senderFullName;
                    templateParams.rest_count = "<a href='javascript:void(0);' title='{0}'>{1} others</a>".format(allNameJoined, totalMinusOne);

                    if( firstName !== currentUser.getName() ){
                        templateParams.old_member_name = firstName;
                    }else{
                        templateParams.old_member_name = 'you';
                    }

                    if( isSelf ){

                        if(!totalMinusOne){
                            langTemplateString = langTemplate.SELF_MEMBER_CHANGE_TO_ADMIN;
                        }else{
                            langTemplateString = langTemplate.SELF_MULTIPLE_MEMBER_CHANGE_TO_ADMIN;
                        }

                    }else{

                        if(!totalMinusOne){
                            langTemplateString = langTemplate.OTHER_MEMBER_CHANGE_TO_ADMIN;
                        }else{
                            langTemplateString = langTemplate.OTHER_MULTIPLE_MEMBER_CHANGE_TO_ADMIN;
                        }
                    }


                    break;

                case GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_MEMBER:

                    templateParams.admin_name = senderFullName;

                    if( firstName !== currentUser.getName() ){
                        templateParams.old_admin_name = firstName;
                    }else{
                        templateParams.old_admin_name = 'you';
                    }


                    templateParams.rest_count = "<a href='javascript:void(0);' title='{0}'>{1} others</a>".format(allNameJoined, totalMinusOne);


                    if( isSelf ){

                        if(!totalMinusOne){

                            if( firstName === senderFullName ){
                                langTemplateString = langTemplate.SELF_REMOVED_FROM_ADMIN_BY_SELF;
                            }else{
                                langTemplateString = langTemplate.SELF_ADMIN_CHANGE_TO_MEMBER;
                            }


                        }else{
                            langTemplateString = langTemplate.SELF_MULTIPLE_ADMIN_CHANGE_TO_MEMBER;
                        }

                    }else{

                        if(!totalMinusOne){

                            if( firstName === senderFullName ){
                                langTemplateString = langTemplate.OTHER_REMOVED_FROM_ADMIN_BY_SELF;
                            }else{
                                langTemplateString = langTemplate.OTHER_ADMIN_CHANGE_TO_MEMBER;
                            }

                        }else{
                            langTemplateString = langTemplate.OTHER_MULTIPLE_ADMIN_CHANGE_TO_MEMBER;
                        }
                    }

                    break;

                case GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_OWNER:

                    templateParams.member_name = senderFullName;
                    templateParams.admin_name = firstName;

                    if( firstName !== currentUser.getName() ){

                        langTemplateString = langTemplate.OTHER_USER_ADDED_AS_OWNER;
                    }else{

                        langTemplateString = langTemplate.SELF_USER_ADDED_AS_OWNER;
                    }


                    break;

                case GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_INFO_UPDATED:

                    templateParams.member_name = senderFullName;
                    templateParams.group_name = groupNewName;

                    if( isSelf ){

                        langTemplateString = langTemplate.SELF_UPDATE_GROUP_INFO;

                    }else{

                        langTemplateString = langTemplate.OTHER_UPDATE_GROUP_INFO;
                    }


                    break;

                case GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_NAME_CHANGE:

                    templateParams.member_name = senderFullName;
                    templateParams.group_name = groupNewName;

                    if( isSelf ){

                        langTemplateString = langTemplate.SELF_RENAME_GROUP;

                    }else{

                        langTemplateString = langTemplate.OTHER_RENAME_GROUP;
                    }

                    break;

                case GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_PICTURE_CHANGE:

                    templateParams.member_name = senderFullName;
                    templateParams.group_name = groupNewName;

                    if( isSelf ){

                        langTemplateString = langTemplate.SELF_CHANGE_GROUP_PIC;

                    }else{

                        langTemplateString = langTemplate.OTHER_CHANGE_GROUP_PIC;
                    }

                    break;

            }

            if(!!langTemplateString){
                statusMessage = langTemplateString.supplant(templateParams);
            }

            return statusMessage;

        }

        function _getTagEmptyMessageObject(tagId){
            var currentUser = Auth.currentUser(),
                currentUserId = currentUser.getKey();

            var object = {
                tagId : tagId,
                userId : currentUser.getKey(),
                fullName : currentUser.getName(),
                message : ' ',
                messageDate : new Date().getTime(),
                messageType : GENERAL_CONSTANTS.MESSAGE_TYPES.BLANK_MESSAGE,
                packetId : tagChatFactory.getUUIDPacketId()
            };

            var tagMessageObject = tagChatFactory.createNewTagMessage(tagId, object);
            return tagMessageObject;

        }

        function _getCurrentChatServerTime(){

            var chatServerTime = CHAT_GLOBAL_VALUES.serverTimeDiff;
            var lcoalTimeInServerTime = new Date().getTime() - chatServerTime;
            return lcoalTimeInServerTime;

        }

        function _hasChatSession(serverReceivedTime){

            var serverTime = _getCurrentChatServerTime();
            return ( serverTime - serverReceivedTime ) < GENERAL_CONSTANTS.ACTUAL_TAG_REGISTER_TIMEOUT;


        }

        function _executeAfterTagRegisterEvent(tagId, func, args, immidiate){

            if(immidiate){
                func.call(null, args);

            }else{

                var eventHandler = function(event) {
                    if(event.data.tagId.toString() === tagId.toString()){
                        func.call(null, args);
                        document.removeEventListener('tagregistered', eventHandler);
                    }
                };

                document.addEventListener('tagregistered', eventHandler);
            }

        }


    }
})();


(function() {
	'use strict';

	angular
        .module('ringid.chat')
		.factory('tagChatManager', tagChatManager);

	tagChatManager.$inject = [
		 	'$$connector', '$q', '$timeout',
			'Auth', 'CHAT_LANG',
			'tagChatFactory',
			'ChatWorkerCommands',  'tagChatUI', 'tagChatHelper',
			'ChatFactory', 'chatHistoryFactory',
			'userFactory', 'utilsFactory', 'profileFactory', 'tagChatStorage',
			'OPERATION_TYPES' ,'Ringalert', 			
			'ChatUtilsFactory', 'ChatConnector', 'SystemEvents'

	];

	function tagChatManager (

			 $$connector, $q, $timeout,
			 Auth, CHAT_LANG,
			 tagChatFactory,
			 ChatWorkerCommands, tagChatUI, tagChatHelper,
			 ChatFactory, chatHistoryFactory,
			 userFactory, utilsFactory, profileFactory, tagChatStorage,
			 OPERATION_TYPES, Ringalert, 			 
			 ChatUtilsFactory, ChatConnector, SystemEvents

	) {


		var Constants                            = CHAT_APP.Constants;

		var GENERAL_CONSTANTS                    = Constants.GENERAL_CONSTANTS;

		var AUTH_SERVER_ACTIONS                  = Constants.AUTH_SERVER_ACTIONS;

		var TAG_CHAT_PACKET_TYPE                 = Constants.TAG_CHAT_PACKET_TYPE;
		var OFFLINE_PACKET_TYPE                  = Constants.OFFLINE_PACKET_TYPE;
		var FRIEND_CHAT_PACKET_TYPE              = Constants.FRIEND_CHAT_PACKET_TYPE;
		
		var TAG_CHAT_LANG                        = CHAT_LANG.TAG;		

		var AuthRequests                         = CHAT_APP.AuthRequests;
		var ChatRequests                         = CHAT_APP.ChatRequests;

		var callXTimeAfterYIntervalStopOnSuccess = utilsFactory.callXTimeAfterYIntervalStopOnSuccess;

		/******************************* TAG CRUD Start ******************************/
		function _createTag( object ) {
			/***
			 * @param tagObject
			 * tagObject = { tagId : '', uIds : [] }
			 */

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				aTag,
				aTagMemberObjectParam,
				aTagMemberObject,
				aTagAdminObjectParam,
				aTagAdminObject,
				authFailed;



			/************ Create Tag Object **************/

			object.tagMembersCount =  object.memberUIds.length + object.adminUIds.length +  1;
			aTag = tagChatFactory.createNewTag(object);


			/************ Add Tag Owner Start **************/

			aTagMemberObjectParam = {
				userId : currentUser.getKey(),
				addedBy : currentUser.getKey(),
				status : GENERAL_CONSTANTS.MEMBER_STATUS.OWNER
			};

			aTagMemberObject = tagChatFactory.createNewTagMember(aTag.getTagId(), aTagMemberObjectParam, true);
			aTag.addMember( aTagMemberObject );

			/************ Add Tag Owner End **************/


			/************ Add Tag Members Start **************/

			for(var tagMemberIndex = 0; tagMemberIndex < object.memberUIds.length; tagMemberIndex++ ){
				var aTagMemberUId = object.memberUIds[tagMemberIndex];

				aTagMemberObjectParam = {
					userId : aTagMemberUId,
					addedBy : currentUser.getKey(),
					status : GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER
				};

				aTagMemberObject = tagChatFactory.createNewTagMember(aTag.getTagId(), aTagMemberObjectParam, true);
				aTag.addMember( aTagMemberObject );
			}

			/************ Add Tag Members End **************/

			/************ Add Tag Admins Start **************/

			for(var tagAdminIndex = 0; tagAdminIndex < object.adminUIds.length; tagAdminIndex++ ){
				var aTagAdminUId = object.adminUIds[tagAdminIndex];

				aTagAdminObjectParam = {
					userId : aTagAdminUId,
					addedBy : currentUser.getKey(),
					status : GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN
				};

				aTagAdminObject = tagChatFactory.createNewTagMember(aTag.getTagId(), aTagAdminObjectParam, true);
				aTag.addMember( aTagAdminObject );
			}

			/************ Add Tag Admins End **************/

			/************ Create Tag In Auth Start **************/

			aTag.setObjectLock();
			tagChatFactory.addTagObject(aTag);			

			utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED);

            object.uIds = object.adminUIds.concat(object.memberUIds);		

			var requestObject = ChatRequests.getOfflineTagCreateTagObject(aTag.getTagId(),
				 aTag.getTagName(), aTag.getPictureUrl(), aTag.getSerializedMembers()
			);

			ChatConnector.request(requestObject).then(function(response){
				aTag.removeObjectLock();

				if( !!response.sucs){
					deferred.resolve(response);					

					ChatWorkerCommands.startChatSession(aTag.getTagId(), 
						GENERAL_CONSTANTS.SESSION_TYPES.TAG, aTag.getMemberUserIds());

				}else if(response.error){
					deferred.error(response);

				}else{
					deferred.reject(response);

				}
			});

			return deferred.promise;

		}

		function __getMembersForCRUD(oldTagObj, memberUIdsToSet, adminUIdsToSet){

			var currentUser = Auth.currentUser(),
				oldTagMemberListCopy,  oldTagMembersAndAdminsMap,
				allOldTagMembersAndAdminsMap, aTagMemberObject,
				statusChanged, aNewMember,
				newTagMemberObject, aNewAdmin,
				newTagAdminObject,
				serializedMemberAdminsToRemove = [],
				serializedMemberAdminsToStatusChange = [],
				serializedNewMemberAdminsToAdd = [],
				membersAdminToAddOnSuccess = [],
				membersAdminToRemoveOnSuccess = [],
				membersAdminToUpdateOnSuccess = [],
				newMemberUIdsToSetCache = {},
				newAdminUIdsToSetCache = {},
				oldMembersUIdCache = {};


			oldTagMemberListCopy = oldTagObj.getMembersObjectMap().copy();
			oldTagMembersAndAdminsMap = oldTagMemberListCopy;
			allOldTagMembersAndAdminsMap = oldTagMembersAndAdminsMap.all();

			angular.forEach(memberUIdsToSet, function(aMemberUId){
				newMemberUIdsToSetCache[aMemberUId] = true;
			});

			angular.forEach(adminUIdsToSet, function(anAdminUId){
				newAdminUIdsToSetCache[anAdminUId] = true;
			});

			for(var oldTagMembersAndAdminsMapIndex = 0; oldTagMembersAndAdminsMapIndex < allOldTagMembersAndAdminsMap.length; oldTagMembersAndAdminsMapIndex++ ){

				aTagMemberObject = allOldTagMembersAndAdminsMap[oldTagMembersAndAdminsMapIndex].value;

				oldMembersUIdCache[ aTagMemberObject.getId() ] = true;

				if( aTagMemberObject.isOwner() ){
					continue;
				}

				if( !newAdminUIdsToSetCache[ aTagMemberObject.getId()] && !newMemberUIdsToSetCache[ aTagMemberObject.getId() ]){
					//Now Not In Member And Admin, remove this user

					//Admin to Remove List
					serializedMemberAdminsToRemove.push(aTagMemberObject.serialize());

					membersAdminToRemoveOnSuccess.push(aTagMemberObject);

				}else
				{

					statusChanged = false;
					if( aTagMemberObject.isAdmin() ){
						//Previously Admin

						if(  !!newMemberUIdsToSetCache[ aTagMemberObject.getId() ] ){
							//Now In Member

							//Change Status To Member
							aTagMemberObject.makeMember();

							statusChanged = true;

						}

					}else if( aTagMemberObject.isMember() ){
						//Previously Member

						if(  !!newAdminUIdsToSetCache[ aTagMemberObject.getId() ] ){
							//Now In Admin

							//Change Status To Member
							aTagMemberObject.makeAdmin();

							statusChanged = true;

						}
					}

					if(statusChanged){

						//Add to Status Change List
						//Only { userId : userId } needed, using serialize for generic interface
						serializedMemberAdminsToStatusChange.push(aTagMemberObject.serialize());

						membersAdminToUpdateOnSuccess.push(aTagMemberObject);
					}

				}

			}

			angular.forEach(memberUIdsToSet, function(aMemberUId){

				if( !oldMembersUIdCache[aMemberUId] && aMemberUId !== currentUser.getKey() ){
					//New Member

					aNewMember = userFactory.getUser(aMemberUId);

					newTagMemberObject = tagChatFactory.createNewTagMember(
						oldTagObj.getTagId(),
						{ 	userId : aMemberUId, addedBy : currentUser.getKey(),
							fullName : aNewMember.getName(),
							status : GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER
						},
						true
					);
					membersAdminToAddOnSuccess.push(newTagMemberObject);

					serializedNewMemberAdminsToAdd.push( newTagMemberObject.serialize() );

				}
			});

			angular.forEach(adminUIdsToSet, function(anAdminUId){

				if( !oldMembersUIdCache[anAdminUId] && anAdminUId !== currentUser.getKey() ){
					//New Admin

					aNewAdmin = userFactory.getUser(anAdminUId);

					newTagAdminObject = tagChatFactory.createNewTagMember(
						oldTagObj.getTagId(),
						{ 	userId : anAdminUId, addedBy : currentUser.getKey(),
							fullName : aNewAdmin.getName(),
							status : GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN
						},
						true
					);

					membersAdminToAddOnSuccess.push(newTagAdminObject);

					serializedNewMemberAdminsToAdd.push( newTagAdminObject.serialize() );

				}
			});


			return {
				serializedMemberAdminsToRemove : serializedMemberAdminsToRemove,
				serializedMemberAdminsToStatusChange : serializedMemberAdminsToStatusChange,
				serializedNewMemberAdminsToAdd : serializedNewMemberAdminsToAdd,
				membersAdminToAddOnSuccess : membersAdminToAddOnSuccess,
				membersAdminToRemoveOnSuccess : membersAdminToRemoveOnSuccess,
				membersAdminToUpdateOnSuccess : membersAdminToUpdateOnSuccess

			};


		}

		function __hasTagUpdated(oldTagObj, newTagName, newPictureFileName,
								 serializedNewMemberAdminsToAdd, serializedMemberAdminsToRemove, serializedMemberAdminsToStatusChange){

			if( (serializedNewMemberAdminsToAdd.length > 0) 		||
				(serializedMemberAdminsToRemove.length > 0) 		||
				(serializedMemberAdminsToStatusChange.length > 0) 	||
				(oldTagObj.getTagName() !== newTagName) 			||
				( oldTagObj.getPictureUrl() !== newPictureFileName)

			){
				return true;
			}
			return false;

		}


		function __addNewMembers(oldTagObj, serializedNewMemberAdminsToAdd, membersAdminToAddOnSuccess){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				addTagMembersInAuthFailed,
				serializedNewMemberAdminsUserIds,
				addTagMemberInChatServerChatSocketCallPacketId,
				addTagMemberInChatServerChatSocketCallSuccessStatus,
				tagMemberAddConfirmation;

			if( serializedNewMemberAdminsToAdd.length > 0 ){

				/**************************** Handle New Members in Auth *********************************/

				addTagMembersInAuthFailed = false;

				serializedNewMemberAdminsUserIds = serializedNewMemberAdminsToAdd.keyValues('userId');


				var requestObject = AuthRequests.getTagChatMembersAddObject(oldTagObj.getTagId(), serializedNewMemberAdminsUserIds );

				ChatWorkerCommands.sendTagChatMemberAddAuthRequest( requestObject );

				/**************************** Handle New Members in Chat *********************************/

				var requestObject = ChatRequests.getTagChatTagMemberAddObject(oldTagObj.getTagId(),
					serializedNewMemberAdminsToAdd 
				);

				var serverCurrentTime = ChatUtilsFactory.getChatServerCurrentTime();
				
				ChatConnector.request(requestObject).then(function(response){
					
					if( !!response.sucs ){

						angular.forEach(membersAdminToAddOnSuccess, function(aMemberToAdd){
							oldTagObj.addMember(aMemberToAdd);
						});

						oldTagObj.setMembersCount( oldTagObj.getMembersCount() + membersAdminToAddOnSuccess.length);

						tagChatUI.showTagMembersAddStatusMessage(oldTagObj.getTagId(),
							currentUser.getKey(),
							serializedNewMemberAdminsToAdd,
							serverCurrentTime,
							response.packetId /* Need to check this */
						);

						deferred.resolve({ sucs : true , mg : 'Member( '+ membersAdminToAddOnSuccess.length +' ) Added in ' + oldTagObj.getTagName() });

					}

				}, function(response){

					deferred.reject({ sucs : false , mg : 'Unable to send tag new member add packet to chat server.'});

				});
	
			}else{
				deferred.resolve({ sucs: false});
			}

			return deferred.promise;

		}

		function __removeOldMembers(oldTagObj, serializedMemberAdminsToRemove, membersAdminToRemoveOnSuccess){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				removeTagMemberInChatServerChatSocketCallPacketId,
				removeTagMemberInChatServerChatSocketCallSuccessStatus;

			if( serializedMemberAdminsToRemove.length > 0){


				/**************************** Handle Old Members Remove in Chat *********************************/

				var serverCurrentTime = ChatUtilsFactory.getChatServerCurrentTime();

				var requestObject = ChatRequests.getTagChatMemberRemoveLeaveObject( oldTagObj.getTagId(), 
					serializedMemberAdminsToRemove
				);
				
				ChatConnector.request(requestObject).then(function(response){
					
					if( !!response.sucs ){

						angular.forEach(membersAdminToRemoveOnSuccess, function(aMemberToRemove){
							oldTagObj.removeMember(aMemberToRemove);
						});

						oldTagObj.setMembersCount( oldTagObj.getMembersCount() - membersAdminToRemoveOnSuccess.length);

						tagChatUI.showTagMembersRemoveStatusMessage(oldTagObj.getTagId(),
							currentUser.getKey(),
							serializedMemberAdminsToRemove,
							serverCurrentTime,
							response.packetId /* need to check this */

						);

						deferred.resolve({ sucs : true , mg : 'Member( '+ membersAdminToRemoveOnSuccess.length +' ) Removed from ' + oldTagObj.getTagName() });				
					}

				}, function(response){
					
					deferred.reject({ sucs : false , mg : 'Unable to send tag member remove packet to chat server.'});

				});
				
			}else{
				deferred.resolve({ sucs: false});
			}

			return deferred.promise;
		}

		function __changeMemberStatus(oldTagObj, serializedMemberAdminsToStatusChange, membersAdminToUpdateOnSuccess){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer();

			var serverCurrentTime = ChatUtilsFactory.getChatServerCurrentTime();
			if( serializedMemberAdminsToStatusChange.length > 0){


				/**************************** Handle Old TagMember Status Change in Chat *********************************/

				var requestObject = ChatRequests.getTagChatTagMemberTypeChangeObject(oldTagObj.getTagId(), 
					serializedMemberAdminsToStatusChange
				);

				ChatConnector.request(requestObject).then(function(response){
					
					if( !!response.sucs ){

						angular.forEach(membersAdminToUpdateOnSuccess, function(aMemberToUpdate){
							oldTagObj.updateMember(aMemberToUpdate);
						});

						tagChatUI.showMemberTypeChangeStatusMessage(oldTagObj.getTagId(),
							currentUser.getKey(),
							serializedMemberAdminsToStatusChange,
							serverCurrentTime,
							response.packetId
						);

						deferred.resolve({ sucs : true , mg : 'Member( '+ membersAdminToUpdateOnSuccess.length +' ) Status Updated for ' + oldTagObj.getTagName() });

					}

				}, function(response){
					
					deferred.reject({ sucs : false , mg : 'Unable to send tag member status change packet to chat server.'});

				});
				

			}else{
				deferred.resolve({ sucs: false});
			}

			return deferred.promise;
		}

		function __updateTagInformation(oldTagObj, newTagName, newPictureFileName){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				oldTagName = oldTagObj.getTagName(),
				oldTagPictureUrl = oldTagObj.getPictureUrl(),
				tagNameUpdated = oldTagObj.getTagName() !== newTagName,
				tagPictureUrlUpdated =oldTagObj.getPictureUrl() !== newPictureFileName,
				tagInfoUpdated = tagNameUpdated || tagPictureUrlUpdated,
				tagInfoChangeStatusMessageType,
				activityType;
				

			if( tagInfoUpdated  ){

				/**************************** Handle tag info update in Chat *********************************/

				tagInfoChangeStatusMessageType = tagChatUI.getTagInfoChangeStatusMessage(oldTagObj.getTagId(),
					{ tagName : newTagName || "", tagPictureUrl: newPictureFileName || "" }
				);

				//Reflect Changes
				if(tagNameUpdated){
					oldTagObj.setTagName( newTagName );
					activityType = GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_RENAME;

					var requestObject = ChatRequests.getTagChatTagInformationObject(oldTagObj.getTagId(), 
						activityType, newTagName, oldTagPictureUrl
					);

					ChatConnector.request(requestObject).then(function(response){
						
						if( !!response.sucs ){

							tagChatUI.showTagInfoChangeStatusMessage(oldTagObj.getTagId(),
								currentUser.getKey(),
								{ statusMessageType : tagInfoChangeStatusMessageType, tagName : newTagName }
							);

							if( !tagPictureUrlUpdated){
								deferred.resolve({ sucs : true , mg : 'Updated Group Info of ' + oldTagObj.getTagName() });	
							}
							
						}

					}, function(response){
						
						if(tagNameUpdated){
							oldTagObj.setTagName( oldTagName );
						}

						deferred.reject({ sucs : false , mg : 'Unable to send tag info tag name change packet to chat server.'});

					});
					

					
				}

				if( tagPictureUrlUpdated){

					oldTagObj.setPictureUrl( newPictureFileName );
					activityType = GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_URL_RENAME;

			
					var requestObject = ChatRequests.getTagChatTagInformationObject(oldTagObj.getTagId(), 
						activityType, oldTagName, newPictureFileName
					);

					ChatConnector.request(requestObject).then(function(response){
						
						if( !!response.sucs ){

							tagChatUI.showTagInfoChangeStatusMessage(oldTagObj.getTagId(),
								currentUser.getKey(),
								{ statusMessageType : tagInfoChangeStatusMessageType, tagName : newTagName }
							);

							deferred.resolve({ sucs : true , mg : 'Updated Group Info of ' + oldTagObj.getTagName() });					

						}

					}, function(response){
						
						if( tagPictureUrlUpdated){
							oldTagObj.setPictureUrl( oldTagPictureUrl );
						}

						deferred.reject({ sucs : false , mg : 'Unable to send tag info tag picture url packet to chat server.'});

					});
					
				}

			}else{
				deferred.resolve({ sucs: false});
			}

			return deferred.promise;

		}

		function _updateTag(oldTagObj, newTagName, newPictureFileName, memberUIdsToSet, adminUIdsToSet){

			var currentUser = Auth.currentUser(),
				membersForCRUD,
				serializedNewMemberAdminsToAdd,
				membersAdminToAddOnSuccess,
				serializedMemberAdminsToRemove,
				membersAdminToRemoveOnSuccess,
				serializedMemberAdminsToStatusChange,
				membersAdminToUpdateOnSuccess;


			var deferred = $q.defer();

			/****************************  Get MemberUId Diff *********************************/
				membersForCRUD = __getMembersForCRUD(oldTagObj, memberUIdsToSet, adminUIdsToSet);
				serializedNewMemberAdminsToAdd = membersForCRUD.serializedNewMemberAdminsToAdd;
				membersAdminToAddOnSuccess = membersForCRUD.membersAdminToAddOnSuccess;

				serializedMemberAdminsToRemove = membersForCRUD.serializedMemberAdminsToRemove;
				membersAdminToRemoveOnSuccess = membersForCRUD.membersAdminToRemoveOnSuccess;

				serializedMemberAdminsToStatusChange = membersForCRUD.serializedMemberAdminsToStatusChange;
				membersAdminToUpdateOnSuccess = membersForCRUD.membersAdminToUpdateOnSuccess;

				var successCount = 0;

				/****************************  Handle New Members *********************************/
				__addNewMembers(oldTagObj, serializedNewMemberAdminsToAdd, membersAdminToAddOnSuccess).then(function(response){
					if(!!response.sucs){
						successCount++;
						deferred.notify(response);
					}
				}, deferred.reject);



				/**************************** Handle Old Members Remove *********************************/
				__removeOldMembers(oldTagObj, serializedMemberAdminsToRemove, membersAdminToRemoveOnSuccess).then(function(response){
					if(!!response.sucs){
						successCount++;
						deferred.notify(response);
					}
				}, deferred.reject);

				/**************************** Handle Current Member Status Change *********************************/
				__changeMemberStatus(oldTagObj, serializedMemberAdminsToStatusChange, membersAdminToUpdateOnSuccess).then(function(response){
					if(!!response.sucs){
						successCount++;
						deferred.notify(response);
					}
				}, deferred.reject);


				/**************************** Handle Tag Info Update *********************************/
				__updateTagInformation(oldTagObj, newTagName, newPictureFileName).then(function(response){
					if(!!response.sucs){
						successCount++;
						deferred.notify(response);
					}
				}, deferred.reject);


				setTimeout(function(){
					if( !successCount ){
						deferred.reject({ sucs: false });
					}else{
						deferred.resolve({ sucs: true });
					}

				}, 18000);

			utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED);

			return deferred.promise;


		}
		/******************************* TAG CRUD End ******************************/

		/******************************* TAG Member CRUD Start ******************************/

		function _leaveFromTag(tagId){
			var tagObject = tagChatFactory.getTag(tagId);

			var currentOwner = tagObject.getMember(Auth.currentUser().getKey());

			return _removeTagMember(tagId, [ currentOwner.serialize() ], [currentOwner] );
		}

		function _removeTagMember(tagId, tagMemberUserIdsToRemove, membersAdminToRemoveOnSuccess){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				tagObject = tagChatFactory.getTag(tagId),
				isSuccess = false;


			var requestObject = ChatRequests.getTagChatMemberRemoveLeaveObject( tagId, 
				tagMemberUserIdsToRemove
			);
		
			ChatConnector.request(requestObject).then(function(response){
				
				if( !!response.sucs ){

					tagObject = tagChatFactory.getTag(tagId);

					var statusMsg = 'Member( '+ membersAdminToRemoveOnSuccess.length +' ) Removed from ' + tagObject.getTagName();
					
					var tagRemoved = false;

					for(var index = 0; index < membersAdminToRemoveOnSuccess.length; index++ ){
						var aMemberToRemove = membersAdminToRemoveOnSuccess[index];

						if( aMemberToRemove.getId() === currentUser.getKey() ){

							statusMsg = 'You left from (' + tagObject.getTagName() + ') conversation ';

							tagChatFactory.removeTagObject(tagId);

							tagRemoved = true;
							
							deferred.resolve({ sucs : true , mg :  statusMsg });


						}

						if( tagRemoved ) break;

						tagObject.removeMember(aMemberToRemove);

					}

					if( !tagRemoved ){

						deferred.resolve({ sucs : true , mg :  statusMsg });		
					}

				}

			}, function(response){

				deferred.reject({ sucs : false , mg : 'Unable to send tag member remove packet to chat server.'});
				
			});
			

			utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED);

			return deferred.promise;
		}

		function _changeTagMemberStatus(tagId, serializedStatusToChangeMembers, membersAdminToUpdateOnSuccess){

			var currentUser = Auth.currentUser(),
				deferred = $q.defer(),
				tagObject = tagChatFactory.getTag(tagId),
				isSuccess = false;

			
			var requestObject = ChatRequests.getTagChatTagMemberTypeChangeObject(tagId, 
				serializedStatusToChangeMembers
			);

			ChatConnector.request(requestObject).then(function(response){
				
				if( !!response.sucs ){
					angular.forEach(membersAdminToUpdateOnSuccess, function(aMemberToUpdate){
						tagObject.updateMember(aMemberToUpdate);
					});

					deferred.resolve({ sucs : true , mg : 'Member( '+ serializedStatusToChangeMembers.length +' ) Status Updated for ' + tagObject.getTagName() });					
				}

			}, function(response){

				deferred.reject({ sucs : false , mg : 'Unable to send tag member status change packet to chat server.'});

			});

			utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED);

			return deferred.promise;
		}

		function _openPreviouslyOpenedBoxes(tagId){

			callXTimeAfterYIntervalStopOnSuccess(
				function(){

					var tagObject = tagChatFactory.getTag(tagId);

					if( !!tagObject && tagObject.isTagSafeToShow()){
						var tagChatBox = ChatFactory.getBoxByUId(tagId);
						_openTagChatBoxIfClosed(tagId, tagChatBox);
					}

				},
				function(iterationCount){

					var tagObject = tagChatFactory.getTag(tagId);

					if( !!tagObject && tagObject.isTagSafeToShow()){
						return true;
					}
					return false;
				},
				function(){
				},
				5,
				5000
			);

		}

		function _openTagChatBoxIfClosed(tagId, box){


			var shouldLoadHistory = false;

			if(!box){
				shouldLoadHistory = true;

				var tagObject = tagChatFactory.getOrCreateTag(tagId);

				if( tagObject.isTagSafeToShow()){

					ChatFactory.openTagChatBox(tagId);
					box = ChatFactory.getBoxByUId(tagId);					
					box.setTitle(tagObject.getTagName());

				}else{

					box = ChatFactory.creatNonDomBox(tagId, true);			
				}

				box.setTitle(tagObject.getTagName());

			}

			if(shouldLoadHistory){
				box.loadHistoryMessages();
			}

			return box;

		}

		return {

			createTag: _createTag,
			updateTag : _updateTag,
			leaveFromTag : _leaveFromTag,
			removeTagMember  : _removeTagMember,
			changeTagMemberStatus : _changeTagMemberStatus,			

			openTagChatBoxIfClosed : _openTagChatBoxIfClosed,
			openPreviouslyOpenedBoxes : _openPreviouslyOpenedBoxes,

		};


	}

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	var tagChatApp = angular.module('ringid.chat');

	tagChatApp.factory('tagChatModels', tagChatModels);


	tagChatModels.$inject = ['$$stackedMap',
        'profileFactory', 'userFactory', 'utilsFactory', 'Auth',        
		'settings'];


	function tagChatModels($$stackedMap,
                           profileFactory, userFactory, utilsFactory, Auth,						   
							settings){

		var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;
		

		var LOCAL_CHAT = GENERAL_CONSTANTS.LOCAL_CHAT;
		var API_VERSION_PORT_OFFSET = GENERAL_CONSTANTS.API_VERSION_PORT_OFFSET;

		function TagObject(){

            var self = this;

			var tag = {
				id : 0,
				name : 'Group',
				pictureUrl : '',
				userId : 0,
				packetId : 0,
				memberCount : 0, /*** Received From Server With Tag Object **/
                serverDate : 0,
				serverDateDiff : 0,

                /** Members means admin, member, owner **/
				members : $$stackedMap.createNew(),
				messages : $$stackedMap.createNew(),


                /*** our property ***/
                objectLock : false,
				ownerUserId : 0,

				creationTime : 0,

			};



			this.getTagId = function(){
				return tag.id;
			};

			this.setTagId = function(tagId){
				tag.id = tagId;
				tag.creationTime = tagId.toString().substr(0, GENERAL_CONSTANTS.TAG_ID_NO_OF_TIME_DIGIT);
			};

			this.getTagCreationTime = function(){
				return tag.creationTime;
			};

			this.getUserId = function(){
				return tag.userId;
			};

			this.setUserId = function(userId){
				tag.userId = userId;
			};

			this.getPacketId = function(){
				return tag.packetId;
			};

			this.setPacketId = function(packetId){
				tag.packetId = packetId;
			};

            this.renewPacketId = function(){
                self.setPacketId(utilsFactory.getUniqueID('tgrc'));
            };

			this.getTagName = function(){
				return tag.name;
			};

			this.setTagName = function(tagName){
				tag.name = tagName;
			};

			this.setPictureUrl = function(pictureUrl){
				//Storing Picture File Name
				tag.pictureUrl = pictureUrl;
			};

			this.getPictureUrl = function(){
				//Returns Picture File Name
				return tag.pictureUrl.trim();
			};

			this.getPictureFullUrl = function(){
				if( this.getPictureUrl() != ""){
					return settings.imBase + this.getPictureUrl();
				}else{
					return "images/prof.png";
				}
				
			};

            this.setServerDate = function (serverDate) {
                tag.serverDate = serverDate;
				self.setServerDateDiff(serverDate - parseInt(new Date().getTime()));
            };

            this.getServerDate = function(){
                return tag.serverDate;
            };

			this.setServerDateDiff = function (serverDateDiff) {
				tag.serverDateDiff = serverDateDiff;
			};

			this.getServerDateDiff = function(){
				return tag.serverDateDiff;
			};


			this.getMembersCount = function(){
				return tag.memberCount;
			};


			this.setMembersCount = function(memberCount){
				tag.memberCount = memberCount;
			};

			this.isTagSafeToShow = function(){
				return (self.getMembersObjectMap().length() > 1) && self.isUserMember(Auth.currentUser().getKey());
			};





			/***************** Members **************/

			this.initMembers = function(){
				tag.members = $$stackedMap.createNew();
			};

			this.addMember = function(memberObj){
				if( !tag.members){
					tag.members = self.initMembers();
				}

				if(memberObj.isOwner()){
					tag.ownerUserId = memberObj.getId();
				}

				tag.members.save( memberObj.getId(), memberObj);
			};

			this.updateMember = function(updatedMemberObj){
				this.addMember( updatedMemberObj );
			};

			this.removeMember = function(memberObjOrId){
                if( memberObjOrId instanceof TagMember){
    				tag.members.remove(memberObjOrId.getId());
                }else{
                    tag.members.remove(memberObjOrId);
                }
			};

			this.membersLength = function(){
                if( !!tag.members ){
    				return tag.members.length();
                }
                return 0;
			};

			this.getMember = function(memberUserId){
				return tag.members.get(memberUserId);
			};

			this.getMemberObjects = function(){
				return tag.members.values();
			};

            this.getMemberUserIds = function(){
                return tag.members.keys();
            };

            this.getMembersObjectMap = function(){
                return tag.members;
            };

            this.setMembersObjectMap = function(memberObj){
                tag.members = memberObj;
            };

			this.initMemberObjects = function(){
				var tagMembers = tag.members.all();
				for(var index = 0; index < tag.members.length(); index++ ){
					var aTagMember = tagMembers[index].value;
					setTimeout(function(aTagMember){
						aTagMember.initUserObjects();

					}.bind(null, aTagMember), GENERAL_CONSTANTS.API_FETCH_RETRY_DELAY);
				}
			};

			this.getSerializedMembers = function(){
				var allTagMembers = tag.members.all();
				var serializedObjectArray = [];

				for(var tagMembersIndex = 0; tagMembersIndex < allTagMembers.length; tagMembersIndex++ ){
					var aTagMember = allTagMembers[ tagMembersIndex].value;

					serializedObjectArray.push(aTagMember.serialize());
				}

				return serializedObjectArray;
			};

			this.isUserMember = function(userId){
				/*** Returns if userId contains in members list, not actual member status ***/
				if(!tag.members){
					return false;
				}else{
					return !!tag.members.get(userId);
				}
			};

			this.isCurrentUserStatusAdmin = function(userId){
				var userObj = !!tag.members && tag.members.get(userId);
				if(!!userObj){
					return userObj.isAdmin();
				}
				return false;
			};

			this.isCurrentUserStatusMember = function(userId){
				var userObj = !!tag.members && tag.members.get(userId);
				if(!!userObj){
					return userObj.isMember();
				}
				return false;
			};

            this.setObjectLock = function(){
                tag.objectLock = true;
            };

            this.removeObjectLock = function(){
                tag.objectLock = false;
            };

            this.hasObjectLock = function(){
                return tag.objectLock;
            };

			this.setOwnerUserId = function(ownerUserId){
				tag.ownerUserId = ownerUserId;
			};

			this.getOwnerUserId = function(){
				return tag.ownerUserId;
			};

			/*********** *************/

			this.initMessages = function(){
				tag.messages = $$stackedMap.createNew();
			};

			this.addMessage = function(messageObj){
				if( !tag.messages){
					tag.messages = self.initMessages();
				}
				tag.messages.save( messageObj.getPacketId(), messageObj);
			};

			this.removeMessage = function(messageObjOrId){
                if( messageObjOrId instanceof TagMessage){
    				tag.messages.remove(messageObjOrId.getId());
                }else{
                    tag.messages.remove(messageObjOrId);
                }
			};

			this.messagesLength = function(){
                if( !!tag.messages ){
    				return tag.messages.length();
                }
                return 0;
			};

			this.getMessage = function(messagePacketId){
				return tag.messages.get(messagePacketId);
			};

			this.getMessageObjects = function(){
				return tag.messages.values();
			};

            this.getMessageUserIds = function(){
                return tag.messages.keys();
            };

            this.getMessagesObjectMap = function(){
                return tag.messages;
            };

            this.setMessagesObjectMap = function(messageObj){
                tag.messages = messageObj;
            };

			this.debug = function(){
				return tag;
			};


			/**********  *************/

		}

        TagObject.prototype.copy = function(){

              var newTag = new TagObject();
              newTag.setTagId( this.getTagId() );
              newTag.setTagName( this.getTagName() );
              newTag.setPictureUrl( this.getPictureUrl() );
              newTag.setUserId( this.getUserId() );
              newTag.setPacketId( this.getPacketId() );
              newTag.setChatBindingPort( this.getChatBindingPort() );
              newTag.setChatIp( this.getChatIp() );
              newTag.setChatRegisterPort( this.getChatRegisterPort() );
              newTag.setServerDate( this.getServerDate() );

              newTag.setMembersObjectMap( this.getMembersObjectMap().copy() );

              return newTag;

        };

		TagObject.prototype.update = function(newTagObj){

			if( !!newTagObj.getTagName() ){
			  this.setTagName( newTagObj.getTagName() );
			}

			if( !!newTagObj.getPictureUrl() ){
				this.setPictureUrl( newTagObj.getPictureUrl() );
			}

			if( !!newTagObj.getUserId() ){
				this.setUserId( newTagObj.getUserId() );
			}

			if( !!newTagObj.getPacketId() ){
				this.setPacketId(  newTagObj.getPacketId() );
			}

			if( !!newTagObj.getServerDate() ){
				this.setServerDate( newTagObj.getServerDate() );
			}

		};

		TagObject.prototype.sortBy = function(){
			return this.getTagCreationTime();
		};

		function TagMember(){

			var self = this;

			var tagMember = {
				tagId : 0,
				userId : 0,
				fullName : '',
				status : 0,
				statusValue : '',
				addedBy : 0,
				user : {},
				addedByUser : {}
			};

            this.initWithUserMapObject = function(anUserMapObject){

                self.setId( anUserMapObject.getKey() );
                self.setFullName( anUserMapObject.getName() );
                self.setUserObj(anUserMapObject);
            };

			this.setTagId = function(tagId){
				tagMember.tagId = tagId;
			};

			this.getTagId = function(){
				return tagMember.tagId;
			};

			this.setId = function(memberId){
				tagMember.userId = memberId.toString();
			};

			this.getId = function(){
				return tagMember.userId;
			};

			this.getUser = function(){
				return userFactory.getUser(tagMember.userId);
				//return tagMember.user;
			};

			this.setFullName = function(fullName){
				tagMember.fullName = fullName;
			};

			this.getFullName = function(){
				return tagMember.fullName;
			};

			this.getPictureUrl = function(){
				if( !self.getUser().getUserAvatar){
					return 'images/prof.png';
				}else{
					return settings.imBase +  self.getUser().getUserAvatar();
				}
			};

			this.getName = function(){
				if( tagMember.fullName !== ''){

					return tagMember.fullName;

				}else if(!!self.getUser()) {

					  return self.getUser().getName();
				}else{

					return tagMember.userId;
				}

			};

			this.getStatus = function(){
				return tagMember.status;
			};

			this.getStatusValue = function(){
				if( tagMember.status === GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN){
					return 'admin';
				}else if( tagMember.status === GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER){
					return 'member';
				}else{
					return 'owner';
				}
			};

			this.setStatus = function(status){
				tagMember.status = status;
			};

			this.setAddedBy = function(addedBy){
				tagMember.addedBy = addedBy;
			};

			this.getAddedBy = function(){
				return tagMember.addedBy;
			};

			this.getAddedByUser = function(){
				return userFactory.getUser(tagMember.addedBy);
				//return tagMember.addedByUser;
			};

			this.getAddedByUserName = function(){
				return !!self.getAddedByUser() && self.getAddedByUser().getName();
			};

			this.setAddedByUserObj = function(userObj){
				tagMember.addedByUser = userObj;
			};

			this.setUserObj = function(userObj){
				tagMember.user = userObj;
			};

            this.initUserObjects = function(){

				profileFactory.getUserDetailsByUId(tagMember.userId);

				setTimeout(function(tagMember){

					profileFactory.getUserDetailsByUId(tagMember.addedBy);

				}.bind(null, tagMember), 200);

            };

			this.isCurrentUser = function(){
				return self.getId() === Auth.currentUser().getKey();
			};

			this.isAdmin = function(){
				return tagMember.status == GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN;
			};

			this.isMember = function(){
				return tagMember.status == GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER;
			};

			this.isOwner = function(){
				return tagMember.status == GENERAL_CONSTANTS.MEMBER_STATUS.OWNER;
			};

			this.isRemoved = function(){
				return tagMember.status == GENERAL_CONSTANTS.MEMBER_STATUS.REMOVED;
			};

			this.makeAdmin = function(){
				tagMember.status = GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN;
			};

			this.makeMember = function(){
				tagMember.status = GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER;
			};

			this.makeOwner = function(){
				tagMember.status = GENERAL_CONSTANTS.MEMBER_STATUS.OWNER;
			};


			this.serialize = function(){
				return {
					userId : self.getId(),
					fullName : self.getName().utf8Encode(),
					status : self.getStatus(),
					addedBy : self.getAddedBy()
				};
			};
		}

		function TagMessage(){

			var self = this;

			var tagMessage = {
				tagId : 0,
				text: '',
				hrtime: '',
				status: '',
				messageDate: '',
				isDeleted: false,
				messageDateString: '',
				timeout: 0,
				userId : 0,
				fullName : '',
				type : 0,
				packetId : 0,


				/***** Derived *****/
				user : {},

				seenPacketSent : false,
				deliveredPacketSent : false,
				statusType : '',

				seenUsers : [],
				deliveredUsers : [],

				usersToChange : {},

				/*** Helper ****/
				tagName : ''


			};

			this.getTagId = function(){
				return tagMessage.tagId;
			};

			this.setTagId = function(tagId){
				tagMessage.tagId = tagId;
			};

			this.getHumanReadableTime = function(){
				return tagMessage.hrtime;
			};

			this.setHumanReadableTime = function(hrtime){
				tagMessage.hrtime = hrtime;
			};

			this.setFullName = function(fullName){
				tagMessage.fullName = fullName.substring(0, 127);;
			};

			this.getFullName = function(){
				return tagMessage.fullName;
			};

			this.getPacketId = function(){
				return tagMessage.packetId;
			};

			this.setPacketId = function(packetId){
				tagMessage.packetId = packetId;
			};

			this.getMessageText = function(messageText){
				return tagMessage.text;
			};

			this.setMessageText = function(messageText){
				tagMessage.text = messageText;
			};

			this.setStatus = function(messageStatus){
				tagMessage.status = messageStatus;
			};

			this.getStatus = function(){
				return tagMessage.status;
			};

			this.setMessageDate = function(messageDate){
				tagMessage.messageDate = messageDate;
			};

			this.getMessageDate = function(){
				return tagMessage.messageDate;
			};

			this.markAsDeleted = function(){
				tagMessage.isDeleted = true;
			};

			this.unMarkFromDeleted = function(){
				tagMessage.isDeleted = false;
			};

			this.getIsDeleted = function(){
				return tagMessage.isDeleted;
			};

			this.setMessageDateString= function(messageDateString){
				tagMessage.messageDateString = messageDateString;
			};
			this.setTimeout = function(timeout){
				tagMessage.timeout = timeout;

			};
			this.setUserId = function(userId){
				tagMessage.userId = userId;
			};

			this.getMessageDateString= function(){
				return tagMessage.messageDateString;
			};

			this.getTimeout = function(){
				return tagMessage.timeout;
			};

			this.getUserId = function(){
				return tagMessage.userId;
			};

			this.getUser = function(){
				return userFactory.getUser(tagMessage.userId);
			};

			this.getMessageType = function(){
				return tagMessage.type;
			};

			this.setMessageType = function(messageType){
				return tagMessage.type = messageType;
			};

			this.initUserObjects = function() {
				profileFactory.getUserDetailsByUId(tagMessage.userId).then(function (userObj) {
					if (!!userObj) {
						tagMessage.user = userObj;
					}
				});
			};

			this.getSeenPacketSent = function(){
				return tagMessage.seenPacketSent;
			};

			this.getDeliveredPacketSent = function(){
				return tagMessage.deliveredPacketSent;
			};

			this.setSeenPacketSent = function(seenPacketSent){
				tagMessage.seenPacketSent = seenPacketSent;
			};

			this.setDeliveredPacketSent = function( deliveredPacketSent ){
				tagMessage.deliveredPacketSent = deliveredPacketSent;
			};

			this.addSeenUserId = function(userId){
				tagMessage.seenUsers.push(userId);
			};

			this.addDeliveredUserId = function(userId){
				tagMessage.deliveredUsers.push(userId);
			};

			this.setUsersToChange = function(usersToChange){
				tagMessage.usersToChange = usersToChange;
			};

			this.getUsersToChange = function(usersToChange){
				return tagMessage.usersToChange;
			};

			this.setStatusType = function(statusType){
				tagMessage.statusType = statusType;
			};

			this.getStatusType = function(){
				return tagMessage.statusType;
			};

			this.getTagName = function(){
				return tagMessage.tagName;
			};

			this.setTagName = function(tagName){
				tagMessage.tagName = tagName;
			};


			this.serialize = function(){
				return {
					tagId : self.getTagId(),
					userId : self.getUserId(),
					user : self.getUserId(),
					packetId : self.getPacketId(),
					fullName : self.getFullName().utf8Encode(),
					status : self.getStatus(),
					statusType : self.getStatusType(),
					type : self.getMessageType(),
					hrtime : self.getHumanReadableTime(),
					messageDate : self.getMessageDate(),
					isDeleted : tagMessage.isDeleted,
					timeout : self.getTimeout(),
					text : self.getMessageText().utf8Encode(),

					seenPacketSent : self.getSeenPacketSent(),
					deliveredPacketSent : self.getDeliveredPacketSent(),
					usersToChange : Object.keys(tagMessage.usersToChange),

					messageType: self.getMessageType(),
					tag_chat : true,
					tagName : self.getTagName()

				};
			};
		}

		TagMessage.prototype.update = function(newTagMessageObj){

			if( !!newTagMessageObj.getFullName() ){
				this.setFullName( newTagMessageObj.getFullName() );
			}

			if( !!newTagMessageObj.getStatus() ){
				this.setStatus( newTagMessageObj.getStatus() );
			}

			if( !!newTagMessageObj.getStatusType() ){
				this.setStatusType( newTagMessageObj.getStatusType() );
			}

			if( !!newTagMessageObj.getMessageType() ){
				this.setMessageType( newTagMessageObj.getMessageType() );
			}

			if( !!newTagMessageObj.getMessageDate() ){
				this.setMessageDate( newTagMessageObj.getMessageDate() );
			}

			if( !!newTagMessageObj.getMessageText() ){
				this.setMessageText( newTagMessageObj.getMessageText() );
			}

			if( !!newTagMessageObj.getUsersToChange() ){
				this.setUsersToChange( newTagMessageObj.getUsersToChange() );
			}

			if( !!newTagMessageObj.getMessageType() ){
				this.setMessageType( newTagMessageObj.getMessageType() );
			}

			if( !!newTagMessageObj.getSeenPacketSent() ){
				this.setSeenPacketSent( newTagMessageObj.getSeenPacketSent() );
			}

			if( !!newTagMessageObj.getDeliveredPacketSent() ){
				this.setDeliveredPacketSent( newTagMessageObj.getDeliveredPacketSent() );
			}

			if( !!newTagMessageObj.getDeliveredPacketSent() ){
				this.setDeliveredPacketSent( newTagMessageObj.getDeliveredPacketSent() );
			}

			if( !!newTagMessageObj.getTimeout() ){
				this.setTimeout( newTagMessageObj.getTimeout() );
			}

			if( !!newTagMessageObj.getIsDeleted()){
				this.markAsDeleted();
			}

			if( !newTagMessageObj.getHumanReadableTime() ){
				this.setHumanReadableTime(newTagMessageObj.getHumanReadableTime());
			}
		};

		return {

			TagObject : TagObject,
			TagMember : TagMember,
			TagMessage: TagMessage

		};
	}


})();

/*
 * © Ipvision
 * @Ibrahim Rashid
 * Tyring to build an optimized serializer for localstorage
 */

(function() {
	'use strict';

	angular
        .module('ringid.chat')
		.factory('tagChatStorage', tagChatStorage);

		tagChatStorage.$inject = [
			'Storage', 'Auth', 'utilsFactory'

		];

		function tagChatStorage(
			Storage, Auth, utilsFactory

		) {

			var StorageObjectModel = {
				packets : {}
			};

			function _init(){
				var localStorageObjectModel = __readFromLocalStorage();
				if(!localStorageObjectModel){					
					__writeToLocalStorage(StorageObjectModel );	
				}else{
					StorageObjectModel  = angular.fromJson(localStorageObjectModel);
				}

			}

			function _getStoreKey(){
				return 'tagc-store-' + Auth.currentUser().getKey();
			}

			function __writeToLocalStorage(data){
				Storage.setData(_getStoreKey(), angular.toJson(data));
			}

			function __readFromLocalStorage(){
				return Storage.getData(_getStoreKey());
			}

			function _savePacket(packetId, packetData){
				StorageObjectModel.packets[packetId] = utilsFactory.arrayBuffer2String(packetData.buffer.slice(6));
				__writeToLocalStorage(StorageObjectModel);
			}

			function _getPacket(packetId){				
				return utilsFactory.string2ArrayBuffer(StorageObjectModel.packets[packetId]);
			}

			function _getAllPackets(){
				return StorageObjectModel.packets;
			}

			if(Auth.isLoggedIn()){
				//_init();
			}

			return {

				savePacket : _savePacket,
				getPacket  : _getPacket,
				getAllPackets : _getAllPackets
			}

			

		}
})();

(function() {
    'use strict';

    angular
        .module('ringid.chat')
        .factory('tagChatUI', tagChatUI);

    tagChatUI.$inject = [
            'ChatFactory',
            'utilsFactory',
            'chatHistoryFactory',
            'tagChatFactory',
            'Ringalert'
        ];

    function tagChatUI (

        ChatFactory,
        utilsFactory,
        chatHistoryFactory,
        tagChatFactory,
        Ringalert

    ) {

        var Constants = CHAT_APP.Constants;
        var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;

        return {
            getTagInfoChangeStatusMessage : _getTagInfoChangeStatusMessage,
            showTagInfoChangeStatusMessage : _showTagInfoChangeStatusMessage,

            showMemberTypeChangeStatusMessage: _showMemberTypeChangeStatusMessage,

            showTagMembersAddStatusMessage : _showTagMembersAddStatusMessage,
            showTagMembersRemoveStatusMessage : _showTagMembersRemoveStatusMessage

        };

        ///////////////////

        function __getMemberStatusValue(memberStatusString){
            var memberStatusValue;

            if( memberStatusString=== 'admin'){
                memberStatusValue = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_ADMIN;
            }else if( memberStatusString === 'member'){
                memberStatusValue = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_MEMBER;
            }else{
                memberStatusValue = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_OWNER;
            }

            return memberStatusValue;
        }

        function __getTagMemberByStatusGroup( changedTagMembers ){

            var statusChangeGroup = {};

            for(var index = 0; index < changedTagMembers.length; index++){
                var aTagMember = changedTagMembers[ index ];

                var statusValue;
                if( angular.isString(aTagMember.status)){
                    statusValue = __getMemberStatusValue(aTagMember.status);
                }else{
                    statusValue = aTagMember.status;
                }

                if(!statusChangeGroup[statusValue]){
                    statusChangeGroup[statusValue] = [];
                }

                statusChangeGroup[statusValue].push(aTagMember);
            }

            return statusChangeGroup;
        }


        function _showMemberTypeChangeStatusMessage(tagId, userId, changedTagMembers, messageDate, packetId){


            //if( !tagObject){
            //    tagObject = tagChatFactory.getTag(tagId);
            //}

            var chatBox = ChatFactory.getBoxByUId(tagId);

            var statusChangeGroup = __getTagMemberByStatusGroup(changedTagMembers);

            var restInfo = {};
            if( !!messageDate ){
                packetId = tagChatFactory.getUUIDPacketId(messageDate, true);
                restInfo['messageDate'] = messageDate;
            }


            var packetIndex = 1;

            for( var statusType in statusChangeGroup){

                if( statusChangeGroup.hasOwnProperty(statusType) ){

                    if(!packetIndex){
                        packetId = packetId + '_'  + packetIndex;
                    }

                    var statusMessageType = "";

                    statusType = parseInt(statusType);

                    if( statusType === GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN){
                        statusMessageType = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_ADMIN;

                    }else if( statusType === GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER ){

                        statusMessageType = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_MEMBER;
                    }else{

                        statusMessageType = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_OWNER;
                    }

                    var tagStatusMessage = tagChatFactory.createTagStatusMessage(
                        packetId,
                        tagId,
                        userId,
                        statusMessageType,
                        statusChangeGroup[statusType],
                        restInfo
                    );

                    if( !tagStatusMessage){ continue; }

                    var serializedStatusMessageObject = tagStatusMessage.serialize();


                    if(!chatBox){

                        chatHistoryFactory.addMessage(serializedStatusMessageObject, tagId);

                    }else{

                        chatBox.pushMessage(serializedStatusMessageObject, userId);
                    }

                }
            }

        }


        function _getTagInfoChangeStatusMessage(tagId, changedTagInfo, tagObject){

            if( !tagObject){
                tagObject = tagChatFactory.getTag(tagId);
            }

            var tagStatusMessageType = 0;

            if( !!tagObject){

                if( ( !!changedTagInfo.tagName && !!changedTagInfo.tagPictureUrl )
                    &&
                    ( tagObject.getTagName() !== changedTagInfo.tagName
                        && tagObject.getPictureUrl() !== changedTagInfo.tagPictureUrl.trim()
                    )
                ){
                    tagStatusMessageType = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_INFO_UPDATED;

                }else{

                    if( !!changedTagInfo.tagName && tagObject.getTagName() !== changedTagInfo.tagName  ){
                        tagStatusMessageType = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_NAME_CHANGE;
                    }

                    if( !!changedTagInfo.tagPictureUrl && tagObject.getPictureUrl() !== changedTagInfo.tagPictureUrl.trim()  ){
                        tagStatusMessageType = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_PICTURE_CHANGE;
                    }
                }

            }

            return tagStatusMessageType;

        }

        function _showTagInfoChangeStatusMessage(tagId, userId, changedTagInfo, packetId, tagObject){

            if( !tagObject){
                tagObject = tagChatFactory.getTag(tagId);
            }

            if( !packetId ){
                packetId = tagChatFactory.getUUIDPacketId();
            }

            var tagStatusMessageType = changedTagInfo.statusMessageType;
            if(!tagStatusMessageType){
                tagStatusMessageType = _getTagInfoChangeStatusMessage(tagId, changedTagInfo, tagObject);
            }

            if(!!changedTagInfo.messageDate){
                packetId = tagChatFactory.getUUIDPacketId(changedTagInfo.messageDate, true);
            }

            if(tagStatusMessageType !== 0){

                var chatBox = ChatFactory.getBoxByUId(tagId);

                var tagStatusMessage = tagChatFactory.createTagStatusMessage(
                    packetId,
                    tagId,
                    userId,
                    tagStatusMessageType,
                    [],
                    changedTagInfo
                );

                if( !tagStatusMessage){ return; }

                var serializedStatusMessageObject = tagStatusMessage.serialize();

                if(!chatBox){

                    chatHistoryFactory.addMessage(serializedStatusMessageObject, tagId);

                }else{

                    chatBox.pushMessage(serializedStatusMessageObject, userId);
                }

            }

        }

        function _showTagMembersAddStatusMessage(tagId, userId, changedMembers, messageDate, packetId, tagObject){

            if( !tagObject){
                tagObject = tagChatFactory.getTag(tagId);
            }

            var chatBox = ChatFactory.getBoxByUId(tagId);

            var changedMembersByStatus = __getTagMemberByStatusGroup(changedMembers);

            var restInfo = {};
            if( !!messageDate ){
                restInfo['messageDate'] = messageDate;
            }

            for( var statusType in changedMembersByStatus) {

                if (changedMembersByStatus.hasOwnProperty(statusType)) {

                    var typePacketId = packetId + '_' + statusType;

                    var statusMessageType = "";

                    statusType = parseInt(statusType);

                    if( statusType === GENERAL_CONSTANTS.MEMBER_STATUS.ADMIN){

                        statusMessageType = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_ADMIN_ADD;

                    }else if( statusType === GENERAL_CONSTANTS.MEMBER_STATUS.MEMBER ){

                        statusMessageType = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_ADD;

                    }else if( statusType === GENERAL_CONSTANTS.MEMBER_STATUS.OWNER ){

                        statusMessageType = GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_STATUS_CHANGE_OWNER;
                    }

                    var tagStatusMessage = tagChatFactory.createTagStatusMessage(
                        typePacketId,
                        tagId,
                        userId,
                        statusMessageType,
                        changedMembersByStatus[statusType],
                        restInfo
                    );

                    if( !tagStatusMessage){
                        continue;
                    }

                    var serializedStatusMessageObject = tagStatusMessage.serialize();

                    if(!chatBox){
                        chatHistoryFactory.addMessage(serializedStatusMessageObject, tagId);

                    }else{
                        chatBox.pushMessage(serializedStatusMessageObject, userId);
                    }

                }
            }

        }


        function _showTagMembersRemoveStatusMessage(tagId, userId, changedMembers, messageDate, packetId, tagObject) {

            if (!tagObject) {
                tagObject = tagChatFactory.getTag(tagId);
            }

            if (!packetId) {
                packetId = tagChatFactory.getUUIDPacketId(messageDate, true);
            }

            var chatBox = ChatFactory.getBoxByUId(tagId);

            for(var index = 0; index < changedMembers.length; index++){
                var tagMember = tagObject.getMember(changedMembers[index].userId);
                if(!!tagMember){
                    changedMembers[index].fullName = tagMember.getName();
                }

            }

            var restInfo = {};
            if( !!messageDate ){
                restInfo['messageDate'] = messageDate;
                packetId = tagChatFactory.getUUIDPacketId(messageDate, true);
            }

            var tagStatusMessage = tagChatFactory.createTagStatusMessage(
                packetId,
                tagId,
                userId,
                GENERAL_CONSTANTS.STATUS_MESSAGE_TYPES.TAG_MEMBER_DELETE,
                changedMembers,
                restInfo
            );

            if( !tagStatusMessage){ return; }


            var serializedStatusMessageObject = tagStatusMessage.serialize();

            if (!chatBox) {
                chatHistoryFactory.addMessage(serializedStatusMessageObject, tagId);

            } else {
                chatBox.pushMessage(serializedStatusMessageObject, userId);
            }
        }



        

    }
})();

(function(global) {
	'use strict';

	angular
		.module('ringid.chat')
		.factory('chatRequestProcessor', chatRequestProcessor);

	chatRequestProcessor.$inject = [
		 	'$$connector', '$q', '$timeout',
			'Auth',
			'tagChatFactory',
			'tagChatUI', 'tagChatHelper',
			'ChatFactory', 'chatHistoryFactory',
			'userFactory', 'utilsFactory', 'profileFactory', 'tagChatStorage',
			'OPERATION_TYPES' ,'Ringalert',
			'CHAT_LANG',
			'ChatUtilsFactory', 'ChatConnector' ];

	function chatRequestProcessor (

			 $$connector, $q, $timeout,
			 Auth,
			 tagChatFactory,
			 tagChatUI, tagChatHelper,
			 ChatFactory, chatHistoryFactory,
			 userFactory, utilsFactory, profileFactory, tagChatStorage,
			 OPERATION_TYPES, Ringalert,
			 CHAT_LANG,
			 ChatUtilsFactory, ChatConnector
	) {

		var CHAT_APP 		   = global.CHAT_APP;
		var Constants          = CHAT_APP.Constants;
		
		var GENERAL_CONSTANTS  = Constants.GENERAL_CONSTANTS;
		var CHAT_GLOBAL_VALUES = Constants.CHAT_GLOBAL_VALUES;
		var ChatRequests       = CHAT_APP.ChatRequests;	
		var SharedHelpers	   = CHAT_APP.SharedHelpers;
		var TAG_CHAT_LANG      = CHAT_LANG.TAG;

		
	
		var _getUnreadMessagesMultipleTimes = function(){
				
			var offlineUpdateTime = CHAT_GLOBAL_VALUES.offlineUpdateTime;
			var requestServerTime = SharedHelpers.getChatServerCurrentTime();

			var requestObject = ChatRequests.getOfflineGetRequestObject(offlineUpdateTime, 0);
			ChatConnector.request(requestObject).then(function(response){
				if( !!response.sucs ){
					CHAT_GLOBAL_VALUES.offlineUpdateTime = requestServerTime;
				}
			});

		};


		var _getTagHistoryMessagesMultipleTimes = function(tagId, pageDirection, packetId, limit){


			packetId =  packetId || tagChatFactory.getUUIDPacketId();
			limit = limit || 10;

			var requestObject = ChatRequests.getOfflineTagHistoryMessageRequestObject(tagId, pageDirection, limit, packetId)
			return ChatConnector.request(requestObject);	

		};


		var _getFriendHistoryMessagesMultipleTimes = function(friendId, pageDirection, packetId, limit){

			packetId =  packetId || tagChatFactory.getUUIDPacketId();
			limit = limit || 10;

			var requestObject = ChatRequests.getOfflineFriendHistoryMessageRequestObject(friendId, pageDirection, limit, packetId)
			return ChatConnector.request(requestObject);

		};


		var _sendTagUnreadMessageConfirmation = function(userId, messagePacketIds){

			var requestObject = ChatRequests.getOfflineTagUnreadMessageConfirmationObject(messagePacketIds);			
			ChatConnector.send(requestObject);
	
		};

		var _sendFriendUnreadMessageOfflineConfirmation = function(userId, packetId, messagePacketIds){

			var requestObject = ChatRequests.getOfflineFriendUnreadMessageConfirmationObject(messagePacketIds, packetId);			
			ChatConnector.send(requestObject);

		};

		var getHistoryRequestMethodByBox = function(chatBox){

			var historyRequestMethod;
			if(chatBox.isTagChat){
				historyRequestMethod = _getTagHistoryMessagesMultipleTimes
			}else{
				historyRequestMethod = _getFriendHistoryMessagesMultipleTimes
			}
			return historyRequestMethod
		};


		var _sendFriendInformation = function( friendObj ){
			var requestObject = ChatRequests.getOfflineFriendInformationObject(friendObj.getUId(), friendObj.getName(), 
				friendObj.getOnlineStatus(), friendObj.getAppType() || 1, friendObj.getDeviceToken(), friendObj.getUserMood());

			ChatConnector.send( requestObject );
		}

		return {
			getUnreadMessagesMultipleTimes 	: _getUnreadMessagesMultipleTimes,
			getTagHistoryMessagesMultipleTimes : _getTagHistoryMessagesMultipleTimes,
			getFriendHistoryMessagesMultipleTimes : _getFriendHistoryMessagesMultipleTimes,
			getHistoryRequestMethodByBox : getHistoryRequestMethodByBox,
			sendTagUnreadMessageConfirmation : _sendTagUnreadMessageConfirmation,
			sendFriendUnreadMessageOfflineConfirmation : _sendFriendUnreadMessageOfflineConfirmation,

			sendFriendInformation : _sendFriendInformation,
		};

	}

})(window);

(function(global){
    'use strict';

    var chatApp;
    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {
      console.log(e);
    }

    chatApp.factory('ChatResponseProcessor', ChatResponseProcessor);

    ChatResponseProcessor.$inject = ['tagChatFactory', 'Auth', 
    'ChatFactory', 'chatHistoryFactory', 'CHAT_LANG', 'utilsFactory', 'tagChatUI', 'SystemEvents'];

    function ChatResponseProcessor(tagChatFactory, Auth, 
        ChatFactory, chatHistoryFactory, CHAT_LANG, utilsFactory, tagChatUI, SystemEvents) {

        var Constants = global.CHAT_APP.Constants;
        var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;

        var CHAT_LANG = CHAT_LANG.CHAT;
        
        function _getBox( boxId , nonDomBoxValue, isTagChat){
            
            var box = ChatFactory.getBoxByUId(boxId);
            //if user closes the box in the mean time then reopen it
            if(!box){
                ChatFactory.creatNonDomBox(boxId, isTagChat);//false for isTagChat flag
                box = ChatFactory.getBoxByUId(boxId);
                box.nonDomBox = nonDomBoxValue || false;//we don't want to reopen and show the box to user for getting deliver/seen/delete packet
                
                chatHistoryFactory.updateBox(box);
            }
        
            return box;
        }


        function _doUnRegisterTask( boxId ){
            CHAT_SESSION.UnRegister( boxId );
        }

        function _getMessageStatus(statusNo){

            var statusValue = GENERAL_CONSTANTS.MESSAGE_STATUS_VALUE[statusNo];

            if( !!statusValue){
                statusValue =  statusValue.charAt(0) + statusValue.substr(1).toLowerCase();
            }

            return statusValue
        }

        function _doOnMessageTypeDeleteMessage( boxId, userId, packetId, chatBox ){
            
            if( !chatBox ){
                chatBox = ChatFactory.getBoxByUId( boxId );
            }

            if( userId == Auth.currentUser().getKey() ){

              if( chatBox ){
                  chatBox.removeMessage( packetId );
              }

              chatHistoryFactory.removeMessage( packetId, boxId );

            }else{

              var msgObj;
              if( chatBox ){
                  msgObj = chatBox.getMessage( packetId );
              }else{
                  msgObj = chatHistoryFactory.getMessage( boxId, packetId );
              }

              if(!!msgObj){
                  msgObj.text =  CHAT_LANG.MESSAGE_DELETE_TEXT;
                  msgObj.status = 'Deleted';
                  chatHistoryFactory.updateMessage(msgObj, boxId);
              }
            }
        }



        /**************************** FRIEND RESPONSE PROCESSORS ************************/

        function _getFriendBoxId( userId, friendId ){
            var boxId;
            if( userId == Auth.currentUser().getKey() ){
                boxId = friendId;
            }else{
                boxId = userId;
            }
            
            return boxId;
        }

        function _getFriendBox( boxId , nonDomBoxValue){            
            return _getBox(boxId, nonDomBoxValue, false);
        }

        function _updateMessageStatusToDelivered( boxId, msgObj ){
            if(!!msgObj){
                if( msgObj.status != 'Seen' && msgObj.status != 'Deleted'
                    && msgObj.status != 'Viewed' && msgObj.status != 'Played'){
                    msgObj.status = 'Delivered';
                }
                chatHistoryFactory.updateMessage(msgObj, boxId );            
            }
        }

        function _doFriendUnregisterTask( friendId ){
            _doUnRegisterTask( friendId );
        }


        /**************************** GROUP RESPONSE PROCESSORS ************************/

        function _getTagChatBox(tagId, nonDomBoxValue, tagObject){
            if(!tagObject){
                tagObject = tagChatFactory.getTag(tagId);
            }

            var chatBox = _getBox(tagId, nonDomBoxValue, true)
            
            if( !!tagObject ){
                chatBox.setTitle(tagObject.getTagName());    
            }
        
            return chatBox;
        }

        function _doTagUnregisterTask( tagId ){
            _doUnRegisterTask( tagId );
        }

        function _processTagMemberAddUpdate( responseObject ){
            var userId     = responseObject.userId,
                tagId      = responseObject.tagId,
                tagMembers = responseObject.tagMembers,
                packetId   = responseObject.packetId;
            
            var tagObject, 
                messageDate = responseObject.messageDate || null;

            tagObject = tagChatFactory.getOrCreateTag(tagId);

            tagChatUI.showTagMembersAddStatusMessage(tagId,
                userId,
                tagMembers,
                messageDate,
                packetId,
                tagObject
            );

            if(!!tagObject && !responseObject.fromHistory){
                _addMembersToTagObject(tagObject, tagMembers, userId);                
            }
        }

        function _processTagMemberRemoveLeave( responseObject ){
            
            var userId     = responseObject.userId,
                tagId      = responseObject.tagId,
                tagMembers = responseObject.tagMembers,
                packetId   = responseObject.packetId;
        
            var tagObject, currentUserRemoved,
            messageDate = responseObject.messageDate || null;

            delete responseObject.packetId;

            tagObject = tagChatFactory.getOrCreateTag(tagId);

            tagChatUI.showTagMembersRemoveStatusMessage( tagId,
                userId,
                tagMembers,
                messageDate,
                packetId,
                tagObject
            );

            if( !responseObject.fromHistory ){
                currentUserRemoved = _removeMembersFromTagObject(tagObject, tagMembers);
                if( currentUserRemoved ){
                    _doAfterCurrentUserRemovedFromTag( tagId );
                    //todo do chat unregister task
                    _doTagUnregisterTask( tagId );                
                }            
            }

        }

        function _processTagInformation( responseObject ){
            var userId        = responseObject.userId,
                tagId         = responseObject.tagId,
                activityType  = responseObject.activityType,
                tagName       = responseObject.tagName,
                tagPictureUrl = responseObject.tagPictureUrl,
                packetId      = responseObject.packetId;
        
            /* method body */
            var oldTagObject = tagChatFactory.getTag(tagId);

            if(!!oldTagObject){
                tagChatUI.showTagInfoChangeStatusMessage(tagId,
                    responseObject.userId,
                    responseObject
                );

                if( !responseObject.fromHistory){
                    aNewTag = tagChatFactory.updateTag(tagId, responseObject, oldTagObject);
                }


            }else{

                if( !responseObject.fromHistory) {
                    aNewTag = tagChatFactory.createNewTag(responseObject);
                    tagChatFactory.addTagObject(aNewTag);
                }
            }
          
            utilsFactory.triggerCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED);

        }

        function _processTagMemberStatusChange( responseObject ){
            var userId     = responseObject.userId,
            tagId      = responseObject.tagId,
            tagMembers = responseObject.tagMembers,
            packetId   = responseObject.packetId;
        
            /* method body */
            var tagObject,
                messageDate = responseObject.messageDate || null;

          
            tagObject = tagChatFactory.getOrCreateTag(tagId);

            tagChatUI.showMemberTypeChangeStatusMessage(tagId,
                userId,
                tagMembers,
                messageDate,
                packetId
            );

            if( !responseObject.fromHistory){
                _updateMemberStatusInTagObject(tagObject, tagMembers);
            }

            utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED,{ boxId : tagId });

        }

        function _processTagCreate( responseObject ){
                        
            var box = _getTagChatBox( responseObject.tagId );
            box.updateBoxMessageMinMaxPacketId( responseObject );
                    
        }

        function _processAGroupActivity(tagId, packetId, activityItem){
            /*
            * activityItem signature : { changedByUserId:'', userId : '', status : '', activityValue : '' }
            *
            * */

            if( activityItem.changedByUserId == activityItem.userId
                && activityItem.status == GENERAL_CONSTANTS.MEMBER_STATUS.OWNER ){
                /* case : IbrahimRashid made IbrahimRashid owner */
                return;
            }

            switch (activityItem.activityType){

                case GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.DELETED :
                    _processTagMemberRemoveLeave( {

                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagMembers : [{userId: activityItem.userId}],
                        fromHistory : activityItem.fromHistory

                    });
                    break;
                case GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.ADDED :
                    _processTagMemberAddUpdate({

                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagMembers : [{userId: activityItem.userId, status : activityItem.status, fullName : activityItem.activityValue}],
                        fromHistory : activityItem.fromHistory
                    });
                    break;
                case GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.LEAVE :
                    _processTagMemberRemoveLeave( {

                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagMembers : [{userId: activityItem.userId}],
                        fromHistory : activityItem.fromHistory

                    });
                    break;
                case GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_RENAME:
                    _processTagInformation({
                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagName : activityItem.activityValue,
                        fromHistory : activityItem.fromHistory

                    });
                    break;
                case GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.MEMBER_TYPE_CHANGE :
                    _processTagMemberStatusChange({
                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagMembers : [{userId: activityItem.userId, status : activityItem.status }],
                        fromHistory : activityItem.fromHistory
                    });
                    break;
                case GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_URL_RENAME :
                    _processTagInformation({
                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagPictureUrl : activityItem.activityValue,
                        fromHistory : activityItem.fromHistory
                    });

                    break;

                case GENERAL_CONSTANTS.TAG_ACTIVITY_TYPE.TAG_CREATED :
                    _processTagCreate({
                        userId : activityItem.changedByUserId,
                        packetId : packetId,
                        tagId : tagId,
                        messageDate : activityItem.activityDate,
                        tagName : activityItem.activityValue,
                        tagMembers : [],
                        fromHistory : activityItem.fromHistory
                    });
                    break;
            }
        }

        function _processGroupActivityMessage(groupActivityMessage){


            var activityType = groupActivityMessage.packetType;
            var userId = groupActivityMessage.userId;
            var tagId = groupActivityMessage.tagId;
            var packetId = groupActivityMessage.packetId;
            var activityDate = groupActivityMessage.messageDate;

            var message;
            try{
                message = angular.fromJson(groupActivityMessage.message);
            }catch(e){
                return; 
            }

            var activityItem = {
                changedByUserId : groupActivityMessage.userId,
                userId          : message.mId,
                status          : message.mT,
                activityValue   : message.n,
                activityType    : activityType,
                activityDate    : activityDate,
                fromHistory     : groupActivityMessage.fromHistory || false
            };

            _processAGroupActivity(tagId, packetId, activityItem);
        }
    
        function _doAfterCurrentUserRemovedFromTag(tagId){
            var chatBox = ChatFactory.getBoxByUId(tagId);

            if(!!chatBox){
                ChatFactory.closeChatBox(chatBox.getKey()); //removes corresponding box from boxes stack using userId which is the key
                chatHistoryFactory.removeOpenBox(chatBox.getKey());
            }            
        }

        function _addMembersToTagObject(aTag, members, addedByUserId){

            if( members.length == 1){
                tagChatFactory.removeTagObject(aTag.getTagId());
                return;
            }

            for(var tagMemberIndex = 0;tagMemberIndex < members.length; tagMemberIndex++ ){
                var memberObject = members[tagMemberIndex];
                if(!!addedByUserId){
                    memberObject.addedBy = addedByUserId;
                }

                var tagMemberObject = tagChatFactory.createNewTagMember( aTag.getTagId(), memberObject, true );
                if( !tagMemberObject.isRemoved()){
                    aTag.addMember( tagMemberObject );
                }

            }
        }

        function _removeMembersFromTagObject(aTag, tagMembers){
            var hasCurrentUser = false;
            for(var index = 0; index < tagMembers.length; index++){
                var tagMemberObject = aTag.getMember(tagMembers[index].userId);
                if(!!tagMemberObject){
                    hasCurrentUser = tagMemberObject.isCurrentUser();
                    aTag.removeMember(tagMemberObject);
                }
            }
            return hasCurrentUser;
        }

        function _updateMemberStatusInTagObject(aTag, tagMembers){
            for( var index = 0; index < tagMembers.length; index++ ){
                var aTagMember = tagMembers[index];

                if( !!aTag){
                    var tagMemberObject = aTag.getMember(aTagMember.userId);
                    if( !!tagMemberObject){
                        tagMemberObject.setStatus(aTagMember.status);
                    }
                }
            }
        }        

        return {

            doFriendUnregisterTask         : _doFriendUnregisterTask,
            getFriendBoxId                 : _getFriendBoxId,
            getFriendBox                   : _getFriendBox,
            updateMessageStatusToDelivered : _updateMessageStatusToDelivered,
            doOnMessageTypeDeleteMessage   : _doOnMessageTypeDeleteMessage,
            getMessageStatus               : _getMessageStatus,

            doTagUnregisterTask            : _doTagUnregisterTask,
            getTagChatBox                  : _getTagChatBox,
            processAGroupActivity          : _processAGroupActivity,
            processGroupActivityMessage    : _processGroupActivityMessage,
            addMembersToTagObject          : _addMembersToTagObject,
            removeMembersFromTagObject     : _removeMembersFromTagObject,
            updateMemberStatusInTagObject  : _updateMemberStatusInTagObject,

            processTagMemberAddUpdate      : _processTagMemberAddUpdate,
            processTagMemberRemoveLeave    : _processTagMemberRemoveLeave,
            processTagInformation          : _processTagInformation,
            processTagMemberStatusChange   : _processTagMemberStatusChange
        }

    }

})(window);



(function () {
    'use strict';

    openBox.$inject = ['ChatFactory', 'tagChatFactory', 'rgDropdownService', 'utilsFactory', 'Auth', 'ChatHelper', 'ChatWorkerCommands'];
    function openBox( ChatFactory,  tagChatFactory, rgDropdownService , utilsFactory, Auth, ChatHelper, ChatWorkerCommands) {
        return {
            link: function (scope, element, attrs) {

                element.on("click", function (event) {

                    var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;
                    var SESSION_TYPES = GENERAL_CONSTANTS.SESSION_TYPES;

                    var boxId = !attrs.boxId ? false : attrs.boxId;
                    var isTagChat = attrs.isTagChat == "true" ? true : false;

                    if( !boxId ){
                        return;
                    }

                    if( attrs.openChatBox == Auth.currentUser().getKey() ){
                        return;
                    }

                    utilsFactory.safeDigest(scope);
                    rgDropdownService.close(event);

                    var tagObject, tagChatBoxOpened = false;
                    if( isTagChat ){
                        tagObject = tagChatFactory.getTag(boxId);

                        if( !!tagObject && tagObject.isTagSafeToShow()){
                            tagChatBoxOpened = true;

                            var tagObject = tagChatFactory.getTag(boxId);
                            ChatWorkerCommands.startChatSession(boxId, SESSION_TYPES.TAG, tagObject.getMemberUserIds())
                            ChatFactory.openTagChatBox(boxId, true);
                        }

                    }else{

                        ChatWorkerCommands.startChatSession(boxId, SESSION_TYPES.FRIEND)
                        ChatFactory.openChatBox(boxId, true);
                    }

                    var box = ChatFactory.getBoxByUId(boxId);

                    if(!!box){
                        ChatHelper.decreaseUnreadCount(box);

                        if( tagChatBoxOpened ){
                            box.setTitle( tagObject.getTagName() );
                        }

                    }

                    utilsFactory.safeDigest(scope);

                    event.preventDefault();
                    event.stopPropagation();
                });
            }
        };
    }

    openChatBox.$inject = ['ChatFactory', 'utilsFactory', 'Auth', 'ChatHelper', 'ChatWorkerCommands'];
    function openChatBox(ChatFactory, utilsFactory, Auth, ChatHelper, ChatWorkerCommands) {
        return {
            link: function (scope, element, attrs) {
                element.on("click", function (event) {

                    var boxId = attrs.openChatBox;

                    var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;
                    var SESSION_TYPES = GENERAL_CONSTANTS.SESSION_TYPES;

                    if( !boxId ){
                        return;
                    }
                    if( boxId == Auth.currentUser().getKey() ){
                        return;
                    }

                    utilsFactory.safeDigest(scope);
                    ChatFactory.openChatBox(boxId, true);

                    //PullerSubscriber.requestForIp(attrs.openChatBox);
                    var box = ChatFactory.getBoxByUId(boxId);

                    if(box.getUser().friendshipStatus()==1){
                        //this is friend
                        ChatWorkerCommands.startChatSession(boxId, SESSION_TYPES.FRIEND)
                        // PullerSubscriber.requestForIp(attrs.openChatBox);

                    }else{
                        //this is not friend yet
                        var permission = Auth.getPermission();
                        if(permission.ancht ==1){

                            ChatWorkerCommands.startChatSession(boxId, SESSION_TYPES.FRIEND)
                            // PullerSubscriber.requestForIp(attrs.openChatBox);

                        }else{
                            var box =ChatFactory.getBoxByUId(boxId);
                            box.blocked = true;
                        }
                    }

                    if(!!box){
                        ChatHelper.decreaseUnreadCount(box);
                    }

                    event.preventDefault();
                    event.stopPropagation();
                });
            }
        };
    }




    openTagChatBox.$inject =  [ 'ChatFactory', 'tagChatFactory', 'tagChatManager', 'Auth', '$rootScope', 'ChatHelper', 'ChatWorkerCommands'];
    function openTagChatBox( ChatFactory, tagChatFactory, tagChatManager, Auth, $rootScope, ChatHelper, ChatWorkerCommands) {

        return {
            link: function (scope, element, attrs) {
                element.on("click", function () {

                    var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;
                    var SESSION_TYPES = GENERAL_CONSTANTS.SESSION_TYPES;

                    var tagId = attrs.openTagChatBox;

                    if( tagId <= 0){
                        return;
                    }

                    if( attrs.openChatBox == Auth.currentUser().getKey() ){
                        return;
                    }

                    var tagObject = tagChatFactory.getTag(tagId);

                    var box = ChatFactory.openTagChatBox(tagId, true);

                    box.setTitle( tagObject.getTagName() );

                    if( !!tagObject && tagObject.isTagSafeToShow()){

                        if(!!tagObject){

                            ChatWorkerCommands.startChatSession(tagId, SESSION_TYPES.TAG, tagObject.getMemberUserIds())

                        }
                    }

                    if(!!box){
                        box.loadHistoryMessages();  
                        ChatHelper.decreaseUnreadCount(box);                      
                    }
                });
            }
        };
    }


    makeVisibleChatBox.$inject = ['ChatFactory','$rootScope'];
    function makeVisibleChatBox(ChatFactory,$rootScope) {
        /*
         * Description: directive to make the hidden chatbox visible
         * param: userId (which is the key for the stackmap)
         * Scope: level 2 childscope of chatController scope
         * Event: no event is broadcasting/emitting
         * Dependency: ChatFactory
         * Date: 04-04-15
         * Developed By: rabbi
         * */

        return {
            link: function (scope, element, attrs) {
                element.on("click", function () {

                    scope.rbox.value.isFocused = true; // to make reordered box on focused
                    ChatFactory.makeVisibleChatBox(attrs.makeVisibleChatBox);
                    $rootScope.$broadcast("focusOn", scope.rbox.value.getKey());
                    element.parent().parent().children().eq(0).removeClass('blink'); // for removing blink class when user clicks on hidden box
                });
            }
        };
    }


    showHiddenBoxes.$inject = ['ChatFactory','$rootScope'];
    function showHiddenBoxes(ChatFactory,$rootScope) {
        return {
            link: function (scope, element, attrs) {
                element.on("click", function () {
                    ChatFactory.openChatBox(attrs.openChatBox);
                });
            }
        };
    }

    closeBox.$inject = ['ChatFactory','chatHistoryFactory', 'tagChatFactory'];
    function closeBox(ChatFactory,chatHistoryFactory, tagChatFactory) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                element.on('click', function () {
                    ChatFactory.closeChatBox(scope.box.value.getKey()); //removes corresponding box from boxes stack using userId which is the key
                    chatHistoryFactory.removeOpenBox(scope.box.value.getKey());

                    var tagObject = tagChatFactory.getTag(scope.box.value.getKey());
                    if( !!tagObject ){
                        tagObject.initMessages();
                    }

                    scope.$parent.$digest();
                });
            }
        }; // return object for directive factory function
    }

    minimizeBox.$inject = ['ChatFactory'];
    function minimizeBox(ChatFactory) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                element.on('click', function (event) {
                    if(!!scope.box.value.blinkOn && !scope.box.value.isMinimized){//true false: if blinking is on then it won't minimize
                        //blink on and not minimized
                        scope.$broadcast("blinkerOff", scope.box.value.getKey());
                        scope.$broadcast("focusOn", scope.box.value.getKey());
                    } else if(!!scope.box.value.blinkOn && !!scope.box.value.isMinimized){//true true:
                        //blink on and minimized
                        ChatFactory.minimizeBox(scope.box.value.getKey());
                        scope.$broadcast("blinkerOff", scope.box.value.getKey());
                        scope.$broadcast("focusOn", scope.box.value.getKey());//won't work this focus event as the event gets fired before digest is finished so it gets the element hidden
                    } else if(!scope.box.value.blinkOn && !scope.box.value.isMinimized){// false true:
                        //blink off and not minimized
                        ChatFactory.minimizeBox(scope.box.value.getKey());

                    } else if(!scope.box.value.blinkOn && !!scope.box.value.isMinimized){ // false false:
                        //blink off and minimized
                        ChatFactory.minimizeBox(scope.box.value.getKey());
                        scope.$broadcast("focusOn", scope.box.value.getKey());//won't work this focus event as the event gets fired before digest is finished so it gets the element hidden
                    }
                    //ChatFactory.minimizeBox(scope.box.value.getKey());
                    scope.$digest();
                    event.stopPropagation();
                });
            }
        }; // return object for directive factory function
    }

    maximizeBox.$inject = ['ChatFactory'];
    function maximizeBox(ChatFactory) {
        return {
            scope: false,
            restrict: 'A',
            link: function (scope, element, attrs) {

            }
        }; // return object for directive factory function
    }

    tagChatEdit.$inject = ['ChatFactory', 'rgDropdownService' , '$compile'];
    function tagChatEdit(ChatFactory, rgDropdownService, $compile) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {


                element.on('click', function (event) {
                    scope.showDropdown = !scope.showDropdown;
                    event.stopPropagation();
                });

            },
            controller : [ '$scope', 'tagChatFactory', 'tagChatManager', 'Auth', 'Ringalert', '$compile',
                function($scope, tagChatFactory, tagChatManager, Auth, Ringalert, $compile){

                    $scope.showDropdown = false;


                    $scope.hasTagObjectLock = function(tagId){

                        var tagObject = tagChatFactory.getTag(tagId);
                        if( !!tagObject){
                            return tagObject.hasObjectLock();
                        }
                        return false;
                    };

                    $scope.getTagDDControl = function(tagId){
                        var tagObject = tagChatFactory.getTag(tagId);
                        //var currentUserMemberObject = tagObject.getMember(Auth.currentUser().getKey());
                        var currentUserMemberObject = tagObject.getMember(Auth.loginData.uId);
                        return {
                            tagId : tagId,
                            isOwner : !!currentUserMemberObject ? currentUserMemberObject.isOwner() : false
                        };
                    };


                    $scope.tagMemberDDActions = tagMemberDDActions;
                    $scope.tagMemberDDHtml = 'pages/partials/tag-chat/member-actions-dropdown.html';

                    // edit, view or delete
                    function tagMemberDDActions(actionObj) {
                        switch(actionObj.action) {
                            case 'edit':
                            case 'view':
                                rgDropdownService.close(actionObj.event);

                                return function() {
                                    return {tagId: actionObj.tagId};
                                };


                                break;
                            case 'delete':

                                rgDropdownService.close(actionObj.event);

                                var tagObject = tagChatFactory.getTag(actionObj.tagId);

                                tagObject.setObjectLock();

                                tagChatManager.leaveFromTag(actionObj.tagId, currentUser.getKey()).then(function(response){

                                    tagObject.removeObjectLock();
                                    Ringalert.show(response, 'info');


                                }, function(response){

                                    tagObject.removeObjectLock();
                                    Ringalert.show(response, 'error');

                                });

                                break;
                            default:
                        }
                    }



                }]
        }; // return object for directive factory function
    }

    chatScrollBottom.$inject = ['$rootScope', 'rgScrollbarService', 'utilsFactory', 'SystemEvents'];
    function chatScrollBottom($rootScope, rgScrollbarService, utilsFactory, SystemEvents) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
               scope.$on("ScrollToBottom",function(event, userId){
                    if(userId == scope.box.value.getKey()){
                        element[0].scrollTop = element[0].scrollHeight;
                        event.preventDefault();
                        // rgScrollbarService.scrollTo(scope, 100);

                    }
                });

                var doScroll = function(offset){
                    rgScrollbarService.recalculate(scope);
                    rgScrollbarService.hasScroll(scope);
                    utilsFactory.safeDigest(scope);

                    element[0].scrollTop = offset;      
                    //rgScrollbarService.scrollTo(scope, 100);              
                    
                }

                var ScrollToBottomRef = utilsFactory.onCustomEvent('ScrollToBottom', function(data){

                    if(data.boxId == scope.box.value.getKey()){

                        doScroll(element[0].scrollHeight);
                    }
                });

                var ScrollToUnreadRef = utilsFactory.onCustomEvent('ScrollToUnread', function(data){

                    if(data.boxId == scope.box.value.getKey()){
                        

                        var unreadElem = element[0].querySelector('.status-unread-container');
                        if( !unreadElem ){
                            doScroll(element[0].scrollHeight);
                        }else{

                            if( data.topAlign ){
                                doScroll( unreadElem.offsetTop - 20);
                            }else{
                                doScroll( element[0].scrollHeight - (unreadElem.offsetTop - 221) );
                            }
                       }
                    }
                });

                // var boxOpennedRef = utilsFactory.onCustomEvent(SystemEvents.CHAT.BOX_OPENNED, function(data){                 

                //     if(data.boxId == scope.box.value.getKey()){

                //         setTimeout(function(){ 
                //             element[0].scrollTop = element[0].scrollHeight 
                //         }, 200);
                //     }

                // });


                scope.$on('$destroy', function(){
                    utilsFactory.removeCustomEvent('ScrollToBottom', ScrollToBottomRef);
                    utilsFactory.removeCustomEvent('ScrollToUnread', ScrollToUnreadRef);
                    // utilsFactory.removeCustomEvent(SystemEvents.CHAT.BOX_OPENNED, boxOpennedRef);

                });
            }
        }; // return object for directive factory function
    }

    chatBlinker.$inject = ['$window','chatHistoryFactory'];
    function chatBlinker($window,chatHistoryFactory) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                //var blinkerTimerFunction;
                if(scope.box.value.blinkOn === true){
                    element.addClass('blink');
                }
                scope.$on('blinkerEvent', function (event, userId) {
                    if(userId.toString() === scope.box.value.getKey()){
                        //if(!blinkerTimerFunction){
                        if(scope.box.value.isMinimized){
                            //blinkerTimerFunction = $window.setInterval(function () {
                            //    element.css({border: '2px solid red'});
                            if(scope.box.value.isFocused === false) {// doesn't matter it is focused or not if minimised it will blink
                                element.addClass('blink');
                                scope.box.value.blinkOn = true;
                            }
                            //},500);
                        } else {
                            //blinkerTimerFunction = $window.setInterval(function () {
                            //    element.css({border: '2px solid red'});
                            if(scope.box.value.isFocused === false) {
                                element.addClass('blink');
                                scope.box.value.blinkOn = true;
                            }
                            //},500);
                        }
                        chatHistoryFactory.updateBox(scope.box.value);
                        //}
                        //scope.$watch('box.value.isFocused', function (newValue, oldValue ) {
                        //    if(newValue === true && blinkerTimerFunction !== false){
                        //        $window.clearInterval(blinkerTimerFunction);
                        //        blinkerTimerFunction = false;
                        //    }
                        //});
                    }
                    //TODO have to handle blinking for hidden boxes
                    // this has been handled with another directive named chatBlinkerH
                    //if(scope.rbox){
                    //    if(userId === scope.$parent.$parent.rbox.value.getKey()){
                    //        element.addClass('blink');
                    //    }
                    //}
                });
                scope.$on('blinkerOff', function (event, userId) {
                    if(userId.toString() === scope.box.value.getKey()){
                        //element.css({border: 'none'});
                        element.removeClass('blink');
                        scope.box.value.blinkOn = false;
                        chatHistoryFactory.updateBox(scope.box.value);
                        //if(blinkerTimerFunction){
                        //    $window.clearInterval(blinkerTimerFunction);
                        //    blinkerTimerFunction = false;
                        //}
                    }
                });
            }
        }; // return object for directive factory function
    }


    chatBlinkerH.$inject = [ '$window','chatHistoryFactory' ];
    function chatBlinkerH($window,chatHistoryFactory) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                scope.$on('blinkerEvent', function (event, userId) {
                    if(userId.toString() === scope.rbox.value.getKey()){
                        element.addClass('blink');
                        element.parent().parent().children().eq(0).addClass('blink');
                        chatHistoryFactory.updateBox(scope.rbox.value);//might cause problem, didn't have enough time to be sure, will dig out later
                    }
                });
            }
        }; // return object for directive factory function
    }

    chatSelectEmo.$inject = ['ChatPacketSenderService'];
    function chatSelectEmo(ChatPacketSenderService) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {

                scope.selectEmoticon = function(emoticon){

                    scope.messageText = scope.messageText + emoticon.symbol();


                };
            }
        }; // return object for directive factory function
    }

    chatBindOutsideClick.$inject = ['$document', 'utilsFactory'];
    function chatBindOutsideClick($document, utilsFactory) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                element.bind('click', function(e) {
                    e.stopPropagation();
                });
                $document.bind('click', function() {
                    scope.showHidden = false;
                    utilsFactory.safeDigest(scope);
                    //scope.$apply(scope.showHidden);
                });
            }
        }; // return object for directive factory function
    }

    sharedContent.$inject = ['utilsFactory'];
    function sharedContent(utilsFactory){
        return {
            restrict: 'A',
            link : function(scope){

                scope.initMessageData = function(){
                    scope.messageData = {ogData : {}, locationData :{} };
                };

                scope.resetOgInfo = function(){
                    scope.messageData.ogData = {};
                    scope.ogStatus = {preview : false, loading: false, filterOnProgress: false};
                };

                scope.resetMessageLocation = function(){
                    scope.messageData.locationData = { description : '', lat : '', lng: ''};
                };

                scope.resetMessageText = function(){
                    scope.messageText = "";
                };

                scope.resetBottomMenu = function(){
                    scope.showBottomMenu = false;
                };

                scope.resetMessageInput = function(digest){

                    scope.initMessageData();

                    scope.resetBottomMenu();
                    scope.resetMessageText();
                    scope.resetOgInfo();
                    scope.resetMessageLocation();

                    if(!!digest){
                        utilsFactory.safeDigest(scope);

                    }
                };

                scope.resetMessageInput(false);
            }
        };
    }

    angular
        .module('ringid.chat')
        .directive('openBox', openBox)
        .directive('openChatBox', openChatBox)
        .directive('openTagChatBox',openTagChatBox)
        .directive('makeVisibleChatBox', makeVisibleChatBox)
        .directive('showHiddenBoxes', showHiddenBoxes)
        .directive('closeBox', closeBox)
        .directive('minimizeBox', minimizeBox)
        .directive('maximizeBox', maximizeBox)
        .directive('tagChatEdit', tagChatEdit)
        .directive('chatScrollBottom', chatScrollBottom)
        .directive('chatBlinkerH', chatBlinkerH)
        .directive('chatBindOutsideClick', chatBindOutsideClick)
        .directive('sharedContent', sharedContent);

        // end of module definition
})(); // end of self invoking anonymous function, this is used to avoid the conflict of name of the module

/**
 * Created by ibrahim on 4/01/16.
 */
(function () {
    'use strict';

    /** Helpers **/
    function getMessagePacketIdForHistoryRequest(message){
        var packetId = message.key;

        if( message.status == 'status_update'){
            try{
                packetId = packetId.split('_')[0];
            }catch(e){
            }
        }

        return packetId;
    }

    var doHistoryRequest = function(scope, chatRequestProcessor, chatBox, direction, newPacketId ){
        
        var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;

        if(!!chatBox && !!chatBox.nonDomBox ){

            var bottomMessage = chatBox.getBottomMessage();
            var topMessage = chatBox.getTopMessage();

            //var bottomPacketId = chatBox.messageMaxPacketId,
            //    topPacketId = chatBox.messageMinPacketId;

            var topPacketId, bottomPacketId;

            if( !topMessage && !bottomMessage){
            
                topPacketId = bottomPacketId = newPacketId; 
            
            }else{
                //bottomPacketId = getMessagePacketIdForHistoryRequest(bottomMessage);
                //topPacketId = getMessagePacketIdForHistoryRequest(topMessage);
                bottomPacketId = chatBox.messageMinPacketId;
                topPacketId = chatBox.messageMaxPacketId
            }

            var historyRequestMethod = chatRequestProcessor.getHistoryRequestMethodByBox(chatBox);

            var isSameMessage = ( topPacketId == bottomPacketId );

            var limit = GENERAL_CONSTANTS.HISTORY_MAX_MESSAGE + 2;

            if( !direction || direction == GENERAL_CONSTANTS.PAGE_DIRECTION.UP )
            {
                doSendHistoryRequest(scope, historyRequestMethod, chatBox, GENERAL_CONSTANTS.PAGE_DIRECTION.UP, bottomPacketId, limit);
            }

            if(!isSameMessage){
                
                if( !direction || direction == GENERAL_CONSTANTS.PAGE_DIRECTION.DOWN ){
                    doSendHistoryRequest(scope, historyRequestMethod, chatBox, GENERAL_CONSTANTS.PAGE_DIRECTION.DOWN, topPacketId, limit);                            
                }
            }
            
        }
    };


    function doSendHistoryRequest(scope, requestMethod, chatBox, direction, packetId, limit){

        var boxId = chatBox.getKey();

        scope.historyLoading = true;        

        requestMethod.call(this, boxId, direction, packetId, limit)
            .then(function(response){
                if(!!response.sucs){
                    scope.historyLoading = false;
                }
            }, function(){
                scope.historyLoading = false;
                chatBox.hasHistoryMessage = true;
            });

        setTimeout(function(){
            if( !scope.historyLoading ){
                scope.historyLoading = false;
            }
        }, 10000);
    }

    /** **/


    chatBoxUi.$inject = ['utilsFactory', 'SystemEvents', 'ChatFactory', '$rootScope', 'chatRequestProcessor', 'chatTabSync'];
    function chatBoxUi(utilsFactory, SystemEvents, ChatFactory, $rootScope, chatRequestProcessor, chatTabSync){

            var templateUrl = 'pages/chatbox.html';

            return {
                restrict: 'E',
                replace: true,
                scope : true,
                templateUrl  : templateUrl,
                link : function(scope){

                    var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;

                    var boxOpennedRef = utilsFactory.onCustomEvent(SystemEvents.CHAT.BOX_OPENNED, function(data){                 

                        var chatBox = ChatFactory.getBoxByUId(data.boxId);

                        if(!!chatBox){
                            
                            if( chatBox.messages.length < GENERAL_CONSTANTS.HISTORY_MAX_MESSAGE ){                                
                                                        
                                setTimeout(function(){                                
                                    // utilsFactory.triggerCustomEvent('ScrollToBottom', {boxId : data.boxId });    

                                    chatBox.loadHistoryMessages();                                    
                                    
                                    
                                    setTimeout(function(){
                                        utilsFactory.triggerCustomEvent('ScrollToUnread', {boxId : data.boxId });                                        
                                    }, 100);

                                }, 500);


                                // if( chatBox.messages.length < GENERAL_CONSTANTS.HISTORY_MAX_MESSAGE ){                                
                                    
                                //     var newPacketId = ChatFactory.getUUIDPacketId();

                                //     doHistoryRequest( scope, chatRequestProcessor, chatBox, GENERAL_CONSTANTS.PAGE_DIRECTION.UP, newPacketId );
                                // }
                            }

                        }

                        
                        if(!!data.sendToTab){
                            chatTabSync.sendData(GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.CHAT_BOX_INFO_UPDATE, {boxId : data.boxId});
                        }

                        utilsFactory.safeDigest(scope);

                    });
               
                    var tagListUpdatedFuncRef = utilsFactory.onCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED, function(){
	                utilsFactory.safeDigest(scope);
	            });
                    
                    scope.$on('$destroy', function(){
                        utilsFactory.removeCustomEvent(SystemEvents.CHAT.BOX_OPENNED, boxOpennedRef); 
                        utilsFactory.removeCustomEvent(SystemEvents.CHAT.TAG_LIST_UPDATED, tagListUpdatedFuncRef);
                    });

                }


            };
    }

    function extraChatBoxes(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/extra-chatboxes.html'

        };
    }

    singleChatBox.$inject = ['rgScrollbarService', 'utilsFactory', '$rootScope', 'SystemEvents', 'chatTabSync', 'ChatFactory', 'chatRequestProcessor'];
    function singleChatBox(rgScrollbarService, utilsFactory, $rootScope, SystemEvents, chatTabSync, ChatFactory, chatRequestProcessor){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-chatbox.html',
            link : function(scope, elem, attr){
                
                var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;

                var boxCallbacks = {};

                var boxCallback = function(data){

                    rgScrollbarService.recalculate(scope);
                    rgScrollbarService.hasScroll(scope);

                    utilsFactory.safeDigest(scope);

                    if( !data.noScroll ){                        
                        utilsFactory.triggerCustomEvent('ScrollToUnread', {boxId : data.boxId });
                    }                    
                }

                var doSomethingOnMessageReceived = function(data){
                    var boxId = data.boxId.toString();
                    
                    if( boxId == scope.box.key){

                        if( !boxCallbacks[boxId] ){                            
                            boxCallbacks[boxId] = {};
                        }

                        if( !boxCallbacks[boxId][data.type] ){                            
                            
                            boxCallbacks[boxId][data.type] = utilsFactory.debounce(function(){
                                boxCallback(data);
                            }, 200, false);                    
                        }

                        boxCallbacks[boxId][data.type].call(this)                    
                    }
                };
                

                var chatHistoryLoadedRef = utilsFactory.onCustomEvent('CHAT_HISTORY_LOADED', function(data){                    
                    var boxId = data.boxId.toString();

                    if( boxId == scope.box.key){
 
                        // if( scope.box.value.messages.length < GENERAL_CONSTANTS.HISTORY_MAX_MESSAGE ){

                        var newPacketId = ChatFactory.getUUIDPacketId();

                        doHistoryRequest(scope, chatRequestProcessor, scope.box.value, null, newPacketId)

                        utilsFactory.safeDigest(scope);
                        
                        // setTimeout(function(){
                        //     utilsFactory.triggerCustomEvent('ScrollToUnread', {boxId : boxId });    
                        // }, 500);
                        
                    }

                });

                var newMessagePushedRef = utilsFactory.onCustomEvent('NEW_MESSAGE_PUSHED', function(data){
                    data['type'] = 'pushed';
                    doSomethingOnMessageReceived(data);
                });

                var messageReceivedRef = utilsFactory.onCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED, function(data){
                    scope.$broadcast("blinkerEvent", data.boxId);
                    data['type'] = 'received';
                    doSomethingOnMessageReceived(data);
                });

                var chatBoxUpdatedRef  = utilsFactory.onCustomEvent(SystemEvents.CHAT.BOX_UPDATED,function(data){
                    
                    if(data.boxId == scope.box.key){
                        utilsFactory.safeDigest(scope);
                    }
                });
                
                
	
                scope.$on('$destroy', function(){

                    utilsFactory.removeCustomEvent('CHAT_HISTORY_LOADED', chatHistoryLoadedRef );
                    utilsFactory.removeCustomEvent('NEW_MESSAGE_PUSHED', newMessagePushedRef );
                    utilsFactory.removeCustomEvent(SystemEvents.CHAT.MESSAGE_RECEIVED, messageReceivedRef );
                    utilsFactory.removeCustomEvent(SystemEvents.CHAT.BOX_UPDATED, chatBoxUpdatedRef );
                });
            }

        };
    }
    function chatBoxTopBar(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-topbar.html'

        };
    }
    function chatBoxTopBarMenu(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-topbar-menu.html',
            link : function(scope){

                var box = scope.box.value;

                scope.hideTopbar = true;

                setTimeout(function(){
                    scope.hideTopbar = false;
                    scope.$rgDigest();
                }, 3000);

                //box.hideSuggestion = true;
                //
                //setTimeout(function(){
                //    if(box.value ){
                //        box.hideSuggestion = false;
                //        scope.$rgDigest();
                //    }
                //}, 10000);

                scope.shouldShowLastOnlineBar = function(){
                    return ( box.offlineStatus && box.lastSeenBar && !!box.getUser().lastOnline && box.getUser().lastOnline() );
                };

                scope.shouldShowFriendSuggestion = function(){
                    return (!box.hideSuggestion & !box.isTagChat && !!box.getUser() && box.getUser().friendshipStatus() != 1 ) && !box.offlineStatus;
                };

                scope.shouldShowChatBoxTopbarMenu = function(){
                    return !box.isTagChat && ( scope.shouldShowLastOnlineBar() || scope.shouldShowFriendSuggestion() );
                };


            }

        };
    }
    function chatBoxUrlPreview(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-url-preview.html'

        };
    }
    chatBoxBottom.$inject = ['utilsFactory', '$document'];
    function chatBoxBottom(utilsFactory, $document){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-bottom.html',
            link : function(scope, elem, attr){

                scope.toggleMenu = function(){
                    scope.showBottomMenu = !scope.showBottomMenu;
                    utilsFactory.safeDigest(scope);
                };

                //elem.on('mouseover', function(){
                //    scope.showBottomHover = true;
                //    utilsFactory.safeDigest(scope);
                //
                //});
                //
                //elem.on('mouseleave', function(){
                //    scope.showBottomHover = false;
                //    utilsFactory.safeDigest(scope);
                //
                //});

            }

        };
    }

    function chatBoxLocationInfo(){
        return {
            restrict: 'E',
            replace: true,
            link : function(scope){

            },
            templateUrl: 'pages/partials/chat/chatbox-location-info.html'

        };
    }


    chatBoxBottomMenu.$inject = ['utilsFactory', 'rgRecorderService'];
    function chatBoxBottomMenu(utilsFactory, rgRecorderService){
        return {
            restrict: 'E',
            replace: true,
            link : function(scope, elem, attr){

                scope.showMediaButton = rgRecorderService.hasUserMediaSupport();

                elem.on('mouseover', function(){
                    scope.$parent.bottomMenuHover = true;

                });

                elem.on('mouseleave', function(){
                    scope.$parent.bottomMenuHover = false;

                });

            },
            templateUrl: 'pages/partials/chat/chatbox-bottom-menu.html'

        };
    }

    chatBoxMiddle.$inject = ['rgScrollbarService', '$rootScope', 'utilsFactory']
    function chatBoxMiddle(rgScrollbarService, $rootScope, utilsFactory){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-middle.html',
            link : function(scope){

                          
            }

        };
    }
    chatSingleMessage.$inject = ['utilsFactory', '$ringbox', 'SystemEvents'];
    function chatSingleMessage(utilsFactory, $ringbox, SystemEvents){
        return {
            restrict: 'E',
            replace: true,
            link : function(scope,element, attr){
                var singleMessageUpdatedEventReference = utilsFactory.onCustomEvent('SINGLE_MESSAGE_UPDATED',function(data){
                    var message = data.message;
                    if(message.key == scope.message.key){
                        utilsFactory.safeDigest(scope);
                    }
                });
                var boxInstance;
                scope.openRingboxContent = function (message) {
                    boxInstance = $ringbox.open({
                        type : 'remote',
                        scopeData:{
                            message : message,
                            viewport : utilsFactory.viewport
                        },
                        resolve: {
                            data : {}
                        },
                        onBackDropClickClose: true,
                        templateUrl : 'pages/partials/chat/media-preview.html'
                    });
                };
                

                var singleMessageTimeoutRef = utilsFactory.onCustomEvent('SINGLE_MESSAGE_TIMEDOUT', function(data){
                    var box = data.box;
                    if(!!boxInstance){
                        boxInstance.close();
                    }
                });        
                
                scope.$on("$destroy", function () {
                    utilsFactory.removeCustomEvent('SINGLE_MESSAGE_UPDATED', singleMessageUpdatedEventReference);
                    utilsFactory.removeCustomEvent('SINGLE_MESSAGE_TIMEDOUT', singleMessageTimeoutRef);

                });

            },
            templateUrl: 'pages/partials/chat/message/single.html'

        };
    }

    function chatFileUploadProgress(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/message/upload-progress.html'

        };
    }

    singleMessageStatus.$inject = ['utilsFactory'];
    function singleMessageStatus(utilsFactory){

        var CHAT_GLOBAL_VALUES = CHAT_APP.Constants.CHAT_GLOBAL_VALUES;

        var getMessageStatusText = function(isTagChat, messageStatus){
            var statusText = !messageStatus ? 'Pending' : messageStatus;

            if(statusText === 'Sent') {
                statusText = 'Delivered';
            }

            //statusText += ' ' + messageTime;

            return statusText;

        };

        var getMessageTime = function(messageDate){
            var localTime = messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff;
            var localFormatedTime = utilsFactory.chatVerbalDate(localTime);
            return localFormatedTime;
        };

        return {
            restrict: 'E',
            replace: true,
            link : function(scope, elem, attrs){

                scope.$watch("message.status", function(){

                    scope.message.statusText = getMessageStatusText(
                        scope.box.value.isTagChat,
                        scope.message.status
                    );
                    scope.message.statusDate = getMessageTime(scope.message.messageDate);
                    scope.message.statusUserName = scope.message.user.getName();

                });

            },
            templateUrl: 'pages/partials/chat/message/status.html'            
        };
    }

    chatHistoryLoader.$inject = ['chatRequestProcessor', 'tagChatFactory', 'ChatFactory'];
    function chatHistoryLoader(chatRequestProcessor, tagChatFactory, ChatFactory){

        return {
            restrict: 'E',
            replace: true,
            link : function(scope, elem, attrs){

                var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;

                scope.historyLoading = false;
                //scope.noMoreHistoryMessageText = "Group conversion has not yet started";

                elem.on('click', function(){
                    
                    var newPacketId = ChatFactory.getUUIDPacketId();

                    doHistoryRequest(scope, chatRequestProcessor, scope.box.value, GENERAL_CONSTANTS.PAGE_DIRECTION.UP, newPacketId);

                    //scope.historyLoading = true;

                    // var chatBox = scope.box.value;
                    // var bottomMessage = chatBox.getBottomMessage();

                    // var bottomPacketId;

                    // if( !bottomMessage){
                    //     bottomPacketId = tagChatFactory.getUUIDPacketId();
                    // }else{
                    //     bottomPacketId = chatBox.messageMinPacketId;
                    // }

                    // var historyRequestMethod = chatRequestProcessor.getHistoryRequestMethodByBox(chatBox);

                    // doSendHistoryRequest(scope, historyRequestMethod, chatBox, GENERAL_CONSTANTS.PAGE_DIRECTION.UP, bottomPacketId, 10);


                    //var message = scope.box.value.getBottomMessage(),
                    //    boxId = scope.box.key,
                    //    offlineRequester;
                    //
                    //if(scope.box.value.isTagChat){
                    //    offlineRequester = chatRequestProcessor.getHistoryMessagesMultipleTimes;
                    //}else{
                    //    offlineRequester = chatRequestProcessor.getFriendHistoryMessagesMultipleTimes;
                    //}
                    //
                    ////var requestPacketId = scope.box.value.messageMinPacketId;
                    //var requestPacketId = !message ? '' : message.key;
                    //
                    //if ( requestPacketId == ''){
                    //    requestPacketId = tagChatFactory.getUUIDPacketId();
                    //}
                    ////if( !!message){
                    ////    requestPacketId = message.key;//tagChatFactory.getUUIDPacketId(message.messageDate, true);
                    ////}
                    //
                    //if( requestPacketId != ''){
                    //
                    //    scope.historyLoading = true;
                    //    scope.$rgDigest();
                    //
                    //    offlineRequester( boxId, GENERAL_CONSTANTS.PAGE_DIRECTION.UP, requestPacketId )
                    //        .then(function(response){
                    //            if(!!response.sucs){
                    //                scope.historyLoading = false;
                    //            }
                    //        }, function(){
                    //            scope.historyLoading = false;
                    //        });
                    //}



                });
            },
            templateUrl: 'pages/partials/chat/history-loader-view.html'

        };
    }

    /* Single Page Directives */

    function singlePageChatUI(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/home.html',
            controller : 'ChatHistoryController'

        };
    }

    function chatSinglePageTop(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/top.html'

        };
    }

    function chatSinglePageLeft(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/left.html'

        };
    }

    function chatSinglePageRight(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/right.html'

        };
    }

    function chatLeftSingleBox(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/left-single-box.html'

        };
    }

    function chatRightSingleBox(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/right-single-box.html'

        };
    }

    function chatMessageBox(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/single-page/message-box.html'

        };
    }

    function chatBoxTopBarStatus(){
        return {
            restrict: 'E',
            replace: true,
            templateUrl: 'pages/partials/chat/chatbox-topbar-status.html',
            link : function(scope, elem){

            }

        };
    }

    angular
        .module('ringid.chat')
        .directive('chatBoxUi', chatBoxUi)
        .directive('chatBoxTopBar', chatBoxTopBar)
        .directive('chatBoxMiddle', chatBoxMiddle)
        .directive('chatBoxBottom', chatBoxBottom)
        .directive('extraChatBoxes', extraChatBoxes)
        .directive('chatBoxUrlPreview', chatBoxUrlPreview)

        .directive('chatBoxTopBarStatus', chatBoxTopBarStatus)
        .directive('chatBoxTopBarMenu', chatBoxTopBarMenu)
        .directive('chatBoxBottomMenu', chatBoxBottomMenu)
        .directive('chatBoxLocationInfo', chatBoxLocationInfo)

        .directive('chatSingleMessage', chatSingleMessage)
        .directive('chatFileUploadProgress', chatFileUploadProgress)

        .directive('singleMessageStatus', singleMessageStatus)
        .directive('chatHistoryLoader', chatHistoryLoader)

        .directive('singleChatBox', singleChatBox)

        /* Single Page Directives */

        .directive('chatSinglePageTop', chatSinglePageTop)

        .directive('chatSinglePageLeft', chatSinglePageLeft)
        .directive('chatLeftSingleBox', chatLeftSingleBox)

        .directive('chatSinglePageRight', chatSinglePageRight)
        .directive('chatRightSingleBox', chatRightSingleBox)

        .directive('chatMessageBox', chatMessageBox)

        .directive('singlePageChatUI', singlePageChatUI);


})();

/**
 * Created by mahbubul on 8/23/15.
 */

(function(){
    'use strict';

    var chatApp;

    try {
    chatApp = angular.module('ringid.chat');
    } catch (e) {

    }

    chatApp.directive('chatFocus', chatFocusDirective);

    chatFocusDirective.$inject = ['fileUploadService',
    'chatHistoryFactory', '$document', '$rootScope',
     'utilsFactory','Auth', 'ChatHelper',
    'settings','ChatSeenSend', 'ChatPacketSenderService', 'SystemEvents', 'chatTabSync', 'Ringalert', 'ChatConnector'];

    function chatFocusDirective(fileUploadService,
         chatHistoryFactory, $document, $rootScope,
         utilsFactory,Auth, ChatHelper,
         settings,ChatSeenSend, ChatPacketSenderService, SystemEvents, chatTabSync, Ringalert, ChatConnector

    ) {
        
        var Constants =  CHAT_APP.Constants;
        var CHAT_GLOBAL_VALUES = Constants.CHAT_GLOBAL_VALUES;
        var GENERAL_CONSTANTS = Constants.GENERAL_CONSTANTS;


        return {
            controller: ['$scope','ChatSeenSend', 'ChatHelper', 'Auth', 'rgScrollbarService', function ($scope,ChatSeenSend, ChatHelper, Auth, rgScrollbarService) {
                $scope.onViewedCalled = function (message) {                            
                    var box = $scope.box.value;
                    var isTagChat = $scope.box.value.isTagChat;
                    var messages = [{key: message.key, value: message}];
                    var filterMessagesByViewPort = function(messages){
                        var filteredMessages = [];
                        for(var index = 0, length = messages.length; index < length; index++){
                            if(messages[index].value.user.getKey() !== Auth.loginData.uId
                                && messages[index].value.status !== "Deleted"
                                && messages[index].value.status !== "Played"
                                && messages[index].value.status !== "Viewed"
                                && messages[index].value.status !== "status_update"
                                && messages[index].value.seenSent != true
                            ) {
                                filteredMessages.push(messages[index]);
                            }
                        }
                        return filteredMessages;
                    };
                    if(angular.isArray(messages) && messages.length>0){
                        //todo filter by viewport
                        messages = filterMessagesByViewPort(messages);
                        //messages = filterMessageByMessageType(messages);
                        if(messages.length <1){
                            return;
                        }
                        //ChatHelper.decreaseUnreadCount(box,messages.length);
                        ChatSeenSend.sendSeenPacket(box, messages);

                        if( !isTagChat ){//f2f
                            ChatHelper.startTimerOthers($scope, messages);
                        }
                    }// end of empty message check logic
                };
                $scope.showUnreadMessages = function () {
                    var box = $scope.box.value;

                    ChatHelper.decreaseUnreadCount(box);

                    utilsFactory.triggerCustomEvent('ScrollToUnread', {boxId : $scope.box.key, topAlign : true });

                    // $rootScope.$broadcast("ScrollToUnread",box.getKey());                                                

                };
            }],
            link: function(scope, element, attrs) {
                var boxId = scope.box.value.getKey();
                scope.uploadBoxValue = scope.box.value.getKey();

                scope.uploadAction = function (actionObj) {


                    var keyOrPacketId = utilsFactory.getUniqueID("ring");
                    var dummyMsgObj = {
                        key             :   keyOrPacketId,
                        uploadProgress  :   actionObj.uploadFile.getProgress,
                        uploading       :   true,
                        message         :   " ",
                        mediaUrl        :   actionObj.uploadFile.getPreview(),
                        //messageDate     :   parseInt(new Date().getTime()),
                        messageDate     :   parseInt(new Date().getTime() + CHAT_GLOBAL_VALUES.serverTimeDiff),
                        messageType     :   GENERAL_CONSTANTS.MESSAGE_TYPES.IMAGE,
                        packetId        :   keyOrPacketId,
                        sessionId       :   utilsFactory.getToken,
                        timeout         :   0,
                        status          :   0,
                        getMessageTime  : function(){
                            var localTime = dummyMsgObj.messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff;
                            var localFormatedTime = utilsFactory.chatVerbalDate(localTime);
                            return localFormatedTime;
                        },
                        fileUploadObject : actionObj.uploadFile

                    };
                    scope.box.value.pushDummyMessage(dummyMsgObj,Auth.currentUser(),true);

                    fileUploadService.setScopeForDigest(scope);

                    utilsFactory.safeDigest(scope);

                    var afterUploadCallback = function(imgData) {

                        fileUploadService.removeScope(scope);

                        if( !!imgData.sucs ){

                            var box = scope.box.value;
                            var isTagChat = box.isTagChat;
                            var isBoxOffline = box.offlineStatus;
                            var mediaData = { url : imgData.url, caption : imgData.caption, width: imgData.iw, height: imgData.ih };
                            var msg = settings.imBase + imgData.url;

                            box.removeMessage(keyOrPacketId);
                            utilsFactory.safeDigest(scope);
                           
                            ChatPacketSenderService.sendMessage( box, msg, GENERAL_CONSTANTS.MESSAGE_TYPES.IMAGE, {mediaData : mediaData});


                            scope.resetMessageInput();
                            utilsFactory.safeDigest(scope);

                            utilsFactory.triggerCustomEvent("ScrollToBottom", {boxId : scope.box.key });

                        }

                    };
                    var uploadFailedCallback = function(response){
                        Ringalert.show({mg:'Image Upload Failed, please try again'}, 'error');
                        box.removeMessage(keyOrPacketId);
                    };

                    actionObj.uploadFile.fetchMeta(function(){

                        dummyMsgObj.message = actionObj.uploadFile.getPreview();
                        dummyMsgObj.uploading = true;

                        actionObj.uploadFile.initUpload().then(function(imgData){
                            dummyMsgObj.uploading = false;
                            afterUploadCallback(imgData);
                        }, function(response){
                            console.log(response);
                            dummyMsgObj.uploading = false;
                            uploadFailedCallback(response);
                        });

                    });
                };

                var boxCamUploadRef = utilsFactory.onCustomEvent('BOX_CAM_UPLOAD', function(data){
                    if( scope.box.value.getKey() == data.boxId ){
                        scope.uploadAction(data);
                    }
                });

                $document.on('click', function(event) {
                    //if(scope.box.value.getKey() !== attrs.chatFocus) // can't receive clicked element for other elements, while this event fires double for clicked element
                    scope.box.value.isFocused = false;
                });


                var messages = scope.box.value.getMessages();
                var box = scope.box.value;
                var isTagChat = scope.box.value.isTagChat;

                var filterMessageByMessageType = function(messages){
                    var filteredMessages = [];
                    for(var index = 0, length = messages.length; index < length; index++){
                        switch (messages[index].value.messageType){
                            case 2 :
                            case 3 :
                            case 4 :
                            case 5 :
                            case 6 :
                                filteredMessages.push(messages[index]);
                                break;
                        }
                    }
                    return filteredMessages;
                };
                var filterMessagesByViewPort = function(messages){
                    var filteredMessages = [];
                    for(var index = 0, length = messages.length; index < length; index++){
                        if(messages[index].value.user.getKey() !== Auth.loginData.uId
                            && messages[index].value.status !== "Deleted"
                            && messages[index].value.status !== "Played"
                            && messages[index].value.status !== "Viewed"
                            && messages[index].value.status !== "status_update"
                            && messages[index].value.seenSent != true
                        ) {
                            filteredMessages.push(messages[index]);
                        }
                    }
                    return filteredMessages;
                };


                var updateMessagesStatus = function(messages){
                    var messagesToUpdate = [];
                    for(var index = 0, length = messages.length; index < length; index++){
                        if ( messages[index].value.status == 'Unread' && ( !messages[index].value.timeout || messages[index].value.timeout == 0 )  ){
                            messages[index].value.status = 'Received';
                            messagesToUpdate.push(messages[index].value);
                        }
                    }

                    chatHistoryFactory.updateMessages(messagesToUpdate, box.getKey());

                };

                var decreaseGlobalUnreadCount = function(boxId){
                   chatHistoryFactory.removeUnreadMessageInfoByBoxId(boxId)                            
                };
                /* for handling the focus on another tab : starts*/
                var chatTabSyncNewData = utilsFactory.onCustomEvent(SystemEvents.CHAT.TAB_SYNC_NEW_DATA, function(data){

                    if(GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.SECRET_CHAT_TIMER == data.type){
                        if(data.boxId == box.getKey()){
                            if(angular.isArray(messages) && messages.length>0){
                                updateMessagesStatus(messages);

                                //todo filter by viewport
                                var filteredMessages;
                                filteredMessages = filterMessagesByViewPort(messages);
                                filteredMessages = filterMessageByMessageType(filteredMessages);
                                if(filteredMessages.length <1){
                                    return;
                                }

                                decreaseGlobalUnreadCount(data.boxId);
                                box.updateUnreadCount();

                                //ChatHelper.decreaseUnreadCount(box,messages.length);
                                //ChatSeenSend.sendSeenPacket(box, messages);

                                if( !isTagChat ){//f2f
                                    ChatHelper.startTimerText(scope, filteredMessages);
                                }
                            }// end of empty message check logic
                        }
                    }

                });
                /* for handling the focus on another tab : ends*/
                /*for handling use case when user is focused by default:starts*/
                var wasFocusedRef = utilsFactory.onCustomEvent('WAS_FOCUSED', function (data) {
                    if( !!data && !!data.box){
	                    var chatBox = data.box;
	                    var filteredMessages = data.filteredMessages;
	                    if(chatBox.getKey() == box.getKey()) {
	                        if (!chatBox.isTagChat) {//f2f
	                            ChatHelper.startTimerText(scope, filteredMessages);
	                        }
	                        /* for sending the focus to another tab {secretTimer}*/
	                        chatTabSync.sendData(GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.SECRET_CHAT_TIMER, {boxId: chatBox.getKey()});
	                    }
                    }
                    
                });
                /*for handling use case when user is focused by default:ends*/

                var doStartSecreetTimerRef = utilsFactory.onCustomEvent('DO_START_SECRET_TIMER', function (data) {
                    if( !!data && data.boxId == boxId ){

                        if( data.others){
                            ChatHelper.startTimerOthers(scope, data.messages);    
                        }else{
                            ChatHelper.startTimerText(scope, data.messages);    
                        }                        
                    }
                });

                var onFocusCallback = function (event) {
                    event.stopPropagation();

                    var boxId = scope.box.value.getKey();
                    var box = scope.box.value;

                    var needDigest = false;
                    if( box.unreadCount > 0){
                        decreaseGlobalUnreadCount(boxId);    
                        box.updateUnreadCount();
                        needDigest = true;
                    }

                    if( !scope.bottomMenuHover && !scope.bottomMenuButtonHover){
                        scope.showBottomMenu = false;
                        needDigest = true;                                
                    }

                    if(needDigest){
                        utilsFactory.safeDigest(scope);
                    }

                    
                    for(var i=0; i<scope.boxes.length; i++){
                        scope.boxes[i].value.isFocused = false;
                    }
                    //handling the case while user is clicking the minimize button then onclick will fire and for this case we need to make isFocused false for that box

                    if (box.isMinimized === true) {
                        box.isFocused = false;
                    } else {
                        box.isFocused = true;
                    }
                    scope.$broadcast("blinkerOff", boxId);
                    scope.$broadcast("focusOn", boxId);

                    
                    if(angular.isArray(messages) && messages.length>0){
                        updateMessagesStatus(messages);

                        //todo filter by viewport
                        var filteredMessages;
                        filteredMessages = filterMessagesByViewPort(messages);
                        filteredMessages = filterMessageByMessageType(filteredMessages);
                        if(filteredMessages.length <1){
                            return;
                        }


                        //ChatHelper.decreaseUnreadCount(box,messages.length);
                        ChatSeenSend.sendSeenPacket(box, filteredMessages);

                        if( !isTagChat ){//f2f
                            ChatHelper.startTimerText(scope, filteredMessages);
                        }
                        /* for sending the focus to another tab {secretTimer}*/
                        chatTabSync.sendData(GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.SECRET_CHAT_TIMER, {boxId : box.getKey()});
                    }// end of empty message check logic

                };

                element.on('click', onFocusCallback);


                scope.$on('$destroy', function(){
                    utilsFactory.onCustomEvent('BOX_CAM_UPLOAD', boxCamUploadRef );
                    utilsFactory.onCustomEvent('DO_START_SECRET_TIMER', doStartSecreetTimerRef );
                    utilsFactory.onCustomEvent('WAS_FOCUSED', wasFocusedRef );
                    utilsFactory.onCustomEvent(SystemEvents.CHAT.TAB_SYNC_NEW_DATA, chatTabSyncNewData );                    

                });
            }
        };
    }
})();

/**
 * Created by mahbubul on 8/23/15.
 */
(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}

    var ChatRequests = CHAT_APP.ChatRequests;

    chatMessageDirective.$inject = ['Auth', 'profileFactory', '$compile', 'chatHistoryFactory','$interval', 'ChatHelper', 'utilsFactory'];
    function chatMessageDirective(Auth, profileFactory, $compile, chatHistoryFactory,$interval, ChatHelper, utilsFactory) {

        return {
            restrict: 'A',
            scope: true,

            link: function (scope, element, attrs) {

                var box = scope.$eval(attrs.messageBox);
                box = box.value;
                var message = scope.$eval(attrs.messageMsg);
                //var first_children = element.children();
                var avatorDom;
                var dateLineDom;

                var takeDecisionForShowingMessageUserAvator  = function(){
                    if(box.isConsicutive(message.key)){
                        return false;
                    }else{
                        return true;
                    }
                };
                scope.message.takeDecisionForShowingMessageUserAvator = takeDecisionForShowingMessageUserAvator;
                scope.message.showAvator = takeDecisionForShowingMessageUserAvator();

                if (message.user.isCurrentUser()) {
                    element.addClass('cm-box-r');
                    if( message.status !== 'status_update') {
                       
                        avatorDom = angular.element('<img ng-show="message.showAvator" class="chat-img-r chat-img" src="' + message.user.avatar('thumb') + '" />');
                        var compiledAvatorDom = $compile(avatorDom)(scope);
                        element.append(compiledAvatorDom);
                       
                    }
                } else {
                    element.addClass('cm-box');
                    if( message.status !== 'status_update') {
                       
                        avatorDom = angular.element('<img ng-show="message.showAvator" class="chat-img-l chat-img" src="' + message.user.avatar('thumb') + '" />');
                        var compiledAvatorDom = $compile(avatorDom)(scope);
                        element.prepend(compiledAvatorDom);
                       
                    }
                }
               


                var takeDecisionForShowingDate = function () {
                    var currentMessageDate = Math.floor(message.messageDate / (1000*3600*24))
                    if(box.previousDate != currentMessageDate ){
                        box.previousDate = currentMessageDate;
                        
                        return true;
                    } else{
                        return false;
                    }
                };
                scope.message.takeDecisionForShowingDate = takeDecisionForShowingDate;
                scope.message.showDate = takeDecisionForShowingDate();

                
                dateLineDom = angular.element('<div class="line" ng-show="message.showDate"><div class="line-m">{{ message.messageDate | date }}</div></div><div ng-show="message.showDate" class="clear"></div>');
                var compiledDateLineDom = $compile(dateLineDom)(scope);
                element.prepend(compiledDateLineDom);

                scope.$on('timeoutDelete', function (event,messageKey,timeoutCount) {

                    if(messageKey === message.key){
                        
                        
                        if(timeoutCount>0){
                            scope.message.timeout = timeoutCount;

                        }else{
                            var messageUserKey = message.user.getKey();
                            if(messageUserKey == Auth.loginData.uId){
                          
                                scope.message.timeout = 0;
                               
                                scope.message.secretTimedOut = true;
                                switch (scope.message.messageType) {
                                    case 2:
                                    case 3:
                                    case 4://this is for location
                                    case 5://this is for url
                                    case 6:
                                        scope.message.status = 'Deleted';
                                        break;
                                    case 8:
                                        scope.message.status = 'Played';
                                    case 7:
                                    case 9:
                                    case 10:
                                        scope.message.status = 'Viewed';
                                        break;
                                }// end of switch for messageType

                                chatHistoryFactory.updateMessage(scope.message, box.getKey());

                            }else{
                                
                                ChatHelper.deleteMessageFromOwn(box, message);
                                utilsFactory.triggerCustomEvent("SINGLE_MESSAGE_TIMEDOUT", {box: box});
                                
                            }
                        }
                    }
                });
            }
        };
    }

    
    chatEditMessage.$inject = ['$rootScope'];
    function chatEditMessage($rootScope) {

            return {
                restrict: 'EA',
                link: function (scope, element, attrs) {

                    var CHAT_GLOBAL_VALUES = CHAT_APP.Constants.CHAT_GLOBAL_VALUES;

                    element.on('click', function (event) {
                        $rootScope.$broadcast('editMessageEvent', attrs.editMessage, scope.message);
                    });
                    var calculateOneHourFilter = function(messageDate){
                        var currentTime = Math.floor(Date.now());
                        var messageDateInLocalTime = messageDate - CHAT_GLOBAL_VALUES.serverTimeDiff;
                        var diff = currentTime - messageDateInLocalTime;
                        var oneHour = 1000 * 3600;
                        if(diff > oneHour)
                            return false;
                        else
                            return true;
                    };

                    scope.message.canEdit = function(){
                        return (scope.message.user.isCurrentUser() &&
                        calculateOneHourFilter(scope.message.messageDate) &&
                        ([4, 6, 7, 8, 9, 10].indexOf(scope.message.messageType) === -1) &&
                        !(scope.message.timeout>0 || scope.message.secretTimedOut == true)&&
                        (['Deleted', 'status_update', 'Viewed', 'Played'].indexOf(scope.message.status) === -1));

                    };
                }
            }; // return object for directive factory function

    }


    chatRetryMessage.$inject = ['ChatPacketSenderService'];
    function chatRetryMessage( ChatPacketSenderService) {

        return {
            restrict: 'EA',
            link: function (scope, element, attrs) {
                element.on('click', function (event) {
                    ChatPacketSenderService.retryMessage(scope.box.value, scope.message, scope.messageData);
                });

            }
        }; // return object for directive factory function

    }

    chatDeleteMessage.$inject = ['Storage', 'utilsFactory', 'Auth', 'ChatConnector', 'ChatHelper', 'tagChatFactory'];
    function chatDeleteMessage(Storage, utilsFactory, Auth, ChatConnector, ChatHelper, tagChatFactory ) {

        return {
            restrict: 'EA',
            link: function (scope, element, attrs) {

                scope.message.canDelete = function(){
                    return (['status_update'].indexOf(scope.message.status) === -1);
                };

                element.on('click', function (event) {
                    ChatHelper.deleteMessageFromOwn(scope.box.value, scope.message);
                    
                    if(scope.message.user.getKey().toString() === Auth.loginData.uId.toString()) {
                        
                        if (scope.box.value.isTagChat) {// for tagChat

                            var tagId = scope.box.value.getKey();
                            var tagObject = tagChatFactory.getTag(tagId);
                            
                            var packets = [{packetId: scope.message.key}]
                            var requestObject = ChatRequests.getTagChatMultipleMsgDeleteObject(tagId, packets);
                            ChatConnector.send(requestObject);
                                                        

                        } else {// for individual chat
                            if(scope.message.secretTimedOut != true || scope.message.timeout>0){// checking if it was not a secret Message as delete message packet won't be sent for secret message

                                scope.box.value.sendTabUpdate(scope.message);

                                var friendId = scope.box.value.getKey();
                                var packets = [{packetId: scope.message.key}]
                                var requestObject = ChatRequests.getFriendChatMultipleMsgDeleteObject(friendId, packets);
                                ChatConnector.send(requestObject);
                           
                            }
                        }
                    }

                });
            }


        }; // return object for directive factory function
    }


    chatMessageReact.$inject = ['profileFactory'];
    function chatMessageReact(profileFactory) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                var message = scope.$eval(attrs.chatMessageReact);

                var SClasses = ['status_pending','status_delivered','status_seen','status_sent'];

                var doUpdateStatus = function(){

                    if( message.status == 'status_update'){
                        element.addClass('status_update');

                    } else{
                        if(message.user.isCurrentUser()){
                            element.addClass('status_received');
                        }else{
                            if(SClasses[message.status]){
                                element.addClass(SClasses[message.status]);
                            }
                        }
                    }
                };

                if(!angular.isObject(message.user)){

                    profileFactory.getUserDetailsByUId(message.user).then(function (userObj) {
                        if (!!userObj) {
                            message.user = userObj;
                            doUpdateStatus();
                            utilsFactory.safeDigest(scope);
                        }
                    });

                }else{
                    doUpdateStatus();
                }
            }
        }; // return object for directive factory function
    }
    
    
    sendMessageDirective.$inject = ['ChatFactory','$timeout', 'ChatConnector', 'tagChatFactory', 'tagChatManager','$$connector', 'OPERATION_TYPES', 'ChatPacketSenderService', 'ChatHelper', 'utilsFactory', 'SystemEvents', 'Ringalert'];
    
    function sendMessageDirective(ChatFactory,$timeout, ChatConnector, tagChatFactory, tagChatManager,$$connector, OPERATION_TYPES,
                      ChatPacketSenderService, ChatHelper, utilsFactory, SystemEvents, Ringalert ) {
            
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {

                var GENERAL_CONSTANTS = CHAT_APP.Constants.GENERAL_CONSTANTS;
                var AUTH_SERVER_ACTIONS = CHAT_APP.Constants.AUTH_SERVER_ACTIONS;

                scope.messageText = "";
                var doGetCaretPosition = function(ctrl) {

                            var CaretPos 						= 0;
                            var caretPositions 					= {
                                startPos			: 0,
                                endPos 				: 0,
                                selectionLength		: 0
                            };
                            // IE Support
                            if (document.selection) {

                                ctrl.focus ();
                                var Sel 						= document.selection.createRange ();

                                Sel.moveStart ('character', -ctrl.value.length);

                                CaretPos 						= Sel.text.length;
                            }
                            // Firefox support
                            else if (ctrl.selectionStart || ctrl.selectionStart == '0'){
                                CaretPos 						= ctrl.selectionStart;
                                caretPositions.startPos 		= ctrl.selectionStart;
                                caretPositions.endPos 			= ctrl.selectionEnd;
                                caretPositions.selectionLength 	= Math.abs(ctrl.selectionStart - ctrl.selectionEnd);
                            }

                            return (caretPositions);

                        };
                        var setCaretPosition = function(el, caretPositions, st) {
                            //var el = document.getElementById(el);

                            el.value 							= el.value;
                            var tempText 						= el.value;

                            // ^ this is used to not only get "focus", but
                            // to make sure we don't have it everything -selected-
                            // (it causes an issue in chrome, and having it doesn't hurt any other browser)

                            if (el !== null) {

                                if (el.createTextRange) {
                                    var range = el.createTextRange();
                                    el.value = tempText.slice(0, caretPositions.startPos) + st + tempText.slice(caretPositions.endPos);
                                    range.move('character', caretPositions.startPos+st.length);
                                    range.select();
                                    return true;
                                }

                                else {
                                    // (el.selectionStart === 0 added for Firefox bug)
                                    if (el.selectionStart || el.selectionStart === 0) {
                                        el.focus();

                                        el.value = tempText.slice(0, caretPositions.startPos) + st + tempText.slice(caretPositions.endPos);
                                        el.setSelectionRange(caretPositions.startPos+st.length, caretPositions.startPos+st.length);
                                        return true;
                                    }

                                    else  { // fail city, fortunately this never happens (as far as I've tested) :)
                                        el.focus();
                                        return false;
                                    }
                                }
                            }
                        };                            

                scope.selectedLocation = function(){
                    
                    utilsFactory.triggerCustomEvent("ScrollToBottom", {boxId : scope.box.key });


                    utilsFactory.getUserLocation().then(function(location){
                        if( location.sucs ){
                            scope.messageData.locationData = location;

                            if( !!location.lat && location.lat != 9999) {
                                ChatPacketSenderService.sendMessage( scope.box.value, '', GENERAL_CONSTANTS.MESSAGE_TYPES.LOCATION_SHARE, scope.messageData )

                            }else{
                            }                    

                            scope.$rgDigest();
                            utilsFactory.triggerCustomEvent("ScrollToBottom", { boxId : scope.box.key });


                        }else{
                            Ringalert.show({mg: 'Please Enable Browser Location Tracking.'}, 'error');
                        }                            

                        scope.resetMessageInput(true);                            
                    })                            

                    
                };


                scope.selectEmoticonChat = function (emoticon) {

                    if (emoticon.isSticker() || emoticon.isLargeEmoticon()) {
                        scope.resetMessageInput();

                        var requestObject = ChatPacketSenderService.sendMessage( scope.box.value, emoticon.srcWithoutBase(), 6 )                                            


                        utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_SUBMITTED, { boxId : scope.box.value.getKey() });

                        scope.messageText = "";

                        utilsFactory.triggerCustomEvent("ScrollToBottom", {boxId : scope.box.value.getKey() });


                    }else{

                        scope.messageText = scope.messageText +""+ emoticon.symbol();

                        element[0].focus();
                    }
                };

                var bindEvent = function () {
                   
                    element.on('keyup', function (event) {
                        
                        if( event.which === 13 ){

                            if(element.attr('messageKey')){
                                scope.box.value.editMessageKey = element.attr('messageKey');
                                element.removeAttr('messageKey');
                                scope.box.value.editMessageDate = element.attr('messageDate');
                                element.removeAttr('messageDate');
                                element.removeClass('editing');
                            }

                            var messageType = ChatPacketSenderService.getMessageType( scope.messageData );    

                            if(scope.messageText !== '' ){
                               
                                ChatPacketSenderService.sendMessage(scope.box.value, scope.messageText, messageType, scope.messageData)                                                                                                                                                        
                                
                                scope.resetMessageInput(true);
                                
                                utilsFactory.triggerCustomEvent("ScrollToBottom", {boxId : scope.box.key });

                                utilsFactory.triggerCustomEvent(SystemEvents.CHAT.MESSAGE_SUBMITTED, { boxId : scope.box.value.getKey() });                                    
                                

                            }
                            
                            
                        }else{
                            
                            if (scope.box.value.isTyping() === false) {
                                
                                ChatPacketSenderService.sendTypingPacket(scope.box.value);

                                scope.box.value.setTypingBool(true);
                                
                                setTimeout(function () {
                                    scope.box.value.setTypingBool(false);
                                    utilsFactory.triggerCustomEvent(SystemEvents.CHAT.BOX_UPDATED, {boxId : scope.box.key });
                                }, 5000);

                            }                    
                        }
                        
                    });
                };

                var unbindEvent = function () {
                    element.off('keyup');
                };

                bindEvent();

                scope.$on('$destroy', unbindEvent);

                if(scope.box.value.isFocused === true){
                    element[0].focus();
                }


                scope.$on('editMessageEvent', function (event, boxKey, messageObj) {
                    if(scope.box.value.getKey() == boxKey){

                        var messageType = messageObj.messageType;

                        switch (messageType){

                            case GENERAL_CONSTANTS.MESSAGE_TYPES.TEXT:
                                scope.messageText = messageObj.text;
                                break;

                            case GENERAL_CONSTANTS.MESSAGE_TYPES.LOCATION_SHARE:
                                scope.locationData = messageObj.locationInfo;
                                break;

                            case GENERAL_CONSTANTS.MESSAGE_TYPES.LINK_SHARE:
                                var jsonObject = angular.fromJson(messageObj.text);
                                scope.messageText = messageObj.ogData.message || messageObj.ogData.description
                                break;

                            //case GENERAL_CONSTANTS.MESSAGE_TYPES.STICKER:
                            //case GENERAL_CONSTANTS.MESSAGE_TYPES.IMAGE:
                            //case GENERAL_CONSTANTS.MESSAGE_TYPES.CAMERA_IMAGE:
                            //case GENERAL_CONSTANTS.MESSAGE_TYPES.AUDIO:
                            //case GENERAL_CONSTANTS.MESSAGE_TYPES.VIDEO:

                        }

                        element.addClass('editing');
                        element.attr('messageKey', messageObj.key);
                        element.attr('messageDate', messageObj.messageDate);

                        utilsFactory.safeDigest(scope);
                    }
                });
            }

        }; // return object for directive factory function
    }    

    chatApp.directive('messageDirective', chatMessageDirective);
    chatApp.directive('editMessage', chatEditMessage);
    chatApp.directive('retryMessage', chatRetryMessage);
    chatApp.directive('deleteMessage', chatDeleteMessage);
    chatApp.directive('chatMessageReact', chatMessageReact);
    chatApp.directive('sendMessageDirective', sendMessageDirective);



})();

/**
 * Created by mahbubul on 8/23/15.
 */
(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {}

    chatApp
        .directive('setTimeout', ['ChatFactory','$compile','$document', function (ChatFactory, $compile, $document) {
            return {
                restrict: 'EA',
                //replace: true,
                template: '<a><span class="icon-timer-s"></span></a>',
                link: function (scope, element, attrs) {
                    //var showTimeout = false,
                    var timeoutBarCompiledDom,
                        openTimeoutPopup = function () {
                            scope.showTimeout = true;
                            scope.closeSettingPopup();
                            $document.bind('click', closeTimeoutPopup);

                            var timeoutBarDom = angular.element('<set-timeout-bar ></set-timeout-bar>');
                            timeoutBarCompiledDom = $compile(timeoutBarDom)(scope);
                            //element.append(timeoutBarCompiledDom);
                            //element.parent().parent().next().prepend(timeoutBarCompiledDom);
                            element.parent().parent().parent().next().prepend(timeoutBarCompiledDom);
                        },
                        closeTimeoutPopup = function () {
                            scope.showTimeout = false;
                            $document.unbind('click', closeTimeoutPopup);
                            if(timeoutBarCompiledDom)
                                timeoutBarCompiledDom.remove();
                        };
                    scope.closeTimeoutPopup = function () {
                        closeTimeoutPopup();
                    };
                    scope.showTimeout = false;

                    element.on('click', function (event) {
                        //console.log('cl');
                        console.dir(scope.showTimeout);
                        if (!scope.showTimeout) {
                            openTimeoutPopup();
                        } else {
                            closeTimeoutPopup();
                        }
                        event.stopPropagation();
                    });

                }
            }; // return object for directive factory function
        }])
        .directive('setTimeoutBar', ['ChatFactory','$compile', function (ChatFactory,$compile) {
            return {
                restrict: 'E',
                //replace: true,
                template:'<div class="timeout-area-with-popup"><div class="timeoutDivnew">\n\
<span class="enable-secret-chat">Enable Secret Chat:</span><div class="switchnew"><input class="float-left" ng-model="box.value.secretChat" type="checkbox"><label><i></i></label></div>\n\
<a href="#" ng-click="cancel($event)" ng-disabled="!box.value.secretChat" class="correct-sec icon-close-b"></a>\n\
<a href="#" ng-click="showValueBox($event)" class="timeout-sec icon-time"><p>sec</p><span>{{ timeout>4 ? timeout : 5}}</span></a></div></div>',
//<a href="#" ng-click="done($event)" ng-disabled="!box.value.secretChat" class="correct-icon-sec"></a>\n\
//<input class="timer-c" type="number" value="17" min="1" max="300" step="1" ng-model="timeout" ng-disabled="!box.value.secretChat" />\n\
//<br/>\n\
//<input class="btn-timer" type="button" ng-click="done($event)" value="Done" ng-disabled="!box.value.secretChat" />\n\
//<input class="btn-timer float-right" type="button" ng-click="cancel($event)" ng-disabled="!box.value.secretChat" value="Cancel"/>\n\
//</div>',
                link: function (scope, element, attrs) {
                    var timeoutVarriable = 0;
                    var timeoutVaueCompiledDom;

                    //element.on('keyup', function (event) {
                    //    scope.box.value.timeout = scope.timeout;
                    //});
                    scope.timeout = scope.box.value.timeout;
                    scope.showTimeoutBox = false;
                    //scope.secretChat = scope.box.value.secretChat;
                    //scope.box.value.secretChat = scope.secretChat;

                    //scope.done = function ($event) {
                    //    if(scope.timeout)
                    //        timeoutVarriable = parseInt(scope.timeout);
                    //    scope.box.value.timeout = timeoutVarriable;
                    //    //scope.box.value.secretChat = scope.secretChat;
                    //    //console.dir(scope.box.value.secretChat);
                    //    scope.closeTimeoutPopup();
                    //    //scope.showTimeout = true;
                    //    //element.remove();
                    //    //scope.$digest();
                    //    //scope.closeTimeoutPopup();
                    //    //element.remove();
                    //    if(!!$event)
                    //        $event.stopPropagation();
                    //};
                    scope.cancel = function ($event) {
                        //scope.box.value.timeout = 0;
                        //alert('cancel:'+scope.box.value.getKey())
                        scope.closeTimeoutPopup();
                        if(!!$event){
                            $event.preventDefault();
                            $event.stopPropagation();
                        }
                    };
                    scope.showValueBox = function ($event) {
                        if (!scope.showTimeoutBox) {
                            scope.showTimeoutBox = true;
                            var timeoutValueDom = angular.element('<set-timeout-Value ></set-timeout-Value>');
                            timeoutVaueCompiledDom = $compile(timeoutValueDom)(scope);
                            element.children(0).append(timeoutVaueCompiledDom);
                        } else{
                            scope.hideValueBox();
                        }

                        if(!!$event){
                            $event.preventDefault();
                            $event.stopPropagation();
                        }
                    };
                    scope.hideValueBox = function($event){
                        scope.showTimeoutBox = false;
                        if(timeoutVaueCompiledDom)
                            timeoutVaueCompiledDom.remove();
                        if(!!$event){
                            $event.preventDefault();
                            $event.stopPropagation();
                        }

                    };
                    element.on('click', function (event) {
                        //event.preventDefault();
                        event.stopPropagation();
                    });
                    //element.on('click', function (event) {
                    //    scope.showTimeout = false;
                    //    console.log('r:' + scope.showTimeout);
                    //    event.stopPropagation();
                    //});

                }
            }; // return object for directive factory function
        }])
        .directive('setTimeoutValue', ['ChatFactory', function (ChatFactory) {
            return {
                restrict: 'EA',
                templateUrl: 'pages/partials/chat-timeout-value-box.html',
                link: function (scope, element, attrs) {
                    //element.on('click', function (event) {
                    //    //console.log('cl');
                    //    if (!scope.showTimeout) {
                    //        openTimeoutPopup();
                    //    } else {
                    //        closeTimeoutPopup();
                    //    }
                    //    event.stopPropagation();
                    //});
                    scope.selectTimeout = function ($event, time) {
                        scope.box.value.timeout = scope.timeout = time;
                        scope.hideValueBox($event);
                        //scope.$digest();
                    }
                }
            }; // return object for directive factory function
        }])
        ;
})();

/**
 * Created by mahbubul on 2/4/16.
 */
/**
 * Created by mahbubul on 8/23/15.
 */
(function(){
    'use strict';
    var chatApp;

    try {
        chatApp = angular.module('ringid.chat');
    } catch (e) {
    }
    chatApp
        .directive('setting', ['ChatFactory','$compile','$document', function (ChatFactory, $compile, $document) {
            return {
                restrict: 'EA',
                //replace: true,
                template: '<a><span class="icon-g-settings"></span></a>',
                link: function (scope, element, attrs) {
                    //var showTimeout = false,
                    var settingBarCompiledDom,
                        openSettingPopup = function () {
                            scope.showSetting = true;
                            scope.closeTimeoutPopup();
                            $document.bind('click', closeSettingPopup);

                            var settingBarDom = angular.element('<setting-bar ></setting-bar>');
                            settingBarCompiledDom = $compile(settingBarDom)(scope);
                            //element.append(timeoutBarCompiledDom);
                            //element.parent().parent().next().prepend(timeoutBarCompiledDom);
                            element.parent().parent().parent().next().prepend(settingBarCompiledDom);
                        },
                        closeSettingPopup = function () {
                            scope.showSetting = false;
                            $document.unbind('click', closeSettingPopup);
                            if(settingBarCompiledDom)
                                settingBarCompiledDom.remove();
                        };
                    scope.closeSettingPopup = function () {
                        closeSettingPopup();
                    };
                    scope.showSetting = false;

                    element.on('click', function (event) {
                        //console.log('cl');
                        console.dir(scope.showSetting);
                        if (!scope.showSetting) {
                            openSettingPopup();
                        } else {
                            closeSettingPopup();
                        }
                        event.stopPropagation();
                    });

                }
            }; // return object for directive factory function
        }])
        .directive('settingBar', ['ChatFactory', '$compile', 'profileFactory', 'tagChatFactory', 'ChatUtilsFactory', 'Auth', 'ChatConnector',   'PLATFORM', 'Ringalert', 
            function (ChatFactory, $compile, profileFactory, tagChatFactory, ChatUtilsFactory, Auth, ChatConnector,   PLATFORM, Ringalert ) {
            return {
                restrict: 'E',
                //replace: true,
                //<span class="enable-block">Block:</span><div class="switch-enable-block"><input class="float-left" ng-model="box.value.blocked" type="checkbox"><label><i></i></label></div>\n\
                template:'<div class="timeout-area-with-popup"><div class="timeoutDivnew">\n\
<span class="secret-visible">Timer:</span><div class="switch-secret-visible"><input class="float-left" ng-model="box.value.isSecretVisible" type="checkbox"><label><i></i></label></div>\n\
<a href="#" ng-click="cancel($event)" ng-disabled="!box.value.secretChat" class="correct-sec icon-close-b"></a>\n\
</div></div>',
//<a href="#" ng-click="done($event)" ng-disabled="!box.value.secretChat" class="correct-icon-sec"></a>\n\
//<input class="timer-c" type="number" value="17" min="1" max="300" step="1" ng-model="timeout" ng-disabled="!box.value.secretChat" />\n\
//<br/>\n\
//<input class="btn-timer" type="button" ng-click="done($event)" value="Done" ng-disabled="!box.value.secretChat" />\n\
//<input class="btn-timer float-right" type="button" ng-click="cancel($event)" ng-disabled="!box.value.secretChat" value="Cancel"/>\n\
//</div>',

//FOLLOWING LINE NEED TO BE ADDED WHILE BLOCK/UNBLOCK WILL BE ADDED
//<span class="enable-block" ng-show="box.value.getUser().friendshipStatus()==1">Block:</span><div ng-show="box.value.getUser().friendshipStatus()==1" class="switch-enable-block"><input ng-click="blockUnblock($event)" class="float-left" ng-model="box.value.blocked" type="checkbox"><label><i></i></label></div>\n\
                link: function (scope, element, attrs) {
                    var getUUIDPacketId = tagChatFactory.getUUIDPacketId;
                    var currentUserObject = Auth.currentUser();
                    var currentUserUtId = currentUserObject.getUtId();
                    var checkBlockedByUtIdExists = function (utId) {
                        if(scope.box.value.blockedByUtId && scope.box.value.blockedByUtId.length > 0){
                            var flag = 0;
                            for(var iterator = 0, iteratorLimit = scope.box.value.blockedByUtId.length; iterator < iteratorLimit; iterator++ ){
                                if( scope.box.value.blockedByUtId[iterator] == utId){
                                    flag = 1;
                                }
                            }
                            if( flag == 1){
                                return true;
                            } else{
                                return false;
                            }
                        }else{
                            return false;
                        }
                    };
                    var removeBlockedUtId = function (utId){
                        var index =  scope.box.value.blockedByUtId.indexOf(utId);
                        if (index > -1) {
                            scope.box.value.blockedByUtId.splice(index, 1);
                        }
                    };
                    var sendBlockUnblockToAuthServer = function(forceFlag){//if forceFlag true parameter is passed then we have to give this priority and ignore scope.box.value.blocked value
                        var blockedFlag = scope.box.value.blocked ? 0 : 1; // sv = 0:blocked and sv=1:nonBlocked
                        if(forceFlag){
                            blockedFlag = 1;
                        }
                        var blockObjectAuth = {
                            actn        : 82,                                   // another was 216, but 216 is obsolete, 82 will be for me
                            sv          : blockedFlag,                          // value to be sent for blocking to auth server
                            sn          : 7,                                    // 7 for chat
                            utId        : scope.box.value.getUser().getUtId(),  // utId from userObject
                            isCurrent   : false                                 // in this case not currentUser
                        };
                        profileFactory.saveChatPvcEdit(blockObjectAuth).then(function(data){
                            if(data.sucs === true){
                                //$scope.fPrivacyInfo.chatPrivacy = fPrivacyInfo.chatPrivacy;
                            }else{
                                //$scope.fPrivacyInfo.chatPrivacy = 0;
                            }
                        });
                    };
                    var sendBlockUnblockToChatServer = function(){
                        return true;
//                        if( !scope.box.value.checkWaitingTimePassed() && scope.box.value.hasIpPort() ){
//                            var currentServerTime = chatUtilsFactory.getChatServerCurrentTime();
//                            var packetId = getUUIDPacketId(currentServerTime);
//                            var blockUnblockObjectChat = {
//                                ip                      : scope.box.value.getIp(),
//                                port                    : scope.box.value.getPort(),
//                                packetType              : scope.box.value.blocked ? 27 : 28,
//                                packetId                : packetId,
//                                userId                  : Auth.currentUser().getKey(),
//                                friendId                : scope.box.value.getKey(),
//                                //blockDate               : currentServerTime,
//                                isSecretVisible         : 1,//isSecretVisible instead of isAddToDb
//                                blockUnblockUpdateDate  : currentServerTime,
//                                platform                : PLATFORM.WEB
//                            };
//                            if(scope.box.value.blocked){
//                                var blockUnblockPacket = PacketDataParse.constructPacket(blockUnblockObjectChat, 27, CHAT_PACKET_FORMAT.FRIEND_BLOCK_PKT.FORMAT);
//                                var arrayBuffer = ArrayBuffer.prototype.slice.call( blockUnblockPacket.buffer, 6 );
//                                var parsedBlockObject = PacketDataParse.parsePacket(arrayBuffer, 27, CHAT_PACKET_FORMAT.FRIEND_BLOCK_PKT.FORMAT);
//                            }else{
//                                var blockUnblockPacket = PacketDataParse.constructPacket(blockUnblockObjectChat, 28, CHAT_PACKET_FORMAT.FRIEND_UNBLOCK_PKT.FORMAT);
//                                var arrayBuffer = ArrayBuffer.prototype.slice.call( blockUnblockPacket.buffer, 6 );
//                                var parsedBlockObject = PacketDataParse.parsePacket(arrayBuffer, 28, CHAT_PACKET_FORMAT.FRIEND_UNBLOCK_PKT.FORMAT);
//                            }
//                            //var arrayBuffer = ArrayBuffer.prototype.slice.call( blockUnblockPacket.buffer, 6 );
//                            //var parsedBlockObject = PacketDataParse.parsePacket(arrayBuffer, 27, CHAT_PACKET_FORMAT.FRIEND_BLOCK_PKT.FORMAT);
//                            console.log(parsedBlockObject);
//                            //ChatConnector.send(blockUnblockPacket);
//                        }
                    };
                    scope.cancel = function ($event) {
                        //scope.box.value.timeout = 0;
                        //alert('cancel:'+scope.box.value.getKey())
                        scope.closeSettingPopup();
                        if(!!$event){
                            $event.preventDefault();
                            $event.stopPropagation();
                        }
                    };
                    scope.blockUnblock = function($event){
//						if(!scope.box.value.blocked){
//                            
//                            if(scope.box.value.blockedByUtId){
//                                if(scope.box.value.blockedByUtId.length > 1 && checkBlockedByUtIdExists(currentUserUtId)){
//                                    scope.box.value.blocked = true;
//                                    Ringalert.show("You can't Unblock as your friend blocked you.", "warning");
//                                    sendBlockUnblockToAuthServer(true);
//                                    PullerSubscriber.requestForIp(scope.box.value.getKey());
//                                    removeBlockedUtId(currentUserUtId);
//
//                                } else if(scope.box.value.blockedByUtId.length == 1 && checkBlockedByUtIdExists(currentUserUtId)){
//                                    PullerSubscriber.requestForIp(scope.box.value.getKey());
//                                    sendBlockUnblockToAuthServer();
//                                    sendBlockUnblockToChatServer();
//                                    removeBlockedUtId(currentUserUtId);
//
//                                } else if(scope.box.value.blockedByUtId.length == 1 && !checkBlockedByUtIdExists(currentUserUtId)){
//                                    scope.box.value.blocked = true;
//                                    Ringalert.show("You can't Unblock as your friend blocked you.", "warning");
//
//                                } else if(scope.box.value.blockedByUtId.length == 0){
//                                    scope.box.value.blocked = true;
//                                    Ringalert.show("You can't Unblock as your friend blocked you.", "warning");
//                                }
//   		                      //  if(scope.box.value.blockedByUtId == currentUserUtId){
//       		                  //      // on this logical condition user will be able to unblock friend as he blocked him
//                                 //   sendBlockUnblockToAuthServer();
//                                 //   sendBlockUnblockToChatServer();
//                                 //   PullerSubscriber.requestForIp(scope.box.value.getKey());
//           		              //  }else{
//               		          //      // otherwise unblocking process will not proceed and ui will be get back to the previous state.
//                                 //   scope.box.value.blocked = true;
//                                 //   Ringalert.show("You can't Unblock as your friend blocked you.", "warning");
//                    	        //}
//                       		}// end of checking if it was previously blocked by himself or not
//                            else{
//                                //scope.box.value.blocked = true;
//                                //Ringalert.show("You can't Unblock as your friend blocked you.", "warning");
//                            }
//						}else {
//                            if(checkBlockedByUtIdExists(currentUserUtId)){
//
//                            }else{
//                                scope.box.value.blockedByUtId.push(currentUserUtId);
//                            }
//                            sendBlockUnblockToAuthServer();
//                            sendBlockUnblockToChatServer();
//                        }

                        /* for sending the BLOCK/UNBLOCK to another tab */
                        //chatTabSync.sendData(CHAT_GENERAL_CONSTANTS.TAB_SYNC_ACTIONS.CHAT_BLOCK_UNBLOCK, {boxId : scope.box.value.getKey()});
                    };
                    element.on('click', function (event) {
                        //event.preventDefault();
                        event.stopPropagation();
                    });

                }
            }; // return object for directive factory function
        }])
    ;
})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.chat')

        .directive('rgTagChatList',
            function () {
                return {
                    restrict: 'E',
                    templateUrl: 'pages/partials/tag-chat/tag-chat-list.html'
                };
            }
        )



})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.circle', [
			//'ringid.ringbox',
			//'ringid.common.rgdropdown_directive',
			'ringid.friend.friends_factory',
			'ringid.common.user_factory',
			//'ringid.common.stacked_map'
		]);
})();

/*
 * © Ipvision
 */

(function() {
    'use strict';

	angular
		.module('ringid.circle')
		.service('circleHttpService', circleHttpService);

		circleHttpService.$inject = ['$$connector', 'OPERATION_TYPES'];
		function circleHttpService($$connector, OPERATION_TYPES) { //jshint ignore:line
			var self = this, // jshint ignore:line
                OTYPES = OPERATION_TYPES.SYSTEM.CIRCLE,
                REQTYPE = OPERATION_TYPES.SYSTEM.REQUEST_TYPE;

			self.go = function(data, method){
				method = method || 'post';
                return $$connector.request(data);
			};

			self.getCircleMembers = function(circleId,pvtid,lim) {
				var payload = {
					actn: OTYPES.TYPE_GROUP_MEMBERS_LIST,
					grpId: circleId,
					scl:1,
					lmt: lim || 40,
					pvtid: pvtid || 0
				};

				return $$connector.send(payload,REQTYPE.REQUEST);
			};

			self.createCircle = function(obj){
				var payload = {
					actn: OTYPES.TYPE_CREATE_GROUP,
                    gNm: obj.tg.utf8Encode(),
					uId:obj.uId,
					groupMembers: obj.alluser
				};
				return $$connector.request(payload,REQTYPE.UPDATE);
			};

			self.getCircles = function(){
				var payload = {
					actn: OTYPES.TYPE_GROUP_LIST,
                    ut: -1,
                    gpmut: -1
				};
				return $$connector.send(payload, REQTYPE.REQUEST);
			};

			self.getCircle = function(key){
				return $$connector.request({
					actn : OTYPES.TYPE_GROUP_DETAILS,
					grpId : key
				},REQTYPE.REQUEST);
			};

			self.getCirclesInfo = function(){
				var payload = {
					actn: OTYPES.TYPE_GROUP_LIST,
					ut: -1,
					gpmut: -1
				};
				return $$connector.request(payload, REQTYPE.REQUEST);
			};

			self.addMembers = function(obj){ // payload are not checked
				var payload = {
					actn: OTYPES.TYPE_ADD_GROUP_MEMBER,
					grpId: obj.grpId,
					groupMembers : obj.members
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.removeMember = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_REMOVE_GROUP_MEMBER,
					grpId: obj.grpId,
					groupMembers:[
						{uId: obj.uId}
					]
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.removeMembers = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_REMOVE_GROUP_MEMBER,
					grpId: obj.grpId,
					groupMembers: obj.members
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.addRemoveAdmins = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_EDIT_GROUP_MEMBER,
					grpId: obj.grpId,
					groupMembers : obj.members

				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.addRemoveAdmin = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_EDIT_GROUP_MEMBER,
					grpId: obj.grpId,
					groupMembers : [
						{
							admin: obj.admin,//admin = "true",
							uId: obj.uId//uId = 2000006232
						}
					]

				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.leaveCircle = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_LEAVE_GROUP,
					grpId: obj.grpId
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.deleteCircle = function(obj) {
				var payload = {
					actn: OTYPES.TYPE_DELETE_GROUP,
					grpId: obj.grpId
				};
				return $$connector.request(payload, REQTYPE.UPDATE);
			};

			self.getMemberResult = function (param,cid,stval) {
				var payload = {
					actn: OTYPES.TYPE_GROUP_MEMBERS_SEARCH_RESULT,
					grpId: cid,
					schPm: param,
					st: stval || 0
				};
				return $$connector.send(payload, REQTYPE.REQUEST);
			};



		}

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.circle')
		.factory('circleMap', circleMap);

		circleMap.$inject = ['userFactory', 'friendsFactory', '$$stackedMap','settings','utilsFactory'];
		function circleMap(userFactory, friendsFactory, $$stackedMap,settings,utilsFactory) { // jshint ignore:line
			return {
				create: function(obj){
					var circle = {
						gNm: '',
						grpId: 0,
						ists: 0, /*  circle delete status , 1: deleted, 0: not deleted */
                        sAd: '',
                        ut: 0,
						mc:'',
						mt:'',

                        groupMembers: '',
						memberList: [],
						members: {},
						allMembersMap: $$stackedMap.createNew(), /** Contains Both Members and Admins **/
						adminIds: [],
						memberIds: []
					};
					if ( angular.isObject(obj) ) {
						circle = angular.extend({}, circle, obj);

					}

					function _log(){
					}

					function _removeAdminId(uId){
						var index = circle.memberIds.indexOf(uId);
						if( index !== -1) {
                            circle.memberIds.splice(index, 1);
                        }
					}

					function _removeMemberId(uId){
						var index = circle.adminIds.indexOf(uId);
						if( index !== -1) {
							circle.adminIds.splice(index, 1);
                        }
					}

					function _refreshLength(){
						circle.mc = circle.allMembersMap.length();
					}

					function _update(obj){
						angular.extend(circle, obj);
					}

					var ObjectToReturn = {
						sortBy: function() {
							return circle.gNm.toLowerCase();
						},

						update  : _update,

             			addMember: function(uId, isAdmin) {
							var user = userFactory.create(uId);

                            circle.allMembersMap.save(user.getKey(), user);

							if(!!isAdmin){
								ObjectToReturn.promoteToAdmin(user.getKey());
							}else{
								ObjectToReturn.removeFromAdmin(user.getKey());
							}

							_refreshLength();

                        },
						isAdmin: function() {
							//if (circle.adminIds.indexOf(key) > -1) {
							if ( circle.mt === 1 ) {
								return true;
							} else {
								return false;
							}
						},

						isMember: function() {
							//if (circle.adminIds.indexOf(key) > -1) {
							if ( circle.mt === 0 ) {
								return true;
							} else {
								return false;
							}
						},

                        isSuperAdmin: function(uId) {
                            if (circle.sAd === uId) {
                                return true;
                            } else {
                                return false;
                            }

                        },

						getSuperAdminUId : function(){
							return circle.sAd;
						},

						promoteToAdmin: function(uId) {
							_removeMemberId(uId);

							circle.adminIds.push(uId);

							circle.allMembersMap.get(uId).setGroupAdmin(circle.grpId);

							_log();
						},
						removeFromAdmin: function(key) {
							_removeAdminId(key);

							circle.memberIds.push(key);

							circle.allMembersMap.get(key).removeGroupAdmin(circle.grpId);

							_log();
						},
						getAdmins: function() {
							var adminsMap = circle.allMembersMap.copy();
							for(var i = 0; i < circle.memberIds.length; i++) {
								adminsMap.remove(circle.memberIds[i]);
							}

							return adminsMap;
						},
						getMember : function(uId){
							return circle.allMembersMap.get(uId);
						},
                        getMembers: function() {
							var membersMap = circle.allMembersMap.copy();
							for(var i = 0; i < circle.adminIds.length; i++) {
								membersMap.remove(circle.adminIds[i]);
							}

							return membersMap;
                        },
						setMembers: function(newMembers) {

							angular.forEach(newMembers, function(aNewMember){
								// console.log('ists:'+aNewMember.ists);
								if(!aNewMember.ists){

									var member = userFactory.create(aNewMember);

									circle.allMembersMap.save(member.getKey(), member);

									if (aNewMember.admin) {
										if( circle.adminIds.indexOf(member.getKey()) !== -1){
											circle.adminIds.push(member.getKey());
										}else{
											ObjectToReturn.promoteToAdmin(member.getKey());
										}
									} else {
										if( circle.memberIds.indexOf(member.getKey()) !== -1){
											circle.memberIds.push(member.getKey());
										}else{
											ObjectToReturn.removeFromAdmin(member.getKey());
										}
									}
								}
							});

							//_refreshLength();

							_log();


						},
						resetMembers: function() {
							circle.allMembersMap.reset();
							circle.adminIds = [];
							circle.memberIds = [];
						},
						removeMember: function(memberKey) {
							var removedMember;
							removedMember = circle.allMembersMap.remove(memberKey);
							_removeAdminId(memberKey);
							_removeMemberId(memberKey);

							_refreshLength();

						},
						getAllMembers: function() {
							return circle.allMembersMap;
						},
						getMemberIds : function(){
							return circle.memberIds.slice();
						},
						getAdminIds : function(){
							return circle.adminIds.slice();
						},

						getMembersObjectCount: function() {
							return circle.allMembersMap.length();
						},
						getMembersCount: function() {
							//return circle.allMembersMap.length();
							return circle.mc;
						},
						getMemberType: function(){
							return circle.mt;
						},
						setMemberCount : function(count){
							circle.mc = count;
						},
						getLink: function(subPage) {
							 subPage = (subPage||'');
							return settings.baseUrl + utilsFactory.getRingRoute('CIRCLE_HOME',{circleId:circle.grpId,subpage : subPage});
						},
						getLinkOnly: function(subPage) {
							subPage = (subPage||'');
							return  utilsFactory.getRingRoute('CIRCLE_HOME',{circleId:circle.grpId,subpage : subPage}).slice(1);
						},
						getKey: function() {
							return circle.grpId;
						},
						getName: function() {
							return circle.gNm;
						},
						getAnchor: function(){
							return '<a class="cir-title" href="/#/circle/' + circle.grpId +'" >'+circle.gNm+'</a>';
						}

					};

					return ObjectToReturn;
				}
			};
		}
})();



/*
 * © Ipvision
 */

(function() {
	'use strict';

	angular
		.module('ringid.circle')
		.factory('circlesManager', circlesManager);

	circlesManager.$inject = ['$routeParams', '$location', '$rootScope','$$connector', 'OPERATION_TYPES', 'Storage',
        '$$stackedMap', '$$q', 'circleMap', 'userFactory', 'circleHttpService', 'Notification', 'SystemEvents','Ringalert', 'Auth'];
	function circlesManager($routeParams, $location, $rootScope, $$connector, OPERATION_TYPES, StorageFactory, // jshint ignore:line
                            $$stackedMap, $q, circleMap, UserFactory, circleHttpService, Notification, SystemEvents, Ringalert, Auth) {

        var myCircles = $$stackedMap.createNew(true, 'asc'),
            initialized = false,
            circlesOfMe = $$stackedMap.createNew(true, 'asc'),
            circlesFetchTimeout,
            OTYPES = OPERATION_TYPES.SYSTEM.CIRCLE;
        var maxUserId;
        var stVal;



        function _removeLocalCircle(circleId){
            circlesOfMe.remove(circleId);
            $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_REMOVED, { circleId : circleId});
        }

        function doCreateCircle(circleMapObject, aGroup){

            var circle = circleMapObject.get(aGroup.grpId);
            if( !circle ){
                circle = circleMap.create(aGroup);
            }else{
                circle.update(aGroup);
            }
            circleMapObject.save(circle.getKey(), circle);

            return circle;

        }

        function CreateAndSaveCircle(aGroup){

                var circle;
                if(!aGroup.ists){

                    if (aGroup.sAd == Auth.currentUser().getKey() ) {
                        circle = doCreateCircle(myCircles, aGroup);
                    } else {
                        circle = doCreateCircle(circlesOfMe, aGroup);
                    }
                }
                return circle;
        }

        function _processCircleList(circleList){
            angular.forEach(circleList, CreateAndSaveCircle);
        }

        function redirect(circleId) {
            if ($routeParams.circleId && $routeParams.circleId == circleId) { //jshint ignore:line
                Ringalert.show('Circle Deleted', 'success');
                $location.path('/');
            }
        }

        function redirectHome(){
            Ringalert.show('Circle does not exist!', 'warning');
            $location.path('/');
        }

        function processCircleUpdates (json){
            var circleId,
                circleToUpdate;

            if( json.sucs){
                switch(json.actn){
                    case OTYPES.TYPE_UPDATE_EDIT_GROUP_MEMBER:
                    case OTYPES.TYPE_UPDATE_ADD_GROUP_MEMBER:
                        circleId = json.grpId;
                        circleToUpdate = getCircle(circleId);
                        if(!!circleToUpdate){
                            circleToUpdate.setMembers(json.groupMembers);
                        } else {
                        }
                        break;
                    case OTYPES.TYPE_UPDATE_DELETE_GROUP:
                        circleId = json.grpId;
                        circleToUpdate = getCircle(circleId);
                        if(!!circleToUpdate) {
                            _removeLocalCircle(circleToUpdate.getKey());
                            redirect(json.grpId);
                        } else {
                        }
                        break;
                    case OTYPES.TYPE_UPDATE_REMOVE_GROUP_MEMBER:
                        circleId = json.grpId;
                        circleToUpdate = getCircle(circleId);

                        if(!!json.removedMembers && !!circleToUpdate){
                            angular.forEach(json.removedMembers, function(aMemberUId){
                                circleToUpdate.removeMember(aMemberUId);
                            });
                        } else {
                        }
                        break;
                    case OTYPES.TYPE_UPDATE_ADD_TO_GROUP_BY_FRIEND:
                        json.groupList = [{
                            gNm: json.gNm,
                            grpId: json.grpId,
                            mc: json.mc,
                            sAd: json.sAd
                        }];
                        _processCircleList(json.groupList);
                        processCircleMembersData(json.groupMembers);

                        break;
                }
            }
        }

        function circleUpdateFilter(json){
            return json.actn === OTYPES.TYPE_UPDATE_EDIT_GROUP_MEMBER ||
                   json.actn === OTYPES.TYPE_UPDATE_ADD_GROUP_MEMBER ||
                   json.actn === OTYPES.TYPE_UPDATE_DELETE_GROUP ||
                   json.actn === OTYPES.TYPE_UPDATE_REMOVE_GROUP_MEMBER ||
                   json.actn === OTYPES.TYPE_UPDATE_ADD_TO_GROUP_BY_FRIEND;
        }

            function processCirclesData(json) {
                clearTimeout(circlesFetchTimeout);
                if (json.actn === OTYPES.TYPE_GROUP_LIST && json.sucs === true) {
                    _processCircleList(json.groupList);

                    $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_LIST_PROCESS_COMPLETE);
                }
            }

            function processCircleMembersData(json) {
                if(json.sucs === true) {
                    if(angular.isArray(json.groupMembers) && json.groupMembers.length){
                        for( var j=0; j<json.groupMembers.length; j++ ){
                            maxUserId = json.groupMembers[j].id;
                        }
                        var circle = myCircles.get(json.groupMembers[0].grpId);

                        if (!circle) {
                            circle = circlesOfMe.get(json.groupMembers[0].grpId);
                        }

                        if(!circle){
                           return;
                        }

                        circle.setMembers(json.groupMembers);
                    }
                }
                $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_PROCESS_COMPLETE,{
                    success : true
                });
            }

        function processCircleSearchMembersData(json) {
            stVal = json.tr;
            if(json.sucs === true) {
                if(angular.isArray(json.groupMembers) && json.groupMembers.length){

                    var circle = myCircles.get(json.groupMembers[0].grpId);

                    if (!circle) {
                        circle = circlesOfMe.get(json.groupMembers[0].grpId);
                    }

                    if(!circle){
                        return;
                    }

                    circle.setMembers(json.groupMembers);
                }
            }
            $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_PROCESS_COMPLETE,{
                success : json.sucs
            });
        }

            function getSingleCircleInfo(circleid,circleObj) {
                //var defer = $q.defer();
                circleHttpService.getCircle(circleid).then(function(data){
                    if(data.sucs===true){
                        circleObj.setMemberCount(data.mc);
                        //defer.resolve(data);
                        $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_UPDATE_MEMBER_COUNT);
                    }
                });
                //return defer.promise;
            }

            function getCircle(circleKey) {
                return myCircles.get(circleKey) || circlesOfMe.get(circleKey);
            }

            function getCirclePromise(key){
                var circle = getCircle(key),defer = $q.defer();

                if(circle){
                    setTimeout(function(){
                        defer.resolve(circle);
                    });
                }else{
                    circleHttpService.getCircle(key).then(function(json){
                         if(json.sucs){
                            json.grpId = key;
                            json.ists = 0;
                            circle = CreateAndSaveCircle(json);
                            defer.resolve(circle);
                         }else{
                            defer.reject(false);
                         }
                    },function(reason){

                    });
                }
                return defer.promise;
            }

            function getCircles (circleCreatedByMe) {
                if (circleCreatedByMe) {
                    return myCircles;
                } else {
                    return circlesOfMe;
                }
            }

            function createCircle(circleObj) {
                //circleHttpService.createCircle(circleObj);
                var deferred = $q.defer();
                circleHttpService.createCircle(circleObj).then(function(data) {
                    //var response = angular.fromJson(data);
                    if (data.sucs === true) {
                        circleHttpService.getCircles();
                        Notification.info('Your circle ' + circleObj.tg + ' created successfully.');
                    }
                    deferred.resolve(data);
                });

                return deferred.promise;

            }

            function addMembers(members,circleid) {

                var deferred = $q.defer();
                var circleObj = {
                    //grpId : circle.getKey(),
                    grpId : circleid,
                    members : members
                };

                circleHttpService.addMembers(circleObj).then(function(data) {
                    var circle = getCircle(circleid);
                    deferred.resolve(data);
                });

                return deferred.promise;

            }

            function getCircleMembers(circleid,pvtid,lim){
                if( pvtid === 0 ){
                    maxUserId = pvtid;
                }
                circleHttpService.getCircleMembers(circleid,maxUserId,lim);
            }

            function getMemberResult(param,cid) {
                circleHttpService.getMemberResult(param,cid,stVal);
            }

            function leaveGroup(circle) {
                var deferred = $q.defer();
                circleHttpService.leaveCircle({grpId: circle.getKey()}).then(function(data) {
                    var response = angular.fromJson(data);
                    if (response.sucs === true) {
                        // remove circle
                        myCircles.remove(circle.getKey());
                        circlesOfMe.remove(circle.getKey());
                        deferred.resolve(response);
                    } else {
                        deferred.reject('Failed');
                    }
                });
                return deferred.promise;
            }

            function deleteCircle(circle) {
                var deferred = $q.defer();
                circleHttpService.deleteCircle({grpId:circle.getKey()}).then(function(response) {
                   // var response = angular.fromJson(data);
                    if (response.sucs === true) {
                        // remove circle
                        myCircles.remove(circle.getKey());
                        circlesOfMe.remove(circle.getKey());
                        deferred.resolve(response);
                    } else {
                        deferred.reject('Failed');
                    }
                });
                return deferred.promise;
            }

            //function addMembers(members, circleid) {
            //
            //    var obj = {
            //        //grpId : circle.getKey(),
            //        grpId : circleid,
            //        members : members
            //    };
            //
            //    angular.forEach(members, function(aMember){
            //        circle.addMember(aMember.uId, aMember.admin);
            //    });
            //
            //    circle.setMemberCount(circle.getMembersObjectCount());
            //
            //    circleHttpService.addMembers(obj).then(function(data) {
            //
            //        if (data.sucs !== true) {
            //            angular.forEach(members, function(aMember){
            //                circle.removeMember(aMember.uId);
            //            });
            //            circle.setMemberCount(circle.getMembersObjectCount());
            //
            //        }
            //
            //        $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE);
            //
            //    },function(errData) {
            //    });
            //}

            function removeMember(memberKey, circle) {
                var param = {
                    grpId: circle.getKey(),
                    uId: memberKey
                };

                var removedMember = circle.removeMember(memberKey);

                circleHttpService.removeMember(param).then(function(data) {
                    if (data.sucs !== true) {

                        circle.addMember(removedMember);
                        Ringalert.show(data, 'error');

                    }
                    $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE);

                },function(errData) {
                });
            }

            function removeMembers(membersUIds, circle) {
                var param = {
                    grpId: circle.getKey(),
                    members : []
                };

                angular.forEach(membersUIds, function(aMemberUId){
                    param.members.push({uId : aMemberUId } );
                    circle.removeMember(aMemberUId);
                });

                circle.setMemberCount(circle.getMembersObjectCount());

                circleHttpService.removeMembers(param).then(function(data) {
                    if (data.sucs !== true) {

                        angular.forEach(membersUIds, function(aMemberUId){
                            circle.addMember(aMemberUId);
                        });

                        circle.setMemberCount(circle.getMembersObjectCount());

                        Ringalert.show(data, 'error');

                    }

                    $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE);

                },function(errData) {
                });
            }

            function toggleMembership(obj, circle) {

                circleHttpService.addRemoveAdmin(obj).then(function(data) {

                    if (data.sucs === true) {
                        var groupMember = data.groupMembers[0];

                        if( groupMember.uId === obj.uId && groupMember.admin === true){
                            circle.promoteToAdmin(obj.uId);
                        }else if( groupMember.uId === obj.uId && groupMember.admin === false){
                            circle.removeFromAdmin(obj.uId);
                        }

                        $rootScope.$broadcast(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE);
                    }
                },function(errData) {
                });
            }







        function init(force) {
            if (!initialized) {
                $$connector.subscribe(processCircleUpdates, {
                    action: [
                            OTYPES.TYPE_UPDATE_DELETE_GROUP, //352,// "delete_group";
                            OTYPES.TYPE_UPDATE_REMOVE_GROUP_MEMBER, //354,  //"remove_group_member";
                            OTYPES.TYPE_UPDATE_ADD_GROUP_MEMBER, //356,// "add_group_member";
                            OTYPES.TYPE_UPDATE_EDIT_GROUP_MEMBER //358, //  "edit_group_member";
                    ]
                });

                $$connector.subscribe(processCirclesData, {
                    action: [
                        OTYPES.TYPE_GROUP_LIST
                    ]
                });
            }

            if (!initialized || force) {
                initialized = true;
                circleHttpService.getCircles();
            }
        }


        return {
            init: init,
            processCircleUpdates : processCircleUpdates,
            circleUpdateFilter : circleUpdateFilter,
            processCirclesData: processCirclesData,
            processCircleMembersData: processCircleMembersData,
            processCircleSearchMembersData:processCircleSearchMembersData,

            getCircle: getCircle,
            getCirclePromise: getCirclePromise,
            getCircles : getCircles,
            createCircle: createCircle,
            getCircleMembers: getCircleMembers,
            leaveGroup: leaveGroup,
            deleteCircle:deleteCircle,
            addMembers: addMembers,
            removeMember: removeMember,
            removeMembers: removeMembers,
            toggleMembership: toggleMembership,
            redirectHome:redirectHome,
            getMemberResult:getMemberResult,
            getSingleCircleInfo:getSingleCircleInfo
		};


	}

})();





/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.circle')
		.controller('CirclePopupController', CirclePopupController);

		CirclePopupController.$inject = ['$scope' ,'circlesManager', '$boxInstance', 'friendsFactory', '$$stackedMap', 'localData', 'Ringalert', 'Auth', 'rgScrollbarService','$location'];
		function CirclePopupController($scope,circlesManager, $boxInstance, friendsFactory, $$stackedMap, localData, Ringalert, Auth, rgScrollbarService,$location) { // jshint ignore:line
			//load friends
			$scope.friends = friendsFactory.getFriends('friends');
			$scope.circleAddMode = false;

			$scope.selectedMembers = [];

            $scope.state = {
                loading: false,
                noData: false
            };


			$scope.circleNameSection = true;
			$scope.circleMemberSection = false;
			$scope.circleAdminSection = false;
			$scope.friendDropdown = false;

			$scope.$watch('friendsNameFilter',function(newval,oldval){
				if(newval){
					$scope.friendDropdown = true;
				}else{
					$scope.friendDropdown = false;
				}
			});


			$scope.closeFriendDd = function(){
				$scope.friendDropdown = false;
				$scope.$rgDigest();
			};

			$scope.friendsNameFilter = '';
			$scope.memberfilter = '';

			$scope.nextPart = function (param) {
				switch (param) {
					case 'setmembers':
						$scope.circleNameSection = false;
						$scope.circleMemberSection = true;
						break;
					case 'setadmins':
						$scope.circleMemberSection = false;
						$scope.circleAdminSection = true;
						break;
				}
			};

			$scope.$on('$destroy', function() {
				$scope.friendlist.reset();
				$scope.selectedMembers = [];
			});

			//$scope.friends = friendsFactory.getFriends('friends');
			$scope.friendlist = friendsFactory.getFriends('friends').copy();


			$scope.models = {
				errCircleName: false,
				errMemberList: false,
				errAdminList: false
			};

			if( !localData.circleId ) {
				$scope.circleAddMode = true;
			}

			$scope.editMode = false;

			if (localData && localData.circleId) {

				//get circle data
				$scope.circle = circlesManager.getCircle(localData.circleId);

				$scope.memberList = $scope.circle.getMembers();
				$scope.adminList = $scope.circle.getAdmins();

				$scope.isCurrentUserSuperAdmin = $scope.circle.isSuperAdmin(Auth.currentUser().getKey());

				$scope.models.popupTitle = 'Edit Group';
				$scope.models.circleName = $scope.circle.getName();

				$scope.editMode = true;

			}else{

				$scope.models.popupTitle = 'Create New Circle';
				$scope.models.circleName = '';

				// create new stack
				$scope.memberList = $$stackedMap.createNew();
				$scope.adminList = $$stackedMap.createNew();

			}


			$scope.addToCircle = addToCircle;
			$scope.addToAdmin = addToAdmin;
			$scope.removeMember= removeMember;
			$scope.removeAdmin = removeAdmin;
			$scope.createCircle = createCircle;
			$scope.updateCircle = updateCircle;

			$scope.close = $boxInstance.close;
			$scope.validateCircle = validateCircle;
			$scope.loadMoreFriends = loadMoreFriends;


			function createCircle() {
//				if (!validateCircle()) {
//                    return;
//                }

				var frndIds = $scope.memberList.keys();
				var adminIds = $scope.adminList.keys();

				//$scope.memberList.all()[1].value.user.uId

				var frnds = [];
				for(var i=0; i<$scope.memberList.length();i++){
					frnds[i] = {admin:'false',uId:$scope.memberList.all()[i].value.user.uId};
				}

				var admins = [];
				for(var j=0; j<$scope.adminList.length();j++){
					admins[j] = {admin:'true',uId:$scope.adminList.all()[j].value.user.uId};
				}
				var allUser = admins.concat(frnds);

                var circleObj = {
					tg: $scope.models.circleName,
					alluser:allUser,
					uId:Auth.currentUser().getUId()
                };
				//console.log(circleObj);
               	circlesManager.createCircle(circleObj).then(function (data) {
					if(data.sucs===true){
						$boxInstance.closeAll();
						$location.path('/circle/'+data.grpId);
					}
				});

			}

			function updateCircle() {
				if (!validateCircle()) {
                    return;
                }

				var newMemberIds = $scope.memberList.keys();
				var newAdminIds = $scope.adminList.keys();

				var previousMemberIds = $scope.circle.getMemberIds();
				var previousAdminIds = $scope.circle.getAdminIds();

				var newMembersToAdd = newMemberIds.difference(previousMemberIds);
				var previousMembersToRemove  = previousMemberIds.difference(newMemberIds);

				var newAdminsToAdd = newAdminIds.difference(previousAdminIds);
				var previousAdminsToRemove = previousAdminIds.difference(newAdminIds);

				/* Add New Admin and Member */

				var newMemberAndAdminToAdd = [];
				angular.forEach(newMembersToAdd, function(aNewMemberUId){
					newMemberAndAdminToAdd.push({ admin: false, uId : aNewMemberUId });
				});

				angular.forEach(newAdminsToAdd, function(aNewAdminUId){
					newMemberAndAdminToAdd.push({ admin: true, uId : aNewAdminUId });
				});


				if(newMemberAndAdminToAdd.length > 0){
					circlesManager.addMembers(newMemberAndAdminToAdd, $scope.circle);
				}

				/* Remove Old Admin and Member */

				var memberKeysToRemove = previousMembersToRemove;
				memberKeysToRemove = memberKeysToRemove.concat(previousAdminsToRemove);


				if(memberKeysToRemove.length > 0){
					circlesManager.removeMembers(memberKeysToRemove, $scope.circle);
				}

				Ringalert.show('Circle Updated', 'success');

				$scope.close();
			}

            function needMoreFriends() {
                if ( ($scope.memberList.length() + $scope.adminList.length()) > $scope.friends.length() - 10) {
                    loadMoreFriends();
                }
            }

			function addToCircle(member) {
                //needMoreFriends();
                $scope.memberList.add(member.getUtId(), member);
				$scope.selectedMembers.push(member);
				$scope.friendlist.remove(member.getUtId());
				$scope.friendDropdown = false;
				$scope.friendsNameFilter = '';
				$scope.$rgDigest();
			}

			function removeMember( member) {
				$scope.memberList.remove(member.getUtId());
				$scope.$rgDigest();
			}

			function addToAdmin( admin ) {
                //needMoreFriends();
				$scope.adminList.add(admin.getUtId(), admin);
				$scope.memberList.remove(admin.getUtId());
				$scope.$rgDigest();
			}

			function removeAdmin( admin) {
				$scope.adminList.remove(admin.getUtId());
				$scope.memberList.add(admin.getUtId(), admin);
				$scope.$rgDigest();
			}

			function toggleLoading(bool) {
                $scope.state.loading = bool;
                if (!bool) {
                    rgScrollbarService.recalculate($scope);
                }
                if (!$scope.$$phase && !$scope.$root.$$phase) {
                    $scope.$digest();
                }
            }

            $scope.$watch('friendName', function(newVal) {
                if (newVal && newVal.length >1) {
                    toggleLoading(true);
                    friendsFactory.searchContact({schPm: newVal}, true).then(function() {
                        $scope.friends = friendsFactory.getFriends('friends');
                        $scope.friendlist = friendsFactory.getFriends('friends').copy();
                        toggleLoading(false);
						$scope.$rgDigest();
                    }, function() {
                        toggleLoading(false);
						$scope.$rgDigest();
                    });
                }else{
                	$scope.friendlist = friendsFactory.getFriends('friends').copy();
                	$scope.$rgDigest();
                }
            });

            function loadMoreFriends() {
                // no request in progress
                if (!$scope.state.loading && $scope.friends.length() !== friendsFactory.totalFriends('friends')) {
                    toggleLoading(true);
                    friendsFactory.getContactDetails().then(function() {
						$scope.friends    = friendsFactory.getFriends('friends');
						$scope.friendlist = friendsFactory.getFriends('friends').copy();
                        toggleLoading(false);
                    }, function() {
                        toggleLoading(false);
                    });

                    // in case the promise never resolves or rejects
                    setTimeout(function() {
                        $scope.state.loading = false;
                    }, 3000);
					$scope.$rgDigest();
                }
            }

			function validateCircle() {
                if ($scope.models.circleName.length > 60) {
                    $scope.models.errCircleName = 'Maximum 60 characters';
                } else if ($scope.models.circleName.length === 0) {
                    $scope.models.errCircleName = 'Name required';
                } else {
                    $scope.models.errCircleName = '';
                }
                $scope.models.errMemberList = ($scope.memberList.length() < 1) ? true : false;

				// no need to check adminLIst. Creator of Circle is Admin automatically
                //$scope.models.errAdminList = ($scope.adminList.length() < 1) ? true : false;

				if($scope.models.errCircleName.length === 0 && !$scope.models.errMemberList) {
					return true;
				} else {
					return false;
				}
                return valid;
			}
		}

})();

/*
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.circle')
        .controller('circleEditPopupController', circleEditPopupController);

    circleEditPopupController.$inject = ['$scope' ,'circlesManager', '$boxInstance', 'friendsFactory', '$$stackedMap', 'localData', 'remoteData', 'Ringalert', 'SystemEvents'];
    function circleEditPopupController($scope,circlesManager, $boxInstance, friendsFactory, $$stackedMap, localData, remoteData, Ringalert, SystemEvents) { // jshint ignore:line

        $scope.selectedMembers = [];
        $scope.state = {
            loading: false,
            noData: false
        };

        $scope.circleMemberSection = false;
        $scope.friendDropdown = false;

        $scope.$watch('friendsNameFilter',function(newval,oldval){
            if(newval){
                $scope.friendDropdown = true;
            }else{
                $scope.friendDropdown = false;
            }
        });

        $scope.closeFriendDd = function(){
            $scope.friendDropdown = false;
            $scope.$rgDigest();
        };

        $scope.friendsNameFilter = '';
        $scope.memberfilter = '';

        $scope.$on('$destroy', function() {
            $scope.friendlist.reset();
            $scope.selectedMembers = [];
        });

        $scope.friendlist = friendsFactory.getFriends('friends').copy();

        //$scope.models = {
        //    errCircleName: false,
        //    errMemberList: false,
        //    errAdminList: false
        //};

        $scope.memberList = $$stackedMap.createNew();
        //  $scope.adminList = $$stackedMap.createNew();
        $scope.addToCircle = addToCircle;
        //$scope.addToAdmin = addToAdmin;
        $scope.removeMember= removeMember;
        //$scope.removeAdmin = removeAdmin;
        $scope.updateCircle = updateCircle;

        $scope.close = $boxInstance.close;
        //$scope.validateCircle = validateCircle;

        function updateCircle() {
            var frnds = [];
            for(var i=0; i<$scope.memberList.length();i++){
                frnds[i] = {admin:'false',uId:$scope.memberList.all()[i].value.user.uId};
            }
            circlesManager.addMembers(frnds, localData.target).then(function(data){
                if(data.sucs===true) {
                    circlesManager.getSingleCircleInfo(localData.target,localData.circleObj);
                    //    .then(function (json) {
                    //    $scope.close();
                    //    $scope.$rgDigest();
                    //});
                }else{
                    Ringalert.show(data.mg, 'info');
                    $scope.$rgDigest();
                }
                $scope.close();
            });

        }

        function addToCircle(member) {
            $scope.memberList.add(member.getUtId(), member);
            $scope.selectedMembers.push(member);
            $scope.friendlist.remove(member.getUtId());
            $scope.friendDropdown = false;
            $scope.friendsNameFilter = '';
            $scope.$rgDigest();
        }

        function removeMember( member) {
            $scope.memberList.remove(member.getUtId());
            $scope.$rgDigest();
        }
        //
        //function addToAdmin( admin ) {
        //    //needMoreFriends();
        //    $scope.adminList.add(admin.getUtId(), admin);
        //    $scope.memberList.remove(admin.getUtId());
        //    $scope.$rgDigest();
        //}

        //function removeAdmin( admin) {
        //    $scope.adminList.remove(admin.getUtId());
        //    $scope.memberList.add(admin.getUtId(), admin);
        //    $scope.$rgDigest();
        //}
        //
    }

})();

/*
 * © Ipvision
 */

(function() {
	'use strict';
	angular
		.module('ringid.circle')
		.controller('CirclePageController', CirclePageController);

		CirclePageController.$inject = ['$scope', '$routeParams', '$location', 'circlesManager', 'friendsFactory', 'Auth', '$ringbox',
			'SystemEvents',  '$$connector','OPERATION_TYPES','circleHttpService', '$timeout', 'APP_CONSTANTS', 'Ringalert', 'rgDropdownService', '$rootScope'];
		function CirclePageController($scope, $routeParams, $location, circlesManager, friendsFactory, Auth,  $ringbox, // jshint ignore:line
                                      SystemEvents, $$connector,OPERATION_TYPES,circleHttpService, $timeout, APP_CONSTANTS, Ringalert, rgDropdownService, $rootScope) {
			var vm = this;

			var circleId = $routeParams.circleId;
			var subpage = $routeParams.subpage;
			$scope.loadMoreCircleMember = false;
			$scope.showSearchLoader = false;
			$scope.hideLoadButton = false;
			$scope.currentUserUId = Auth.currentUser().getUId();
			circlesManager.getCirclePromise(circleId).then(function(circle){
				if(circle){
					vm.circle = circle;
					$scope.isCurrentUserAdmin = vm.circle.isAdmin();
					$scope.isCurrentUserSuperAdmin = vm.circle.isSuperAdmin($scope.currentUserUId);
					//requestForCircleMembers();
					if(subpage==='members'){
                        $scope.showBackKey = 0;
                        $scope.showBack = function(key, event) {
                            var isAnchor = event.target.getAttribute('data-is-anchor');
                            if (!isAnchor) {
                                $scope.showBackKey = key;
                                event.preventDefault();
                                event.stopPropagation();
                                $scope.$rgDigest();
                            }
                        };
						requestForCircleMembers();
					}
					pageInit();
				}else{
					circlesManager.redirectHome();
				}

			},function (reason){
				   circlesManager.redirectHome();
			});


            $scope.showComingSoon = function($event) {
                $event.preventDefault();
                $event.stopPropagation();
                Ringalert.show('Coming soon', 'info');
            };

			/* Fixed Data to Init */
			vm.ddHtml = 'pages/dropdowns/circle-edit-dropdown.html';//$templateCache.get('circle-edit-dropdown.html');
			vm.ddAction = openConfirmation;
			vm.ddControl = {
				isAdmin : $scope.isCurrentUserAdmin,
				isSuperAdmin : $scope.isCurrentUserSuperAdmin,
				getCircleData : function(){
                    rgDropdownService.close();
					return { circleId : circleId };
				}
			};


			vm.ddMemberHtml = 'pages/dropdowns/circle-member-dropdown.html';//$templateCache.get('circle-member-dropdown.html');
			vm.ddMemberAction = circleMemberAction;

			vm.removeMember = removeMember;

			if (angular.isUndefined($routeParams.subpage)) {
				vm.subPage = 'post';
			} else {
				vm.subPage = $routeParams.subpage;
			}

			vm.subPageLink = 'pages/home/circle.' + vm.subPage + '.html';

			/* Dynamic Data */

          //  vm.circle = circlesManager.getCircle(circleId);

			vm.isCurrentUserAdmin = false;
			vm.isCurrentUserSuperAdmin = false;

			vm.getFriendType = function(memberObj){
				return memberObj.friendshipStatus();
			};

			if(!!vm.circle){
				$scope.isPageReady = false;
				if(!$scope.circleMembers.length){
					requestForCircleMembers();
				}

			}else{
				$scope.isPageReady = false;

			}

			vm.shouldShowMemberEditMenu = function(memberObj){

				//console.log( vm.isCurrentUserAdmin ,  vm.isCurrentUserSuperAdmin, !vm.circle.isSuperAdmin(memberObj.getKey()) )

				return  !memberObj.isCurrentUser() &&
					    (( vm.isCurrentUserSuperAdmin ||  (vm.isCurrentUserAdmin && !memberObj.isAdmin(circleId))) ) &&
					    ( !vm.circle.isSuperAdmin(memberObj.getKey()) );

			};

			//vm.getMemberEditMenuControl = function (memberObj) {
			//	return {
			//		isAdmin: memberObj.isAdmin(vm.circle.getKey()),
			//		isSuperAdmin: vm.isCurrentUserSuperAdmin,
			//		member: memberObj,
			//		friendShipType: vm.getFriendshipType(memberObj)
			//	}
			//};

			vm.memberListSubscriptionKey = $$connector.subscribe(circlesManager.processCircleMembersData,
				{action:OPERATION_TYPES.SYSTEM.CIRCLE.TYPE_GROUP_MEMBERS_LIST}
			);
			vm.searchListSubscriptionKey = $$connector.subscribe(circlesManager.processCircleSearchMembersData,
				{action:OPERATION_TYPES.SYSTEM.CIRCLE.TYPE_GROUP_MEMBERS_SEARCH_RESULT}
			);

			$scope.$on(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_PROCESS_COMPLETE, function(event,data){
				// $scope.$rgDigest();
				$scope.loadMoreCircleMember = false;
				$scope.showSearchLoader = false;
				if(!data.success){
					$scope.hideLoadButton = true;
				}else{
					$scope.hideLoadButton = false;
				}
				// $scope.$rgDigest();
				pageInit();
                $scope.$rgDigest();
			});

			$scope.$on(SystemEvents.CIRCLE.MY_CIRCLE_UPDATE_MEMBER_COUNT, function (event,data) {
				$scope.$rgDigest();
			});

   //     $scope.$on(SystemEvents.CIRCLE.MY_CIRCLE_LIST_PROCESS_COMPLETE, function(){
			// 			if(!vm.circle){
			// 				vm.circle = circlesManager.getCircle(circleId);
			// 				if(vm.circle){
			// 					requestForCircleMembers();
			// 				}

			// 			}

   //       });

      		$scope.$on(SystemEvents.CIRCLE.MY_CIRCLE_MEMBER_LIST_UPDATE_COMPLETE, function(){
				setMembers();
		  		$scope.$rgDigest();
			});


			$scope.$on(SystemEvents.CIRCLE.MY_CIRCLE_REMOVED, function($event, data){
				if(data.circleId === $routeParams.circleId){

					Ringalert.show('Circle has been Removed OR You have been removed from the circle.', 'info');

					$timeout(function(){
						$location.path('/');
					});
				}
			});


			$scope.cMemberSearch = function () {
				if( vm.searchParam ) {
					$scope.showSearchLoader = true;
					//$scope.hideLoadButton = true;
					circlesManager.getMemberResult(vm.searchParam,circleId);
				}else{
					$scope.hideLoadButton = false;
				}
				$scope.$rgDigest();
			};


			$scope.loadMoreMembers = function () {
				if( vm.searchParam ){
					$scope.showSearchLoader = true;
					circlesManager.getMemberResult(vm.searchParam,circleId);
					//console.log('load more search');
				}else{
					var lim = 20;
					$scope.loadMoreCircleMember = true;
					circlesManager.getCircleMembers(circleId,null,lim);
					//console.log('load more member');
				}
				$scope.$rgDigest();

			};

			$scope.getCircleId = function() {
				return{
					data: function() {
						return {
							target: circleId,
							circleObj: vm.circle
						};
					}
				};
			};


			$scope.$on('$destroy', function() {
				if (vm.circle) {
					vm.circle.resetMembers(); //.reset();
				}
				$$connector.unsubscribe(vm.memberListSubscriptionKey);
				$$connector.unsubscribe(vm.searchListSubscriptionKey);
			});



			function pageInit(){
				if( vm.circle ){
					$scope.isPageReady = true;
					setMembers();
					//if($scope.circleMembers.length > 0){
						//setPageSettings();
					//}
					setPageSettings();
				}
				$scope.$rgDigest();
			}

			function setPageSettings(){

				vm.isCurrentUserAdmin = $scope.currentUser.isAdmin(vm.circle.getKey());

				vm.isCurrentUserSuperAdmin = vm.circle.isSuperAdmin(Auth.currentUser().getKey());

				/** For Circle Edit DropDown **/
				vm.ddControl.isAdmin = vm.isCurrentUserAdmin;
				vm.ddControl.isSuperAdmin = vm.isCurrentUserSuperAdmin;

			}

			function setMembers(){
				$scope.circleMembers = vm.circle.getAllMembers();
                $scope.$rgDigest();
			}

			function requestForCircleMembers(){
				circlesManager.getCircleMembers(circleId,0);
			}


			function removeMember(memberKey) {
				circlesManager.removeMember(memberKey, vm.circle);
			}

			function circleMemberAction(actionObj) {
                rgDropdownService.close(actionObj.event);
				switch(actionObj.action) {
					case 'remove':
						circlesManager.removeMember(actionObj.member.getKey(), vm.circle);
						break;

					case 'changemember':

						circlesManager.toggleMembership(
                            {
                                grpId: vm.circle.getKey(), uId: actionObj.member.getKey(), admin: Boolean(actionObj.admin)
                            },
                            vm.circle
                        );

						break;

					case 'addfriend' :
                    case 'accept':
                    case 'reject':
                        if (!actionObj.friend.isLoading()) {
                            friendsFactory.friendAction(actionObj, true).then(function() {
                                $scope.$rgDigest();
                            }, function() {
                                $scope.$rgDigest();
                            });
                        }
						break;
					default:
				}
                $scope.$rgDigest();

			}


            function openConfirmation(actionObj) {
                var message = 'Are you sure you want to ' + actionObj.action + ' ' + vm.circle.getName() +'?';

                rgDropdownService.close(actionObj.event);
                var boxInstance = $ringbox.open({
                        type : 'remote',
                        scope:false,
                        controller: 'RingBoxConfirmController',
                        resolve : {
                            localData : {
                                message : message
                            }
                        },
                        templateUrl : 'pages/partials/ringbox-confirm.html'
                });

                boxInstance.result.then(function(confirmed){
                    if(confirmed){
                        circleAction(actionObj);
                    }
                });
            }

			function circleAction (actionObj) {
				switch(actionObj.action) {
					case 'delete':
						circlesManager.deleteCircle(vm.circle).then(function(response) {
							if (response.sucs === true) {
								$location.path('/');
                                //$rootScope.$rgDigest();
                            } else {
                                $scope.$rgDigest();
                            }
						}, function(errData) {
                            $scope.$rgDigest();
						});
						break;
					case 'leave':
						circlesManager.leaveGroup(vm.circle).then(function(response) {
							if (response.sucs === true) {
								$location.path('/');
								$rootScope.$rgDigest();
							}
                            $scope.$rgDigest();
						},function(errData) {
                            $scope.$rgDigest();
						});
						break;
					default:
				}

			}



		}

})();


/*
 * © Ipvision
 */

(function() {
    'use strict';
    angular
        .module('ringid.circle')
        .controller('allCirclePopupController', allCirclePopupController);

    allCirclePopupController.$inject = ['$scope', 'OPERATION_TYPES', '$$connector', 'circlesManager', 'rgScrollbarService'];
    function allCirclePopupController($scope, OPERATION_TYPES,  $$connector, circlesManager, rgScrollbarService) { // jshint ignore:line

        var timeOut;
        $scope.getCircles = getCircles;

        function getCircles(own) {
            if (own === 'true' || own === true) {
                return circlesManager.getCircles(true);
            } else {
                return circlesManager.getCircles(false);
            }
        }

        //$scope.circleList = remoteData.target;
        //console.log($scope.circleList.length);

        // in case user clicks on circle list popup immediately after login. actuall fetch requests is send after 3 sec of successful login
        $$connector.subscribe(function() {
            if (!timeOut) {
                timeOut = setTimeout(function() {
                    clearTimeout(timeOut);
                    rgScrollbarService.recalculate($scope);
                    $scope.$rgDigest();
                });
            }
        }, {
            action: [
                OPERATION_TYPES.SYSTEM.CIRCLE.TYPE_GROUP_LIST
            ]
        });
    }

})();

/* 
 * © Ipvision 
 */

(function () {
    'use strict';
    angular.module('ringid.album', ['ngRoute']);
})();


/* 
 * Ipvision
 */

(function () {
    'use strict';

    angular.module('ringid.album')
            .factory('imageUploadService', imageUploadService)
            .factory('ringFileUploaderService', ringFileUploaderFactory);

    imageUploadService.$inject = ['$http', 'settings', 'OPERATION_TYPES'];
    function imageUploadService($http, settings, OPERATION_TYPES) {
        var OTYPES = OPERATION_TYPES.ALBUM;
        //var deferred = $q.defer();
        return{
            getImageUploadInfo: function () {
//                albumHttpService.getImageUploadInfo().success(function (data) {
//                    var dData = angular.fromJson(data);
//                    return deferred.resolve(dData);
//                    //console.log(data);
//                }).error(function (errData) {
//                    return deferred.reject(errData);
//                });
                return $http.post(settings.baseUrl + '/secure/APIAlbum',
                        {
                            operation: OTYPES.GET_IMAGE_UPLOAD_INFO
                        }
                );
            },
            createAlbum: function (data) {
                return $http.post(settings.baseUrl + '/secure/APIAlbum',
                        {
                            operation: OTYPES.CREATE_ALBUM,
                            albumName: data.albumName,
                            imgIdList: data.imgIdList,
                            sts: data.sts,
                            captionList: data.captionList
                        }
                );
            }
        };
    }

    ringFileUploaderFactory.$inject = ['$rootScope', '$q'];
    function ringFileUploaderFactory($rootScope, $q) {
        var svc = {
            post: function (files, data, progressCb) {
                return {
                    to: function (uploadUrl, index)
                    {
                        var deferred = $q.defer();
//                        if (!files) {
//                            deferred.reject("No files to upload");
//                            return;
//                        }
//                        console.log('files.name --> ' + files.name);

                        var xhr = new XMLHttpRequest();

                        var formData = new FormData();
                        if (files) {
                            formData.append("file", files, files.name);
                        }

                        if (data) {
                            Object.keys(data).forEach(function (key) {
                                formData.append(key, data[key]);
                            });
                        }

//------------------------------- If Array of files is sent as parameter (start) -------------------------------
//                        for (var idx = 0; idx < files.length; idx++) {
//                            formData.append(files[idx].name, files[idx]);
//                        }
//------------------------------- If Array of files is sent as parameter (end) -------------------------------

                        xhr.open("POST", uploadUrl);
                        xhr.upload.onprogress = progress;
                        xhr.onload = load;
                        xhr.upload.onerror = error;
                        xhr.send(formData);

                        function progress(e) {
//                            $rootScope.$apply(function () {
                            var percentCompleted;
                            if (e.lengthComputable) {
                                percentCompleted = Math.round(e.loaded / e.total * 100);
                                if (progressCb) {
                                    progressCb(percentCompleted);
                                } else if (deferred.notify) {
                                    deferred.notify(e);
                                }
                            }
//                            });
                        }

                        function load(e) {
                            $rootScope.$apply(function () {
                                var dt;
//                                if(typeof xhr.responseText !== 'object'){
//                                    dt = {"msg":"Errorrrrr"};
//                                    console.log('dt.msg --> ' + dt.msg)
//                                }
                                    
//                                console.log('xhr.responseText --> ' + xhr.responseText);
                                var ret = {
                                    files: files,
                                    data: angular.fromJson(xhr.responseText)
                                };
                                deferred.resolve(ret);
                            });
                        }

                        function error(e) {
                            console.log('error ----');
                            var msg = xhr.responseText ? xhr.responseText : "An unknown error occurred posting to '" + uploadUrl + "'";
                            $rootScope.$apply(function () {
                                deferred.reject(msg);
                            });
                        }

                        return deferred.promise;
                    }
                };
            },
            postExistingImage: function (files, data, progressCb) {
                return{
                    to: function (uploadUrl, index) {

                    }
                };
            }
        };
        return svc;
    }

})();


(function() {
    'use strict';
    var feedApp;
      feedApp = angular
            .module('ringid.feed', [
              'ngWebSocket','ringid.utils','ringid.config','ringid.connector','rg.custom.compiler.directive'
            ]);
            
            
})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
                .module('ringid.feed', [
                    'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config', 'ringid.media'
                ]);
    }


    feedApp.factory("$$feedMap",$$feedMap);

    $$feedMap.$inject =  ['Auth', 'settings','$$stackedMap', '$$imageMap', 'Media', '$$mediaAlbumMap', '$$mediaMap',
        'userFactory', 'utilsFactory', 'circlesManager', '$sce','EmotionFactory','MESSAGES','OPERATION_TYPES','PrivacySet'];

    function $$feedMap(Auth, settings,$$stackMap, $$imageMap, Media, $$mediaAlbumMap, $$mediaMap,
        User, utilsFactory, circlesManager, $sce,EmotionFactory,MESSAGES,OPERATION_TYPES,PrivacySet){
            var keyPrefix = "nf_",
                sortBy = 'tm',
                messages = MESSAGES.FEED,
                OTYPES = OPERATION_TYPES.SYSTEM,
                userCardString = '<user-card user="feed.user()"></user-card>',
                feed_defaults = {
                        //key: key,
                        nfId: 0, /* News Feed Id */
                        utId : 0,
                        isNew: 0, // when is new one the its needed to add on the first cell top by default it will be on top for tm sorting
                        lctn: '',
                        lat : 9999, //default 9999
                        lng : 9999, //default 9999
                        gNm: "",
                        grpId:  0,
                        sts:  "", // emoticon replace needed here
                        stsTags:  [], // emoticon replace needed here
                        tim:  0,
                        imT:  0,
                       // medias:[],
                       // audios : [],
                        //album: {},
                        fndId: 0,
                        whoShare: {},
                        mdaCntntLst : [],
                        type:  0,
                        mdLst : [],//feeling
                        tm: Date.now(), // tm need to keep raw for sorting
                        //time : $filter('date')(new Date(_d.tm),DATE_FORMAT),
                        at: Date.now(),
                        ic: 0, //current user comment 0/1
                        il: 0, //current user like 0/1
                        is: 0, //current user share
                        nc: 0, //number of comment
                        nl: 0, //number if like
                        ns: 0, //number of share
                        sc: 0, // feed text more than 1000 word/char
                        tfc : 0, //total tag friend count
                        stp : 0, //feed sub type SINGLE_AUDIO_FEED_SHARED = 1; SINGLE_VIDEO_FEED_SHARED = 2; required building feed message
                        fc : 0,//feed category GENERAL_FEED = 0;SPECIAL_FEED = 1;
                       // orginal: {}, // orginal feed if its a shared feed
                       // message : '' ,//tile message assigned in bottom
                       // subMessage : '',//submessage shows last activty message assgined in bottom
                        actvt :  0, //
                        afn :  "", //activity first name
                        auId :  0,//activity utId
                        //pending : _d.pending || false,
                        lnkDmn: '',
                        lnkDsc: '',
                        lnkTtl: '',
                        lnkURL: '',
                        lnlImgURL: '',
                        /** Client Side Property  */
                        //viewColumn : _d.viewColumn || '',
                        fTgLst : []
                    }; //initalize feed basic object on response

        function RingFeed(feed,user){
             var that = this;
            //tagUsers

            that.key = keyPrefix + feed.nfId;
            that.updateRaw(feed);
            that.setFeedUser(user);


            that.feelings = {};
            that.tagUsers = [];
            that.shareUsers = [];
            that.circle = {};
            that.orginal = {};
            that.feedHtml = "";
            that.images = $$stackMap.createNew(true,'asc');//creating empty omage stacked map
            that.medias = $$stackMap.createNew();//creating empty video stacked map
            that.audios = $$stackMap.createNew();
            that.setImages();
            that.initMedias();
             if (!!that._f.fndId) {
                that.friend = User.create({
                    uId: that._f.fndId,
                    fn: that._f.ffn,
                    ln: that._f.fln
                });
            }else{
                that.friend = false;
            }
            that.initOgData();
            that.initLocationData();
            that.update(null,false,true);
            if(that.isSingleContentFeed()){
                var content = that.getSingleContent();
                if(!that.images.length()){
                    that._f.is = content.share();
                    that._f.ns = content.getTotalShare();
                }
                that._f.ic = content.selfComment();
                that._f.nc = content.getTotalComment()
            }

            Object.defineProperty(that, 'ddControl', {
                                  enumerable: false,
                                  configurable: false,
                                  writable: false,
                                  value: {
                                        feedKey: that._f.nfId,
                                        showEdit: function () {
                                            return (that._u.isCurrentUser() && that._f.nl < 1) ? true : false;
                                        },
                                        feedUser: function () {
                                            return that._u;
                                        },
                                        tagButtonText : function(){
                                            return that.tagUsers.length ? 'Edit Tag' : 'Add Tag';
                                        },
                                        showDelete : function(){
                                           return that._u.isCurrentUser() || that.friend && that.friend.isCurrentUser();
                                        },
                                        showTagButton : function(){
                                            return that._u.isCurrentUser() && !that._f.grpId;
                                        },
                                        showReportButton : function(){
                                            return !that._u.isCurrentUser();
                                        },
                                        getSpamId : function(){
                                            return that.isSingleContentFeed()?that.getSingleContent().getKey():that.getKey();
                                        },
                                        getSpamType : function(){
                                            return (that.images.length() && "image") || (that.medias.length() && "media") || (that.audios.length() && "media") || "feed";
                                        }
                                    }
                                });
        }


        RingFeed.prototype = {
                 /** todo : need improvement
                 * @description : updates this feed raw data
                 * @param json : target json object
                 * @param doNotupdateTm : when set true it will not update tm .. useful when we need to update but don't want to change the order in feed
                     */
                updateRaw : function(json,doNotupdateTm){
                    var previousTime;
                        if(this._f){
                            previousTime = (doNotupdateTm || !json.tm) ? this._f.tm : json.tm;
                            angular.extend(this._f,json);
                            this._f.tm = previousTime;
                        }else{
                            this._f = angular.extend({},feed_defaults,json);
                        }

                        if(this._f.lat === 9999){
                            this._f.lctn = "";
                        }
                        json = null;
                },
                update : function(json, doNotupdateTm,doNotUpdateRaw){
                    var that = this;
                    if(!doNotUpdateRaw){
                        that.updateRaw(json,doNotupdateTm);
                    }

                    //Init Feed Feelings

                    if(that._f.mdLst && that._f.mdLst.length){
                        that.feelings = EmotionFactory.getEmotion(that._f.mdLst[0],true);
                    }
                    that.setTagUsers();

                    /**
                     * @note : if order changes of comments stackmap,then in feed factory there is firstComment and lastCommnet Api to be changed
                     */
                    if (that._f.at) {
                        that.vtime = utilsFactory.verbalDate(that._f.at);
                    } else {
                        that.vtime = "";// preventing from throwing error
                    }

                    //set feed top message
                    that.setFeedTopMessage();

                    that.processFeedMessage();

                    that.addPostfixMessage();

                    // linkify or emotify
                    that.parseStatus();//initial parsing
                    json = null;
                },
                getKey: function () {
                    return this._f.nfId;
                },
                sortBy: function () {
                    return this._f[sortBy] || this._f['tm'];
                },
                getMapKey: function () {
                    return this.key;
                },
                setFeedKey: function (key) {
                    this._f.nfId = key;
                },
                getFeedKey: function (key) { // used by rg like. cause all media image have feed key so for keeping same api name this has been added
                    return this._f.nfId;
                },
                getPrivacy : function(){
                    return PrivacySet['PVC'+(this._f.fpvc || 3)];
                },
                getByProperty: function (property_name, return_default) {
                    return_default = return_default || false;
                    return this._f.hasOwnProperty(property_name) ? this._f[property_name] : return_default;
                },

                checkMessageUpdated : function(){
                    return this.message + this._f.lctn + this.tagUsers.reduce(function(prev,curr){
                        return prev.toString() + curr.toString();
                    },"") + this._f.tfc;
                },

                getTargetWall : function(){
                    return this.friend;
                },
                getTargetCircle : function(){
                    return angular.equals({},this.circle) ? this._f.gNm:this.circle;
                },
                setFeedUser : function (user){
                    var that = this;
                    if (angular.isDefined(user)) {
                        that._u = user;
                    } else {
                        if(that._f.utId){
                            that._u = User.getByUtId(that._f.utId);
                        }else if(that._f.uId){
                            that._u =  User.getUser(that._f.uId);
                        }else{
                            that._u = false;
                        }
                        if(!that._u){
                            var uOb = {};
                                if(that._f.uId){
                                    uOb.uId = that._f.uId;
                                }
                                if(that._f.utId){
                                    uOb.utId = that._f.utId;
                                }
                                if(that._f.fn){
                                    uOb.fn = that._f.fn;
                                }
                                if(that._f.prIm){
                                    uOb.prIm = that._f.prIm;
                                }
                            that._u = User.create(uOb);
                        }
                    }//updating feed user

                },
                user: function () {
                    return this._u;
                },
                processFeedMessage : function (){

                    var circleGroupPrefix = '',linkPrefix="",subtype,replacer = [userCardString],that = this;

                    if(!!that.friend){
                        circleGroupPrefix='F';
                    }else if(that._f.grpId){
                        that.circle = circlesManager.getCircle(that._f.grpId);
                        circleGroupPrefix = 'C';
                    }

                    switch(that._f.type){
                        case OTYPES.NEWS_FEED_TYPE_IMAGE://1
                            if(that.images.length() > 0){
                                that.message = messages['TYPE_1' + that.images.top().getImageType() + circleGroupPrefix] || messages['TYPE_D'];
                                that.message = that.feedConditionalReplacer(that.message,[that._u.isCurrentUser()]);
                            }else{
                               that.message = messages['TYPE_D']; //default
                            }
                            break;
                        case OTYPES.NEWS_FEED_TYPE_STATUS://2
                            if(that.hasOgData()){
                                linkPrefix = "L"
                            }
                            that.message = messages['TYPE_2'+circleGroupPrefix+linkPrefix];
                            break;

                        case OTYPES.NEWS_FEED_TYPE_MULTIPLE_IMAGE://3
                            that.message = messages['TYPE_'+that._f.type];
                            that.message = that.feedConditionalReplacer(that.message,[that._u.isCurrentUser()]);
                            replacer.push(that._f.tim);
                            break;
                        case OTYPES.NEWS_FEED_TYPE_ALBUM://4
                        case OTYPES.NEWS_FEED_TYPE_AUDIO://5
                        case OTYPES.NEWS_FEED_TYPE_VIDEO://6
                            subtype = that._f.stp || 0;
                            that.message = messages['TYPE_'+that._f.type+subtype];

                            if(!subtype && (that.medias.length() || that.audios.length())){
                                //if((that.medias.length() || that.audios.length()) > 1){
                                    replacer.push(that.medias.length() || that.audios.length());
                                // }else{
                                //     replacer.push('a');
                                // }

                            }else{
                                replacer.push('<user-card class="share-user" user="feed.getSingleContent().user()"></user-card>');
                            }

                           // replacer.push('<user-card class="share-user" user="feed.getSingleContent().user()"></user-card>')
                            break;
                        default:

                            that.message = messages['TYPE_D'];
                            break;
                    }

                    if(!!that.friend){
                        that.message += " " + messages['F_POSTFIX'].format('<user-card class="wall-user" user="feed.getTargetWall()"></user-card>');
                    }else if(that._f.grpId){
                        that.message += " " + messages['C_POSTFIX'].format('<a class="cir-title" href="/#/circle/' + that._f.grpId +'" >'+that._f.gNm+'</a>');
                    }
                    that.rawmessage = that.message;
                    that.message = that.message.format(replacer);
                    that.oldMessage = that.message;
                },
                updateShareMessage : function(){
                    var temstr = userCardString;
                    if(this.orginal.getTotalShare() > 1){
                        temstr += "and "+(this.orginal.getTotalShare() - 1)+" other people";
                    }
                    var repl = [userCardString];
                    this.message = messages['TYPE_SHARE'];
                    repl.push('<user-card class="share-user" user="feed.getOrginalFeed().user()"></user-card>');
                    this.message = this.message.format(repl);
                    this.oldMessage = this.message;
                    this.addPostfixMessage();
                },
                addPostfixMessage : function(){
                    var that = this;
                    that.message = that.oldMessage;

                    if(that._f.mdLst.length || that.tagUsers.length ||  that.location){
                        if(that.rawmessage !== '{0}'){
                            that.message += " &mdash;";
                        }else{
                            that.message += " is";
                        }

                    }

                    if(!!that._f.mdLst.length){
                        that.message += '&nbsp;<span class="feelings-text">feeling</span> <img class="feed_emo" src="'+that.feelings.url+'" />&nbsp;'+that.feelings.nm;
                    }

                    if(!!that.tagUsers.length){
                        that.message += '&nbsp;<feed-tag-more-user tag-feed="feed"></feed-tag-more-user>';
                    }

                    if(this._f.lctn){
                        that.message += '&nbsp;<location-card feed="feed"></location-card>';
                    }
                },

                getMessageText: function () {
                    return this.message;
                },
                hasActivityMessage : function(){
                    //console.info(feed.subMessage,!!feed.subMessage,"feedMessage");
                  return this._f.actvt > 0;
                },
                setActivity : function(json){
                    this._f.actvt = json.actvt || 0;
                    this._f.afn = json.afn;
                    this._f.auId = json.auId;
                    this.setFeedTopMessage();
                },
                setFeedTopMessage: function(){
                    var that = this;
                    if(that._f.actvt > 0){
                        // todo : when this is a share feed check if afn comes in orginal or whoshare
                        that.subMessage = "";

                        if(that._f.actvt && !!MESSAGES.FEED['ACT_'+that._f.actvt]){
                            var activity_user = User.getByUtId(that._f.auId), acmessage = '<b>You</b>';

                            if(activity_user){
                                if(!activity_user.isCurrentUser()){
                                    acmessage = '<user-card user="feed.getActivityUser()"></user-card>';
                                }
                            }else{

                                if(Auth.currentUser().getUtId() !== that._f.auId){
                                    activity_user = User.createByUtId({fn:that._f.afn,utId:that._f.auId},true);

                                    acmessage = '<user-card user="feed.getActivityUser()"></user-card>';
                                }
                            }

                            that._au = activity_user;

                            that.subMessage = MESSAGES.FEED['ACT_'+that._f.actvt].format(acmessage);
                        }

                        that.subMessage =  $sce.trustAsHtml ( that.subMessage );

                    }
                },
                getActivityMessage : function(i, k, fe){
                   // console.log("scope Id : "+ i +"  parent index : " + k ,"  feed : "+fe.getKey());
                   // console.dir(fe);
                  return this.subMessage;
                },
                getActivityUser : function(){
                    return this._au;
                },

                parseStatus : function () {
                         var usr,text_spilit = [],that = this;
                    if (that._f.sts || that._f.stsTags) {
                        if(that._f.stsTags && that._f.stsTags.length){
                            var start=0,end;
                            that._f.stsTags.sort(function(a,b){
                                return b.pstn > a.pstn ? -1:1;
                            });
                            for(var i=0;i<that._f.stsTags.length;i++){
                                // for security make this glue dynamic
                                //end = this._f.stsTags[i].pstn - start+1;
                                end = that._f.stsTags[i].pstn - start;
                                usr = User.create(that._f.stsTags[i]);
                                if(end > 0){
                                    text_spilit.push(utilsFactory.parseForLE(that._f.sts.substr(start,end)));
                                }
                                text_spilit.push(usr.getLink({'class' : 'tag', 'title': usr.getName().trim(), 'data-link':usr.getUtId()}));
                                start = that._f.stsTags[i].pstn;
                            }
                             end = that._f.sts.length - start;
                             if(end > 0){
                                text_spilit.push(utilsFactory.parseForLE(that._f.sts.substr(start,end)));
                             }
                             that.feedHtml = text_spilit.join("");
                        }else{
                            that.feedHtml = utilsFactory.parseForLE(that._f.sts);
                        }
                        that.feedHtml = $sce.trustAsHtml(that.feedHtml);
                    }else{
                        that.feedHtml = "";
                    }
                },
                parseMoreText: function (feedObj) {
                    //feed = angular.extend(this._f, feedObj);
                    this._f.sts = feedObj.sts;
                    this.parseStatus();
                },
                showMore : function(){
                    return !!this._f.sc;
                },
                setText: function (sts,stsTags) {
                    this._f.sts = sts;
                    if(stsTags){
                        this._f.stsTags = stsTags;
                    }
                    this.parseStatus();
                },
                text: function () {
                    return this._f.sts;
                },
                getDynamicText: function () {
                    return this.feedHtml;
                },
                getDynamicTextMore: function (words, uid) {
                    words = parseInt(words)>0 ? parseInt(words): 20;
                    var ptrn = '(', text,
                        fhtml = utilsFactory.parseForLE(this._f.sts);
                    for (var i = words; i > 0; i--) {
                      ptrn += '[\\S]+\\s';
                    }
                    ptrn +=')(.*)';
                    text = fhtml.replace(new RegExp(ptrn),'<span class="with-more"><input id="read'+uid+'" type="checkbox" /><span class="less">$1</span><span class="more">$2</span><label for="read'+uid+'" class="trigger"></label></span>');
                    return $sce.trustAsHtml(text);
                },

                getAtTime: function(){
                    return this._f.at;
                },
                time: function () {
                    return this.vtime;
                },
                updateTime: function () {
                    this.vtime = utilsFactory.verbalDate(this._f.at);
                },
                setTime: function (tm) {
                    this._f.tm = tm;
                    //updateTime();
                },
                getTimestamp: function(){
                    return this._f.tm;
                },
                incomingLike: function (type) {
                    return (type && ++this._f.nl) || --this._f.nl;
                },
                like: function (dolike,totalLike) {
                    if (!dolike) {
                        return this._f.il;
                    }
                    this._f.il = this._f.il ^ 1;
                    if(totalLike){
                       this._f.nl = totalLike;
                    }else{
                       this._f.nl = this._f.il ? this._f.nl+1 : this._f.nl-1;
                    }
                    if(this.identical){
                        this.identical.like(dolike);
                    }
                    return this._f.il;
                },
                setTotalLikes: function (nl,il){
                    this._f.nl = nl;
                    if(angular.isDefined(il)){
                        this._f.il = il;
                    }
                    if(this.identical){
                        this.identical.setTotalLikes(nl,il);
                    }
                },
                setIdenticalFeed : function(f){
                    this.identical = f; //
                },
                getTotalLikes: function () {
                    return this._f.nl;
                },
                setTotalComment :function(loc,ic){
                    this._f.nc = loc;
                    if(angular.isDefined(ic)){
                        this._f.ic = ic;
                    }
                    if(this.identical){
                        this.identical.setTotalComment(loc.ic);
                    }
                },
                getTotalComment: function () {
                    return this._f.nc;
                },
                selfComment: function () {
                    return this._f.ic;
                },

                getTotalShare: function () {
                    return this._f.ns;
                },
                getShareUsers : function(){
                    return this.shareUsers;
                },
                addShareUser : function(usr){
                    if(typeof usr == 'array'){
                        this.shareUsers = this.shareUsers.concat(usr);
                    }else{
                        this.shareUsers.push(usr);
                    }
                    return this.shareUsers;
                },
                share: function (doShare,totalShare) {
                    if (!doShare) {
                        return this._f.is;
                    }
                    this._f.is = this._f.is ^ 1;
                    if(totalShare){
                       this._f.ns = totalShare;
                    }else{
                       this._f.ns = this._f.is ? this._f.ns+1 : this._f.ns-1;
                    }
                    return this._f.is;
                },
                shares: function (mainFeed) { // mainFeed Is The Feed that Shared Current Feed
                    this.orginal = mainFeed;
                    this.orginal.addShareUser(this._u);
                    this.updateShareMessage();
                },
                getWhoShares: function () {
                    return this._f.whoShare;
                },
                getOrginalFeed: function () {
                    return this.orginal;
                },
                hasSharedFeed: function () {
                    return !angular.equals({}, this.orginal);
                },

                getTotalImage : function(){
                  return this._f.tim;
                },
                setImages: function () {
                    var temp,loopIndex = 0,imlength,timg;
                    if (!!this._f.imageList) {
                        try {
                            temp = angular.isString(this._f.imageList) ? angular.fromJson(this._f.imageList): this._f.imageList;
                        } catch (e) {
                        }
                        imlength = temp.length > 3 ? 3 : temp.length;
                        for (loopIndex = 0; loopIndex < imlength; loopIndex++) {
                            // temp[i].link = settings.imBase + temp[i].iurl;
                            temp[loopIndex].nfId = this._f.nfId;
                            timg = $$imageMap(temp[loopIndex],this._u);
                            this.images.add(timg.getMapKey(), timg);
                        }
                            // console.log($images.all());

                        //$images.sort('desc', 'sortByTime');//sort is not needed using default sort by id as image layout requires

                    }//if response have images then pushing into image map

                  switch(this.images.length()){
                      case 1:
                          this.imlayout = 5;
                          break;

                      case 2:
                          this.imlayout = 4;
                          break;
                      default:
                          this.imlayout = this._f.nfId % 4;
                          break;
                  }
                },
                getImages: function (map) {
                  return map ? this.images : this.images.all();
                },
                getImageLayout : function(withCLass){
                    return this.imlayout;
                },


                hasMedia: function() {
                    return this.images.length() > 0 || this.medias.length() > 0 || this.audios.length() > 0;
                },
                getAlbum: function() {
                    return this.album;
                },
                initMedias : function(){
                    if(!!this._f.mdaCntntLst && this._f.mdaCntntLst.length > 0) {
                        var user = this._f.stp > 0?null:this._u,mdaCntntLst = this._f.mdaCntntLst;

                            //feed.album = $$mediaAlbumMap.createAlbum({
                                //albn: mdaCntntLst[0].albn,
                                //albId: mdaCntntLst[0].albId,
                                //mc: mdaCntntLst.length,
                                //mdaT: mdaCntntLst[0].mdaT,
                                //utId: user ? user.getUtId() : 0
                            //}, user);

                            //feed.album.pushContent(mdaCntntLst, user,feed.nfId);

                            //if (feed.album.isAudio()){
                                //$audios = feed.album.getContents();
                            //} else if (albumMap.isVideo()){
                                //$medias = feed.album.getContents();
                            //}
                            //feed.medias = $medias;
                            //feed.audios = $audios;

                            //albumMap = Media.getAlbum(mdaCntntLst[0].albId);
                            //if (!albumMap) {
                                this.album = $$mediaAlbumMap.createAlbum({
                                    albn: mdaCntntLst[0].albn,
                                    albId: mdaCntntLst[0].albId,
                                    mc: mdaCntntLst.length,
                                    mdaT: mdaCntntLst[0].mdaT,
                                    utId: user ? user.getUtId() : 0
                                });

                                this.album.pushContent(mdaCntntLst, user, this._f.nfId);
                            //}
                        if (this.album.isAudio()){
                            this.audios = this.album.getContents(); //albumMap.pushContent(mdaCntntLst, user,this._f.nfId,this.audios);
                        } else if (this.album.isVideo()){
                            this.audios = this.album.getContents(); //.albumMap.pushContent(mdaCntntLst, user,this._f.nfId,this.medias);
                        }
                        //this.album = albumMap;
                    }
                },
                getMedias: function () {
                    return this.medias;
                },
                getAudios : function(){
                    return this.audios;
                },


                setViewColumn : function(column){
                    this.viewColumn = column;
                },
                getViewColumn : function(){
                    return this.viewColumn;
                },
                getUrl : function(){
                    /** Not an ideal place, will be refactored */
                    // var feedId, isShared=false;
                    // if (feedMapObjectToReturn.hasSharedFeed()) {
                    //     feedId = feedMapObjectToReturn.getOrginalFeed().getKey();
                    //     isShared = true;
                    // } else {
                    //     feedId = feedMapObjectToReturn.getKey();
                    // }
                    return utilsFactory.getRingRoute('SINGLE_FEED', {feedId : this._f.nfId, shared: this.hasSharedFeed()});
                },
                getWhoShareUrl : function() {
                    var feedId;
                    if (this.hasSharedFeed()) {
                        feedId = this.getOrginalFeed().getKey();
                    } else {
                        feedId = this.getKey();
                    }
                    return utilsFactory.getRingRoute('WHO_SHARED_FEED', {feedId : feedId});
                },

                hasFeelings : function(){
                    return !!this._f.mdLst.length;
                },
                getFeelings : function(){
                    return this.feelings;
                },

                setFeelings : function(feelings){
                    if(!!feelings && !!feelings.id){
                        this.feelings = feelings;
                        this._f.mdLst[0] = feelings.id;
                    }else{
                        this.feelings = {};
                        this._f.mdLst = [];
                    }
                    this.addPostfixMessage();
                },


                //starts tag user part
                setTagUsers : function (feedTagList, feedTagFriendCount){

                    if(!feedTagList){
                        feedTagList = this._f.fTgLst;
                    }else{
                        this._f.fTgLst = feedTagList;
                    }

                    this.tagUsers.length = 0;
                    if(feedTagList && feedTagList.length){

                        for(var i = 0;i < feedTagList.length;i++){

                            feedTagList[i].fn = feedTagList[i].nm;
                            this.tagUsers.push(User.createByUtId(feedTagList[i]));
                        }
                    }
                    if(angular.isDefined(feedTagFriendCount)){
                        this._f.tfc = feedTagFriendCount;
                    }
                },
                updateTagUser : function(obTag){

                    this.setTagUsers(obTag.fTgLst, obTag.tfc);

                    this.addPostfixMessage();
                },
                hasTagUsers :function(){
                    return !!this.tagUsers.length;
                },
                getTagUsers : function(){
                    return this.tagUsers;
                },
                validateForUpdateTag : function(){
                    return this._f.lctn !== '' || this._f.lnkURL || this._f.sts ||  this.images.length()  || this.medias.length() ||  this.audios.length();
                },
                hasMoreTagUsers : function(){
                    return this._f.tfc > this.tagUsers.length;
                },
                getMoreTagUsers : function(){
                    return this._f.tfc - this.tagUsers.length;
                },
                getTotalTag : function(){
                    return this._f.tfc;
                },
                getLocationText : function(){
                   return this._f.lctn;
                },
                getLocationShortText : function(){
                   if( !!this._f.lctn ){
                      var location = this._f.lctn;
                      var parts = this._f.lctn.split(',');

                      if( parts.length > 2){
                           location = parts[0].replace("(", "");
                      }

                      if( location.length > 30){
                           location = location.substr(0, 30) + '...';
                      }
                      return location;
                   }
                },
                setLocationText : function(location){
                   this._f.lctn = location;
                   this.addPostfixMessage();
                    return location;
                },
                resetLocationText : function(){
                    this._f.lctn = '';
                },


                getContentType : function(){
                    var a;
                    if(this.images.length()){
                        a = 'image';
                    }else if(this.medias.length()){
                        a = 'media';
                    }else if(this.audios.length()){
                        a = 'media';
                    }else {
                        a = 'feed';
                    }
                    return a;
                },
                hasLocationInfo: function(){
                    return this._f.lctn !== '' && !this._f.lnkURL && !this._f.sts && !this.images.length() && !this.medias.length() && !this.audios.length();
                },

                getLocationInfo : function(){
                    return this.locationData;
                },

                getLocationUrl : function(){
                    return $sce.trustAsResourceUrl( utilsFactory.getGoogleMapJSUrl(this._f.lat, this._f.lng, this._f.lctn, false) );
                },

                getLocationEmbedUrl : function(){
                    return $sce.trustAsResourceUrl( utilsFactory.getGoogleMapJSUrl(this._f.lat, this._f.lng, this._f.lctn, true) );
                },
                getLocationStaticEmbedUrl : function(){
                    return $sce.trustAsResourceUrl( utilsFactory.getGoogleMapStaticUrl(this._f.lat, this._f.lng, this._f.lctn) );
                },
                initLocationData : function(){
                    if(this._f.lat !== 9999){
                        this.locationData = { description: this._f.lctn, lat : this._f.lat, lng: this._f.lng };
                    }else{
                        this.locationData = { description: this._f.lctn };
                    }
                },
                setLocationInfo : function(location){
                    this._f.lctn = location.description;
                    this._f.lat = location.lat;
                    this._f.lng = location.lng;
                    this.initLocationData();
                    this.addPostfixMessage();
                },

                getStrmURL: function() {
                  return this._f.strmURL;
                },
                getLinkDomain: function(){
                    return this._f.lnkDmn;
                },
                getLinkUrl : function(){
                    return this._f.lnkURL;
                },
                getLinkTitle : function(){
                    return this._f.lnkTtl;
                },
                getLinkDescription : function(){
                    return this._f.lnkDsc;
                },
                getLinkImageUrl : function(){
                    return this._f.lnlImgURL;
                },
                hasOgData : function(){
                    return !!(this._f.lnlImgURL || this._f.lnkTtl || this._f.lnkDsc)
                },
                getOgData : function(){
                    return this.ogData;
                },
                initOgData : function (){
                    if(!this.ogData){
                        this.ogData = {};
                    }
                    this.ogData['image'] = this._f.lnlImgURL;
                    this.ogData['description'] = this._f.lnkDsc;
                    this.ogData['title'] = this._f.lnkTtl;
                    this.ogData['url'] = this._f.lnkURL;
                    this.ogData['lnkDmn'] = this._f.lnkDmn;
                },
                setOgData : function(ogData){
                    this._f.lnkDsc = ogData.lnkDsc || ogData.description ||'' ;
                    this._f.lnkTtl = ogData.lnkTtl || ogData.title || '' ;
                    this._f.lnkURL = ogData.lnkURL || ogData.url || '' ;
                    this._f.lnlImgURL = ogData.lnlImgURL || ogData.image || '' ;
                    this._f.lnkDmn = ogData.lnkDmn || ogData.domain || '' ;
                    this.initOgData();

                },

                isEmpty : function(ignore){ //ignore is object it should contain the property to ignore check
                    ignore = ignore || {};
                    return !this.text || (ignore.tagUsers && this.tagUsers.length);
                },
                isSpecial : function(){
                    return this._f.fc > 0;
                },
                isFeed : true,
                isTimelinePost : function(){
                            return this.friend && this.friend.isCurrentUser();
                        },
                isWallPost : function(){
                    return !!this.friend;
                },
                isCirclePost : function(){
                    return this._f.grpId > 0;
                },
                isMediaShared : function(){
                    return this._f.stp > 0;
                },
                isSingleContentFeed : function(){
                    return (this.images.length() === 1 || this.medias.length() === 1 || this.audios.length() === 1);
                },
                getSingleContent : function(){
                     return (this.images.length() && this.images.bottom()) || (this.medias.length() && this.medias.bottom()) || (this.audios.length() && this.audios.bottom()) || this;
                },
                isPending : function(val){
                    if(val !== undefined){
                        this.pending = !!val;
                    }
                    return this.pending;
                },
                isShareAble : function(returnWithMessage){
                    var sucs = true,rc,
                        content = this.isSingleContentFeed() && !this.images.length(),
                        f = this.getSingleContent();
                    if(this._u.isCurrentUser() || (content && f.user().isCurrentUser())){
                        rc = 'RC15';//reason code 15 from setting
                        sucs = false;
                    }else if(!!this.friend){
                        rc = 'CRCFS1';//custom reason code feed share
                        sucs = false;
                    }else if(!!this._f.grpId){
                        rc = 'CRCFS2';
                        sucs = false;
                    }else if(this._f.is && !content){
                        rc = 'CRCFS3';
                        sucs = false;
                    }
                    return !returnWithMessage?sucs:{sucs:sucs,rc:rc};
                },
                // getFeedRaw : function(){ // for debug
                //     return this._f;
                // },
                encodeUtf8Fields : function(){
                    var utf8fields = [
                        'location', 'lctn', 'lnkDmn',  'lnkDsc', 'lnkTtl', 'lnkURL', 'lnlImgURL'
                    ],utf8fieldsIndex,feedUtf8AttributeName;
                    for(utf8fieldsIndex = 0; utf8fieldsIndex < utf8fields.length; utf8fieldsIndex++){
                         feedUtf8AttributeName = utf8fields[utf8fieldsIndex];
                        if(!this._f[ feedUtf8AttributeName ]){
                            this._f[ feedUtf8AttributeName ] = '';
                        }else{
                            this._f[ feedUtf8AttributeName ] = this._f[ feedUtf8AttributeName ].utf8Encode();
                        }
                    }
                },
                feedConditionalReplacer : function(str,conditions){
                    var i=0; conditions = conditions || [];
                        str = str.replace(/(\w+)?\|\|(\w+)?/g,function(match,p1,p2){
                            if(conditions[i] !== undefined){
                                return !!conditions[i]?p1:p2;
                            }else{
                                return "";
                            }
                        });
                        return str.replace(/(\s){2,}/g," ");// replacing two or more spaces into one
                }
        }




        return {
                getPrefix: function () {
                    return keyPrefix;
                },
                setSortKey : function(key){
                    sortBy = key;
                },
                setPrefix: function (prefix) {
                    keyPrefix = prefix;
                },
                getSortIndex: function () {
                    return sortBy;
                },
                makeKey: function (key) {
                    return keyPrefix + key;
                },

                create: function (_d, user) {
                         return new RingFeed(_d,user);
                }
            };
     }




})();


(function(undefined) {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket','ringid.puller','ringid.utils','ringid.config', 'ringid.notification'
            ]);
    }


    feedApp.factory('feedFactory', feedFactory);

    feedFactory.$inject = [ 'fileUploadService', '$$connector', '$$q','$$stackedMap','$$feedMap','utilsFactory','OPERATION_TYPES', 'APP_CONSTANTS', 'Ringalert','Auth','MIN_TIMESTAMP', '$rootScope', 'SystemEvents'];
    function feedFactory( fileUploadService, $$connector, $q,$$stackedMap,$$feedMap,utilsFactory,OPERATION_TYPES, APP_CONSTANTS, Ringalert,Auth,MIN_TIMESTAMP, $rootScope, SystemEvents) {
        var NO_MORE_FEED = false, OTYPES = OPERATION_TYPES.SYSTEM, AC = APP_CONSTANTS;
        //$feed = $$stackedMap.createNew($$feedMap.getSortIndex());

        var feed_index = OTYPES.TYPE_NEWS_FEED + '.all';
        var pvtId = 0;
        // note : do not need anymore
        //var possibleActions = [OTYPES.TYPE_NEWS_FEED,
        //    OTYPES.TYPE_GROUP_NEWS_FEED,
        //    OTYPES.TYPE_MY_NEWS_FEED,
        //    OTYPES.TYPE_FRIEND_NEWSFEED,
        //    OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS
        //];
        var latestFeeds = [];
        var feedList = {},
            incomingFeedData = [],
            pushInIncomingFeed = false,//to keep incoming feed data in json format for later process
            ignoreActions = []; // its have key,action,callback. callback should return true or false
                               // if it returns true it will not go further execution with that action for feed

        var processorFunctions = {};
        var FEED_SCOPES = {};

        processorFunctions[OTYPES.TYPE_NEWS_FEED] = pushFeed;
        processorFunctions[OTYPES.TYPE_MY_NEWS_FEED] = pushFeed;
        processorFunctions[OTYPES.TYPE_FRIEND_NEWSFEED] = pushFeed;
        processorFunctions[OTYPES.TYPE_GROUP_NEWS_FEED] = pushFeed;
        processorFunctions[OTYPES.TYPE_MEDIAS_NEWS_FEED] = pushFeed;
        //processorFunctions[OTYPES.TYPE_COMMENTS_FOR_STATUS] = pushComments;
        //processorFunctions[OTYPES.TYPE_LIKES_FOR_STATUS] = updateWhoLike;
        //processorFunctions[OTYPES.TYPE_LIST_LIKES_OF_COMMENT] = updateWhoLike;

        // updates todo : complete the list of updates
        processorFunctions[OTYPES.TYPE_UPDATE_ADD_STATUS] = updateAddStatus;
        processorFunctions[OTYPES.ACTION_UPDATE_SHARE_STATUS] = updateShareStatus;
        processorFunctions[OTYPES.TYPE_UPDATE_DELETE_STATUS] = updateDeleteStatus;
        processorFunctions[OTYPES.TYPE_UPDATE_EDIT_STATUS] = processUpdates;
        processorFunctions[OTYPES.TYPE_UPDATE_LIKE_STATUS] = processUpdates;
        processorFunctions[OTYPES.TYPE_UPDATE_UNLIKE_STATUS] = processUpdates;
        processorFunctions[OTYPES.TYPE_UPDATE_ADD_STATUS_COMMENT] = processUpdates;
        //processorFunctions[OTYPES.TYPE_UPDATE_LIKE_COMMENT] = processUpdates;
      //  processorFunctions[OTYPES.TYPE_UPDATE_UNLIKE_COMMENT] = processUpdates;
        processorFunctions[OTYPES.TYPE_UPDATE_DELETE_STATUS_COMMENT] = processUpdates;
       // processorFunctions[OTYPES.TYPE_UPDATE_EDIT_STATUS_COMMENT] = processUpdates;



        return {
            init: init,
            addScope : function(nfId,$scope){
                FEED_SCOPES[nfId] = $scope;
            },
            removeScope : function(nfId){
                if(FEED_SCOPES[nfId]){
                    delete FEED_SCOPES[nfId];
                }
            },
            getFeed: getFeed,

            updateTime: updateTime,

            pushFeed : pushFeed,
            processIncomingFeed : processIncomingFeed,
            setpushInIncomingFeed :function(val){
                pushInIncomingFeed = !!val;
            },
            getPushIncomingFeed : function(){
                return pushInIncomingFeed;
            },
            hasUnprocessedFeed : function(){
                return incomingFeedData.length;
            },
            addIgnoreFilter: addIgnoreFilter,

            removeIgnoreFilter: removeIgnoreFilter,

            setFactoryKey: setFactoryKey,

            createFeed : createFeed,

            process: process,

            getFeedFilter: getFeedFilter,

            noMoreFeed: noMoreFeed,

            requestForFeed: requestForFeed,
            initFeedRequest : initFeedRequest,

            getSingleFeed: getSingleFeed,

            requestForMoreFeed: requestForMoreFeed,
            getRawFeeds: getRawFeeds,

            getFeeds: getFeeds,

            addFeed: addFeed,

            shareFeed: shareFeed,

           // likeUnlikeFeed: likeUnlikeFeed,

          //  fetchComments: fetchComments,

          //  fetchCommentsByOffset: fetchCommentsByOffset,

         //   fetchCommentById: fetchCommentById,

         //   addComment: addComment,

         //   likeUnlikeComment: likeUnlikeComment,

            deleteFeed: deleteFeedService,

            updateFeed: updateFeed,

          //  deleteComment: deleteComment,

           // updateComment: updateComment,

           // fetchWhoLikesFeed: fetchWhoLikesFeed,

            reset: reset,

            moreFeedText: moreFeedText,

            getSingleFeedPageKey: getSingleFeedPageKey,

            getWhoShareFeedId : getWhoShareFeedId,
            getTagUsers : getTagUsers,
            setSortBy : setSortBy,
            getCurrentPageValue : getCurrentPageValue,
            hasSpecialFeed : function(){
                var pageValue = getCurrentPageValue();
                return (OTYPES.TYPE_NEWS_FEED === pageValue.action) && (feedList.special && feedList.special.length() > 0);
            },
            getSpecialFeedList : function(){
                return feedList.special && feedList.special.all();
            },
            synchLike : synchLike,
            synchComment : synchComment
            /**
             * @description : this function is for fake feed generation for testing purpose
             * @params : startingOffset,length
             *
             */
            //fakeFeed : fakeFeedGenerator

        };


        /////////////////////////////

        // ------------------------- Private -----------------------------------
        function setSortBy(key){
            $$feedMap.setSortKey(key);
        }
        function getIndexedFeed() {

            return feedList.hasOwnProperty(feed_index) ? feedList[feed_index].data : $$stackedMap.createNew();
        }

        function getIndexedRemovedFeed(){
            return feedList.hasOwnProperty(feed_index) ? feedList[feed_index].removed : $$stackedMap.createNew();
        }
        function getCurrentPageValue(){ // returns current Feed Page Action
            var keyParts = [];
            try {
                keyParts = feed_index.split('.', 2);
            } catch (e) {
                return false;
            }

            if (keyParts.length != 2) {
                return false;
            }

            return {
                    action : parseInt(keyParts[0]),
                    page : keyParts[1]
                   };
        }


        function updateTime() {
            var feeds = getIndexedFeed();
            for(var i=0; i<feeds.length();i++){
                var timediff = Date.now()-feeds.all()[i].value.getTimestamp();
                if(timediff < 3600000) {
                    feeds.all()[i].value.updateTime();
                }
            }
        }
        //setInterval(feedFactory.updateTime, 180000);
        function init(ob) {

            var $feed = getIndexedFeed();

            if ($feed.length() < 10) {
                requestForFeed(ob);

                return true;// return for scope set busy //
            } else {

                return false; //return for scope set busy false cause no ajax call initiated
            }
            // initiating stack for holding feeds
        }
        function reset() {
            getIndexedFeed().reset();
            getIndexedRemovedFeed().reset();
            incomingFeedData.length = 0;
        }
        function getMinTm(){
            var sortIndex = $$feedMap.getSortIndex(),$feed = getIndexedFeed();
            if(sortIndex === 'tm'){
                return $feed.length() ? $feed.top().getTimestamp() : MIN_TIMESTAMP;
            }
            var mintimestamp = $feed.length() ? $feed.top().getAtTime() : MIN_TIMESTAMP;

            // $feed.doForAll(function(f){
            //     if(f.getTimestamp() < mintimestamp){
            //         mintimestamp = f.getTimestamp();
            //     }
            // });
            return mintimestamp;
        }
        function createFeed(json,user){
            return $$feedMap.create(json,user);
        }
        function DashboardFeedFilter(){
            return true;//all Kinda of filter will be shown
        }
        function singlePageFilter(message,pageValue){
            return message.nfId == pageValue.page || ( message.whShrLst && message.whShrLst[0].nfId == pageValue.page);
        }
        function GroupNewsFeedFilter(message,pageValue){
            return !!message.grpId && message.grpId == pageValue.page;
        }
         function MediaNewsFeedFilter(message,pageValue){
            return true;
        }
        function CurrentUserPageFilter(tempData,pageValue){

            if(!pageValue){
                pageValue = getCurrentPageValue();
            }
            if((pageValue.page === tempData.uId) || (!!tempData.fndId && pageValue.page === tempData.fndId)){
                return true;
            }
            if(!!tempData.orgFd && ( pageValue.page === tempData.orgFd.uId)){
                return true;
            }
            return false;
        }
        function processCurrentUserFriendFeed(feedData){
            processCurrentUserFeed(feedData);
        }

        function processCurrentUserFeed(feedData){
            processAllFeed(feedData,CurrentUserPageFilter,{
                processWhoShare : function(tempData,$feed,pageValue){
                    var _d1,_d;
                    if(tempData.uId === pageValue.page && tempData.orgFd){ // someone shares it but main owner is the current user

                        _d = createFeed(tempData.orgFd);
                        _d1 = createFeed(tempData);
                        _d1.shares(_d);
                        $feed.save(_d1.getMapKey(), _d1);
                        //saveOrginalFeedIntoRemoved(_d1,tempData.nfId); profile pages doesn't need to process the update share
                    }
                }
            });
        }


        function processGroupNewsFeed(feedData){
            processAllFeed(feedData,GroupNewsFeedFilter);
        }
        function processMediasNewsFeed(feedData){
            processAllFeed(feedData,MediaNewsFeedFilter);
        }
        function processDashboardFeed(feedData){
            processAllFeed(feedData,DashboardFeedFilter);
        }
        function processSpecialFeed(json) {
            var _d;
            if(!feedList.special){
                feedList.special = $$stackedMap.createNew($$feedMap.getSortIndex(), 'desc');
            }
            _d = createFeed(json);
            feedList.special.save(_d.getMapKey(), _d);
        };

        function processAllFeed(feedData,filterFunc,options){
            options = options || {};
            if(!angular.isFunction(filterFunc))filterFunc = function(){return true;};
            var message = angular.isArray(feedData) ? feedData : feedData.newsFeedList;
            if(!angular.isArray(message))return;
            var pageValue = getCurrentPageValue();
            var $feed = getIndexedFeed(),_d,tempKey,_d1,tempData;
            var newsfeedid;
            for (var i = 0; i < message.length; i++) {
                tempData = message[i];
                newsfeedid = tempData.nfId;
                if(pvtId==0){
                    pvtId = newsfeedid;
                }else{
                    if(newsfeedid < pvtId){
                        pvtId = newsfeedid;
                    }
                }
                if(tempData.fc > 0){processSpecialFeed(message[i]);continue;}
                if(!filterFunc(tempData,pageValue))continue;
                if (tempData.deleted) {
                    deleteFromIndexedFeed(tempData.nfId);
                //} else if (tempData.sharedFeed) { //todo : may be no use now ! please check calls when user share from share controller
                //    _d1 = createFeed(tempData.sharedFeed);
                //    tempData.sharedFeed = {};//no need
                //    _d = createFeed(tempData);
                //    _d.shares(_d1);
                //    // TODO may be original feed d1 should remove from here !
                //    $feed.save(_d.getMapKey(), _d);
                } else if (tempData.whShrLst || tempData.orgFd) { // when share feed comes from server
                    if(!!options.processWhoShare && angular.isFunction(options.processWhoShare)){
                        options.processWhoShare.call(null,tempData,$feed,pageValue);
                    }else{
                        if(tempData.orgFd){
                            _d = createFeed(tempData);
                            if (!(_d1 = _getFeed(tempData.orgFd.nfId))) {
                            _d1 = createFeed(tempData.orgFd);
                            }
                        }else{
                            _d = createFeed(tempData.whShrLst[0]);
                            if (!(_d1 = _getFeed(tempData.nfId))) {
                            _d1 = createFeed(tempData);
                            }
                        }
                        _d.shares(_d1);
                        $feed.save(_d.getMapKey(), _d);
                        saveOrginalFeedIntoRemoved(_d1,_d.getKey());
                    }

                } else {
                    _d = createFeed(tempData);
                    $feed.save(_d.getMapKey(), _d);
                }

            }

        }

        function processSingleFeed(feedData){
            processAllFeed(feedData,singlePageFilter);
        }

        function getCurrentPageFilter(pageValue){
            if(!pageValue){
                pageValue = getCurrentPageValue();
            }
            switch (pageValue.action) {
                case OTYPES.TYPE_MY_NEWS_FEED:
                case OTYPES.TYPE_FRIEND_NEWSFEED:
                    return CurrentUserPageFilter;
                case OTYPES.TYPE_GROUP_NEWS_FEED:
                    return GroupNewsFeedFilter;
                case OTYPES.TYPE_MEDIAS_NEWS_FEED:
                    return MediaNewsFeedFilter;
                case OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS:
                    return singlePageFilter;
                case OTYPES.TYPE_NEWS_FEED:
                default :
                    return DashboardFeedFilter;

            }
        }

        function pushFeed(feedData) {
            var pageValue = getCurrentPageValue();
            switch (pageValue.action) {
                case OTYPES.TYPE_MY_NEWS_FEED:
                    processCurrentUserFeed(feedData);
                    break;
                case OTYPES.TYPE_FRIEND_NEWSFEED:
                    processCurrentUserFriendFeed(feedData)
                    break;
                case OTYPES.TYPE_GROUP_NEWS_FEED:
                    processGroupNewsFeed(feedData);
                    break;
                case OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS:
                    processSingleFeed(feedData);
                    break;
                case OTYPES.TYPE_NEWS_FEED:
                    processDashboardFeed(feedData);
                    break;
                case OTYPES.TYPE_MEDIAS_NEWS_FEED : 
                    processMediasNewsFeed(feedData);
                    break;
                default:
                    break;
            }

        }
        function processIncomingFeed(){
            var tempData;
            while(incomingFeedData.length && pushInIncomingFeed){
                tempData = incomingFeedData.shift();
                if(!!tempData.callback){
                    tempData.callback.call(null,tempData,true);
                }else{
                    pushFeed([tempData]);
                }

            }
        }
        function saveOrginalFeedIntoRemoved(feed,reference,removedMap){
            if(!removedMap){
                removedMap = getIndexedRemovedFeed();
            }
            feed.reference = reference;
            removedMap.save(feed.getMapKey(),feed);
        }
        function _getRemovedFeed(nfId,removedMap){
            if(!removedMap){
                removedMap = getIndexedRemovedFeed();
            }
            nfId = $$feedMap.getPrefix() + nfId;
            return removedMap.get(nfId);
        }
        function _getFeed(nfId) {
            var $feed;
            $feed = getIndexedFeed();
            nfId = $$feedMap.getPrefix() + nfId;
            return $feed.get(nfId);

        }

        function _addFeed(feed) {
            var $feed = getIndexedFeed();
            $feed.add(feed.getMapKey(), feed);

        }

        function deleteFeed(key,$feed) {
            if(!$feed){
                $feed = getIndexedFeed();
            }
           return $feed.remove($$feedMap.makeKey(key));

        }

        function synchLike(nfId,il,loc){
            if(!nfId)return;
            var f = getFeed(nfId);
            if(f && f.isSingleContentFeed()){
                f.setTotalLikes(loc,il);
                return FEED_SCOPES[nfId];
            }
        }

        function synchComment(nfId,total,is){
            if(!nfId)return;
            var f = FEED_SCOPES[nfId];
            if(f && f.feed.isSingleContentFeed()){
                f.feed.setTotalComment(total,is);
                return f;
            }
        }



        // function updateWhoLike(message, feed) {
        //     var commentOrFeed;
        //     if (!feed || (!!feed && feed.getKey() !== message.nfId)) {
        //         feed = _getFeed(message.nfId);
        //     }
        //     if (!feed)return;
        //     if (!!message.cmnId) {
        //         commentOrFeed = feed.getCommentByKey(message.cmnId) || feed;
        //     } else {
        //         commentOrFeed = feed;
        //     }
        //     var likes = message.likes || [];
        //     for (var i = 0; i < likes.length; i++) {
        //         commentOrFeed.incomingWhoLikes(likes[i]);
        //     }

        // }

        function processUpdates(json) {

            var f = _getFeed(json.nfId);
            var scope = FEED_SCOPES[json.nfId];
            if (!f || !scope){
                return;
            }

            switch (json.actn) {

                case OTYPES.TYPE_UPDATE_EDIT_STATUS:
                    f.update(json);

                    break;

                case OTYPES.TYPE_UPDATE_LIKE_STATUS:
                case OTYPES.TYPE_UPDATE_UNLIKE_STATUS:

                    f.setTotalLikes(json.loc);
                    f.setFeedTopMessage();
                    break;

                case OTYPES.TYPE_UPDATE_ADD_STATUS_COMMENT:
                case OTYPES.TYPE_UPDATE_DELETE_STATUS_COMMENT :

                    f.setTotalComment(json.loc);
                    f.setFeedTopMessage();
                    break;

            }
            return scope;
        }

        function updateDeleteStatus(json) {
            deleteFeed(json.nfId);
        }

       function updateShareStatus(json,forceProcess,selfShared,currentUser) {
            if(pushInIncomingFeed && !forceProcess){
                json.callback = updateShareStatus;
                var filterFunc = getCurrentPageFilter();
                if(filterFunc.call(null,json.newsFeed)){ //validating if this feed should processed via current page
                    incomingFeedData.push(json);
                }
                return;
            }

            var key = json.newsFeed.orgFd && json.newsFeed.orgFd.nfId;
            if(!key)return;
            var f = _getFeed(key);
            var $removed = getIndexedRemovedFeed();
            if(f){ // searched in main feed list
                // note : its found in main list so nobody shares it so we just deletes it
                //and update with latest with common function
                if(selfShared){
                    f.setActivity(json.newsFeed.orgFd);
                    return FEED_SCOPES[f.getKey()];
                }else{
                    saveOrginalFeedIntoRemoved(f,json.newsFeed.nfId,$removed);
                    deleteFeed(f.getKey());
                }
            }else{ // searched for previously added to removed feed
                f = _getRemovedFeed(key,$removed);
                if(f){ // found in removed feed
                    //todo : synch current three feed
                    var filterFunc = getCurrentPageFilter();
                    processAllFeed([json.newsFeed],filterFunc,{processWhoShare:
                        function(message,$feed,pageValue){
                            var _d,_d1,orginal = _getFeed(f.reference);//getting orginal feed
                                if(!orginal){
                                    pushFeed([message]); // normally update
                                    return;
                                }
                            if(pageValue.page == OTYPES.TYPE_FRIEND_NEWSFEED || pageValue.page == OTYPES.TYPE_MY_NEWS_FEED){
                                return;// todo : check if there needed to update
                            }
                            f.update(message,true);// updating the old feed without the tm to keep the order
                            if(selfShared){
                                f.addShareUser(currentUser);
                                orginal.updateShareMessage();
                                orginal.setActivity(message);
                                return FEED_SCOPES[orginal.getKey()];
                            }
                            // todo : when current user share status the whoShare doesn't contain the current user data. instead previous share user data.need to be checked with auth
                                // deleting the feed from orginal feed list
                            _d = createFeed(message); //creating new feed
                            _d.setActivity(message.orgFd);//set orginal feed activity
                            //_d1 = createFeed(tempData);
                            //_d1.addShareUser(orginal.getOrginalFeed().getShareUsers());//pushing orginal user
                                deleteFeed(f.reference);
                                _d.shares(f);
                                $feed.save(_d.getMapKey(), _d);


                        }
                    });
                    return;
                // todo here you should return after calling processAllFeed with whoShare processor
                }else{ //also not found in removed feed . means the orginal feed does not exist in removed feed list
                    // so saving the orginal feed into removed feed list.
                    //note : processAllFeed and processUsersFeed saves orginal feed
                }

            }
            pushFeed([json.newsFeed]);
        }



        function updateAddStatus(json) {
            if (!json.imageList && json.type === 1) { // when updates comes then it brings image imformation directly to feed data
                json.imageList = [json];            // but feedmap processes image in imagesList
            }
            if(pushInIncomingFeed){
                var filterFunc = getCurrentPageFilter();
                if(filterFunc.call(null,json,getCurrentPageValue())){
                    incomingFeedData.push(json);
                }
            }else{
                pushFeed([json]);
            }

        }

        function _process(json) {
            //console.dir(json);
            var i, ignore = false, feedData = angular.isArray(json) ? json[0] : json;
            if (ignoreActions.length) {
                for (i = 0; i < ignoreActions.length; i++) {
                    if (ignoreActions[i].action === feedData.actn) {
                        ignore = ignoreActions[i].callback.call(null, feedData);
                    }
                }
            }
            if (!!processorFunctions[feedData.actn] && !ignore) {
               return processorFunctions[feedData.actn].call(null, feedData);
            }

        }

        //------------------------- Public -------------------------

        function getFeed(key) {
            // key = $$feedMap.getPrefix() + key;
            return _getFeed(key);
        }

        function addIgnoreFilter(action, callback) {
            var key = utilsFactory.getUniqueID();

            ignoreActions.push({
                key: key,
                action: action,
                callback: callback
            });

            return key;
        }

        function removeIgnoreFilter(key) {
            var idx = -1;

            for (var i = 0; i < ignoreActions.length; i++) {
                if (ignoreActions[i].key === key) {
                    idx = i;
                }
            }

            return idx != -1 ? ignoreActions.splice(idx, 1) : [];
        }

        function setFactoryKey(key) {
            feed_index = key;
            if (!feedList.hasOwnProperty(feed_index)){
                feedList[feed_index] = {
                    data: $$stackedMap.createNew($$feedMap.getSortIndex(), 'desc'),
                    removed : $$stackedMap.createNew(),//removed feed
                    no_more_feed: false
                };
            }

            //feedList.special = feed.special || $$stackedMap.createNew($$feedMap.getSortIndex(), 'desc');

        }

        function process(json) {
          return _process(json);
        }

        function getFeedFilter() {
            return function (m) {
                return !!processorFunctions[m.actn];
            };

        }
        function getRawFeeds() {
            return getIndexedFeed().all();

        }

        function getFeeds() {
           // var t0 = performance.now();

            //console.dir($feed.all());
            var $feed = getIndexedFeed();
            return $feed.all();
        }
        function noMoreFeed() {
            return feedList.hasOwnProperty(feed_index) ? feedList[feed_index].no_more_feed : false;

        }
        function requestForFeed(ob) {
            var d_limit = AC.FEED_LIMIT;
            ob = angular.copy(ob || {});
            ob.pvtid = pvtId || 0;
            ob.st = getFeeds().length || 0
            switch (utilsFactory.feedColumn()) {
                case 1:
                     d_limit = 5;
                    break;
                case 2:
                 d_limit = 6;
                break;
                case 3:
                     d_limit = 9;
                    break;
            };
            ob.lmt = ob.lmt || d_limit;

            return $$connector.send(ob, OTYPES.REQUEST_TYPE.REQUEST);
        }
        function initFeedRequest(ob){
            ob = angular.copy(ob || {});
           // ob.lmt = 5;
            ob.scl = 2;
            ob.tm = 0;
            requestForFeed(ob);
        }

        function requestForMoreFeed(ob, scl) {
            var timestamp = getMinTm();
            //todo : if scl == 1 we need to send max tm instead of min tm
            ob = angular.copy(ob || {});
            ob.scl = scl || 2;
            ob.tm = timestamp ? timestamp : MIN_TIMESTAMP;
            return requestForFeed(ob);

        }
        function getSingleFeed(feedId, whoShare) {

            var payload = {
                actn: OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS,
                nfId: feedId
            };

            var deffer = $q.defer();

            var feedObj = getFeed(feedId);

            if(!feedObj){

                $$connector.request(payload, OTYPES.REQUEST_TYPE.REQUEST)
                    .then(function(feedData){
                        if(feedData.sucs === true){

                            // pushFeed(feedData);
                            //
                            // if( !!whoShare){
                            //     pushFeed(feedData);
                            //     var whoShareFeedId = getWhoShareFeedId(feedData);
                            //     feedObj = getFeed(whoShareFeedId);
                            // }else{
                            //     deleteWhoShareFromSingleFeedData(feedData);
                            //     pushFeed(feedData);
                            //     feedObj = getFeed(feedId);
                            // }
                            var message = angular.isArray(feedData) ? feedData : feedData.newsFeedList[0];
                            if( !!whoShare && message.orgFd){
                                if( message.orgFd ){
                                    feedObj = createFeed(message);
                                    var orginalFeed = createFeed(message.orgFd);
                                    feedObj.shares(orginalFeed);
                                }
                            }else{
                                feedObj = createFeed(message);
                            }

                            if(feedObj){
                                var $feed = getIndexedFeed();
                                $feed.save(feedObj.getMapKey(), feedObj);
                            }

                            deffer.resolve(feedObj);
                        }else{
                            deffer.resolve(false);
                        }

                    }, function(errData){
                        deffer.reject(errData);
                    });

            }else{

                deffer.resolve(feedObj);
            }

            return deffer.promise;

        }


        function addFeed(ob, user,content_shared) {
            var defer = $q.defer(),lengthPadding = 0,
                _d, /* _d means json data */
                $feed = getIndexedFeed(),
                nfId = utilsFactory.getUniqueID();
                ob.stsTags = [];
                var tempText = '';
                //processing for sts tag
                var tempText = '';
                //processing for sts tag
                if(ob.text){
                   tempText =  ob.text.replace(/##([\d]+)##/g,function(match,$1,index){
                         var offset;
                         offset = index - lengthPadding;
                         ob.stsTags.push({
                            pstn : offset,
                            utId : $1
                         });
                         lengthPadding += match.length;
                        return "";
                    });
                   ob.text = tempText;
                }

            if(!content_shared){
                _d = createFeed({
                    nfId: nfId,
                    fpvc: ob.fpvc,
                    sts: ob.text,
                    lat : ob.lat || 9999,//default 9999
                    lng : ob.lng || 9999,//default 9999
                    //imgIds: ob.images,
                    grpId: ob.group || "",
                    friendId: ob.friend || "",
                    fndId : ob.friend || "",
                    mdLst : ob.mdIds || [],
                    // captionList: ob.captionList,
                    isNew: 1,
                    pending: true,
                    lctn: ob.lctn || '',
                    lnkDmn: ob.lnkDmn || '',
                    lnkDsc: ob.lnkDsc || '',
                    lnkTtl: ob.lnkTtl || '',
                    lnkURL: ob.lnkURL || '',
                    lnlImgURL: ob.lnlImgURL || ''
                }, user);
             $feed.save(_d.getMapKey(), _d);
           }else if(ob.feed){
                _d = ob.feed;
           }else{
                _d = getFeed(ob.nfId);
           }




            var newFeedData = {};
            if(ob.cntntIDLst){
                newFeedData.cntntIDLst = ob.cntntIDLst;
            }
            if (ob.group) {
                newFeedData.grpId = ob.group;
            }

            if (ob.friend) {
                newFeedData.fndId = parseInt(ob.friend);
            }

            if (ob.lctn) {
                newFeedData.lctn = ob.lctn.utf8Encode();
            }

            if( ob.lnkDmn){
                newFeedData.lnkDmn = ob.lnkDmn.utf8Encode();
            }

            if( ob.lnkDsc){
                newFeedData.lnkDsc = ob.lnkDsc.utf8Encode();
            }

            if( ob.lnkTtl){
                newFeedData.lnkTtl = ob.lnkTtl.utf8Encode();
            }

            if( ob.lnkURL){
                newFeedData.lnkURL = ob.lnkURL.utf8Encode();
            }

            if( ob.lnlImgURL){
                newFeedData.lnlImgURL = ob.lnlImgURL.utf8Encode();
            }
            if(ob.stsTags.length){
                newFeedData.stsTags = ob.stsTags;
            }

            newFeedData.actn = OTYPES.TYPE_ADD_STATUS;

            if (!!ob.images && ob.images.length > 0) {
                if (ob.images.length === 1) {//  type for single image
                    newFeedData.type = OTYPES.NEWS_FEED_TYPE_IMAGE;
                    newFeedData = angular.extend({}, newFeedData, ob.images[0].getAuthData());
                } else {// type for multiple images
                    newFeedData.actn = OTYPES.TYPE_ADD_MULTI_IMAGE;
                    newFeedData.type = OTYPES.NEWS_FEED_TYPE_MULTIPLE_IMAGE;
                    // imageList: [{ih, iw, cptn, iurl}]
                    newFeedData.imageList = [];
                    for (var i = 0, lt = ob.images.length; i < lt; i++) {
                        newFeedData.imageList.push(ob.images[i].getAuthData());
                    }
                }
            } else if (!!ob.videos && ob.videos.length > 0) {
                newFeedData.mdaCntntDTO  = {
                    albId: fileUploadService.getUploadAlbum(),
                    htgLst: [],
                    mdaLst: [],
                    mdaT: AC.NEWS_FEED_MEDIA_TYPE_VIDEO,
                    lnkT: AC.NEWS_FEED_MEDIA_TYPE_VIDEO
                };
                newFeedData.type = OTYPES.NEWS_FEED_TYPE_VIDEO;

                for (var i = 0, lt = ob.videos.length; i < lt; i++) {
                    newFeedData.mdaCntntDTO.mdaLst.push((ob.videos[i].getAuthData(true)));
                    if (i === 0) {
                        newFeedData.mdaCntntDTO.htgLst = newFeedData.mdaCntntDTO.mdaLst[0].htgLst;
                    }
                }
            } else if (!!ob.audios && ob.audios.length > 0) {
                newFeedData.mdaCntntDTO  = {
                    albId: fileUploadService.getUploadAlbum(),
                    htgLst: [],
                    mdaLst: [],
                    mdaT: AC.NEWS_FEED_MEDIA_TYPE_AUDIO,
                    lnkT: AC.NEWS_FEED_MEDIA_TYPE_AUDIO
                };
                newFeedData.type = OTYPES.NEWS_FEED_TYPE_AUDIO;

                for (var i = 0, lt = ob.audios.length; i < lt; i++) {
                    newFeedData.mdaCntntDTO.mdaLst.push((ob.audios[i].getAuthData(true)));
                    if (i === 0) {
                        newFeedData.mdaCntntDTO.htgLst = newFeedData.mdaCntntDTO.mdaLst[0].htgLst;
                    }
                }
            } else {// setting action and type for only text post
                newFeedData.actn = OTYPES.TYPE_ADD_STATUS;
                if(content_shared){
                    newFeedData.type = ob.audio ? OTYPES.NEWS_FEED_TYPE_AUDIO:OTYPES.NEWS_FEED_TYPE_VIDEO;
                }else{
                    newFeedData.type = OTYPES.NEWS_FEED_TYPE_STATUS;
                }

            }

            if(ob.mdIds){
                newFeedData.mdIds = ob.mdIds;
            }
            if(ob.tFrndIds){
                newFeedData.tFrndIds = ob.tFrndIds;
            }

            newFeedData.vldt = ob.vldt || "-1";// set validity for timout status // implement it while implementing timout status
            newFeedData.lng = ob.lng || 9999;
            newFeedData.lat = ob.lat || 9999;
            newFeedData.sts = ob.text.utf8Encode(); // setting the feed text
            newFeedData.fpvc = ob.fpvc || 2;

            $$connector.request(newFeedData, OTYPES.REQUEST_TYPE.UPDATE).then(function (json) {
                $rootScope.$broadcast(SystemEvents.FILE_UPLOAD.UPLOADS_POSTED);
                if (json.sucs) {
                    //console.dir(json);
                    if(!content_shared){
                        $feed.remove(_d.getMapKey());
                        if (json.type === OTYPES.TYPE_SINGLE_IMAGE_STATUS) {
                            json.imageList = [json];
                        }
                        pushFeed([json]);
                        // Ringalert.show(json, 'success');
                    }else{
                        _d && _d.share(json.mdaCntntLst[0].is,json.mdaCntntLst[0].ns);
                    }
                    defer.resolve(json);
                } else {
                    if(!content_shared){
                        $feed.remove(_d.getMapKey());
                        Ringalert.show(json, 'error');
                    }
                    defer.reject(json);
                }

            }, function (reason) {
                if(!content_shared){
                    $feed.remove(_d.getMapKey());
                    Ringalert.show(json, 'error');
                }
                defer.reject(json);
            });

            return defer.promise;
        }

        function shareFeed(ob) {
            if(ob.addShare){
                return addFeed(ob,ob.user,true);
            }
            var defer = $q.defer();

            var data = {
                actn: OTYPES.ACTION_SHARE_STATUS,
                sfId: ob.feed.getKey(),
                type: 2,
                sts: ob.text.utf8Encode(),
            };

            if(ob.mdIds){
                data.mdIds = ob.mdIds;
            }

            if(ob.tFrndIds){
                data.tFrndIds = ob.tFrndIds;
            }

            if(!!ob.location){

                if(!!ob.location.description){
                    data['lctn'] = ob.location.description.utf8Encode();
                }

                if(!!ob.location.lat){
                    data['lat'] = ob.location.lat;
                    data['lng'] = ob.location.lng;
                }
            }

            $$connector.request(data, OTYPES.REQUEST_TYPE.UPDATE).then(function (json) {
                // todo remove orginal feed from feedlist and made a function to prevent duplicacy on share feed
                if (!!json.sucs) {
                    // console.dir(json);
                    //$feed.remove(_d.getMapKey());
                    updateShareStatus(json,true,true,Auth.currentUser());
                    ////console.log("after");
                    ////console.dir($feed.all());
                    ob.feed.share(true);

                    defer.resolve(json);
                } else {

                    defer.reject(json);

                    //$feed.remove(_d.getMapKey());
                }


            }, function (reason) {
                defer.reject(reason);
            });
            //console.log("before");
            //console.dir($feed.all());
            return defer.promise;
        }

       

        function deleteFeedService(user, key) {
            var defer = $q.defer();
            var feed = _getFeed(key);
            var $feed = getIndexedFeed();
            if(!feed){
                setTimeout(function(){
                    defer.reject("Can't Delete Invalid Feed");
                });
                return defer.promise;
            }


            if (!feed.user().isCurrentUser(user.getKey())) {
                setTimeout(function () {
                    defer.reject("You are not authorized to delete this feed.");
                }, 100);
            }

            if (feed !== false) {
                // console.log($feed);

                deleteFeed(feed.getKey(),$feed);
                /** TODO : We Should Not Replace Here instead make the feed in gray/pending mode **/

                $$connector.request({
                    actn: OTYPES.TYPE_DELETE_STATUS,
                    nfId: key
                }, OTYPES.REQUEST_TYPE.UPDATE).then(function (json) {
                    if (!json.sucs) {
                        _addFeed(feed);
                        defer.reject(json);
                    } else {
                        defer.resolve(json);
                    }

                }, function (json) {
                    _addFeed(feed);
                    defer.reject(json);

                });

            } else {
                setTimeout(function () {
                    defer.reject("Feed Not Found!");
                }, 100);
            }

            return defer.promise;
        }

        function updateFeed(user, key, status, location, ogData, feedEmotions, taggedFriends) {
            var defer = $q.defer();
            var feed = _getFeed(key);
            var mapkey = feed.getMapKey();
            if (!feed.user().isCurrentUser(user.getKey())) {
                return;
            }
            var oldText = feed.text();
            var oldLocation = feed.getLocationInfo();
            var oldOgData = feed.getOgData();
            var oldEmotions = feed.getFeelings();
            var stsTags = [],lengthPadding=0,tempText;


                if(status){
                   tempText =  status.replace(/##([\d]+)##/g,function(match,$1,index){
                         var offset;
                         offset = index - lengthPadding
                         stsTags.push({
                            pstn : offset,
                            utId : $1
                         });
                         lengthPadding += match.length;
                        return "";
                    });
                   status = tempText;
                }


            var dataToUpdate = {
                actn: OTYPES.TYPE_EDIT_STATUS,
                nfId: key,
                sts: status.utf8Encode()
            };

            if(stsTags.length){
                dataToUpdate['stsTags'] = stsTags;
            }

            location = location || {};
            dataToUpdate['lctn'] = !!location.description ? location.description.utf8Encode() : '';
            dataToUpdate['lat'] = location.lat || 9999;
            dataToUpdate['lng'] = location.lng || 9999;


            //http://192.168.1.117/ringID/ringIDWeb/issues/689
            var shouldUpdateLinkShareInfo = !feed.hasOgData() || feed.getLinkUrl() != ogData.url || feed.getLinkImageUrl() != ogData.image;

            if( shouldUpdateLinkShareInfo ){

                dataToUpdate['lnkDmn'] = ogData.domain || '';
                dataToUpdate['lnkDsc'] = ogData.description ? ogData.description.utf8Encode() : '';
                dataToUpdate['lnkTtl'] = ogData.title ? ogData.title.utf8Encode() : '';
                dataToUpdate['lnkURL'] = ogData.url ? ogData.url.utf8Encode() : '';
                dataToUpdate['lnlImgURL'] = ogData.image || '';
            }

            var shouldUpdateFeedEmotion = false;
            if(!!feedEmotions && !!feedEmotions.id){
                dataToUpdate.mdIds = [feedEmotions.id]; // we will support one emotion at a time for now
                shouldUpdateFeedEmotion = true;
            }else{
                dataToUpdate.mdIds = [];
                shouldUpdateFeedEmotion = true;
            }


            if( !!taggedFriends){
                if(!!taggedFriends.removed){
                    dataToUpdate['rTFrndIds'] = taggedFriends.removed;
                }
                if(!!taggedFriends.new){
                    dataToUpdate['tFrndIds'] = taggedFriends.new;
                }

            }

            if (feed !== false) {
                feed.setText(status,stsTags);
                feed.setLocationInfo(location);

                if(shouldUpdateFeedEmotion){
                    feed.setFeelings(feedEmotions);
                }

                if( shouldUpdateLinkShareInfo ){
                    feed.setOgData(ogData);
                }

                $$connector.request(dataToUpdate, OTYPES.REQUEST_TYPE.UPDATE).then(function (json) {
                    if (json.sucs === false) {
                        feed.setText(oldText);
                        feed.setLocationInfo(oldLocation);

                        if(shouldUpdateFeedEmotion){
                            feed.setFeelings(oldEmotions);
                        }


                        if( shouldUpdateLinkShareInfo ) {
                            feed.setOgData(oldOgData);
                        }


                        defer.reject(json);
                    } else {
                        defer.resolve(json);
                    }
                }, function (json) {
                    feed.setText(oldText);
                    feed.setLocationInfo(oldLocation);

                    if(shouldUpdateFeedEmotion){
                        feed.setFeelings(oldEmotions);
                    }


                    if( shouldUpdateLinkShareInfo ) {
                        feed.setOgData(oldOgData);
                    }

                    defer.reject(json);
                });

                //$feed.remove(feed.getMapKey());
            }
            return defer.promise;
        }

            function moreFeedText(feed) {
            //console.log(obj);
            var defer = $q.defer(),
                payload = {
                    actn: OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS,
                    nfId: feed.getKey()
                };
            $$connector.request(payload, OTYPES.REQUEST_TYPE.REQUEST).then(function (json) {
                if (json.sucs) {
                    if (!!json.newsFeedList) {
                        feed.parseMoreText(json.newsFeedList[0]);
                    } else {
                        feed.parseMoreText(json);
                    }
                    defer.resolve(json);
                } else {
                    Ringalert.show(json, 'error');
                    defer.reject();
                }
            }, function (reason) {

                Ringalert.show(reason, 'error');
                defer.reject();
            });

            return defer.promise;
        }

        function getTagUsers(feed){
            //todo : remember to implement limit and starting offset
            return $$connector.pull({
                actn : OTYPES.TYPE_TAG_USER_LIST,
                nfId : feed.getKey()
            },OTYPES.REQUEST_TYPE.REQUEST);
        }


        function getSingleFeedPageKey(feedId){
            return OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS + "." + feedId ;
        }

        function getWhoShareFeedId(rawFeedData){
            var message = angular.isArray(rawFeedData) ? rawFeedData : rawFeedData.newsFeedList;
            if( message.length > 0 && message[0].whShrLst[0] ){
                return message[0].whShrLst[0].nfId;
            }
            return false;

        }

        function deleteWhoShareFromSingleFeedData(rawFeedData){
            var message = angular.isArray(rawFeedData) ? rawFeedData : rawFeedData.newsFeedList;
            if( message.length > 0 && message[0].whShrLst[0] ){
                delete message[0].whShrLst[0];
            }
        }

        function feedDigset(feedKey){

            var scope = FEED_SCOPES[feedKey]
            if(!!scope){
                scope.$rgDigest();
            }
        }



        /**
         * This function is a fake feed generator
         * were created for who share details fetch from feedWhoShareController
         *
         */
        //function fakeFeedGenerator(starting,length){
        //    var defer = $q.defer();
        //    starting = starting || 0;
        //    length = length || 5;
        //    var DataHouse = [{"nfId":4841,"uId":"2110010010","fndId":"2110063704","utId":5,"sts":"","tm":1442465461657,"at":1442465461657,"type":3,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","ffn":"Tom","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"fprIm":"","fprImPr":1,"imageList":[{"imgId":478,"iurl":"2110010010/1442465443047.jpg","cptn":"","ih":1280,"iw":720,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442465461657,"nl":0,"il":0,"ic":0,"nc":0},{"imgId":479,"iurl":"2110010010/1442465454105.jpg","cptn":"","ih":1280,"iw":720,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442465461657,"nl":0,"il":0,"ic":0,"nc":0}],"sfId":0,"tim":2,"grpId":0,"actvt":0,"auId":0,"imc":2,"sc":false},
        //
        //        {"nfId":4832,"uId":"2110010010","utId":5,"sts":"","tm":1442465426137,"at":1442465426137,"type":1,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"imageList":[{"imgId":477,"iurl":"2110010010/1442465417178.jpg","ih":1280,"iw":720,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442465426137,"nl":0,"il":0,"ic":0,"nc":0}],"sfId":0,"tim":1,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4843,"uId":"2110010010","fndId":"2110063704","utId":5,"sts":"","tm":1442465461657,"at":1442465461657,"type":3,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","ffn":"Tom","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"fprIm":"","fprImPr":1,"imageList":[{},{}],"sfId":0,"tim":2,"grpId":0,"actvt":0,"auId":0,"imc":2,"sc":false},
        //
        //        {"nfId":4834,"uId":"2110010010","utId":5,"sts":"","tm":1442465426137,"at":1442465426137,"type":1,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"imageList":[{}],"sfId":0,"tim":1,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4825,"uId":"2110010010","utId":5,"sts":"","tm":1442465404677,"at":1442465404677,"type":1,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"imageList":[{"imgId":476,"iurl":"2110010010/1442465396383.jpg","ih":1280,"iw":720,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442465404677,"nl":0,"il":0,"ic":0,"nc":0}],"sfId":0,"tim":1,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //        {"nfId":4646,"uId":"2110010130","utId":107,"sts":"fdsfsdfsdf","tm":1442407330406,"at":1442407330406,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4827,"uId":"2110010010","utId":5,"sts":"","tm":1442465404677,"at":1442465404677,"type":1,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"Socrates","afn":"","prIm":"2110010010/1442126728495.jpg","prImPr":1,"imageList":[{}],"sfId":0,"tim":1,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4648,"uId":"2110010130","utId":107,"sts":"fdsfsdfsdf","tm":1442407330406,"at":1442407330406,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4639,"uId":"2110010130","utId":107,"sts":"sadasdasdasd","tm":1442407276553,"at":1442407276553,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4621,"uId":"2110010130","utId":107,"sts":"sadasdasd","tm":1442407247081,"at":1442407247081,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //        {"nfId":4632,"uId":"2110010130","utId":107,"sts":"sadasdasdasd","tm":1442407276553,"at":1442407276553,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4623,"uId":"2110010130","utId":107,"sts":"sadasdasd","tm":1442407247081,"at":1442407247081,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4614,"uId":"2110010130","utId":107,"sts":"asdasdasd","tm":1442407135324,"at":1442407135324,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4605,"uId":"2110010130","utId":107,"sts":"asdasdasd","tm":1442407104103,"at":1442407104103,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4616,"uId":"2110010130","utId":107,"sts":"asdasdasd","tm":1442407135324,"at":1442407135324,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4607,"uId":"2110010130","utId":107,"sts":"asdasdasd","tm":1442407104103,"at":1442407104103,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4588,"uId":"2110010130","utId":107,"sts":"The awesome post","tm":1442405763121,"at":1442405763121,"type":3,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"imageList":[{"imgId":460,"iurl":"2110010130/1442405663379.jpg","cptn":"The awesome guitter","ih":768,"iw":1024,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442405763121,"nl":0,"il":0,"ic":0,"nc":0},{"imgId":461,"iurl":"2110010130/1442405663380.jpg","cptn":"The awesome sunflower","ih":768,"iw":1024,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442405763121,"nl":0,"il":0,"ic":0,"nc":0},{"imgId":459,"iurl":"2110010130/1442405663376.jpg","cptn":"The awesome Flower","ih":768,"iw":1024,"imT":1,"albId":"default","albn":"Feed Photos","tm":1442405763121,"nl":0,"il":0,"ic":1,"nc":2}],"sfId":0,"tim":4,"grpId":0,"actvt":0,"auId":0,"imc":4,"sc":false},
        //
        //        {"nfId":4579,"uId":"2110010130","utId":107,"sts":"asdasdasd ads ad asda dsasd","tm":1442405625514,"at":1442405625514,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false},
        //
        //        {"nfId":4581,"uId":"2110010130","utId":107,"sts":"The awesome post","tm":1442405763121,"at":1442405763121,"type":3,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"imageList":[{},{},{}],"sfId":0,"tim":4,"grpId":0,"actvt":0,"auId":0,"imc":4,"sc":false},
        //
        //        {"nfId":4572,"uId":"2110010130","utId":107,"sts":"asdasdasd ads ad asda dsasd","tm":1442405625514,"at":1442405625514,"type":2,"nc":0,"nl":0,"ns":0,"il":0,"ic":0,"is":0,"sucs":true,"fn":"I am Dracula","afn":"","prIm":"2110010130/1440056454790.jpg","prImPr":1,"sfId":0,"grpId":0,"actvt":0,"auId":0,"imc":0,"sc":false}];
        //
        //    setTimeout(function(){
        //        var r_object=[];
        //        for(var i = starting; i < starting + length;i++){
        //            if(i>DataHouse.length)break;
        //            try{
        //                r_object.push($$feedMap.create(DataHouse[i]));
        //            }catch(e){
        //                console.dir(e);
        //            }
        //        }
        //        if(r_object.length){
        //            defer.resolve(r_object);
        //        }else{
        //            defer.reject("no more Feed");
        //        }
        //    },2000);
        //
        //    return defer.promise;
        //}

    }

})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }
    feedApp.directive('rgFeedSubscriber',rgFeedSubscriber);

    rgFeedSubscriber.$inject = ['$$connector','feedFactory','$window','$$rgsyncher','OPERATION_TYPES','REASON_CODES', '$rootScope'];
        function rgFeedSubscriber($$connector, feedFactory,$window,$$rgsyncher,OPERATION_TYPES,REASON_CODES, $rootScope) {
            return function (cscope, element, attrs) {
                var scope = cscope.$parent,
                    initial_req = true,
                    counter_previous =0,
                    counter_current = 0,
                    OTYPES = OPERATION_TYPES.SYSTEM,
                    timeout_set = false;

                var updateScope = function RecursePro() {
                     //counter_previous = counter_current;
                    // console.log("called UpdateScope");
                    timeout_set = true;
                    var scrollTop = 0;
                    counter_previous = counter_current;
                    window.setTimeout(function () {
                      //  console.log("called timeouts");
                        if (counter_previous !== counter_current){
                             RecursePro(); return;
                        }else{
                            timeout_set = false;
                          //  counter_current = 0;
                            scope.feeds = feedFactory.getFeeds();
                            //scrollTop = element[0].scrollTop;
                            scope.clearRequestTimer && scope.clearRequestTimer();
                            scope.busy = false;
                            scope.$rgDigest();
                            //element[0].scrollTop = (scrollTop+element[0].clientHeight-150);
                        }
                    },30);
                };
                var ignored = false;
                function processFeed(message){
                    var targetScope;
                    if(!ignored){
                        ignored = true;
                        scope.addIgnore();

                        setTimeout(function(){
                            $rootScope.$broadcast('FIRST_FEED_RECEIVED');
                        }, 1000);

                    }
                    if(!message.sucs && message.rc > 0 && message.rc == REASON_CODES.NO_MORE_FEED){
                        scope.setNoMoreFeed(true);
                    }else if(message.rc === 1111){
                        if(!scope.feeds.length){
                            feedFactory.initFeedRequest(scope.params);
                         }
                    }else{
                       targetScope = feedFactory.process(message);
                    }


                    //  console.dir(message);
                    //$timeout(function () {
                    //    feeds = feedFactory.getFeeds();
                    //    $scope.busy = false;
                    //});



                    if(targetScope){
                        targetScope.$rgDigest();
                    }else /*if (counter_current > 5 || (initial_req && counter_current>2))*/ {
                       counter_current++;
                       scope.feeds = feedFactory.getFeeds();
                       if(scope.busy){
                        scope.busy = false;
                        scope.clearRequestTimer() ;
                       }

                       //
                       //counter_current = 0;
                       //initial_req = false;
                      // if(counter_current > 10 && timeout_set === false){
                        //updateScope();
                      // }else{
                       // if(!timeout_set){

                        if(timeout_set === false) {
                            timeout_set = true;
                            requestAnimationFrame(function(){
                                scope.$rgDigest();
                                timeout_set = false;
                            });

                        }


                       // }

                      // }
                    }

                };

                var subKey = $$connector.subscribe(processFeed,{
                    filter : feedFactory.getFeedFilter(),
                    callWithUnresolved : true
                });

                // scope.$on('feedShared',function($ev){
                //     // scope.$digest();
                // });

                //$$connector.request({
                //    "actn" : OTYPES.TYPE_NEWS_FEED,
                //    "request_type" : OTYPES.REQUEST_TYPE.REQUEST,
                //    "lmt" : 10
                //}).then(function(json){
                //    console.dir(json);
                //});


               // feedFactory.requestForFeed(scope.params);


                var syncher_key = $$rgsyncher.add(function(){
                    feedFactory.requestForFeed(scope.params,1);
                });

                scope.$on('$destroy', function (){
                    $$connector.unsubscribe(subKey);
                    feedFactory.reset();
                    $$rgsyncher.remove(syncher_key);
                    if(ignored){
                        scope.removeIgnore();
                    }
                });
            };
        };
})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }
    feedApp.directive('feedImage',feedImage);
    // feedApp.directive("feedImageStyle",function(){
    //     return function (scope,element,attr){
    //         var image = scope.feedimages[attr.feedImageStyle].value;
    //         var styles = {backgroundImage: 'url(' + image.src(600) + ')'};
    //          element.css(styles);
    //     }
    // });
    feedImage.$inject = ['utilsFactory','SystemEvents','$compile'];
    function feedImage(utilsFactory,SystemEvents,$compile) {
            function getHeightByWidth(ob,width){ //ob is image image map offset() api return value
                return (width * ob.height)/ob.width;
            }
// <div ng-repeat="image in feed.getImages()" ng-init="image = image.value;" class="floader" feed-image
//              rg-ringbox="true" ringbox-controller="RingBoxImagePopupController" ringbox-type="remote"
//              ringbox-target="pages/partials/notification/image-popup.html"
//              ringbox-data="getImageData(image, feed)"></div>
            function getImageTemplate(index,template){
                return '<div class="img'+(index+1)+'" style="background-image:url(\'{{::feedimages['+index+'].value.src(600)}}\')" rg-ringbox="true"'
                        +'ringbox-controller="RingBoxImagePopupController" ringbox-type="remote" ringbox-animation="true" '
                        +'ringbox-target="pages/partials/notification/'+(template || 'image-popup.html')+'"'
                        +' ringbox-data="getImageData(feedimages['+index+'].value, feed)"></div>';
            }
            var layoutHtmls = {
                        layout_0 : '<div class="grid">'+getImageTemplate(0)+'</div>'
                                          +'<div class="grid">'+getImageTemplate(1) + getImageTemplate(2)+'</div>',
                        layout_2 : '<div class="grid">'+getImageTemplate(0) + getImageTemplate(1)+'</div>'
                                          +'<div class="grid">'+getImageTemplate(2)+'</div>',
                        layout_4 : '<div class="grid">'+getImageTemplate(0) + getImageTemplate(1)+'</div>',
                        layout_5 : getImageTemplate(0)
                    };
                    layoutHtmls.layout_1 = layoutHtmls.layout_0;
                    layoutHtmls.layout_3 = layoutHtmls.layout_2;
                    layoutHtmls.layout_6 = layoutHtmls.layout_5;
                var layoutHtmls2 = {
                    layout_0 : '<div class="grid">'+getImageTemplate(0,"image-popup-special.html")+'</div>'
                                          +'<div class="grid">'+getImageTemplate(1,"image-popup-special.html") + getImageTemplate(2,"image-popup-special.html")+'</div>',
                        layout_2 : '<div class="grid">'+getImageTemplate(0,"image-popup-special.html") + getImageTemplate(1,'image-popup-special.html')+'</div>'
                                          +'<div class="grid">'+getImageTemplate(2,"image-popup-special.html")+'</div>',
                        layout_4 : '<div class="grid">'+getImageTemplate(0,"image-popup-special.html") + getImageTemplate(1,"image-popup-special.html")+'</div>',
                        layout_5 : getImageTemplate(0,"image-popup-special.html")
                    };
                    layoutHtmls2.layout_1 = layoutHtmls2.layout_0;
                    layoutHtmls2.layout_3 = layoutHtmls2.layout_2;
                    layoutHtmls2.layout_6 = layoutHtmls2.layout_5;
                

            return {
                restrict: 'A',
                scope : true,
                link: function (scope, element, attr) {
                        var layouts;
                        if(attr.feedImage === 'shared'){
                            scope.feed = scope.feed.getOrginalFeed();
                        }
                        //scope.divHeight = element[0].offsetHeight;
                        //scope.divWidth = element[0].offsetWidth;
                        scope.layout_id = scope.feed.getImageLayout();

                        scope.feedimages = scope.feed.getImages();
                       // scope.layout_styles = layoutHtmls['layout_'+scope.layout_id].styles;
                        if(scope.layout_id === 5){
                            if(scope.feedimages[0].value.offset().width < 600 && scope.feedimages[0].value.offset().height < 400){
                                scope.layout_id = 6;
                            }else{
                                if(getHeightByWidth(scope.feedimages[0].value.offset(),600) < 400){
                                    scope.layout_id = 6;
                                }
                            }
                            // element.css({
                            //     height : scope.feedimages[0].value.offset().height +'px'
                            // });
                        }

                        element.addClass('img-layout-'+scope.layout_id);
                        if(scope.feedimages.length){
                            if(attr.popupTemplate){
                                layouts = layoutHtmls2;
                            }else{
                                layouts = layoutHtmls;
                            }
                            var html = $compile(layouts['layout_'+scope.layout_id])(scope);
                            if(scope.feed.getTotalImage() > 3){
                                html[1].lastChild.innerHTML = '<div class="img-bg-opa"></div>\
    <div class="img-bg-counter">+'+(scope.feed.getTotalImage() - 3)+'</div>';
                            }
                            element.html("");
                            element.append(html);

                        }




                        // if(!angular.isDefined(scope.imageslength)){
                        //     scope.imageslength = 1;
                        // }

                        // element.removeClass('floader');

                        // var imageOffset = scope.image.offset();

                        // function setWidthHeight(withClass){
                        //     var classname;
                        //     if(((scope.imageslength >= 3 && scope.$index === 0 )) || scope.imageslength == 1){
                        //         classname = 'full';
                        //         if(utilsFactory.feedCellWidth > imageOffset.width){
                        //             element.css({
                        //                 width : imageOffset.width +'px',
                        //                 height : imageOffset.height +'px'
                        //             });
                        //         }else{
                        //             element.css({
                        //                 width : utilsFactory.feedCellWidth +'px',
                        //                 height : getHeightByWidth(imageOffset,utilsFactory.feedCellWidth) + 'px'
                        //             });

                        //         }
                        //         if(scope.imageslength == 1){
                        //             classname = 'single';
                        //         }
                        //     }else if ((scope.imageslength == 2 || scope.$index > 0 )) {
                        //         classname = 'half';
                        //     }

                        //     if(withClass){
                        //         element.addClass(classname);
                        //     }

                        // }
                        // scope.$on(SystemEvents.COMMON.WINDOW_RESIZED,function ($event) {
                        //     if(!attr['feedImageResponsive']) {
                        //         setWidthHeight()
                        //     }
                        // });

                        // scope.$on(SystemEvents.COMMON.COLUMN_CHANGED,function ($event) {
                        //     if(!attr['feedImageResponsive']) {
                        //         setWidthHeight()
                        //     }
                        // });

                        // if(!attr['feedImageResponsive']){
                        //     setWidthHeight(true);
                        // }

                       // element.css({backgroundImage: 'url(' + scope.image.src(600) + ')'});
                        //  console.dir(scope.image.offset());
                        //if (img.complete) { // sometimes when browser load the image from cache // onload not fired
                        //    loadHandler();
                        //}

                    }
            };
    }

    /** 
     * directive not in use
     */
    // feedApp.directive('feedVideo',feedVideoDirective);

    // feedVideoDirective.$inject = ['utilsFactory','SystemEvents'];
    //  function feedVideoDirective(utilsFactory,SystemEvents) {
    //         function getHeightByWidth(ob,width){ //ob is image image map offset() api return value
    //             return (width * ob.height)/ob.width;
    //         }

    //     return {
    //         restrict: 'A',
    //         link:  function (scope, element, attr) {

    //                 if(!angular.isDefined(scope.medialength)){
    //                     scope.medialength = 1;
    //                 }

    //                // element.removeClass('floader');

    //                 var imageOffset = scope.media.thumbOffset();

    //                 function setWidthHeight(withClass){
    //                     var classname;
    //                     if(((scope.medialength >= 3 && scope.$index === 0 )) || scope.medialength == 1){
    //                         classname = 'full';
    //                             if(scope.media.isVideo()){
    //                                if(utilsFactory.feedCellWidth > imageOffset.width){
    //                                     element.css({
    //                                         width : imageOffset.width +'px',
    //                                         height : imageOffset.height +'px'
    //                                     });
    //                                 }else{
    //                                     element.css({
    //                                         width : utilsFactory.feedCellWidth +'px',
    //                                         height : getHeightByWidth(imageOffset,utilsFactory.feedCellWidth) + 'px'
    //                                     });
    //                                }
    //                             }

    //                         if(scope.medialength == 1){
    //                             classname = 'single';
    //                         }
    //                     }else if ((scope.medialength == 2 || scope.$index > 0 )) {
    //                         classname = 'half';
    //                     }

    //                     if(withClass){
    //                         element.addClass(classname);
    //                     }

    //                 }
    //                 scope.$on(SystemEvents.COMMON.WINDOW_RESIZED,function ($event) {
    //                     if(!attr['feedImageResponsive']) {
    //                         setWidthHeight()
    //                     }
    //                 });

    //                 if(!attr['feedImageResponsive']){
    //                     setWidthHeight(true);
    //                 }

    //                 element.css({backgroundImage: 'url(' + scope.media.feedThumb() + ')'});
    //                 //  console.dir(scope.image.offset());
    //                 //if (img.complete) { // sometimes when browser load the image from cache // onload not fired
    //                 //    loadHandler();
    //                 //}

    //             }


    //     }
        
    // }
})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
        .directive('rgMoreFeed', rgMoreFeed);


    rgMoreFeed.$inject = ['feedFactory', 'SystemEvents'];
    function rgMoreFeed(feedFactory, SystemEvents) {
        return {
            restrict: 'A',
            link: function(scope, element, attr) {

              var feed = scope.$eval(attr.rgMoreFeed),updatedText = false,count=0,moreel;

                function setFeedText(){
                    var content = feed.getDynamicText();
                    if(content.toString()){
                        element.html(content.toString());    
                        if(!scope.editorEnabled){
                            element.removeClass('ng-hide');    
                        }else{
                            element.addClass("ng-hide");
                        }
                        
                    }else{
                        element.addClass("ng-hide");
                    }
                    SetShowMoreButton();
                }

                

                function SetShowMoreButton(){
                    if(feed.showMore() && !updatedText) {
                      moreel = angular.element('<span class="showpointer showmore"> Show More</span>');
                        element.append(moreel);
                        moreel.bind('click', moreFeedText);
                        scope.$on('$destroy',function(){
                           if(!!moreel) { 
                              moreel.unbind('click');
                              moreel = null;
                           }  
                        });
                    }
                }
                setFeedText();

                scope.$on(SystemEvents.FEED.UPDATED, function(event, data){
                    if( data.id === feed.getKey() ){
                        setFeedText();
                    }
                });

                scope.$on(SystemEvents.FEED.RESET, function(event, f){
                    if( f.getKey() === feed.getKey() ){
                        feed = f;
                        setFeedText();
                    }
                });

                scope.$watch('feed.text()', function(oldVal, newVal){
                   if(count > 0){
                    setFeedText();//skipping for first time
                   } 
                   count++;
                });

                scope.$watch('editorEnabled', function(oldVal, newVal){
                    setFeedText();//skipping for first time
                });


                function moreFeedText() {
                    feedFactory.moreFeedText(feed).then(function(json) {
                            scope[attr.rgMoreFeed] = feed;
                            element.html(feed.getDynamicText().toString());
                            moreel.unbind('click');
                            moreel=null;
                            scope.$rgDigest();
                            updatedText = true;
                        //scope.$digest();
                    });
                }



            }
        };
    }

})();


/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
        .directive('rgIncomingFeed', rgIncomingFeed);


    rgIncomingFeed.$inject = ['feedFactory', '$window','utilsFactory','OPERATION_TYPES'];
    function rgIncomingFeed(feedFactory, $window,utilsFactory,OPERATION_TYPES) {
        return {
            restrict: 'A',
            link: function(scope, element, attr) {
                var windowEl = angular.element($window)
                    ,pageValue = feedFactory.getCurrentPageValue()
                    ,extraHeight = 0
                    ,previousScrollTop
                    ,OTYPES = OPERATION_TYPES.SYSTEM;
                
                switch (pageValue.action) {
                    case OTYPES.TYPE_MY_NEWS_FEED:
                    case OTYPES.TYPE_FRIEND_NEWSFEED:
                         extraHeight = 492;break;
                    case OTYPES.TYPE_GROUP_NEWS_FEED:
                        extraHeight = 250;break;
                    case OTYPES.TYPE_SINGLE_STATUS_NOTIFICATION_OR_SHARE_DETAILS:
                    case OTYPES.TYPE_NEWS_FEED:
                    default :
                        extraHeight = 0;
                }
                function position(){
                    var scrollP = utilsFactory.viewport.yo,diff,top;

                    if(extraHeight > 0){
                        top = extraHeight + 75;
                        diff = top - scrollP;
                        if(diff > 0){
                            if(diff < 75){
                                element.css('top',75+'px');
                            }else{
                                element.css('top',diff+'px');
                            }
                            
                        }
                    }
                }
                function updateClass(){
                    if(feedFactory.hasUnprocessedFeed()){
                        if(!element.hasClass('active')){
                            element.addClass('active');
                        }
                       
                    }else{
                        element.removeClass('active');
                    }

                }

                function update(){

                     if(utilsFactory.viewport.yo >  500){
                            feedFactory.setpushInIncomingFeed(true);
                     }else{
                        if(feedFactory.hasUnprocessedFeed() && previousScrollTop > utilsFactory.viewport.yo){
                           feedFactory.processIncomingFeed();
                           feedFactory.setpushInIncomingFeed(false);
                           updateClass(); 
                        }else{
                            feedFactory.setpushInIncomingFeed(false);    
                        }
                        
                    }
                    if(element.hasClass('active')){
                        position();
                    }
                    previousScrollTop = utilsFactory.viewport.yo;
                }

                scope.$watch(feedFactory.hasUnprocessedFeed,function(newV,oldV){
                    if(newV > oldV){
                        updateClass();
                    }
                });

                

                

                element.on("click",function(){
                    feedFactory.processIncomingFeed();
                    feedFactory.setpushInIncomingFeed(false);
                    updateClass();
                   
                    utilsFactory.resetScroll();
                    utilsFactory.animateScroll();
                    
                    scope.setFeed();
                    scope.$rgDigest();
                });


                windowEl.bind("scroll", update);
                var cleanupEvents = function () {
                    windowEl.unbind('scroll', update);
                    element.off("click");
                };
                // console.log(elem.scrollTop);

                updateClass();
                scope.$on('$destroy', cleanupEvents);

            }
        };
    }

})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        console.warn("Feed Module Not Found");
        return;
    }
    feedApp.directive('feedTimeoutSelect', feedTimeoutSelect);
    feedApp.directive('feedTimoutOption', feedTimoutOption);
    feedApp.directive('feedTimeoutMenu', feedTimeoutMenu);


    function feedTimoutOption(){

        return {
            restrict: 'E',
            replace : true,
            templateUrl : 'pages/partials/feed-timeout-option.html',
            link : function(scope){
                    scope.$rgDigest();
            },
            controller : ['$scope',function($scope){

                $scope.rows = [1,9,17];
                $scope.cols = [0,1,2,3,4,5,6,7];
                $scope.lastCols = [25,26,27,28,29,30];

                $scope.select = function(v){
                    if(angular.isFunction($scope.onSelect)){
                        $scope.onSelect({item:v});
                        
                    }
                    $scope.close();
                    $scope.$parent.$rgDigest();
                }

            }]
        };

    };

    function feedTimeoutSelect(){

        return function(scope,element,attr){

            element.on("click",function(e){
                e.stopPropagation();
                scope.select(attr['feedTimeoutSelect']);
            });

            scope.$on('$destroy',function(){
                element.off("click");
            });
        };


    };

    feedTimeoutMenu.$inject = ['$document','$compile'];
    function feedTimeoutMenu($document,$compile) {
        return {
            restrict : 'A',
            scope : {
                onSelect : '&ringOnOptionSelect',
                value : '=selectedValue'
            },
            link : function(scope,element,attr){
            
                var menuDom, isOpen = false;
                
                scope.close = function(){
                    if(menuDom) menuDom.remove();
                    menuDom = null;
                    isOpen = false;
                    $document.off("click", checkClickedOnElement);
                };
                scope.$watch('value',function(newval,oldval){
                            if(parseInt(newval) > -1){
                                element.addClass('active');
                            }else{
                                element.removeClass('active');
                            }
                });

                function checkClickedOnElement(e){

                    if(e.target != element[0] && e.target.parentNode != element[0] && e.target.parentNode.parentNode != element[0] && e.target.className !='pt-top') {
                        scope.close();
                    }
                }

                element.on("click",function(event){
                        if(isOpen) {
                          scope.close();
                          return '';
                        }
                    	if(!menuDom){
                        	menuDom = $compile(angular.element('<feed-timout-option></feed-timout-option>'))(scope);
                    	}
                    	element.after(menuDom);
                    	isOpen = true;
                    	

                        $document.on("click", checkClickedOnElement);



                });

                scope.$on('$destroy', function(){
                    element.off('click');
                    $document.off("click", checkClickedOnElement);

                });
            }
        };
    };

})();

/**
 * © Ipvision
 */

(function () {
    'use strict';

    angular.module('ringid.feed')
    .directive('feedRepeat', feedRepeat);

    feedRepeat.$inject = ['$parse', '$compile', '$templateCache', '$http', 'utilsFactory','$rootScope', 'SystemEvents','$sniffer', 'feedFactory'];

    function feedRepeat($parse, $compile, $templateCache, $http, helper, $rootScope, SystemEvents, $sniffer, feedFactory) {

        function compile(element, attr) {


            return function ($scope, $element, $attr, ctrl, $transclude) {

                var expression = $attr.feedRepeat;
                var match = expression.match(/^\s*(.+)\s+in\s+(.*?)\s*$/),
                    index, lhs, rhs, trackByExp, valueIdentifier, cell, cells = [],
                    maxColumn = 3,
                    column = helper.feedColumn(),
                    lastBlockMap = Object.create(null),
                    lastCollection = [],
                    onFeedProcesing = false,
                    wrapper = document.querySelector('div.middle'),
                    feedContainer = document.getElementById('feeds-container'),
                    wh = helper.viewport.y,
                    hwh = wh/2,
                    wst = 0,
                    scrollHeight=0,
                    prefix = $sniffer.vendorPrefix.toLowerCase(),
                    doAnimation = (prefix == 'moz' || prefix == 'ms')? false: true,
                    busy = false,
                    first = true,
                    totalFeeds =0,
                    specialTpl = '',
                    specials = [],
                    readyToFeed = false,
                    lastLoader = false,
                    lastLoaderFrame = false,
                    specialBlockMap = Object.create(null),
                    elm;
                
                /*
                if (!match) {
                    throw "Expected expression in form of '_item_ in _collection track by _key_'";
                } */

                var t0 = window.performance.now();

                lhs = match[1];
                rhs = match[2];
               
                /* find getter function by parsing track by*/
                var getTrackID = (match[3])? $parse(match[3]) : '';

                valueIdentifier = match[1];

                // Creating Feed Cell
                for (index = 0; index < maxColumn; index++) {
                    cell = {};
                    elm = document.createElement('div');
                    elm.className = "cell cell-id" + index;
                    elm.appendChild(document.createComment('cell: ' + index));
                    cell.element = elm;
                
                    /*loader*/
                    var loader = document.createElement('div');

                    loader.innerHTML = '<div class="rf-box">'
                                            + '<div class="rf-top">'
                                                + '<div class="rf-cir">'
                                                     + '<span class="icon-logo-circle"></span>'
                                                + '</div>'
                                                + '<div class="rf-line"></div>'
                                                + '</div>'
                                                + '<div class="rc-feed"> </div>'
                                                + '<div class="rc-feed rc2"> </div>'
                                                + '<div class="rc-feed rc3"> </div>'
                                                + '<div class="rf-ics"></div>'
                                            + '</div>';
                                        
                    loader.style.display = 'none';
                    elm.appendChild(loader);
                    
                    cell.loader = loader;
                    cells[index] = cell;

                    /*post box*/
                    if ($scope.showPostBox() && $attr.postbox && index == 0) {
                        (function (elm) {
                            $http.get($attr.postbox, {cache: $templateCache}).then(function (result) {
                                var template = $compile(result.data)($scope);
                                //elm.firstChild appendChild(template[0]);
                                elm.insertBefore(template[0], elm.firstChild.nextSibling);
                                readyToFeed = true;
                                
                                requestAnimationFrame(function(){
                                  update($scope[rhs]);
                               }); 

                               /*digest after loading postbox*/ 
                               $scope.$rgDigest();

                            });
                        })(elm);
                    }else{
                        readyToFeed = true;
                        requestAnimationFrame(function(){
                                  update($scope[rhs]);
                        }); 
                    }
                  loader = null;
                }
                
                if($scope.showSpecialFeed()){
                $http.get("pages/partials/special-feed.html", {cache: $templateCache}).then(function (result) {
                    specialTpl = result.data;
                 });                    
                }

                

                /* append in main div*/
                for (index = 0; index < maxColumn; index++) {
                    $element[0].appendChild(cells[index].element);
                }
                

                function showLoader(display,calledFrom) { 
                   
                   if(lastLoader == display || lastLoaderFrame) return;

                   requestAnimationFrame(function(){
                      for (var index = 0; index < column; index++) {
                       if(cells && cells[index].loader) cells[index].loader.style.display = (display)?'block':'none';
                      }
                      lastLoaderFrame = false;

                      //console.log('display ='+display+' time '+ window.performance.now());
                      //console.log(calledFrom);
                      

                   });
                   
                   lastLoaderFrame = true;
                   lastLoader = display; 
                    
                }
                
                function setCellVisibility() {

                    for (var index = 0; index < maxColumn; index++) {
                        if (index < column) {
                            cells[index].element.style.display = 'block';
                        }
                        else {
                            cells[index].element.style.display = 'none';
                        }
                    }
                }

                function doColumnChange(){
                    update($scope[rhs]);
                    onScrollEvent(false);
                    busy = false;
                    showLoader(busy,"line 160");
                    setCellVisibility();
                }

                
                /*set view window*/
                wrapper.style.height = wh+'px';
                element[0].className='cols-'+column;
                setCellVisibility();
                busy = true;
                showLoader(busy,"line 170");
                
                /* calculate height*/ 
                var offsetTop = (-1)*wh*4;
                var offsetBottom = wh*4;
                var lastHeight =0;

                /* scorilling hack for refreshing issue */

                document.documentElement.scrollTop = 0;
                document.body.parentNode.scrollTop = 0;
                document.body.scrollTop = 0;

                
                function onScrollEvent(loadFeed) {
                        
                        /*request new feed*/
                        if(!readyToFeed) return;
                        if(!cells) return;

                        requestAnimationFrame(function() {
                            
                            var loadThreshold;
                            scrollHeight = $element[0].scrollHeight; 
                            loadThreshold = scrollHeight - helper.viewport.y - helper.viewport.y;
                            

                            if (helper.viewport.yo > loadThreshold && !!loadFeed) {

                                $scope.LoadMoreData();

                                if($scope.noMoreFeed) return;

                                if($scope.busy != busy) {
                                   busy = $scope.busy;  
                                   showLoader(busy,"Line 205");   
                                }
                            }
                        
                    
                            /*hide feed dom if it is out of the viewport*/ 
                            if(onFeedProcesing) return; 
                            if(Math.abs(helper.viewport.yo - wst) < hwh) return;
                            
                            var cols = [139,0,0], col, trackID, value, block, height, show = [], hide = [], pt=[0,0,0], pb=[0,0,0];  //column1 contain postbox which height is 139
                            wst = helper.viewport.yo;
                            
                            /*special feeds*/
                            
                            for (index = 0; index < specials.length; index++) {
                                value = specials[index];
                                trackID = value.key;
                                if(!specialBlockMap[trackID]) continue;

                                block = specialBlockMap[trackID];
                                if(!block) continue;
                                height = block.height;
                                col = block.cell;
                                cols[col] += height;

                                if( cols[col] >= (offsetTop + wst) &&  cols[col] <= (wst+wh+offsetBottom)) {
                                    if(!!block.clone.RG_HIDDEN) {
                                       show.push(block.clone);
                                    }  
                                } 
                                else {
                                
                                    if(cols[col] < (offsetTop + wst)) {
                                        pt[col] += height;
                                    }
                                        
                                    if(cols[col] >= (offsetTop + wst) && cols[col] > (wst+wh+offsetBottom)) {
                                        pb[col] += height; 
                                    }
                                    
                                    if(!block.clone.RG_HIDDEN) {
                                        
                                       hide.push(block.clone);
                                    }
                                }
                            }    

                            /*regular feed*/
                            for (index = 0; index < lastCollection.length; index++) {
            
                                value = lastCollection[index];
                                trackID = value.key;
                                if(!lastBlockMap[trackID]) continue;
                                block = lastBlockMap[trackID];
                                if(!block) continue;
                                height = block.height;
                                col = block.cell;
                                cols[col] += height;
                                
                                if( cols[col] >= (offsetTop + wst) &&  cols[col] <= (wst+wh+offsetBottom)) {
                                    if(!!block.clone.RG_HIDDEN) {
                                       show.push(block.clone);
                                    }  
                                } 
                                else {
                                
                                    if(cols[col] < (offsetTop + wst)) {
                                        pt[col] += height;
                                    }
                                        
                                    if(cols[col] >= (offsetTop + wst) && cols[col] > (wst+wh+offsetBottom)) {
                                        pb[col] += height; 
                                    }
                                    
                                    if(!block.clone.RG_HIDDEN) {
                                        
                                       hide.push(block.clone);
                                    }
                                }
                            }
                            
                           value = null;
                           block = null;
                           
                           var max = Math.max(Math.max.apply(null, cols),wh);
                            
                          // requestAnimationFrame(function() {
                           
                                wrapper.style.height = (max+hwh)+'px';
                                for (var i = 0; i < cells.length; i++) {
                                   cells[i].element.style.paddingTop = pt[i]+'px';
                                }
                                
                                for (var i = 0; i < show.length; i++) {
                                    show[i].style.display = 'block';
                                    show[i].RG_HIDDEN = false;
                                 }
                                  
                                for (var i = 0; i < hide.length; i++) {
                                    hide[i].style.display = 'none';
                                    hide[i].RG_HIDDEN = true;  
                                } 
                      });     
                           
                  }
                    
                window.addEventListener("scroll", onScrollEvent);
                
                $scope.$on(SystemEvents.COMMON.COLUMN_CHANGED, function(event, newVal){
                    column = newVal;
                    element[0].className='cols-'+column;
                    doColumnChange();  
                });

                $scope.$on(SystemEvents.COMMON.WINDOW_RESIZED, function(event, newVal){
                    column = helper.feedColumn();
                    element[0].className='cols-'+column;
                    doColumnChange();  
                });
               

                $scope.$watchCollection(rhs, update);
                
                
                $scope.$on('$destroy', function(){
                   lastBlockMap = lastCollection = elm = cells = cell = specialBlockMap = specials = wrapper = feedContainer = specialTpl =lastLoader = null;
                   window.removeEventListener("scroll", onScrollEvent);
                });
                
                $scope.$on(SystemEvents.FEED.HEIGHT, function($event, key){
                
                    $event.stopPropagation();
                    
                    if(!lastBlockMap || !lastBlockMap[key]) return;
                      
                    deferFeedHeight(key);
                });

                $scope.$on(SystemEvents.FEED.BUSY, function($event, isBusy){ 
                     busy = isBusy;
                     showLoader(busy,"LINE 343");
                });


                function deferFeedHeight(key){


                    fastdom.defer(3,function() {
                        if(lastBlockMap && lastBlockMap[key]) {
                           lastBlockMap[key].height = lastBlockMap[key].clone.offsetHeight + 12;  
                        }
                     });
                }
                
                function eventTranstionEnd() {
                
                  this.removeEventListener(prefix+'TransitionEnd', eventTranstionEnd);
                  this.removeEventListener('transitionend', eventTranstionEnd); 
                  this.parentNode.removeChild(this);

                }
 

                function update(collection) {
                     

                    var index, i, length = collection.length,
                        value, childScope, cellIndex, trackID, block, prevNode = [],
                        nextNode, nextBlockMap = Object.create(null), parent, clone, 
                        special = 0, initialDigest = false; //speciaSerial = false

                     onFeedProcesing = true;

                     if(!readyToFeed) return;
                     if(!cells) return;

                     if(collection.length == 0 && first) {
                        
                        if($scope.noMoreFeed) {

                            requestAnimationFrame(function(){
                                $scope.$rgDigest();
                                //initialDigest = false;
                            });
                        }
                        return;  
                     }
                     
                     
                      $rootScope.$$postDigest(function() {
                         var index, value, block;
                         for (index = 0; index < collection.length; index++) {
                            value = collection[index];
                            trackID = value.key;
                            if(!lastBlockMap[trackID]) continue;
                            block = lastBlockMap[trackID];
                            if(!block) continue;
                            if(block.childHead) block.scope.$$childHead = block.childHead;
                          }
                      }); 
                    

                    if(feedFactory.hasSpecialFeed()) {
                       specials = feedFactory.getSpecialFeedList();  
                       special = specials.length;
                    }
                    
                    

                    /* Find next Blocks that are going to be added*/
                  
                    for (index = 0; index < length; index++) {

                        cellIndex = (index+special) % column;
                        value = collection[index];    
                        trackID = value.key; // huh, considering a constant track ID

                        if (lastBlockMap[trackID]) {

                            block = lastBlockMap[trackID];
                            if(!block) continue;
                            block.cell = cellIndex;
                            delete lastBlockMap[trackID]; // found it and it is going to be processed in next blockmap and deleted it

                        } else {

                            childScope = $scope.$new();
                            childScope[valueIdentifier] = value;
                            block = {};
                            block.clone = null;
                            block.cell = cellIndex;
                            block.scope = childScope;
                            block.height = 110;
                            block.key = trackID; 
                            block.serial = -1;
                            
                        }

                        //collection[index]['$TrackID'] = trackID;
                        nextBlockMap[trackID] = block;
                    }


                    /* initialise a prev node */
                    for (index = 0; index < column; index++) {
                        if (!prevNode[index]) prevNode[index] = (index == 0 && cells[index].element.firstElementChild) ? cells[index].element.firstElementChild : cells[index].element.firstChild;
                    }

                    /* Remove blocks from existing which are not going to process*/
                    for (trackID in lastBlockMap) {
                        if (lastBlockMap[trackID]) {
                            block = lastBlockMap[trackID];
                            if(!block) continue;
                            block.clone.style.opacity =0;
                            block.clone.RG_DELETE = true;
                            
                            
                            block.clone.addEventListener(prefix+'TransitionEnd', eventTranstionEnd);
                            block.clone.addEventListener('transitionend', eventTranstionEnd);
                            
                            block.scope.$destroy();
                        }
                    }
                    
                    /* Build DOM now*/
                    var defer = 2;
                    var nodesToBeAppeard =[];


                      /* Special feeds*/
                    if(specialTpl && special > 0) {

                       for (index = 0; index < special; index++) {

                           value = specials[index];
                           trackID = value.key;
                           cellIndex = index % column;

                           nextNode = prevNode[cellIndex];
                           parent = nextNode.parentNode;  

                           if(specialBlockMap[trackID]) {
                             
                                 block = specialBlockMap[trackID];
                                 if(!block) continue;
                                 clone = block.clone;
                                 block.cell = cellIndex;

                                 if (clone != nextNode.nextSibling) {
                                   parent.insertBefore(clone, nextNode.nextSibling);  
                                 }

                                /*
                                 if(!block.serialElm) {
                                   block.serialElm = block.clone.querySelector('[feed-serial]');  
                                 } */
                                 
                                 prevNode[block.cell] = clone;
                           } 
                           else {

                               //specials[index]['$TrackID'] = trackID;
                               childScope = $scope.$new();
                               childScope[valueIdentifier] = value.value; 
                               clone = $compile(specialTpl)(childScope);
                               
                               parent.insertBefore(clone[0], nextNode.nextSibling);
                               nextNode = clone[0]; 

                               nextNode.style.opacity =1;

                               block = {};
                               block.clone = clone[0];
                               block.cell = cellIndex;
                               block.scope = childScope;
                               block.height = 110;
                               block.key = trackID; 
                               block.serial = index;
                               block.serialElm = block.clone.querySelector('[feed-serial]');
                               
                               prevNode[cellIndex] = nextNode;
                               specialBlockMap[trackID] = block;

                               (function(nextNode, block){
                                        fastdom.defer(1,function() {
                                           if(!block) return; 
                                           block.height = nextNode.offsetHeight + 12;
                                        });
                                })(nextNode, block); 
                          }

                          if(block.serialElm) {
                            block.serialElm.innerHTML = index+1;
                           // speciaSerial = true;
                          }    
                       } 
                      
                    }

                    /*regular feeds*/

                    for (index = 0; index < length; index++) {

                        value = collection[index];
                        trackID = value.key;
                        block = nextBlockMap[trackID];
                        if(!block) continue;
                        block.scope.$index = index;
                        nextNode = prevNode[block.cell];
                        parent = nextNode.parentNode;
                        clone = block.clone;
                        
                        //if(clone && clone.RG_HIDDEN) continue;

                        if (clone) {
                        
                             // skip nodes that are already pending removal via leave animation
                            do {
                                nextNode = nextNode.nextSibling;
                            } while (nextNode && nextNode.RG_DELETE);
              
                            if (clone != nextNode) {
                               parent.insertBefore(clone, nextNode);  
                            }
                            
                            prevNode[block.cell] = clone;
                            
                            block.childHead = block.scope.$$childHead;
                            block.scope.$$childHead = null;
                            
                         }  
                        else {

                             $transclude(block.scope, function (clone) {

                                parent.insertBefore(clone[0], nextNode.nextSibling);
                                nextNode = clone[0];
                                
                                (function(nextNode, block){
                                    fastdom.defer(++defer,function() {
                                       if(!block) return; 
                                       block.height = nextNode.offsetHeight + 12; // bottom margin of each 12 
                                    });
                                })(nextNode, block); 

                                if(!doAnimation || first || totalFeeds < 10) {
                                    nextNode.style.opacity =1;  
                                } 
                                else { 
                                    nodesToBeAppeard.push(nextNode);
                                }    

                                block.clone = nextNode;
                                prevNode[block.cell] = nextNode;
                                block.serialElm = block.clone.querySelector('[feed-serial]'); 
                                totalFeeds++; 
                            });
                        }
                        
                        
                        if(block.serial != (index+special) && block.serialElm) {
                           block.serialElm.innerHTML = special+index+1;
                           block.serial = index+special;
                        } 
                    }
                    
                    
                    if(nodesToBeAppeard.length> 0 ) {

                            fastdom.defer(2, function() {

                                if(!nodesToBeAppeard) return false;

                                for (index = 0; index < nodesToBeAppeard.length; index++) {
                                    nodesToBeAppeard[index].style.opacity =1;
                                }  
                                nodesToBeAppeard = null;
                            });
                     }


                    if($scope.busy != busy) {
                       busy = $scope.busy;  
                       showLoader(busy,"Line 639"); 
                       busy = null;  
                    }
                    

                    /* Updating last blockmap from current block map*/
                    lastBlockMap = nextBlockMap;
                    lastCollection = collection; 
                    onFeedProcesing = false;
                    
                    /* release ref*/
                    nextBlockMap =  null;
                    first = false;
                    block = null;
                    clone = null;
                    parent = null;
                    nextNode = null;
                    prevNode = null;
                    childScope = null;

                    if(collection.length <= 10) {
                       //initialDigest = true; 
                       requestAnimationFrame(function(){
                          $scope.$rgDigest();
                          //initialDigest = false;
                       }); 
                    }

                }
            }
        }

        return {
            restrict: 'A',
            transclude: true,
            priority: 1000,
            terminal: true,
            compile: compile
        };

    }

})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        console.warn("Feed Module Not Found");
        return;
    }

    feedApp.directive('feedLocationViewItem', feedLocationViewItem);
    function feedLocationViewItem(){
        return {
            restrict: 'E',
            scope: {
                onHover: '&',
                onSelect : '&',
                location : '='
            },
            templateUrl : 'pages/partials/feed_location/item.html',
            link : function(scope, element, attr){

                element.on("click",function(e){
                    e.stopPropagation();

                    if(!!scope.onSelect){
                        scope.onSelect({location: scope.location});
                    }
                });

                if(!!scope.onHover){
                    element.on('mouseover', function(event){
                        scope.onHover({location: scope.location})
                    });
                }

                scope.$on('$destroy',function(){
                    element.off("click");
                    element.off('mouseover');
                });

            }
        }
    }

    feedApp.directive('feedLocationView', feedLocationView);
    feedLocationView.$inject = ['utilsFactory'];
    function feedLocationView(utilsFactory){
        function eventStopPropogate(e){
            e.stopPropagation();
        }
        return {
            restrict: 'E',
            replace : true,
            templateUrl : 'pages/partials/feed_location/view.html',
            compile: function(tElement, tAttrs, transclude) {
                return {
                    pre: function preLink(scope, iElement, iAttrs, controller) {
                        scope.initLocation(iElement);
                    },
                    post: function postLink(scope, iElement, iAttrs, controller) {
                        scope.$rgDigest();
                        iElement.on("click",eventStopPropogate);
                        scope.$on("$destroy",function(){
                            iElement.off("click",eventStopPropogate);
                        })
                    }
                }

            },

            controller : ['$scope',function($scope){

                $scope.keyword = '';

                $scope.showLocationMap = true;

                $scope.suggestedLocations = [];

                $scope.loadingData = false;

                $scope.selfLocation = {};

                //function getLocationText(placeId){
                //    var place = $scope.suggestedLocations[placeId];
                //
                //    var placeText = place.description || place.name;
                //    return placeText;
                //}

                $scope.onLocationItemSelect = function(selectedItem){
                    if(angular.isFunction($scope.onItemSelect)){
                        try{                            
                            var data = { description: selectedItem.terms[0].value };    
                        }catch(e){
                            var data = { description: selectedItem.description };    
                        }                        

                        data['lat'] = 9999;
                        data['lng'] = 9999;

                        if(!!selectedItem.geometry && !!selectedItem.geometry.location){
                            data['lat'] = selectedItem.geometry.location.lat();
                            data['lng'] = selectedItem.geometry.location.lng();
                        }

                        $scope.onItemSelect({location: data});
                        $scope.$parent.$rgDigest();
                        //mouseInside();
                    }
                    $scope.close();
                };

                $scope.shareUserLocation = function(){

                     utilsFactory.getUserLocation().then(function(location){
                        if( location.sucs ){
                            
                            $scope.onItemSelect({location: location});
                            $scope.$rgDigest();        
                            $scope.close();
                            

                        }else{

                            Ringalert.show({mg: 'Unable to detect user location'}, 'error');
                        }
                        
                     })
                
                };

                $scope.onLocationItemHover = onLocationItemHover;

                var marker, map, placesService, AutoCompleteService, AutoComplete, searchInput;
                var placeInfos = {};

                $scope.initLocation = function(iElement){
                    searchInput = iElement.find('input')[0];

                    placesService = new google.maps.places.PlacesService(searchInput);
                    AutoCompleteService = new google.maps.places.AutocompleteService();
                    // AutoComplete = new google.maps.places.Autocomplete(searchInput);

                  //  $scope.mouseInside = false;

                 //   iElement.on('mouseover', onLocationViewHover);

                    //iElement.on('mouseleave', onLocationOptionMouseLeave);

                    //$scope.$watch("keyword", watchKeyword);

                    searchInput.focus();
                    utilsFactory.getUserLocation(true).then(function(location){
                        
                        $scope.selfLocation = location;

                        if( location.sucs ){
                            initMap({lat: location.lat, lng: location.lng, description : location.description });
                        }else{
                            initMap({lat: 23.772493, lng: 90.4098315, description : 'IPvision Ltd.'});
                        }
                    })
                
                    $scope.keyword = !!$scope.value ? $scope.value.description : '';

                };

                ////////////////////////

                // function onLocationViewHover(){
                //     //$scope.mouseInside = true;
                // }

                function onLocationItemHover(location){
                    //$scope.mouseInside = true;

                    try{
                        //var placeId = obj.target.attributes['data-place-id'].nodeValue;
                        updateMapPreviewByPlaceId(location.place_id);
                        showMapPreview();

                    }catch(e){

                    }
                }

                //// Private Functions

                function getPlaceInfo(placeId){
                    placesService.getDetails({ placeId: placeId }, function (place, status) {
                        if (status == google.maps.places.PlacesServiceStatus.OK) {

                            angular.extend(placeInfos[placeId], place);

                            placeInfos[placeId] = place;
                            // $scope.suggestedLocations[placeId] = angular.extend($scope.suggestedLocations[placeId], place);

                        }                        
                        updateSocpe()
                    });
                }

                var processPredictions = function(predictions, status) {
                    if (status != google.maps.places.PlacesServiceStatus.OK) {
                        console.warn(status);
                        hideLoader();
                        return;
                    }

                    resetPredictions()
                    
                    angular.forEach(predictions, function(prediction){
                        var placeId = prediction.place_id;

                        if(!placeInfos[placeId]){
                            getPlaceInfo(placeId);                                                        
                            placeInfos[placeId] = prediction;  
                                                    
                        }else{
                            angular.extend(placeInfos[placeId], prediction);
                        }
                        
                        $scope.suggestedLocations.push(placeInfos[placeId]);
                        
                    });

                    if( $scope.suggestedLocations.length > 0){
                        hideLoader();                        
                    }
                    updateSocpe();

                };

                function showLoader(){ $scope.loadingData = true; }
                function hideLoader(){ $scope.loadingData = false; }
                function showMapPreview() { $scope.showLocationMap = true; }
                function hideMapPreview() { $scope.showLocationMap = false; }
                function getPredictions(){ return $scope.suggestedLocations; }
                function resetPredictions(){ $scope.suggestedLocations = []; }
                function setPredictions(newPredictions){ $scope.suggestedLocations = newPredictions; }
                function updateSocpe(){ $scope.$rgDigest(); }
                function getMapCenterLatLngPoint(location){
                    return new google.maps.LatLng(location.lat, location.lng);
                }
                function initMap(location){                
                                    
                    var center = getMapCenterLatLngPoint( location );

                    map = new google.maps.Map(document.getElementById('feed-location-map'), {
                        center: center,
                        zoom: 13
                    });

                    if( !!location.description ){
                        AutoCompleteService.getPlacePredictions(
                            { input: location.description, 
                              rankBy : google.maps.places.RankBy.DISTANCE                              
                            }, 
                            processPredictions
                        );
                    }

                }

                //// Scope Functions

                // function onLocationOptionMouseLeave(obj){
                //     $scope.mouseInside = false;
                // }

                function updateMapPreviewByPlaceId(placeId){
                    var place = placeInfos[placeId];
                    if(place){
                        if(marker)
                            marker.setMap(null);

                        map.setCenter(place.geometry.location);

                        marker = new google.maps.Marker({
                            map: map,
                            place: {
                                placeId: placeId,
                                location: place.geometry.location
                            }
                        });

                    }
                }

                function search(searchKey){
                    resetPredictions();
                    showLoader();
                    updateSocpe();

                    AutoCompleteService.getPlacePredictions({ input: searchKey }, processPredictions);

                }


                function watchKeyword(e){
                    var newValue = e.target.value;
                    if(!!newValue && newValue.length > 3){
                        search(newValue);
                    }else{
                        resetPredictions();
                        updateSocpe();
                    }
                    $scope.keyword = e.target.value;

                }


                $scope.processKeyup = utilsFactory.debounce(watchKeyword,500);


            }]
        };

    }


    function feedLocationPreview(){
        return {
            replace : true,            
            template : '<span ng-if="!!feed.getLocationInfo().lat" ><a ng-href="{{ ::feed.getLocationUrl() }}"  rg-ringbox="true" ringbox-type="remote" ringbox-target="pages/partials/google-map-preview.html" scope-data="{url : feed.getLocationEmbedUrl() }">  <img height="170px" width="100%" ng-src="{{ ::feed.getLocationStaticEmbedUrl() }}" alt="location-hover" /> </a>'
        }
    }
    feedApp.directive('feedLocationPreview', feedLocationPreview);


})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        console.warn("Feed Module Not Found");
        return;
    }

    feedApp.directive('feedLocationMenu', feedLocationMenu);

    feedLocationMenu.$inject = ['$document','$compile', 'utilsFactory'];
    function feedLocationMenu($document,$compile, utilsFactory ) {
        return {
            restrict : 'A',
            scope : {
                onItemSelect : '&feedLocationMenuOnSelect',
                value : '=selectedValue',
                viewWidth : '@',
                viewHeight : '@',
                autoAdjust : '@'
            },
            link : function(scope,element,attr){

                var menuDom, isOpen = false, slackSpaceWidth = 20, directionProvided;

                //scope.mouseInside = true;

                scope.viewDirection = 'right';
                if(!!attr.feedLocationMenuDirection){
                    scope.viewDirection = attr.feedLocationMenuDirection;
                    directionProvided = true;
                }

                scope.viewWidth = scope.viewWidth || 600;
                scope.viewHeight = scope.viewHeight || 466;

                scope.close = function(){
                    if(menuDom) menuDom.remove();
                    menuDom = null;
                    isOpen = false;
                    //scope.mouseInside = true;
                    $document.off("click", checkClickedOnElement);

                };
                scope.$watch('value',function(newval,oldval){
                        if(!!newval.description){
                            element.addClass('active');
                        }else{
                            element.removeClass('active');
                        }
                });


                function checkClickedOnElement(e){

                     if(e.target != element[0] && e.target.parentNode != element[0] && e.target.parentNode.parentNode != element[0] && e.target.className !='pt-top') {
                        //scope.mouseInside = true;
                        scope.close();
                        if(scope.autoAdjust !== "false"){
                            adjustView(event);    
                        }
                    }
                        
                   

                }

                function adjustView(event){

                    window.eventFix(event); /** Add Polyfill for `pageX`, `pageY` **/

                    var viewportSize = utilsFactory.viewportsize();

                    if( !directionProvided && (event.pageY + scope.viewHeight + slackSpaceWidth > viewportSize.y) ){
                        window.scrollToYOffset(event.pageY - viewportSize.y/2, 500);
                    }

                    if( event.pageX + scope.viewWidth + slackSpaceWidth > viewportSize.x - 200 ){
                        scope.viewDirection += ' left';
                    }

                }

                element.on("click",function(event){

                        if(isOpen) {
                          scope.close();
                          return '';
                        }
                        if(scope.autoAdjust !== "false"){
                            adjustView(event);    
                        }
                        


                    	if(!menuDom){
                        	menuDom = $compile(angular.element('<feed-location-view></feed-location-view>'))(scope);
                    	}
                    	element.after(menuDom);
                    	isOpen = true;

                        $document.on("click", checkClickedOnElement);

                });



                scope.$on('$destroy', function(){
                    if(menuDom) menuDom.remove();
                    element.off('click');
                    $document.off("click", checkClickedOnElement);

                });
                scope.$rgDigest();
            }
        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
        .factory('LikeHttpService',LikeHttpService)
        .controller('LikeController',LikeController)
        .controller('WhoLikeController',WhoLikeController)
        //.directive('rgImageLike', rgImageLike)
        .directive('rgLikes', rgLikes)
        .directive('rgLikerAnchor', rgLikerAnchor)
        .directive('rgWhoLike', rgWhoLike)
        .directive('rgLikerButton', rgLikerButton);



        LikeHttpService.$inject = ['$$connector','OPERATION_TYPES'];
        function LikeHttpService($$connector,OPERATION_TYPES){
                  var OTYPES = OPERATION_TYPES.SYSTEM,ob;

                    ob = {
                        likeUnlike : likeUnlike,
                        likeUnlikeComment : likeUnlikeComment,
                        fetchWhoLikes : fetchWhoLikes,
                        fetchWhoLikesComment : fetchWhoLikesComment
                      //  getPeopleDetails : getPeopleDetails
                    };

                function likeUnlike(ob){
                    var payload = {};
                        switch(ob.type){
                            case 'feed':
                                payload.actn = ob.il === 1 ? OTYPES.TYPE_LIKE_STATUS : OTYPES.TYPE_UNLIKE_STATUS
                                break;
                            case 'image':
                                payload.actn = OTYPES.IMAGE.TYPE_LIKE_IMAGE;
                                payload.imgId = ob.target.getKey();
                                payload.lkd = ob.il;
                                break;
                            case 'media':
                                payload.actn = OTYPES.MEDIA.ACTION_LIKE_UNLIKE_MEDIA;
                                payload.cntntId= ob.target.getKey();
                                payload.lkd = ob.il;
                                break;
                            default:
                               throw new Error("comment type not familiar");
                         };
                         if(ob.target.getFeedKey()){
                           payload.nfId = ob.target.getFeedKey();
                         }
                    return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
                 }
                 function likeUnlikeComment(ob){
                     var payload = {};
                        switch(ob.type){
                            case 'feed':
                                  payload.actn = ob.il ? OTYPES.TYPE_LIKE_COMMENT : OTYPES.TYPE_UNLIKE_COMMENT;
                                  payload.nfId = ob.key;
                                break;
                            case 'image':
                                  payload.actn = OTYPES.IMAGE.TYPE_LIKE_UNLIKE_IMAGE_COMMENT;
                                  payload.imgId = ob.key;
                                  payload.lkd = ob.il;
                                break;
                            case 'media':
                                  payload.actn = OTYPES.MEDIA.ACTION_LIKE_UNLIKE_MEDIA_COMMENT;
                                  payload.cntntId= ob.key;
                                  payload.lkd = ob.il;
                                break;
                            default:
                               throw new Error("comment type not familiar");
                         }
                         if(ob.parentKey){
                          payload.nfId = ob.parentKey;
                         }

                      payload.cmnId = ob.target.getKey();
                    return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
                 }
                 function fetchWhoLikesComment(ob){
                    var payload = {};
                        switch(ob.type){
                            case 'feed':
                                  payload.actn = OTYPES.TYPE_LIST_LIKES_OF_COMMENT;
                                  payload.nfId = ob.key;
                                break;
                            case 'image':
                                  payload.actn = OTYPES.IMAGE.TYPE_IMAGE_COMMENT_LIKES;
                                  payload.imgId = ob.key;
                                break;
                            case 'media':
                                  payload.actn = OTYPES.MEDIA.ACTION_MEDIACOMMENT_LIKE_LIST;
                                  payload.cntntId= ob.key;
                                break;
                            default:
                               throw new Error("comment type not familiar");
                         }
                         if(ob.parentKey){
                          payload.nfId = ob.parentKey;
                         }

                           payload.st = ob.st || 0;

                      payload.cmnId = ob.target.getKey();
                    return $$connector.pull(payload,OTYPES.REQUEST_TYPE.REQUEST);
                 }
                function fetchWhoLikes(ob){
                    var payload = {};
                    switch(ob.type){
                        case 'feed':
                            payload.actn = OTYPES.TYPE_LIKES_FOR_STATUS;
                            payload.nfId = ob.target.getKey();
                            break;
                        case 'image':
                            payload.actn = OTYPES.IMAGE.TYPE_LIKES_FOR_IMAGE;
                            payload.imgId = ob.target.getKey();
                            break;
                        case 'media':
                            payload.actn = OTYPES.MEDIA.ACTION_MEDIA_LIKE_LIST;
                            payload.cntntId = ob.target.getKey();
                            break;
                        //case 'media':break; // check for media fetch comment
                        default:
                           throw new Error("comment type not familiar");
                     }
                      if(ob.target.getFeedKey()){
                           payload.nfId = ob.target.getFeedKey();
                         }
                         payload.st = ob.st || 0;


                    return $$connector.pull(payload,OTYPES.REQUEST_TYPE.REQUEST);
                 }
                 // function getPeopleDetails(utids){
                 //    return $$connector.pull({
                 //      actn : OTYPES.FRIENDS.TYPE_PEOPLE_YOU_MAY_KNOW_DETAILS,
                 //      idList : utids
                 //    },OTYPES.REQUEST_TYPE.REQUEST);
                 // }

          return ob;
        }

        WhoLikeController.$inject = ['$scope','LikeHttpService','rgScrollbarService','userFactory','friendsFactory','InviteFactory','Auth'];
        function WhoLikeController($scope,LikeHttpService,rgScrollbarService,userFactory,friendsFactory,InviteFactory,Auth){
             $scope.loading = true;
             $scope.users = [];
             $scope.contactListAction = function(actionObj) {
                 if (!actionObj.friend.isLoading()) {
                     friendsFactory.friendAction(actionObj, true).then(function() {
                         $scope.$rgDigest();
                     }, function() {
                         $scope.$rgDigest();
                     });
                    $scope.$rgDigest();
                 }
             };
             $scope.isCurrentUser = function(user){
                return user.equals(Auth._currentUser);
             };

            $scope.loadmore = function () {
                if(!$scope.loading){
                    loadMoreUser();
                }
            };

             function loadMoreUser(){
              var reqData,reqFn = 'fetchWhoLikes';
                if($scope.users.length < $scope.target.getTotalLikes()){
                  reqData = {
                            target : $scope.target,
                            type : $scope.likeType,
                            st : $scope.users.length
                       };
                    if($scope.likeComment == 'true'){
                      reqFn = 'fetchWhoLikesComment';
                      reqData.parentKey = $scope.targetOwner();
                      reqData.key = $scope.targetParent();
                       // promise = LikeHttpService.fetchWhoLikesComment({
                       //    target : $scope.target,
                       //     type : $scope.likeType,
                       //     key : $scope.targetParent(),
                       //     parentKey : $scope.targetOwner(),
                       //     st : $scope.users.length
                       //   });
                    }
                    $scope.loading = true;
                    // if($scope.likeType === 'feed' && $scope.target.isSingleContentFeed()){
                    //    reqData.target = $scope.target.getSingleContent();
                    //    reqData.type = $scope.target.getContentType();
                    // }
                    LikeHttpService[reqFn](reqData).then(function(json){
                        //console.log(json);
                                  $scope.loading = false;
                                  if(!json.sucs){
                                     $scope.$close();return;
                                  }
                                  var i,usr;
                                  //var utids = [];
                                  for( i=0;i < json.likes.length;i++){
                                     //utids[i] = json.likes[i].utId;
                                     usr = userFactory.createByUtId(json.likes[i],true,true);
                                    $scope.users.push(usr);
                                    usr.commonFriends(true,true).then(function(){
                                       $scope.$rgDigest();
                                     });
                                  }
                                    rgScrollbarService.recalculate($scope);
                                  $scope.$rgDigest();
                                  // LikeHttpService.getPeopleDetails(utids).then(function(json){
                                  // });
                                },function(reason){
                                  $scope.$close();
                                },function(json){
                                  //$scope.$close();
                                });
                }
             }
             loadMoreUser();

            $scope.getMutualFriend = function(user) {

                return{
                    data: function() {
                        return {
                            target: user
                        };
                    },
                    promise: InviteFactory.getMutualFriend(user)
                };
            };

        }

LikeController.$inject = ['$scope','LikeHttpService','Ringalert','$ringbox','feedFactory'];
function LikeController($scope,LikeHttpService,Ringalert,$ringbox,feedFactory){

    $scope.anchorCallback = angular.noop;
    $scope.buttonCallback = angular.noop;

    function failedLike(reason){
              $scope.target.like(true,reason.loc ? reason.loc : false);
              Ringalert.show(reason, 'error');
              $scope.anchorCallback.call(null,$scope.target.like());
              $scope.buttonCallback.call(null,$scope.target.like());
              $scope.$rgDigest();
          }
    $scope.LikeUnlike = function(){
          var reqData,reqFn = 'likeUnlike';
             reqData = {
              target : $scope.target,
              type : $scope.likeType
            };
          if($scope.likeComment == 'true'){
              reqFn = 'likeUnlikeComment';
              reqData.parentKey = $scope.targetOwner();
              reqData.key = $scope.targetParent();
             //  promise = LikeHttpService.likeUnlikeComment({
             //       target : $scope.target,
             //       type : $scope.likeType,
             //       key : $scope.targetParent(),
             //       parentKey : $scope.targetOwner()
             // });
          }
          reqData.il = $scope.target.like(true);
          $scope.anchorCallback.call(null,reqData.il);
          $scope.buttonCallback.call(null,reqData.il);
          LikeHttpService[reqFn](reqData).then(function(json){
              if(!json.sucs){
                failedLike(json);
              }else{
                if($scope.likeType !== 'feed' && $scope.likeComment !== 'true'){
                  if(json.nfId){
                   var sc = feedFactory.synchLike(json.nfId,reqData.il,json.loc);
                     if(sc){sc.$rgDigest();}
                  }

                }
              }

          },failedLike);
        $scope.$rgDigest();
    };
    $scope.$watch('target', function(newValue) {
          $scope.anchorCallback.call(null,newValue.like());
          $scope.buttonCallback.call(null,newValue.like(),true);
    });
    $scope.showWhoLike = function(){
      if(!$scope.target.getTotalLikes())return;
        var boxInstance = $ringbox.open({
                              type : 'remote',
                              scope:$scope,
                              controller: 'WhoLikeController',
                              templateUrl : 'pages/home/wholikes.html'
                          });

               // boxInstance.result.then(function(updatedFeed){
               //   if(!!updatedFeed){
               //      $scope.feed = updatedFeed;
               //   }
               // });
    }


}






    rgLikerButton.$inject = [];
    function rgLikerButton(){
        return {
          restrict: 'E',
          require: '^rgLikes',
          replace : true,
          template : '<a><i class="lc-ico"></i><b>Like</b></a>',
          link: function(scope, elem, attrs, parentCtrl) {


             function iLikeChange(v,stopAnimation){
                if(v){
                   // elem.addClass('active');
                    //var el = angular.element('');
                    // if(!stopAnimation){
                      elem[0].firstChild.className = elem[0].firstChild.className.replace
      ( "icon-like" , '' ).trim();
      elem[0].firstChild.className = elem[0].firstChild.className.replace
      ( "icon-like-h", '' ).trim();
                       elem[0].firstChild.className += ' icon-like-h';
                       
                       if(!stopAnimation){
                         elem[0].firstChild.innerHTML = '<span class="like-ani"></span>';
                         window.setTimeout(function(){
                            if(elem){
                              elem[0].firstChild.innerHTML = '';
                            }
                         },2000);
                       }

                   //  }

                }else{
                  elem[0].firstChild.className = elem[0].firstChild.className.replace
      ( "icon-like-h", '' ).trim();
      elem[0].firstChild.className = elem[0].firstChild.className.replace
      ( "icon-like", '' ).trim();
      elem[0].firstChild.className += ' icon-like';
                  //elem.removeClass('active');
                }
             }
             scope.buttonCallback = iLikeChange;
             iLikeChange(scope.target.like(),true);
             elem.bind('click',scope.LikeUnlike);
             scope.$on('$destroy',function(){
                elem.unbind("click",scope.likeUnlike);
             });
          }
        }
    }
    rgLikerAnchor.$inject = [];
    function rgLikerAnchor(){
        return {
          restrict: 'E',
          require: '^rgLikes',
          replace : true,
          template : '<a class="lcs_button ">Like</a>',
          link: function(scope, elem, attrs, parentCtrl) {
             elem.bind('click',scope.LikeUnlike);
             scope.$on('$destroy',function(){
                elem.unbind("click",scope.likeUnlike);
             });
          }
        }
    }

    rgWhoLike.$inject = ['$ringbox'];
    function rgWhoLike($ringbox){
        return {
          restrict: 'E',
          require: '^rgLikes',
          replace : true,
          template : '<a class="lcs_button ">{{target.getTotalLikes()}}</a>',
          link: function(scope, elem, attrs, parentCtrl) {
             elem.bind('click',scope.showWhoLike);
             scope.$on('$destroy',function(){
                elem.unbind("click",scope.showWhoLike);
             });
          }
        }
    }



        rgLikes.$inject = [];
        function rgLikes() {
            return {
                restrict: 'EA',
                scope : {
                    target : '=',
                    likeType : '@', // string feed,image,media
                    targetParent : '&',
                    targetOwner : '&',
                    likeComment : '@'
                },
                controller : 'LikeController',
                template : '<rg-liker-button></rg-liker-button><rg-who-like></rg-who-like>',
                link : function(scope,element,attr){
                       function iLikeChange(iLikeValue){ //
                          if(iLikeValue){
                            element.addClass('active');
                          }else{
                            element.removeClass('active');
                          }
                       }
                       scope.anchorCallback = iLikeChange;
                       iLikeChange(scope.target.like());
                       scope.$watch('target.like()',function(){
                          iLikeChange(scope.target.like());
                          scope.buttonCallback.call(null,scope.target.like(),true);
                       });
                }
            };
        }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
    .factory('CommentHttpService',CommentHttpService)
    .controller('CommentsController',CommentsController)
    .directive('rgComments', rgComments)
    .directive('rgImageComments', rgImageComments);
    CommentHttpService.$inject = ['$$connector','OPERATION_TYPES']
    function CommentHttpService($$connector,OPERATION_TYPES){
        var OTYPES = OPERATION_TYPES.SYSTEM,ob;
        ob = {
            getComment : getComment,
            getComments : getComments,
           // likeUnlike : likeUnlike,
            addComment : addComment,
            updateComment : updateComment,
            deleteComment : deleteComment,
          //  fetchWhoLikes : fetchWhoLikes,
            getUpdateFilter : getUpdateFilter
          };
        /**
         * @descripion : for failure test this code can be blocked after testing
         * @return {[type]} [description]
         */
        // function fakePromise(){
        //     var defer = $q.defer();
        //     setTimeout(function(){
        //         defer.reject({
        //             sucs : false,
        //             mg : "not processed successfully"
        //         });
        //     });
        //     return defer.promise;
        //  }



        function getComment(ob) {
            var payload = {};
            switch(ob.type){
                case 'feed':
                    payload.cmntT = 1;
                    payload.nfId = ob.key;
                    break;
                case 'image':
                    payload.cmntT = 2;
                    payload.imgId = ob.key;
                    break;
                case 'media':
                    payload.cmntT = 3;// note : make sure for media its three
                    payload.cntntId = ob.key;
                    break;
                default:
                   throw new Error("comment type not familiar");
             }
            payload.actn = OTYPES.ACTION_GET_FULL_COMMENT;
            payload.cmnId = ob.commentId;
            return $$connector.request(payload,OTYPES.REQUEST_TYPE.REQUEST);
         }
        function getComments(ob,timeOffset,before){
            var scl,
            payload = {};
            if(!ob.key || !ob.type){
                throw new Error("key and type must needed for fetcing comment");
            }
            switch(ob.type){
                case 'feed':
                    payload.actn = OTYPES.TYPE_COMMENTS_FOR_STATUS;
                    payload.nfId = ob.key;
                    break;
                case 'image':
                    payload.actn = OTYPES.IMAGE.TYPE_COMMENTS_FOR_IMAGE;
                    payload.imgId = ob.key;
                    if(ob.target.getFeedKey()){
                        payload.nfId = ob.target.getFeedKey();
                    }
                    break;
                case 'media':
                    payload.actn = OTYPES.MEDIA.ACTION_MEDIA_COMMENT_LIST;
                    payload.cntntId = ob.key;
                    if(ob.target.getFeedKey()){
                          payload.nfId = ob.target.getFeedKey();
                    }
                    break; // check for media fetch comment
                default:
                   throw new Error("comment type not familiar");
             }

             if(timeOffset){
                // 1 for b efore currentTm Comments, 2 for bellow currentTm Comments note : but in this case somehow its inverse lol
                payload.scl = !!before ? before : 1;
                payload.tm = timeOffset;
             }else{
                payload.st = ob.st || 0;
             }
             return $$connector.pull(payload, OTYPES.REQUEST_TYPE.REQUEST);
         }
        // function likeUnlike(ob){
        //     var payload = {};
        //         switch(ob.type){
        //             case 'feed':
        //                 payload.actn = ob.il ? OTYPES.TYPE_LIKE_COMMENT : OTYPES.TYPE_UNLIKE_COMMENT;
        //                 payload.nfId = ob.key;
        //                 break;
        //             case 'image':
        //                 payload.actn = OTYPES.IMAGE.TYPE_LIKE_UNLIKE_IMAGE_COMMENT;
        //                 payload.imgId = ob.key;
        //                 payload.lkd = ob.il;
        //                 if(ob.target.getFeedKey()){
        //                   payload.nfId = ob.target.getFeedKey();
        //                 }
        //                 break;
        //             case 'media':
        //                 payload.actn = OTYPES.MEDIA.ACTION_LIKE_UNLIKE_MEDIA_COMMENT;
        //                 payload.cntntId= ob.key;
        //                 payload.lkd = ob.il;
        //                 if(ob.target.getFeedKey()){
        //                   payload.nfId = ob.target.getFeedKey();
        //                 }
        //                 break;
        //             default:
        //                throw new Error("comment type not familiar");
        //          };
        //     payload.cmnId = ob.commentId;
        //     return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
        //  }
        function addComment(ob){
            var payload = {};
            switch(ob.type){
                case 'feed':
                    payload.actn = OTYPES.TYPE_ADD_STATUS_COMMENT;
                    payload.nfId = ob.key;
                    break;
                case 'image':
                    payload.actn = OTYPES.IMAGE.TYPE_ADD_IMAGE_COMMENT;
                    payload.imgId = ob.key;
                    if(ob.target.getFeedKey()){
                       payload.nfId = ob.target.getFeedKey();
                    }
                    break;
                case 'media':
                    payload.actn = OTYPES.MEDIA.ACTION_ADD_COMMENT_ON_MEDIA;
                    payload.cntntId = ob.key;
                    if(ob.target.getFeedKey()){
                      payload.nfId = ob.target.getFeedKey();
                    }
                    break;
                default:
                   throw new Error("comment type not familiar");
             }
             payload.cmn = ob.text.utf8Encode();
             return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
         }
        function updateComment(ob){
            var payload = {};
            switch(ob.type){
                case 'feed':
                    payload.actn = OTYPES.TYPE_EDIT_STATUS_COMMENT;
                    payload.nfId = ob.key;
                    break;
                case 'image':
                    payload.actn = OTYPES.IMAGE.TYPE_EDIT_IMAGE_COMMENT;
                    payload.imgId = ob.key;
                    break;
                case 'media':
                    payload.actn = OTYPES.MEDIA.ACTION_EDIT_COMMENT_ON_MEDIA;
                    payload.cntntId = ob.key;
                    break;
                //case 'media':break; // check for media fetch comment
                default:
                   throw new Error("comment type not familiar");
             }
            payload.cmnId = ob.commentId;
            payload.cmn = ob.text.utf8Encode();;
            return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
         }
        function deleteComment(ob){
            var payload = {};
            switch(ob.type){
                case 'feed':
                    payload.actn = OTYPES.TYPE_DELETE_STATUS_COMMENT;
                    payload.nfId = ob.key;
                    break;
                case 'image':
                    payload.actn = OTYPES.IMAGE.TYPE_DELETE_IMAGE_COMMENT;
                    payload.imgId = ob.key;
                    break;
                case 'media':
                    payload.actn = OTYPES.MEDIA.ACTION_DELETE_COMMENT_ON_MEDIA;
                    payload.cntntId = ob.key;
                    break;
                //case 'media':break; // check for media fetch comment
                default:
                   throw new Error("comment type not familiar");
             }
            payload.cmnId = ob.commentId;
            return $$connector.request(payload,OTYPES.REQUEST_TYPE.UPDATE);
         }
        // function fetchWhoLikes(ob){
        //     var payload = {};
        //     switch(ob.type){
        //         case 'feed':
        //             payload.actn = OTYPES.TYPE_LIST_LIKES_OF_COMMENT;
        //             payload.nfId = ob.key;
        //             break;
        //         case 'image':
        //             payload.actn = OTYPES.IMAGE.TYPE_IMAGE_COMMENT_LIKES;
        //             payload.imgId = ob.key;
        //             if(ob.target.getFeedKey()){
        //                payload.nfId = ob.target.getFeedKey();
        //             }
        //             break;
        //         case 'media':
        //             payload.actn = OTYPES.MEDIA.ACTION_MEDIACOMMENT_LIKE_LIST;
        //             payload.cntntId = ob.key;
        //             if(ob.target.getFeedKey()){
        //                   payload.nfId = ob.target.getFeedKey();
        //             }
        //             break;
        //         //case 'media':break; // check for media fetch comment
        //         default:
        //            throw new Error("comment type not familiar");
        //      }
        //     payload.cmnId = ob.commentId;
        //     return $$connector.pull(payload,OTYPES.REQUEST_TYPE.REQUEST);
        //  }



         function getUpdateFilter(type,value){
            var mainActionsSet,key,
                actionUpdateFeedSet = [OTYPES.TYPE_UPDATE_ADD_STATUS_COMMENT,OTYPES.TYPE_UPDATE_LIKE_COMMENT,OTYPES.TYPE_UPDATE_UNLIKE_COMMENT,OTYPES.TYPE_UPDATE_DELETE_STATUS_COMMENT,OTYPES.TYPE_UPDATE_EDIT_STATUS_COMMENT],
                actionUpdateImageSet = [OTYPES.IMAGE.TYPE_UPDATE_ADD_IMAGE_COMMENT,OTYPES.IMAGE.TYPE_UPDATE_LIKE_UNLIKE_IMAGE_COMMENT,OTYPES.IMAGE.TYPE_UPDATE_EDIT_IMAGE_COMMENT,OTYPES.IMAGE.TYPE_UPDATE_DELETE_IMAGE_COMMENT],
                actionUpdateMediaSet = [OTYPES.MEDIA.ACTION_UPDATE_ADD_MEDIA_COMMENT,OTYPES.MEDIA.ACTION_UPDATE_LIKE_UNLIKE_MEDIA_COMMENT,OTYPES.MEDIA.ACTION_UPDATE_EDIT_MEDIA_COMMENT,OTYPES.MEDIA.ACTION_UPDATE_DELETE_MEDIA_COMMENT];
                switch(type){
                    case 'feed' : mainActionsSet =  actionUpdateFeedSet;key = 'nfId'; break;
                    case 'image' : mainActionsSet = actionUpdateImageSet;key = 'imgId';break;
                    case 'media' : mainActionsSet = actionUpdateMediaSet;key = 'cntntId'; break;
                    default :
                        return [1111111];// a never matching action
                };
                return function(message){
                       return mainActionsSet.indexOf(message.actn) !== -1 && message[key] === value;
                }
         }



        return ob;
    }

    CommentsController.$inject = ['$scope','$$connector','Ringalert','utilsFactory','CommentHttpService','Auth',
                          '$$stackedMap','$$commentMap','rgDropdownService','OPERATION_TYPES','rgScrollbarService','feedFactory']

    function CommentsController($scope,$$connector,Ringalert,utilsFactory,CommentHttpService,Auth,
                        $$stackMap,$$commentMap,rgDropdownService,OPERATION_TYPES,rgScrollbarService,feedFactory){

        var commentSubsriberKey,OTYPES = OPERATION_TYPES.SYSTEM,loadingTimeout,firstTimeChangedTarget = false;
        $scope.comments = $$stackMap.createNew(true, 'asc');//comment map for feed initialization//$scope.target.getComments();// every
        $scope.loadingComment = false;
        $scope.canComment = true;
        $scope.commentEditorEnabled = false;
        $scope.commentKey = '';
        $scope.commenttext = '';
        $scope.ddCommentHtml = 'pages/dropdowns/comment-edit-dropdown.html';//$templateCache.get('comment-edit-dropdown.html');
        $scope.previousComment = !!$scope.target.getTotalComment();
        $scope.afterComment = true;
        $scope.models = {
                commentedittext: ""
            };
        $scope.currentUser = Auth.currentUser();
        $scope.openRingboxLike = function(comment){
            return comment.getTotalLikes() > 0;
        }
        $scope.loadMoreComment = loadMoreComment;
        $scope.loadPreviousComment = loadPreviousComment;
        $scope.addComment =addComment;
        $scope.updateComment = updateComment;

         if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
             if($scope.target.getMedias().length() || $scope.target.getAudios().length()){
                $scope.likeType = 'media';
             }else if($scope.target.getImages(true).length()){
                $scope.likeType = 'image';
             }
             $scope.parentKey = $scope.target.getSingleContent().getKey();
         }else{
             $scope.likeType = $scope.commentType;
             $scope.parentKey = $scope.target.getKey();
         }

      //  $scope.like = likeUnlikeComment;
    //    $scope.fetchWhoLikes = fetchWhoLikes;
        $scope.hideScroll = !!$scope.hideScroll && $scope.hideScroll !== 'false';
        $scope.showPreviousButton = function(){
             return ($scope.target.getTotalComment() > $scope.comments.length() && $scope.previousComment) && !$scope.loadingComment;
        };
        $scope.showMoreButton = function(){
             return ($scope.target.getTotalComment() > $scope.comments.length() && $scope.afterComment) && !$scope.loadingComment;
        };
        $scope.cancelEdit = function(){
            $scope.commentEditorEnabled = false;
            safeDigest()
        };
        $scope.commentContentEdit  = function(com){
            return function(){
                return com.getDynamicText();
            };
        };
        $scope.actionCommentDropdown = function (actionObj) {
            rgDropdownService.close(actionObj.event);
            //actionObj.event.preventDefault();
            switch (actionObj.action) {
                case 'edit':
                    //console.log('edit');
                    enableCommentEditor(actionObj.commentMap.getKey(), actionObj.commentMap.text());
                    break;
                case 'delete':
                    //console.log(actionObj.commentInfo);
                    deleteComment(actionObj.commentMap);
                    break;
                default:
            }
           // $scope.$parent.$rgDigest();
        };

        //replaced
        function safeDigest(){
            if($scope.$parent && $scope.$parent.$id !== 1){
                $scope.$parent.$rgDigest();
            }else{
                $scope.$rgDigest();
            }
        }
        function enableCommentEditor(commentKey, commentText) {
            if (commentKey) {
                $scope.commentEditorEnabled = true;
                $scope.commentKey = commentKey;
                $scope.models.commentedittext = commentText;
                safeDigest();
            }
        };

        function setLoading(val){
            $scope.loadingComment = val;
            if(loadingTimeout){
                window.clearTimeout(loadingTimeout);
                loadingTimeout = undefined;
            }
         }



        function setupInitials(){
               commentSubsriberKey = $$connector.subscribe(function(json){
                        switch(json.actn){
                            case OTYPES.TYPE_UPDATE_ADD_STATUS_COMMENT :
                            case OTYPES.IMAGE.TYPE_UPDATE_ADD_IMAGE_COMMENT :
                            case OTYPES.MEDIA.ACTION_UPDATE_ADD_MEDIA_COMMENT :
                                pushComments({comments:[json]});
                                  break;
                            case OTYPES.TYPE_UPDATE_EDIT_STATUS_COMMENT:
                            case OTYPES.IMAGE.TYPE_UPDATE_EDIT_IMAGE_COMMENT:
                            case OTYPES.MEDIA.ACTION_UPDATE_EDIT_MEDIA_COMMENT:
                                 var com = $scope.comments.get(json.cmnId);
                                    if(com){
                                        com.setComment(json.cmn);
                                    }
                                    break;
                            case OTYPES.TYPE_UPDATE_LIKE_COMMENT:
                            case OTYPES.TYPE_UPDATE_UNLIKE_COMMENT:
                            case OTYPES.IMAGE.TYPE_UPDATE_LIKE_UNLIKE_IMAGE_COMMENT:
                            case OTYPES.MEDIA.ACTION_UPDATE_LIKE_UNLIKE_MEDIA_COMMENT:
                                var com = $scope.comments.get(json.cmnId);
                                    if(com){
                                        com.incomingLike(json.loc);
                                    }
                                    break;
                            case OTYPES.TYPE_UPDATE_DELETE_STATUS_COMMENT:
                            case OTYPES.IMAGE.TYPE_UPDATE_DELETE_IMAGE_COMMENT:
                            case OTYPES.MEDIA.ACTION_UPDATE_DELETE_MEDIA_COMMENT:
                                $scope.comments.remove(json.cmnId);

                        };
                        safeDigest();
                },{
                    filter : CommentHttpService.getUpdateFilter($scope.commentType,$scope.target.getKey())
                });
               $scope.$on("$destroy",function(){
                        if(commentSubsriberKey){
                            $$connector.unsubscribe(commentSubsriberKey);
                        }
                        commentSubsriberKey = false;
                });
         }


        function loadPreviousComment(force){
            var comment,timeOffset = false;
            if($scope.comments.length()) {
                comment = $scope.comments.getByIndex(0);
                timeOffset = comment.getTimestamp();
            }
            fetchComments(timeOffset,2,force);
         }
         function processPreviousComment(json){
            var arr = [],lowestComment;
            if(!json.comments){return; }
            if(json.comments.length > 5 && $scope.target.getTotalComment() > ($scope.comments.length() + json.comments.length)){
                 json.comments.sort(function(a,b){
                    return a.tm > b.tm ? 1 : -1;
                });
                 json.comments.splice(0,1);
                pushComments({comments : json.comments});
                $scope.previousComment = true;
            }else{
                $scope.previousComment = false;
                pushComments(json);
            }
         }

         function loadMoreComment(){
            var timeOffset = false;
            if(parseInt($scope.activeCommentId) > 0){
                var comment;
                if($scope.comments.length()) {
                    comment = $scope.comments.getByIndex(($scope.comments.length() -1));
                    timeOffset = comment.getTimestamp();
                }
            }
            fetchComments(timeOffset,1);
         }

         function processAfterComment(json){
            var arr = [],lowestComment;
            if(!json.comments){return; }
            if(json.comments.length > 5 && $scope.target.getTotalComment() > ($scope.comments.length() + json.comments.length)){
                json.comments.sort(function(a,b){
                    return a.tm < b.tm ? 1 : -1;
                });
                json.comments.splice(0,1);
                pushComments({comments : json.comments});
                $scope.afterComment = true;
            }else{
                $scope.afterComment = false;
                pushComments(json);
            }
         }
         function initialCommentRequest(){
            if(parseInt($scope.activeCommentId) > 0){
                var type = $scope.commentType,target = $scope.target;

                if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                        target = $scope.target.getSingleContent();
                        type = $scope.target.getContentType();
                }
                CommentHttpService.getComment({
                    key : target.getKey(),
                    type : type,
                    commentId : parseInt($scope.activeCommentId)

                }).then(function(json){
                    if(json.sucs){
                          pushComments({comments:[json.cmntDTO]});
                          loadMoreComment();
                          setTimeout(function(){
                            loadPreviousComment(true);
                        },500);

                       }else{
                        $scope.activeCommentId = 0;
                        fetchComments();
                       }
                       safeDigest();
                },function(reason){
                    fetchComments();
                });
            }else{
                fetchComments();
                $scope.afterComment = false;
            }
         }
        function fetchComments(timeOffset,before,force){
            if(!$scope.target.getTotalComment() || ((before ===2 && !$scope.showPreviousButton()) || (before ===1 && !$scope.showMoreButton())) && !force){
                 return;
            }
            setLoading(true);
            var type = $scope.commentType,target = $scope.target;

            if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                    target = $scope.target.getSingleContent();
                    type = $scope.target.getContentType();
            }

            loadingTimeout = setTimeout(setLoading.bind($scope,false),
                 3000);
            CommentHttpService.getComments({
                key : target.getKey(),
                type : type,
                st : $scope.comments.length(),
                target : target
            },timeOffset,before).then(function(json){
             if(json.sucs){
                if(parseInt($scope.activeCommentId)){
                    if(before === 2){ // previous comment
                        processPreviousComment(json);
                    }else{ // after comment
                        processAfterComment(json);
                    }
                 }else{
                    pushComments(json);
                 }
             }
                 setLoading(false);
                 safeDigest();
            },function(json){
            },function(json){
            });
            safeDigest();
         }
        function pushComments(message){
             var commentMap,i;
             for (i = 0; i < message.comments.length; i++) {
                commentMap = $$commentMap.create(message.comments[i]);
                $scope.comments.save(commentMap.getKey(), commentMap);
             }
         }

         // function faildAddComment(){
         //        $scope.comments.remove(cmnId);
         //        $scope.canComment = true;
         //        Ringalert.show(json,'error');
         //        $scope.commenttext = text;
         //        safeDigest();
         // }

        function addComment(){
            var text = $scope.commenttext,cmnId,commData,target = $scope.target,type=$scope.commentType;
                $scope.canComment = false;
                if (validateComment()) {
                    cmnId = utilsFactory.getUniqueID();//generating unique key for further identification
                    commData = {
                        cmnId: cmnId,
                        cmn: text,
                        deleted: false,
                        isNew: true,
                        edited: false,
                        //nfId: key,
                        pending: true// setting status pending to showing 50% opacity
                    };
                    if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                        target = $scope.target.getSingleContent();
                        type = $scope.target.getContentType();
                    }
                    $scope.comments.add(cmnId,$$commentMap.create(commData,$scope.currentUser));
                    CommentHttpService.addComment({
                        key : target.getKey(),
                        type : type,
                        text : text,
                        target : target
                    }).then(function (json) {
                        if (json.sucs === true) {
                            $scope.comments.remove(cmnId);
                            commData.cmnId = json.cmnId;
                            commData.pending = false;
                            angular.extend(json, commData);
                            var comment = $$commentMap.create(json,$scope.currentUser);
                            $scope.comments.add(comment.getKey(),comment);
                            $scope.target.setTotalComment(json.loc,1);
                            if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                                target.setTotalComment(json.loc,1);
                            }else if($scope.commentType !== 'feed'){
                                var sc = feedFactory.synchComment($scope.target.getFeedKey(),json.loc,1);
                                sc && sc.$rgDigest();
                            }
                            $scope.canComment = true;
                            $scope.commenttext = "";
                            safeDigest();
                            rgScrollbarService.scrollTo($scope,".com-"+comment.getKey(),"bottom");
                            rgScrollbarService.recalculate($scope);
                        } else {
                            $scope.comments.remove(cmnId);
                            $scope.canComment = true;
                            Ringalert.show(json,'error');
                            $scope.commenttext = text;
                            safeDigest();
                        };

                    },function(reason){
                        $scope.comments.remove(cmnId);
                        $scope.canComment = true;
                        Ringalert.show(reason,'error');
                        $scope.commenttext = text;
                        safeDigest();
                    });

                        rgScrollbarService.scrollTo($scope,".com-"+cmnId,"bottom");
                        rgScrollbarService.recalculate($scope);

                }

        }
        function updateComment(comment) {
                if (!comment.user().isCurrentUser()) {
                    $scope.commentEditorEnabled = false;
                    return;
                }
               var text = $scope.models.commentedittext.trim(),
                    type = $scope.commentType,
                    target = $scope.target,
                   oldText = comment.text();
                   comment.setComment(text);
                   comment.isPending(true);
                   if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                        target = $scope.target.getSingleContent();
                        type = $scope.target.getContentType();
                    }
                if (text !== '') {
                    CommentHttpService.updateComment({
                        key : target.getKey(),
                        type : type,
                        commentId : comment.getKey(),
                        text : $scope.models.commentedittext
                    }).then(function(json){
                        if(!json.sucs){
                            comment.setComment(oldText);
                            Ringalert.show(json,'error');
                        }
                        comment.isPending(false);
                        $scope.models.commentedittext = "";
                        safeDigest();
                    },function(reason){
                        comment.setComment(oldText);
                        Ringalert.show(json,'error');
                        safeDigest();
                    });
                    $scope.commentEditorEnabled = false;
                }else{
                    Ringalert.show("Please write something",'error');
                    // show the error message
                }
                safeDigest();
        };

        // function likeUnlikeComment(comm){
        //     var il = comm.like(true);

        //     CommentHttpService.likeUnlike({
        //         key : $scope.target.getKey(),
        //         type : $scope.commentType,
        //         commentId : comm.getKey(),
        //         il : il,
        //         target : $scope.target
        //     }).then(function(json){
        //         if(!json.sucs){
        //             comm.like(true);
        //             Ringalert.show(json, 'error');
        //         }

        //     },function(reason){
        //         comm.like(true);
        //         Ringalert.show(reason, 'error');
        //     });
        // }
        function deleteComment(comm){
            var type = $scope.commentType,target = $scope.target;
            comm.isPending(true);
            if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                target = $scope.target.getSingleContent();
                type = $scope.target.getContentType();
            }
            CommentHttpService.deleteComment({
                key : target.getKey(),
                type : type,
                commentId : comm.getKey()
            }).then(function(json){
               if(json.sucs){
                    $scope.comments.remove(json.cmnId);
                    $scope.target.setTotalComment(json.loc,json.ic);
                    if($scope.commentType === 'feed' && $scope.target.isSingleContentFeed()){
                        target.setTotalComment(json.loc,json.ic);
                    }else if($scope.commentType !== 'feed'){
                         var sc = feedFactory.synchComment($scope.target.getFeedKey(),json.loc,json.ic);
                               sc && sc.$rgDigest();
                    }
                    //todo : decrease the target nc by one
               }else{
                    comm.isPending(false);
                    Ringalert.show(json,'error');
               }
               safeDigest();
            },function(json){
                    comm.isPending(false);
                    Ringalert.show(json,'error');
                    safeDigest();
            });
            safeDigest();
         }
        // function fetchWhoLikes(comment) {
        //     var defer = $q.defer(),dorequest = true;
        //     if (comment.getTotalLikes() === comment.getWhoLikes().length) {
        //             $timeout(function(){
        //                 defer.resolve({sucs: true});
        //             });
        //             dorequest = false;
        //     }
        //     if(dorequest){
        //         CommentHttpService.fetchWhoLikes({
        //             key : $scope.target.getKey(),
        //             type : $scope.commentType,
        //             commentId : comment.getKey(),
        //             target : $scope.target
        //         }).then(function(json){
        //             if (json.sucs === true) {
        //                 var likes = json.likes || [];
        //                 for (var i = 0; i < likes.length; i++) {
        //                     comment.incomingWhoLikes(likes[i]);
        //                 }
        //                 defer.resolve(json);
        //             } else {
        //                 defer.reject(json);
        //             }
        //         },function(reason){
        //             defer.reject(reason);
        //         });
        //     }
        //         return {
        //             data: function () {
        //                 return {
        //                     target: comment
        //                 };
        //             },
        //             promise: defer.promise
        //         };
        //  }

        function validateComment(){
                if ($scope.commenttext.length < 1) {
                    $scope.commentErrorClass = "inputerror";
                    $scope.canComment = true;
                    return false;
                } else {
                    $scope.commentErrorClass = "";
                    return true;
                }
         }

         $scope.$watch('showCommentBox',function(newVal){
                if(newVal){
                    if(!commentSubsriberKey){
                        setupInitials();
                    }
                    if(!$scope.comments.length()){
                        initialCommentRequest();
                    }
                }
         });

          $scope.$watch('target.getKey()',function(newVal){ // for popup image changes
                    if(firstTimeChangedTarget){
                        if(commentSubsriberKey){
                          $$connector.unsubscribe(commentSubsriberKey);
                          setupInitials();
                          $scope.comments.reset();
                        }
                        if(!$scope.comments.length()){
                            initialCommentRequest();
                        }
                    }
                    firstTimeChangedTarget = true;

         });

    }
    function rgComments() {
        return {
            restrict: 'E',
            controller : CommentsController,
            scope : {
                target : '=',
                showCommentBox : '=',
                commentType : '@', // string feed,image,media
                commentOrder : '@', // comment order asc|desc
                activeCommentId : '@', // specific comment id
                hideScroll : '@' // show the scrollbar or not
            },
            //templateUrl: 'pages/partials/comments.html'
			template :  '<div class="feed_comment"><div rg-scrollbar="scrollbar()" disabled="{{::hideScroll}}" ng-class="!hideScroll ? \'comm-scroll-height\':\'\'"><ul class="media-list"><li class="item bd" style="border:none" ng-show="showPreviousButton()"><div class="float-right gray font-12 margin-10"><a class="view_more" rg-click="loadPreviousComment()">load previous comments</a></div><div class="clear"></div></li><li class="item" rg-repeat="comm in comments.all() track by comm.key" ng-init="comment = comm.value" ng-class="{ half_opacity:comment.isPending(),comment_blink: (comment.getKey() == activeCommentId)}"><div class="comment-area"><div class="pro_img_bg_30 mar-right-10" style="flex:none"><a ng-href="{{comment.user().link()}}"><img ng-src="{{ comment.user().avatar(\'thumb\')}}" alt=""></a></div><div class="comm-p"><p class="unm"><a ng-href="{{comment.user().link()}}">{{comment.user().getName()}}</a></p><p class="comment_text" ng-hide="(commentEditorEnabled && commentKey == comment.getKey())" ng-bind-html="comment.getDynamicText()"></p><p ng-if="(commentEditorEnabled && commentKey == comment.getKey())"><span class="comment"><rg-editor class="editor" editor-content="$parent.models.commentedittext" new-line="false" on-enter="$parent.updateComment" on-enter-arg="comment" on-escape="cancelEdit" edit-mode="$parent.commentContentEdit(comment)" show-emoji="true" focus="$parent.$parent.commentEditorEnabled" placeholder="Write your comment..."></rg-editor><span class="esc-to-cancel">Press Esc to <a rg-click="cancelEdit()">cancel</a></span></span></p><ul class="comment_like_menu" ng-hide="comment.isPending() || (commentEditorEnabled && commentKey == comment.getKey())"><li rg-likes="" like-type="{{::likeType}}" target="comment" target-parent="parentKey" target-owner="target.getFeedKey()" like-comment="true"><!-- <a ng-class="{active:comment.like()}" rg-click="like(comment)"><i class="icon-like lc-ico" rg-like="comment.like()" ng-class="{\'icon-like-h\':comment.like()}"></i></a> <a ng-class="{active:comment.like()}" rg-click="like(comment)">&nbsp;Like</a> <a ng-class="{active:comment.like()}" class="counter" href="javascript:void(0)" rg-ringbox="{{::comment.getTotalLikes() > 0}}" ringbox-open="openRingboxLike(comment)" ringbox-controller="fetchLikeController" ringbox-target="pages/home/wholikes.html" ringbox-type="remote" ringbox-data="fetchWhoLikes(comment)">{{comment.getTotalLikes()}}</a> --></li><li class="mar-top-7 feed-m"><span class="time"><i class="icon-dt"></i>{{comment.time()}}</span></li></ul></div><div class="comm-sett"><div ng-show="target.user().isCurrentUser() || comment.user().isCurrentUser()" class="" style="position: relative"><div rg-dropdown="dropdown()" dd-html="ddCommentHtml" dd-control="comment" dd-action="actionCommentDropdown" ng-class="comment.user().isCurrentUser() ? \'icon-ds-arrow\' : \'\'" class="ico-f arrow-b"></div></div></div><div class="clear"></div></div></li></ul></div><div ng-show="loadingComment" style="text-align:center;margin-top:10px"><div class="loader-s"><div class="lr1"></div><div class="lr2"></div><div class="lr3"></div></div></div><div class="item" style="border:none" ng-show="showMoreButton()"><div class="float-right gray font-12 margin-10"><a class="view_more" rg-click="loadMoreComment()">More comments</a></div><div class="clear"></div></div><div ng-if="target.getTotalComment() > comments.length()" class="divider"></div><div class="mar-top-10"><div class="comment-w" ng-class="commentErrorClass"><div class="comment-editor"><rg-editor class="editor" editor-content="commenttext" new-line="false" on-enter="addComment" show-emoji="true" is-disabled="!canComment" focus="showCommentBox" placeholder="Write something...."></rg-editor></div></div></div></div>'
			
			
			
			
			
			
			
			
			        };
    }
     function rgImageComments() {
        return {
            restrict: 'E',
            controller : CommentsController,
            scope : {
                target : '=',
                showCommentBox : '=',
                commentType : '@', // string feed,image,media
                commentOrder : '@', // comment order asc|desc
                activeCommentId : '@' // specific comment id
            },
            //templateUrl: 'pages/partials/image-comments.html'
			template :  '<div class="feed-comment-wrapper" style="height:calc(100% - 165px)"><div class="feed_comment" rg-scrollbar="scrollbar()"><ul class="feed-img-l"><li class="item" style="border:none" ng-show="showPreviousButton()"><div class="float-right gray font-12 margin-10"><a class="view_more" rg-click="loadPreviousComment()">load previous comments</a></div><div class="clear"></div></li><li class="item pv-item" ng-repeat="comm in comments.all()" ng-init="comment = comm.value" ng-class="{ half_opacity:comment.isPending(),active: (comment.getKey() == activeCommentId) }"><div class="comment-area"><div class="pro_img_bg_30 mar-right-10" style="flex:none"><img ng-src="{{::comment.user().avatar(\'thumb\')}}" alt=""></div><div class="comm-p"><p class="unm"><a ng-href="{{::comment.user().link()}}">{{::comment.user().getName()}}</a></p><p class="txt_justify" ng-hide="(commentEditorEnabled && commentKey == comment.getKey())" ng-bind-html="comment.getDynamicText()"></p><p ng-if="(commentEditorEnabled && commentKey == comment.getKey())"><span class="comment"><rg-editor class="editor" editor-content="$parent.models.commentedittext" new-line="false" on-enter="$parent.updateComment" on-enter-arg="comment" on-escape="$parent.cancelEdit" edit-mode="$parent.commentContentEdit(comment)" show-emoji="true" focus="$parent.commentEditorEnabled" placeholder="Write something...." style="width: 94%"></rg-editor><span class="esc-to-cancel">Press Esc to <a rg-click="$parent.cancelEdit()">cancel</a></span></span></p><ul class="comment_like_menu" ng-hide="comment.isPending() || (commentEditorEnabled && commentKey == comment.getKey())"><li rg-likes="" like-type="{{::commentType}}" target="comment" target-parent="target.getKey()" target-owner="target.getFeedKey()" like-comment="true"><!-- <a ng-class="{active:comment.like()}" rg-click="like(comment)"><i ng-class="{\'icon-like-h\':comment.like() > 0}" class="icon-like lc-ico" rg-like="comment.like()"></i></a> <a ng-class="{active:comment.like()}" rg-click="like(comment)">&nbsp;Like</a> <a ng-class="{active:comment.like()}" class="counter" href="javascript:void(0)" rg-ringbox="{{::comment.getTotalLikes() > 0}}" ringbox-open="openRingboxLike(comment)" ringbox-controller="fetchLikeController" ringbox-target="pages/home/wholikes.html" ringbox-type="remote" ringbox-data="fetchWhoLikes(comment)">{{comment.getTotalLikes()}}</a> --></li><li class="mar-left-60"><span class="time"><i class="icon-dt"></i> {{comment.time()}}</span></li></ul></div><div class="comm-sett"><div ng-show="target.user().isCurrentUser() || comment.user().isCurrentUser()" class=""><div rg-dropdown="dropdown()" dd-html="ddCommentHtml" dd-control="comment" dd-action="actionCommentDropdown" ng-class="comment.user().isCurrentUser() ? \'icon-ds-arrow\' : \'\'" class="ico-f arrow-b"></div></div></div><div class="clear"></div></div></li><li ng-show="loadingComment" class="loader-s"><div class="lr1"></div><div class="lr2"></div><div class="lr3"></div></li><li class="item" style="border:none" ng-show="showMoreButton()"><div class="float-right gray font-12 margin-10"><a class="view_more" rg-click="loadMoreComment()">More comments</a></div><div class="clear"></div></li></ul></div><div class="pv-c-top"><div class="width-100-percent"><div class="pv-pro float-left"><img ng-src="{{::currentUser.avatar(\'thumb\')}}" alt=""></div><div class="comment-w" style="width:85%" ng-class="commentErrorClass"><div class="comment-editor popimgcmnt-box"><rg-editor class="editor" editor-content="commenttext" new-line="false" on-enter="addComment" show-emoji="true" is-disabled="!canComment" focus="showCommentBox" placeholder="Write something...."></rg-editor></div></div></div></div></div>'
			
			
			
			
			
			
			
			


			        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

        .directive('rgNewsFeedTop', rgNewsFeedTop);
    
    rgNewsFeedTop.$inject = ['$templateCache'];

    function rgNewsFeedTop($templateCache) {
        
        return {
                scope : {
                    feed : '=',
                    serial : '=',
                    ddTemplate : '=',
                    actionFeedDropdown : '=',
                    dropdown: '&',
                    singleFeed : '@',
                    showdroparrow: '='

                },
               restrict: 'E',
               template: $templateCache.get('top.html')  
            }
     }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
        .directive('rgNewsFeedBottom',rgNewsFeedBottom); 

        rgNewsFeedBottom.$inject = ['$templateCache'];

        function rgNewsFeedBottom($templateCache) {
            
            return {
                restrict: 'E',
                template: $templateCache.get('bottom.html')
            };
        }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

        .directive('rgNewsFeedDetails', rgNewsFeedDetails);

    function rgNewsFeedDetails() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/news_feed/details.html',
            link: function(scope) {
                scope.$rgDigest();
            }

            //scope : {
            //    feed : '=',
            //    editorEnabled : '=',
            //    inputDisabled : '=',
            //    updateFeed : '&',
            //    cancelEdit : '&',
            //    getImageData: '&',
            //    setFeedText : '=',
            //    feedText : '='
            //
            //}


        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

        .directive('rgNewsFeedSharedFeed', rgNewsFeedSharedFeed);

    function rgNewsFeedSharedFeed() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/news_feed/shared_feed.html'
        };
    }

})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

        .directive('rgNewsFeedMenu', rgNewsFeedMenu);

    rgNewsFeedMenu.$inject = ['$compile','SystemEvents','$templateCache','MESSAGES',"Ringalert"];
    
    function rgNewsFeedMenu($compile,SystemEvents, $templateCache,MESSAGES,Ringalert) {
      
        return {
            restrict: 'E',
            template: $templateCache.get('menu.html'),  
            link: function(scope, element, attrs) {
            
                 var comment = null, share = null, 
                     eventListner = element[0].querySelector('[data-events]'),
                     wrapper = element[0].closest('[data-feed-bottom]');
              function clickHandler(e) {
                      
                    if(e.target.hasAttribute('data-event-share') || (e.target.parentNode && e.target.parentNode.hasAttribute('data-event-share'))) {
                          e.stopPropagation();
                          var f = scope.feed.hasSharedFeed() ? scope.feed.getOrginalFeed():scope.feed;
                          var shareablle = f.isShareAble(true);
                          if(!shareablle.sucs) {
                              Ringalert.show(MESSAGES[shareablle.rc],'warning');
                              return;
                          }else{
                            shareHandler();
                          }
                          
                       }
                 
                      if(e.target.hasAttribute('data-event-comment') || (e.target.parentNode && e.target.parentNode.hasAttribute('data-event-comment'))) {
                          e.stopPropagation();
                          commentHandler(); 
                      }
                   
                    scope.$rgDigest();
               }
              eventListner.addEventListener('click', clickHandler);  
               
             function shareHandler() {
                  if(scope.showCommentBox) {
                       wrapper.removeChild(comment); 
                       scope.showCommentBox = false; 
                  } 
                      
                 if(!scope.showShareBox) {                          
                      share = (share)? share : $compile('<feed-inline-share-view></feed-inline-share-view>')(scope)[0];
                      wrapper.appendChild(share); 
                      scope.showShareBox = true;
                      scope.$emit(SystemEvents.FEED.HEIGHT, scope.feed.getMapKey());
                      return;
                   } 
                      
                   if(scope.showShareBox) {
                        wrapper.removeChild(share); 
                        scope.showShareBox = false;
                        scope.$emit(SystemEvents.FEED.HEIGHT, scope.feed.getMapKey());
                        return;
                    }
                    
                    scope.$emit('$feedHeight', scope.feed.getMapKey()); 
               }
               
               function commentHandler() {
                  var templateComment;
                  // if(scope.feed.isSingleContentFeed()){
                  //     templateComment = '<rg-comments target = "feed.getSingleContent()" show-comment-box="showCommentBox" comment-type = "'+scope.feed.getContentType()+'" comment-order = "desc"></rg-comments>';
                  // }else{
                      templateComment = '<rg-comments target = "feed" show-comment-box="showCommentBox" comment-type = "feed" comment-order = "asc"></rg-comments>'
                  //}
               
                    if(scope.showShareBox) {
                       wrapper.removeChild(share); 
                       scope.showShareBox = false;
                    } 
                          
                     if(!scope.showCommentBox) {
                        scope.showCommentBox = true;
                        comment = (comment)? comment : $compile(templateComment)(scope)[0];
                        wrapper.appendChild(comment);                         
                        scope.$emit(SystemEvents.FEED.HEIGHT, scope.feed.getMapKey());
                       // scope.$rgDigest();
                        return;
                    } 
                      
                    if(scope.showCommentBox) {
                         wrapper.removeChild(comment); 
                         scope.showCommentBox = false;
                         scope.$emit(SystemEvents.FEED.HEIGHT, scope.feed.getMapKey());
                         return;
                     } 
               }
               
               /*External scope api*/
                scope.closeShareBox = function() {
                   scope.showShareBox = true;
                   shareHandler();
                   scope.$rgDigest();
                }
                
                scope.closeCommentBox = function() {
                   scope.showCommentBox = true;
                   commentHandler();
                   scope.$rgDigest();
                }
               
               scope.$on("$destroy", function(){
                 /*clear DOM reference*/
                 eventListner.removeEventListener("click",clickHandler);
                   eventListner = null;
                   wrapper = null;
                   comment = null;
                   share = null;
               });  
            

            }

        };
    }

})();

 /**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')
        .directive('locationCard',function(){

         return {
            restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
            replace : true,
            scope : {
              feed : '='
            },
            template : '<span class="location">&nbsp;at&nbsp;<a ng-href="{{ ::feed.getLocationUrl() }}"  rg-ringbox="true" ringbox-type="remote" ringbox-target="pages/partials/google-map-preview.html" scope-data="{url : feed.getLocationEmbedUrl() }">{{::feed.getLocationShortText()}}</a></span>'
          };
        })
        .directive('userCard',function(){

         return {
            restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
            replace : true,
            controller : ['$scope','profileHttpService','InviteFactory','friendsFactory',function($scope,profileHttpService,InviteFactory,friendsFactory){

                $scope.getUserDetail = function(){
                    $scope.showMfc = false;
                    profileHttpService.getUserDetails({utId : $scope.user.getUtId()},true).then(function(json){
                        if(json.sucs){
                            $scope.mfc = json.userDetails.mfc;
                            $scope.showMfc = true;
                            $scope.user.setUid(json.userDetails.uId);
                            $scope.$rgDigest();
                        }
                    });
                };
                $scope.getMutualFriend = function(user) {

                    return{
                        data: function() {
                            return {
                                target: user
                            };
                        },
                        promise: InviteFactory.getMutualFriend(user)

                    };
                };
                $scope.contactListAction = function(actionObj) {
                    if (!actionObj.friend.isLoading()) {
                        friendsFactory.friendAction(actionObj,true).then(function() {
                            $scope.$rgDigest();
                        }, function() {
                            $scope.$rgDigest();
                        });
                        $scope.$rgDigest();
                    }
                };

            }],
            scope : {
              user : '='
            },
            template : '<span class="user"><a ng-href="{{user.link()}}" rg-hovercard="{{::!user.isCurrentUser()}}" on-hover-start="getUserDetail" hover-template-url="pages/partials/hovercards/profile-hover.html">{{::user.getName()}}</a></span>'
          };
        })
        .directive('feedMessage',feedMessage)
        .directive('feedTagMoreUser',feedTagMoreUser);

        feedMessage.$inject = ['$compile'];
         function feedMessage($compile) {
            return {
                restrict: 'A',
                //transclude: true,

                scope : {
                      feed : '=feedMessage'
                    },
                link : function(scope, element, attrs) {

                      scope.$watch('feed.checkMessageUpdated()',
                        function(value) {
                           element.html(scope.feed.getMessageText());
                          $compile(element.contents())(scope);
                        }
                      );
                 }
                // link : function(scope,iElement,attrs){
                //     var html = '<div>'+scope.feed.getMessageText()+'</div>';
                //     html = $compile(html)(scope);
                //     iElement.append(html);
                // },

                   // template : '<ng-transclude></ng-transclude>'
            };


    }

  feedTagMoreUser.$inject = [];
  function feedTagMoreUser(){
          // Runs during compile
          return {
             restrict: 'E', // E = Element, A = Attribute, C = Class, M = Comment
             scope : {
                  feed : '=tagFeed'
                  },
              controller : ['$scope','feedFactory',function(scope,feedFactory){
                //console.log("dreictive controller");


                          scope.getTagUsers = function(feed) {

                              return{
                                  data: function() {
                                      return {
                                          target: feed
                                      };
                                  },
                                  promise: feedFactory.getTagUsers(feed)

                              };
                          };

                  scope.tooltip = '';
                      if(scope.feed.getTotalTag() > 2){
                        var users = scope.feed.getTagUsers();
                        if(users.length > 1){
                          scope.tooltip += users[1].getName();
                          if(!!users[2]){
                            scope.tooltip += "\n"+ users[2].getName();
                            if(scope.feed.getTotalTag() > 3){
                              scope.tooltip += "\nand "+(scope.feed.getTotalTag()- 3) +" others";
                            }
                          // for (var i = 1; i < users.length; i++) {
                          //    scope.tooltip += users[i].getName()+(i<users.length -1 ?"\n":'');
                          // };
                          // if(scope.feed.getTotalTag() > users.length){
                          //     scope.tooltip += "\nand "+(scope.feed.getTotalTag()- users.length) +" others";
                          // }
                        }
                      }
                   }
              }],
             template: '<span class="">with&nbsp;</span>'
                  +'<span class="tag-people"><user-card user="feed.getTagUsers()[0]"></user-card></span>'
                  +'<span ng-if="::feed.getTotalTag() > 1">'
                  +'&nbsp;and&nbsp;<span class="tag-people" ng-if="::feed.getTotalTag() == 2"><user-card user="feed.getTagUsers()[1]"></user-card></span>'
                  +'<span class="" ng-if="::feed.getTotalTag() > 2"><a rg-ringbox="true" ringbox-controller="feedTagUserListController" ringbox-type="remote"'
                  +'ringbox-target="pages/home/tag-user-list.html"'
                  +'ringbox-data="getTagUsers(feed)" class="tag-f-msg" data-tooltip="{{::tooltip}}"'
                  +'>{{::feed.getTotalTag() -1}} others peoples</a></span></span>'


          };
        }
})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

    .directive('rgSingleFeedHeader', rgSingleFeedHeader)
    .directive('rgSingleFeedBody', rgSingleFeedBody)
    .directive('rgSingleFeedMenu', rgSingleFeedMenu)

    function rgSingleFeedBody() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/single_feed/body.html'
        };
    }

    function rgSingleFeedHeader() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/single_feed/header.html'
        };
    }

    function rgSingleFeedMenu() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/single_feed/menu.html'
        };
    }


})();

/**
 * © Ipvision
 */

(function() {
    'use strict';

    angular
        .module('ringid.feed')

        .directive('rgSingleFeedDetails', rgSingleFeedDetails);

    function rgSingleFeedDetails() {
        return {
            restrict: 'E',
            templateUrl: 'pages/partials/single_feed/details.html'

            //scope : {
            //    feed : '=',
            //    editorEnabled : '=',
            //    inputDisabled : '=',
            //    updateFeed : '&',
            //    cancelEdit : '&',
            //    getImageData: '&',
            //    setFeedText : '=',
            //    feedText : '='
            //
            //}


        };
    }

})();

(function () {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        console.warn('Feed Module Not Found');
        return;
    }

    feedApp.directive('feedInlineShareView', feedInlineShareView);

    feedInlineShareView.$inject = ['GlobalEvents', '$compile','$ringhttp'];
    function feedInlineShareView(GlobalEvents, $compile,$ringhttp){ //jshint ignore:line
        return {
          restrict : 'E',
          //templateUrl : 'pages/partials/news_feed/inline-share.html',

			template :  '<div class="status-box noselect inline-share"><form enctype="multipart/form-data"><div style="padding:10px"><div class="float-left"><div class="thumbnail"><div class="icon-logo-circle pss-logo"><a><img class="responsive-all" rg-src="currentUser.avatar(\'thumb\')"></a></div></div></div><div class="post-t float-right"><div class="inline-share-box"><rg-editor class="editor" editor-content="feedText" new-line="on" on-escape="closeShareBox" focus="showShareBox" placeholder="Write something...."></rg-editor><span class="esc-cancel" rg-click="closeShareBox()">Press Esc to <a>Cancel</a></span><p ng-if="emotions.length" class="pst-loc-txt"><span class="feelings-text">feeling</span> <img class="feed_emo" rg-src="emotions[0].url"> {{emotions[0].nm}} &nbsp;<span class="icon-close f-8" rg-click="emotions.length = 0"></span></p><div ng-if="tagList.length"><ul class="tag-fnd-lst"><span class="tag-with">With :</span><li ng-repeat="usr in tagList"><span class="tag-title">{{::usr.getName()}}</span>&nbsp;<span class="icon-close f-11" rg-click="removeTag(usr)"></span></li></ul></div><p ng-if="feedLocation.description" class="pst-loc-txt">{{ feedLocation.description}} <span class="showpointer icon-close f-8" rg-click="resetFeedLocation()"></span></p><p ng-show="!boxIsLoading && errorMessage" class="s-error">{{errorMessage}}</p><!--<p ng-show="!boxIsLoading && !errorMessage" class="s-info"><b>Enter</b> to SHARE, <b>ESC</b> to Cancel</p>--><rg-loader-view2 is-loading="boxIsLoading"></rg-loader-view2></div></div><div class="clear"></div></div><div class="status-photo-box" style="margin:0;padding:0;border-top:1px solid #ebebeb;width:100%"><div><div class="post-b-ico m-l-5"><a data-tooltip-post="Add Feeling" rg-emotion on-select="chooseEmotion(item)" class="p-ab"><span class="status-ico feeling-ico"></span></a></div><div class="post-b-ico m-l-5"><a data-tooltip-post="Tag Friends" rg-tag-friend="" show-if="showAddTag" tag-items="tagList" on-select="addTag(item)" class="p-ab"><span class="status-ico tag-f-ico"></span></a></div><div class="post-b-ico m-l-5"><a data-tooltip-post="Add Location" feed-location-menu="" feed-location-menu-on-select="updateFeedLocation(location)" autoAdjust="{{::autoAdjustScroll}}" selected-value="feedLocation" class="p-ab"><span class="status-ico location-ico"></span></a></div><div class="float-right pad-7-0"><input type="button" ng-disabled="inputDisabled" rg-click="shareFeed()" class="share_btn float-right" value="Share"></div><!--<p>Press escape to cancel</p>--></div></div></form><div class="clear"></div></div>',
			controller : 'feedInlineShareController',
          link : function(scope,elemnet,attr){

          } /*,
          link : function(scope) {

            var hideShareBox = function(e) {
                var code = e.keyCode || e.which;
                if(code === 27) {
                    scope.closeShareBox();
                }
            };

        
            scope.closeShareBox = function() {
                $timeout(function() { // ghapla. needs improvement
                    if(scope.hasOwnProperty('showShareBox')) {
                        scope.showShareBox = false;
                    } else {
                        scope.$parent.showShareBox = false;
                    }
                });
            };
            

          
            scope.$watch('showShareBox', function(newval) {
                if(newval) {
                    document.addEventListener('keydown', hideShareBox);
                } else {
                    document.removeEventListener('keydown', hideShareBox);
                }
            }); 

            //element.on('mouseenter', function() {
                //GlobalEvents.unbindHandler('keydown', 'document', hideShareBox);
            //});

            //element.on('mouseleave', function() {
                //GlobalEvents.bindHandler('keydown', 'document', hideShareBox);
            //});
          } */
      };

    }


})();

(function () {
    'use strict';
    var feedApp;
        feedApp = angular.module('ringid.feed');
 feedApp.controller('FeedMainController', ['$scope', '$timeout','feedFactory', 'utilsFactory','$rootScope','SystemEvents',
        function ($scope, $timeout,feedFactory, helper,$rootScope,SystemEvents) {
            // initiate feed binding for scope
            feedFactory.reset();
            $scope.noMoreFeed  = false;
            $scope.showPostBox = $scope.showPostBox || function(){return true;};
            $scope.showSpecialFeed = $scope.showSpecialFeed || function(){return true;};

            $scope.feeds = feedFactory.getFeeds();
            feedFactory.setFactoryKey($scope.pagekey);
            feedFactory.setSortBy($scope.sortBy || 'tm');
            $scope.busy = true;
            // setTimeout(function(){ // first time we are requesting from rg-feed subscriber directive when directive is ready
            //                        // so after 3 second we need to change the busy filter to normal so that we can request for data again
            //     $scope.busy = false;
            //     $scope.$broadcast(SystemEvents.FEED.BUSY, $scope.busy);
            // },3000);

            var feedUpdateTimer = setInterval(function(){
                feedFactory.updateTime();
                $scope.$rgDigest();
            }, 300000);

            $scope.setFeed = function (forceDigest) {
                $scope.feeds = [];
                $scope.feeds = feedFactory.getFeeds();
                if(forceDigest){
                    $scope.$rgDigest();
                }
            };

           // $scope.scopeData = scopeData;
            $scope.forAdd = $scope.forAdd || 'my';
            $scope.getFeeds = function () {
                if (!$scope.feeds || $scope.feeds.length === 0) {
                    $scope.setFeed();
                }
                return $scope.feeds;
            };

            var busyTimer,previousFeedLength;
            $scope.LoadMoreData = function (syncher) {
                previousFeedLength = $scope.feeds.length;
                if ($scope.busy === false && !$scope.noMoreFeed) {
                    $scope.busy = true;
                    feedFactory.requestForMoreFeed($scope.params);

                    $scope.clearRequestTimer();
                    busyTimer = setTimeout(function(){
                        if($scope.busy ){
                            if(previousFeedLength === $scope.feeds.length){
                                $scope.busy = false;
                                $scope.$broadcast(SystemEvents.FEED.BUSY, $scope.busy);
                                
                            }
                            

                         }
                     },6000);
                }

                /*
                else{
                    $scope.busy = false;
                    $scope.$broadcast(SystemEvents.FEED.BUSY, $scope.busy);
                } */

                // request for loading more data
            };
            $scope.clearRequestTimer = function(a){ // a for getting native undefined
                if(!!busyTimer)clearTimeout(busyTimer);
                busyTimer = a;
            };

            $scope.$on("FeedListChanged",function(){
                $scope.setFeed();
            });



            $scope.setNoMoreFeed = function(state){
                $scope.noMoreFeed = state;
                feedFactory.noMoreFeed(state);
                $scope.busy = false;
                $scope.$broadcast(SystemEvents.FEED.BUSY, $scope.busy);
            }
            $scope.noDataYet = function(){
                return $scope.noMoreFeed && $scope.feeds.length == 0;
            }
            //$scope.incomingFeed = true;
            //$scope.setIncomingFeed = function(val){
            //        $scope.incomingFeed = !!val;
            //};
            //$scope.loadIncomingFeed = function(){
            //    feedFactory.processIncomingFeed();
            //    $scope.setFeed();
            //    $scope.incomingFeed = false;
            //};

            //feedFactory.requestForFeed($scope.params);
            // var initFeedInterval;
            // function initTialFeedRequest(){
            //     if(!$scope.feeds.length){
            //         feedFactory.initFeedRequest($scope.params);
            //         if(!initFeedInterval){
            //             initFeedInterval = setInterval(initTialFeedRequest,6000);
            //         }
            //     }else{
            //         if(initFeedInterval){
            //             clearInterval(initFeedInterval);
            //             initFeedInterval = null;
            //         }
            //     }
            // }
            // initTialFeedRequest();
            //for faster load dashboard feed
            feedFactory.initFeedRequest($scope.params);
            $scope.$on("$destroy",function(){
                // if(initFeedInterval){
                //     clearInterval(initFeedInterval);
                //     initFeedInterval = null;
                // }
                if(feedUpdateTimer){
                    clearInterval(feedUpdateTimer);
                    feedUpdateTimer = null;
                }
                });
             
            $scope.$on(SystemEvents.COMMON.COLUMN_CHANGED,function(){
                $scope.$rgDigest();
            });
        }])
       ;

})();


(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }
    feedApp.controller('SingleFeedSubController', ['$$feedMap', '$scope','$controller', '$routeParams', 'feedFactory', 'Auth','SystemEvents','utilsFactory','$location',
        function ($$feedMap, $scope,$controller, $routeParams, feedFactory, Auth,SystemEvents,utilsFactory,$location){
            var page= 'singleFeed';

            $scope.feedId = parseInt($routeParams.feedId || 0);

            $scope.shared = !!$routeParams.shared ? true : false;

            $scope.activeCommentId = parseInt($routeParams.commentId || 0);

            //console.log($routeParams);

            $scope.isReady = false;
            $scope.noData = false;

            $scope.pagekey  = feedFactory.getSingleFeedPageKey($scope.feedId);

            feedFactory.setFactoryKey($scope.pagekey);

            //$scope.feed = $$feedMap.create({'nfId' : $scope.feedId });

            $scope.singleFeed = true;

            $scope.ogData = {};


            $scope.currentUser = Auth.currentUser();

            getSingleFeed();

            $scope.setFeed = function (deleted) {

                if(deleted){
                    $location.path("/");
                }else{
                    getSingleFeed();
                }
            };
            $scope.skipSaveScope = true;


            ////////////////////////////////////////////////////////////
            $controller('FeedSubController', {$scope: $scope});
            function getSingleFeed(){

                feedFactory.getSingleFeed($scope.feedId, $scope.shared).then(function(feed){
                    if(!!feed){
                        $scope.feed = feed;
                        $scope.isReady = true;
                        initFeedView();
                    }else{
                        $scope.feed = false;
                        $scope.isReady = true;
                        $scope.noData = true;

                    }
                    $scope.$rgDigest();
                });

            }



            function initFeedView(){
                if($scope.feed){
                    $scope.serial = $scope.feed.serial;
                    $scope.feedstatus = $scope.feed.text();
                    $scope.keyid = $scope.feed.getKey();
                    $scope.imageslength = $scope.feed.getImages().length;
                    $scope.shareMenuDisabled = $scope.feed.isCirclePost();
                    $scope.ogData = $scope.feed.getOgData();
                    $scope.ogShowPreview = $scope.feed.hasOgData();
                    $scope.showCommentBox = true;
                    $controller('FeedSubController', {$scope: $scope});
                    utilsFactory.safeDigest($scope);
                    $scope.$broadcast(SystemEvents.FEED.RESET,$scope.feed);

                }
            }
        }]);

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller("FeedSubController",FeedSubController);
        FeedSubController.$inject = ['rgDropdownService', '$rootScope','$scope', '$location', 'feedFactory', 'Ringalert','MESSAGES', 'SystemEvents','$ringbox','Media', 'utilsFactory', 'APP_CONSTANTS'];
     function FeedSubController(rgDropdownService, $rootScope,$scope, $location, feedFactory, Ringalert,MESSAGES, SystemEvents,$ringbox,Media, utilsFactory, AC) {
            $scope.showdroparrow = 0;
            $scope.showCommentBox = false; // use
            $scope.showShareBox = false; // use
            $scope.showCommentView = true; // do not use
            $scope.showShareForm = false; // do not use
            $scope.editorEnabled = false;
            $scope.errorImageEdit = false;

            $scope.feedLocation = {};
            $scope.ogData = $scope.ogData || {};
            $scope.filterOnProgress = false;

            $scope.ogDataLoading = false;
            $scope.ogShowPreview = false;

            $scope.previousFeedLocation = '';

            $scope.emotions = {};
            var f = $scope.feed && $scope.feed.value ? $scope.feed.value : $scope.feed;
            if(f && f.isSingleContentFeed()){
             if(f.getMedias().length() || f.getAudios().length()){
                $scope.likeType = 'media';
             }else if(f.getImages(true).length()){
                $scope.likeType = 'image';
             }
                $scope.likeTarget =  f.getSingleContent();
             }else{
                 $scope.likeType = 'feed';
                 $scope.likeTarget = f;
             }

            $scope.shareMenuDisabled = $scope.shareMenuDisabled ? $scope.shareMenuDisabled : false;
            $scope.toggleCommentBox = function (event) {
                event.stopPropagation();
                $scope.showCommentBox = !$scope.showCommentBox;
                if($scope.showCommentBox) {
                    $scope.showShareBox = false;
                }
                //$scope.showShareForm = !$scope.showCommentBox;
            };


            /**
             *  For update feed verbal time
             */
            //setInterval(feedFactory.updateTime, 180000 );

             $scope.feedEditChooseEmotion = function(subCat){
                 $scope.emotions.length = 0;
                 $scope.emotions.push(subCat);
                 $scope.$rgDigest();
             };

            // $scope.toggleShareBox = function(event) {
            //     event.stopPropagation();
            //     var f = $scope.feed.hasSharedFeed() ? $scope.feed.getOrginalFeed():$scope.feed;
            //     var shareablle = f.isShareAble(true);
            //     if(shareablle.sucs) {
            //         $scope.showShareBox = !$scope.showShareBox;
            //         if($scope.showShareBox) {
            //             $scope.showCommentBox = false;
            //         }
            //         $scope.$rgDigest();
            //     } else {
            //         Ringalert.show(MESSAGES[shareablle.rc],'warning');
            //     }
            // };



            //$scope.hideTheCommentBox = function () {
                //$scope.showCommentBox = false;
                //$scope.showShareForm = !$scope.showCommentBox
            //};

            //$scope.showTheCommentBox = function () {
                //$scope.showCommentBox = true;
                //$scope.showShareForm = !$scope.showCommentBox
            //};

            // feed dropdown data
            //$scope.ddHtml = 'pages/dropdowns/feed-edit-dropdown.html';//$templateCache.get('feed-edit-dropdown.html');
            $scope.ddTemplate =
				'<div class="ng-cloak action pad-204 feed-ac z-in-110 top-23">' +
                                    ' <i class="drop-sprite curve-a curve-t-ico p-ab top11"></i>' +
					'<div class="ac-top-line" ng-if="ddControl.showEdit()">' +
						'<a class="pad-8-14" rg-click="ddAction()({event: $event, action:\'edit\', feedKey: ddControl.feedKey})" href="#"><i class="drop-sprite w-h-13 edit-ico feed-font"></i>Edit</a>' +
					'</div>' +
                    '<div class="ac-top-line" ng-if="ddControl.showReportButton()">' +
                    '<a class="pad-8-14" rg-report spam-type="{{ddControl.getSpamType()}}" spam-id="ddControl.getSpamId()"><i class="drop-sprite add-tag-mar w-h-13 add-tag-ico feed-font"></i>Report</a>' +
                    '</div>'+
					'<div class="ac-top-line" ng-if="ddControl.showTagButton()">' +
						'<a class="pad-8-14" rg-click="ddAction()({event: $event, action:\'edittag\', feedKey: ddControl.feedKey})" href="#""><i class="drop-sprite add-tag-mar w-h-13 add-tag-ico feed-font"></i>{{ddControl.tagButtonText()}}</a>' +
					'</div>' +
					'<div class="ac-top-line" ng-if="ddControl.showDelete()">' +
						'<a class="pad-8-14" rg-click="ddAction()({event: $event, action:\'delete\', feedKey: ddControl.feedKey})" href="#"><i class="drop-sprite w-h-13 delete-mar delete-ico feed-font"></i>Delete</a>' +
					'</div>' +
				'</div>';


            $scope.actionFeedDropdown = function (actionObj) {
                rgDropdownService.close(actionObj.event);
                // console.log(actionObj);
                actionObj.event.preventDefault();
                switch (actionObj.action) {
                    case 'edit':
                        $scope.enableEditor(actionObj.feedKey);
                        break;
                    case 'edittag':
                        openRingBoxToEditTag();
                        break;
                    case 'delete':
                        $scope.deleteFeed(actionObj.feedKey);
                        break;
                    default:
                    //   console.log("no action matched");
                }
            };


            $scope.noDownload = function(event) {
                event.preventDefault();
                Ringalert.show('Currently download option is available in ringID desktop and mobile app version only.');
                 //Ringalert.alert({
                    //title : 'Download',
                    //message : 'Currently download option is available in ringID desktop and mobile app version only.',
                    //showCancel : false,
                    //okCallback : angular.noop//doLogoutTask
                 //});
            };


            $scope.selectAlbum = function(mediaMap) {
                return {
                        data: function () {
                            return {
                                media: mediaMap,
                                //album: feed.getAlbum(),
                                //playlist: feed.getAlbum().getContents().all(),
                                //feedTime: feed.time()
                            };
                        },
                        //promise: media.fetchDetails() // Media.fetchContentDetails(media, true, media.user())
                    };

            };

            // add to album dropdown
            //console.log('FEED AUDIOS: ' + $scope.feed.getAudios().length());
            //console.log('FEED VIDEOS: ' + $scope.feed.getVideos().length());
            // $scope.like = function (f) {
            //    // Ringalert.alert();return;
            //     feedFactory.likeUnlikeFeed($scope.keyid,f).then(function(json){ //success so show notification
            //        // Ringalert.show('','success');// passing empty in message to show default message
            //     },function(json){// failed so show notification
            //         Ringalert.show(json,'error');
            //     });
            //     if(f.like()){
            //         $scope.$broadcast('LikeChange',true);
            //     }

            // };


            $scope.enableEditor = function (feedKey) {
                //$scope.showDropdown = false;

                $scope.showdroparrow = feedKey;
                $scope.editorEnabled = true;
                console.log($scope.showdroparrow);

                var feedObj = feedFactory.getFeed(feedKey);

                $scope.feedText = feedObj.text();
                $scope.feedLocation =  angular.copy(feedObj.getLocationInfo());
                $scope.ogData =  angular.copy(feedObj.getOgData());

                if( $scope.ogData.image){
                    $scope.ogData.images = [$scope.ogData.image];
                }

                $scope.ogShowPreview = feedObj.hasOgData();

                $scope.emotions = [feedObj.getFeelings()];


                var obj = {
                  feedText:  $scope.feedText,
                  feedLocation: $scope.feedLocation,
                  feedKey: feedKey,
                  ogData: $scope.ogData
                };

                $rootScope.$broadcast('enableeditor',obj);
                $scope.$rgDigest();
            };



            $scope.cancelEdit = function () {
                $scope.editorEnabled = false;
                $scope.errorImageEdit = false;
                $scope.$rgDigest();
            };
            function validateUpdate(){
                    return !$scope.feedText
                        && !$scope.feedLocation.description
                        && !$scope.ogData.url
                        && !($scope.feelings && $scope.feelings.id)
                        && !$scope.feed.hasMedia()
                        && !$scope.feed.hasTagUsers();
            }
            $scope.updateFeed = function () {
                $scope.feedText = $scope.feedText.trim();

                if($scope.emotions.length){
                    $scope.feelings = $scope.emotions[0];// we will support one emotion at a time for now
                    $scope.emotions.length = 0;//emptying emotion
                }else{
                    $scope.feelings = false;
                }

                //$scope.showdroparrow = 0;



                if(validateUpdate()){
                    $scope.errorImageEdit = true;
                    $scope.editorEnabled = true;
                }else{
                    feedFactory.updateFeed($scope.currentUser, $scope.keyid, $scope.feedText, $scope.feedLocation, $scope.ogData, $scope.feelings  ).then(function (json) {
                        /* Isolated Directives will update based on this event */
                        $scope.editorEnabled = false;
                        $scope.errorImageEdit = false;

                        $scope.$rgDigest();

                        $scope.$broadcast(SystemEvents.FEED.UPDATED, { id: $scope.keyid });

                    },function(json){
                        Ringalert.show(json,'error');
                        $scope.$rgDigest();
                    });
                }
             $scope.$rgDigest();


            };

            $scope.deleteFeed = function (key) {
                    var message = 'Are you sure you want to delete?';
                    var boxInstance = $ringbox.open({
                            type : 'remote',
                            scope:false,
                            controller: 'RingBoxConfirmController',
                            resolve : {
                                localData : {
                                    message : message
                                }
                            },
                            templateUrl : 'pages/partials/ringbox-confirm.html'
                    });

                    boxInstance.result.then(function(confirmed){
                        if(confirmed){
                            feedFactory.deleteFeed($scope.currentUser, key).then(function (json) {
                                $scope.setFeed(true);
                                Ringalert.show(json,'success');
                            }, function(errJson){
                                $scope.setFeed(true);
                                Ringalert.show(errJson,'error');
                            });
                        }
                    });
            };

            $scope.getShareData = function () {
                return function () {
                    return {keyid: $scope.keyid, feed: $scope.feed.hasSharedFeed() ? $scope.feed.getOrginalFeed():$scope.feed};
                };
            };
            $scope.getImageData = function (image, feed) {

                return function () {
                            return {
                               image: image,
                               feed: feed
                           };
                        };
            };

         $scope.getMediaData = function (media, feed) {

            return {
                    data: function () {
                        return {
                            media: media,
                            //album: feed.getAlbum(),
                            playlist: feed.getAlbum().getContents().all(),
                            feedTime: feed.time()
                        };
                    },
                    promise: media.fetchDetails() // Media.fetchContentDetails(media, true, media.user())
                };

         };
        $scope.getMediaFirstData = function(){
            var media = $scope.feed.getMedias().top();
            if(media){
                return $scope.getMediaData(media,$scope.feed);
            }
        };

        $scope.getAudioFirstData = function(){
            var media = $scope.feed.getAudios().top();
            if(media){
                return $scope.getMediaData(media,$scope.feed);
            }
        };

         $scope.getFeedHtml = function(){
            return $scope.feed.getDynamicText();
         };
            // $scope.fetchWhoLikes = function () {
            //     return {
            //         data: function () {
            //             return {
            //                 target: $scope.feed,
            //                 type:'feed'
            //             };
            //         },
            //         promise: feedFactory.fetchWhoLikesFeed($scope.feed)
            //     };
            // };


             $scope.selectedFeedLocation = function(location){
                 $scope.feedLocation = location;

                 utilsFactory.safeDigest($scope);
             };

             $scope.resetFeedLocation = function(){
                 $scope.feedLocation = {};
             };

         //setInterval(feedFactory.updateTime, 180000);
         //setInterval(function(){
         //    feedFactory.updateTime();
         //    $scope.$rgDigest();
         //}, 180000);

            $scope.goToFeed = goToFeed;

            $scope.isShareAble= function(f){
                f = f.hasSharedFeed() ? f.getOrginalFeed():f;
                return f.isShareAble();
             // return  f.hasSharedFeed() ?(!f.getOrginalFeed().user().isCurrentUser() && !f.user().isCurrentUser()):!f.user().isCurrentUser();
            };



             ///////////////////////////////


             //------------------ Public -------------------

             function goToFeed(feedUrl){
                 if(!!feedUrl){
                     $location.path(feedUrl);
                 }
             }

            function goToImage($event, imageUrl){
                if(!!imageUrl){
                    $location.path(imageUrl);
                }
            }
            function openRingBoxToEditTag () {

               var boxInstance = $ringbox.open({

                        type : 'remote',
                        scope:false,
                        controller: 'feedEditTagController',
                        resolve : {
                            localData : {
                                feed : $scope.feed
                            },
                            remoteData : function(){
                                if($scope.feed.hasTagUsers()){
                                    return feedFactory.getTagUsers($scope.feed);
                                }else{
                                    return {};
                                }
                            }
                        },
                        templateUrl : 'pages/home/feed-tag-user-edit.html'
                });



               boxInstance.result.then(function(updatedFeed){
                 if(!!updatedFeed){
                    $scope.feed = updatedFeed;
                 }
                 $scope.cancelEdit();
               });
            }

        $scope.openRingBoxLike = function(){
            return $scope.feed.getTotalLikes() > 0;
        };
        $scope.openRingboxShare = function(){

            return (($scope.feed.hasSharedFeed() ? $scope.feed.getOrginalFeed().getTotalShare() > 0 : $scope.feed.getTotalShare()) > 0) && !$scope.feed.isMediaShared() && !$scope.feed.isSingleContentFeed();
        };
        $scope.whoShareFalsyFunc = function(){
            if($scope.feed.isSingleContentFeed()){
                Ringalert.show("Oops! This feature is coming soon",'info');
            }
        };

         if(!$scope.skipSaveScope){
             var key = ($scope.feed.value)? $scope.feed.value.getKey(): $scope.feed.getKey();
             feedFactory.addScope(key,$scope);
             $scope.$on('$destroy',function(){
                 feedFactory.removeScope($scope.feed.getKey());
             });
         }


     }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('FeedWhoShareController',FeedWhoShareController);
    FeedWhoShareController.$inject = ['$$connector','$scope','$$feedMap','feedFactory','OPERATION_TYPES','$rootScope','Ringalert'];

    function FeedWhoShareController($$connector,$scope,$$feedMap,feedFactory,OPERATION_TYPES,$rootScope,Ringalert){
        /**
         *
         * This contrller Has been made abstract and couldn't be used alone, use it by extending
         *
         * See, feed.ringbox.whoshare.controller.js , feed.single.whoshare.controller.js
         *
         * $scope.params will contain the parameters to init the controller
         *
         *
         */


        var subKey,ignoreCommKey,ignoreLikeKey,i,OTYPES=OPERATION_TYPES.SYSTEM;

        $scope.feeds = [];
        $scope.message = "";

        $scope.boxIsLoading = !$scope.params.boxIsLoading ?  true : $scope.params.boxIsLoading;

        var dashboardFeed;
        if(!!$scope.params){
            dashboardFeed = feedFactory.getFeed($scope.params.keyid);
        }


        $scope.showMessage = false  ;
        $scope.shareMenuDisabled = true;
        $scope.singleFeed = true;
        $scope.busy = false;


        $scope.boxHeight = $rootScope.windowHeight - 20;


        /**
         * Prohibiting Main feed subscriber from feedFactory not to process data if this controller scope exist for certain action        *
         *
         */
        subKey = $$connector.subscribe(function(json){
            $scope.boxIsLoading = false;
            $scope.isReady = true;
            $scope.busy = false;

            if(!json.sucs){
                $scope.$close();
                //todo : reason code implementation
                Ringalert.show(json.mg || "Opps ! Looks Like Something Went Wrong ! Please Try Later.",'error');
                return;
            }

            if(json.newsFeedList.length){
                for(i=0;i<json.newsFeedList.length;i++){
                    var aFeedMapObject = $$feedMap.create(json.newsFeedList[i]);

                     if( aFeedMapObject.getKey() === dashboardFeed.getKey()){                        
                         aFeedMapObject.setIdenticalFeed(dashboardFeed);
                     }
                    // }else{
                    $scope.feeds.push(aFeedMapObject);
                    // }

                }
            }
            $scope.$rgDigest();
        },{
            action : OTYPES.TYPE_WHO_SHARES_LIST
        });



        function startRequest(){
            $scope.boxIsLoading = true;
            if($scope.feeds.length < $scope.params.feed.getTotalShare() && !$scope.busy){
                $$connector.send({
                    actn : OTYPES.TYPE_WHO_SHARES_LIST,
                    nfId : $scope.params.feed.getKey(),
                    st : $scope.feeds.length
                },OTYPES.REQUEST_TYPE.REQUEST);
                $scope.busy = true;
                setTimeout(function(){ // blocking next three second not to send the request
                    $scope.busy = $scope.busy || false;
                    $scope.$rgDigest();
                },3000);
                $scope.$rgDigest();
                /**
                 * for Testing purpose ther service were created in feedFactory
                 * Now its blocked but if you need to retest block the socket sending option
                 * and unblock this one
                 */
                //  $scope.busy = true;
                // feedFactory.fakeFeed($scope.feeds.length,4).then(function(json){
                //    for(var i=0;i<json.length;i++){
                //        //if(findFromFeeds(json[i].getKey())){
                //           // console.log("duplicate Feed :" + json[i].getKey());
                //       // }else{
                //            $scope.feeds.push(json[i]);
                //      //  }
                
                //    }
                // $scope.busy = false;
                // },function(message){
                //    console.log("Limit Reached");
                // $scope.busy = false;
                // });
                // $scope.$rgDigest();
            }


        }
        $scope.loadMore = startRequest;
        $scope.loadMore();//starting first Request

        $scope.$on('$destroy',function(){
            feedFactory.removeIgnoreFilter(ignoreCommKey);
            feedFactory.removeIgnoreFilter(ignoreLikeKey);
            $$connector.unsubscribe(subKey);
        });
        $scope.skipSaveScope = true;

    }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('FeedRingboxWhoShareController',FeedRingboxWhoShareController);
    FeedRingboxWhoShareController.$inject = ['$controller','$scope','localData'];

    function FeedRingboxWhoShareController($controller, $scope, localData){

        $scope.viewType = 'ringbox';

        $scope.params = localData;
        

        $controller('FeedWhoShareController', {$scope: $scope} )

    }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }


    feedApp.controller("feedShareController",feedShareController);
    feedShareController.$inject = ['$scope', 'Auth', 'feedFactory','$rootScope','Ringalert', 'utilsFactory'];
    function feedShareController($scope,AuthFactory, feedFactory,$rootScope,Ringalert, utilsFactory) {
            /**
                This will act as a abstract base controller,
                Usage Example :
                  `feed.inline.share.controller`
                  `feed.ringbox.share.controller`

                params:
                    $scope.params = {
                      `feed` : FEED_MAP_OBJECT
                      `afterShareCallback` : `Callback FUNCTION AFTER SHARE`
                  }
            */

            $scope.feed = $scope.params.feed;
            $scope.afterShareCallback = $scope.params.afterShareCallback;
            $scope.updateFeedLocation = updateFeedLocation;
            $scope.resetFeedLocation = resetFeedLocation;
            $scope.currentUser = AuthFactory.currentUser();

            resetFeedLocation();
            resetFeedText();
            resetErrorMessage();
            enablePostInput();
            hideLoader();
            
            $scope.shareFeed = shareFeed;

            ///////////////// SCOPE FUNCTIONS ////////////////////

            function shareFeed(ob) {
                var data = getFeedShareData();

                disablePostInput();
                showLoader();
                resetErrorMessage();

                feedFactory.shareFeed(data).then(function (json) {
                    hideLoader();
                    resetFeedText();
                    enablePostInput();
                    resetErrorMessage();
                    resetFeedLocation();

                    emitFeedListChangedEvent();

                    afterShareCallback();
                    showSuccessMsg(json);
                    if($scope.media){
                        $scope.media.share(true);
                        $scope.$close();
                    }else{
                        $scope.$parent.$rgDigest();
                    }
                    
                },function(responseObj){
                    hideLoader();
                    enablePostInput();
                    processErorr(responseObj);
                    $scope.$parent.$rgDigest();
                });
                $scope.$rgDigest();
            }

            ///////////////////////////////////////////////////////////////

            function disablePostInput(){ $scope.inputDisabled = true; }
            function enablePostInput(){ $scope.inputDisabled = false; }

            function showLoader(){ $scope.boxIsLoading = true; }
            function hideLoader(){ $scope.boxIsLoading = false; }

            function setErrorMessage(msg){ $scope.errorMessage = msg; }
            function resetErrorMessage(){ $scope.errorMessage = ""; }

            function resetFeedText(){ $scope.feedText = ""; }
            function setFeedText(text){ $scope.feedText = text;  }

            function setFeedLocation(location){ $scope.feedLocation = location; }
            function resetFeedLocation(location){ $scope.feedLocation = ""; }

            function updateFeedLocation(location){
                //$scope.$apply(function(){
                    setFeedLocation(location);
                    $scope.$rgDigest();
                //})
                // $scope.$digest();
            }

            function emitFeedListChangedEvent(){
              $rootScope.$broadcast("FeedListChanged");
              $scope.$broadcast('cleareditor');
            }

            function showSuccessMsg(json){ Ringalert.show(json,'success'); }

            function showErrorMsg(msg){ Ringalert.show(msg,'error'); }

            function getFeedShareData(){
                var feed = $scope.media ? null:$scope.feed;
              var data =  { text: $scope.feedText,
                  feed: feed && feed.hasSharedFeed()? feed.getOrginalFeed() : feed,
                  location : $scope.feedLocation
              },content = $scope.media,i;

              if($scope.emotions.length){
                  data.mdIds = [$scope.emotions[0].id];// we will support one emotion at a time for now
                  $scope.emotions.length = 0;//emptying emotion
              }

              if($scope.tagList.length){
                  data.tFrndIds = [];
                  for(i=0;i<$scope.tagList.length;i++){
                      data.tFrndIds.push($scope.tagList[i].getUtId());
                  }
                  $scope.tagList.length = 0;
              }
            if(content || (feed  && feed.isSingleContentFeed() && (feed.getMedias().length() || feed.getAudios().length())) ){
                 content = content || feed.getSingleContent();
                 data.audio = content.isAudio();
                 data.cntntIDLst = [content.getKey()];
                 data.addShare = true;
                 data.user = $scope.currentUser;
            }

              return data;

            }


            function afterShareCallback(){
                if(!!$scope.afterShareCallback){
                  $scope.afterShareCallback();
                }
            }

            function processErorr(responseObj){

                var msg = utilsFactory.getReasonMessageFromResponse(responseObj);
                if(msg == ""){
                    msg = "Unable To Share Status. Please Try Again Later";
                }

                $scope.errorMessage = msg;
            }


            $scope.emotions = [];
            $scope.tagList = [];

            $scope.addTag = function(item){
                var index = $scope.tagList.indexOf(item);
                if(index === -1){
                    $scope.tagList.push(item);
                }

            }
            $scope.removeTag = function(usr){
                    var index = $scope.tagList.indexOf(usr);
                    if(index >=0){
                        $scope.tagList.splice(index, 1);
                    }
            };
            $scope.chooseEmotion = function(subCat){
                $scope.emotions.length = 0;//note : now we only support one media at a limt
                $scope.emotions.push(subCat);
            }



        }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }



    feedApp.controller("feedRingboxShareController",feedRingboxShareController);
    feedRingboxShareController.$inject = ['$scope', '$boxInstance', '$controller', 'localData'];
    function feedRingboxShareController($scope, $boxInstance, $controller, localData ) {

        $scope.params = {
          feed: localData.feed,
          afterShareCallback : $scope.$close,
          showSharePostBox: true
        };

        $controller('feedShareController', {$scope: $scope});

    }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }



    feedApp.controller("feedMediaShareController",feedMediaShareController);//using in ringbox media controller
    feedApp.controller("feedInlineShareController",feedInlineShareController);
    feedInlineShareController.$inject = ['$scope',  '$controller'];
    function feedInlineShareController($scope, $controller) {

        $scope.params = {
          feed: $scope.feed,
          afterShareCallback : $scope.closeShareBox,
          showSharePostBox : true
        };

        $controller('feedShareController', {$scope: $scope});

        ////////////////////////////////////
       /*
        function afterShareCallback(){
            $scope.showShareBox = false;
        }
        */

    }

    feedMediaShareController.$inject = ['$scope','$controller'];
    function feedMediaShareController($scope,$controller){
            $scope.params = {
              feed: null,
              afterShareCallback : angular.noop,
              showSharePostBox : true
            };
            $scope.closeShareBox = function(){
                $scope.$close();
            }
            $scope.autoAdjustScroll = "false";
          //  $controller('feedShareController', {$scope: $scope});
    }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller("FeedAddController",['fileUploadService', '$rootScope','$scope','feedFactory','$timeout','$routeParams','SystemEvents','OPERATION_TYPES', 'rgDropdownService','PrivacySet',
        function(fileUploadService, $rootScope,$scope,feedFactory,$timeout,$routeParams,SystemEvents,OPERATION_TYPES, rgDropdownService,PrivacySet){



            // privacy and privacy dropdowns
            //var privacyCode = 2;
            $scope.privacySet = PrivacySet;
            if($scope.forAdd=='circle' || $scope.forAdd === 'friend'){
                $scope.showPrivacy = false;
            }else{
                $scope.showPrivacy = true;
                $scope.privacy = PrivacySet.PVC3;
            }

            $scope.setPrivacy = function(actionObj) {
                //actionObj.event.preventDefault();
              //  privacyCode = actionObj.privacy;
                $scope.privacy = PrivacySet['PVC'+actionObj.privacy];
                rgDropdownService.close(actionObj.event);
                $scope.$rgDigest();
            };
            //$scope.privacyHtml = 'pages/dropdowns/privacy-dropdown.html';
            $scope.privacyTemplate =
                    '<div class="ng-cloak action  ab-drop postbox-action">'+
                        '<div class="a-box" ><a rg-click="ddAction()({event: $event, privacy:ddControl.PVC1.value})" href="#"><span class="{{::ddControl.PVC1.icon}} ab-delete"></span> {{::ddControl.PVC1.text}}</a></div>' +
                        '<div class="a-box"><a rg-click="ddAction()({event: $event, privacy:ddControl.PVC2.value})" href="#"><span class="{{::ddControl.PVC2.icon}} ab-delete"></span> {{::ddControl.PVC2.text}} </a></div>' +
                        '<div class="a-box"><a rg-click="ddAction()({event: $event, privacy:ddControl.PVC3.value})" href="#"><span class="{{::ddControl.PVC3.icon}} ab-delete"></span> {{::ddControl.PVC3.text}}</a></div>' +
                    '</div>' ;


            $scope.feedText = "";
            $scope.feedLocation = {};
            $scope.ogData = {};

            $scope.filterOnProgress = false;
            $scope.ogDataLoading = false;
            $scope.ogShowPreview = false;

            // $scope.uploadEnabled = !$scope.ogData || !$scope.ogData.url ;

            $scope.inputDisabled = false;

            $scope.getValidityValues = function(){
                return new Array(30);
            };

            $scope.showTimeout = false;
            $scope.validity = -1;
            var gdata = {vldt : $scope.validity};

            if($scope.forAdd === 'friend'){
                gdata.friend = $routeParams.uId;

            }else if($scope.forAdd === 'circle'){
                gdata.group = $routeParams.circleId;
                //data.isCircle = true;
            }
            $scope.$on(SystemEvents.FILE_UPLOAD.QUEUE_START,function(){
                $scope.inputDisabled = true;
                $scope.$rgDigest();
            });

            $scope.$on(SystemEvents.FILE_UPLOAD.QUEUE_COMPLETE,function(){
                $scope.inputDisabled = false;
                $scope.$rgDigest();
            });

            $scope.shouldDisableInput = function(){
                return ( $scope.inputDisabled || $scope.ogDataLoading || $scope.filterOnProgress);
            };

            $scope.shouldDisableLocation = function(){
                return ( fileUploadService.imageFiles.length > 0
                        || fileUploadService.videoFiles.length > 0
                        || fileUploadService.audioFiles.length > 0 || !!$scope.ogData.url )
            }

            $scope.shouldDisableLink = function(){
                return ( fileUploadService.imageFiles.length > 0
                        || fileUploadService.videoFiles.length > 0
                        || fileUploadService.audioFiles.length > 0 || !!$scope.feedLocation.lat )
            }

            $scope.shouldDisableMedia = function(){
                return !!$scope.ogData.url || !!$scope.feedLocation.lat;
            }

            var lastAddStatusTime = new Date().getTime(),now,i;


            $scope.addFeed = function(){

                var data = {vldt : $scope.validity};
                //var feedItemCount = 0;

                $scope.inputDisabled = true;
                data = angular.extend({},gdata,{
                    //fpvc: $scope.privacy.value,//privacyCode,
                    text: $scope.feedText,
                    vldt : $scope.validity,
                    images: fileUploadService.imageFiles,
                    videos: fileUploadService.videoFiles,
                    audios: fileUploadService.audioFiles
                });

                if($scope.privacy){
                    data.fpvc = $scope.privacy.value;
                }

                //if(data.images.length > 0) {
                //    feedItemCount++; // only images can be posted
                //}
                //if(data.videos.length > 0) {
                //    feedItemCount++; // only videos can be posted
                //}

                if(!!$scope.feedLocation.description){
                    data.lctn = $scope.feedLocation.description;
                    data.lat = $scope.feedLocation.lat;
                    data.lng = $scope.feedLocation.lng;
                }

                if(!!$scope.ogData.url){
                    data.lnkDmn = $scope.ogData.lnkDmn || $scope.ogData.url || '';
                    data.lnkDsc = $scope.ogData.description || '';
                    data.lnkTtl = $scope.ogData.title || '';
                    data.lnkURL = $scope.ogData.url || '';
                    data.lnlImgURL = $scope.ogData.image || '';

                }

                if($scope.emotions.length){
                    data.mdIds = [$scope.emotions[0].id];// we will support one emotion at a time for now
                    $scope.emotions.length = 0;//emptying emotion
                }


                if($scope.tagList.length){
                    data.tFrndIds = [];
                    for(i=0;i<$scope.tagList.length;i++){
                        data.tFrndIds.push($scope.tagList[i].getUtId());
                    }
                    $scope.tagList.length = 0;
                }

                var originalFeedText = $scope.feedText;
                //http://192.168.1.117/ringID/ringIDWeb/issues/472
                if( data.text != '' && !!data.lnkURL ) {

                    var dataTextProtocolStriped = data.text.replace('https', '').replace('http', '');
                    var feedLinkUrlProtocolStriped = data.lnkURL.replace('https', '').replace('http', '');

                    if (dataTextProtocolStriped[dataTextProtocolStriped.length - 1] == '/') {
                        dataTextProtocolStriped = dataTextProtocolStriped.slice(0, -1);
                    }

                    if (feedLinkUrlProtocolStriped[feedLinkUrlProtocolStriped.length - 1] == '/') {
                        feedLinkUrlProtocolStriped = feedLinkUrlProtocolStriped.slice(0, -1);
                    }

                    if (dataTextProtocolStriped == feedLinkUrlProtocolStriped) {
                        data.text = '';
                    }

                }



                function canPostEmptyStatus(){
                    return !!data.text
                        || !!data.lnkURL
                        || data.images.length > 0
                        || data.videos.length > 0
                        || data.audios.length > 0
                        || (!!data.mdIds && data.mdIds.length > 0)
                        || (!!data.lctn)
                        || (!!data.tFrndIds && data.tFrndIds.length > 0);
                }

                function addFeedRequest(){
                    lastAddStatusTime = now;

                    feedFactory.addFeed(data,$scope.currentUser).then(function(json){

                       $scope.setFeed(json);
                        //$scope.$broadcast('cleareditor');
                        $scope.$parent.$rgDigest();
                    },function(){

                       $scope.setFeed();
                       $scope.feedText = originalFeedText;
                       $scope.$broadcast('seteditor',originalFeedText);
                       $scope.$parent.$rgDigest();
                    },function(state){ // on progress notify call

                    });

                    fileUploadService.imageFiles.length = 0;
                    fileUploadService.imageFiles= [];
                    fileUploadService.videoFiles.length = 0;
                    fileUploadService.videoFiles= [];
                    fileUploadService.audioFiles.length = 0;
                    fileUploadService.audioFiles= [];

                    $scope.feedText = "";
                    $scope.validity = -1;
                    $scope.feedLocation = {};
                    $scope.ogData = {};
                    $scope.ogShowPreview = false;
                    $scope.inputDisabled = false;
                    $scope.errorMessage = false;
                    $scope.setFeed();
                    $scope.$broadcast('cleareditor');
                    $scope.$parent.$rgDigest();
                }

                if( !canPostEmptyStatus() && data.text === ''){

                    $scope.feedText = "";
                    $scope.inputDisabled = false;
                    $scope.errorMessage = true;
                    $scope.ogShowPreview = false;
                    $scope.$rgDigest();
                    //if (data.images.length === 0) {
                        //$rootScope.$broadcast('cleareditor',{sucs:false});
                   // }
                }else{
                     now = new Date().getTime();
                    if(now - lastAddStatusTime < 200){
                        setTimeout(addFeedRequest,200)
                    }else{
                        addFeedRequest();
                    }

                }

            };

            $scope.selectOptions = [];
            $scope.selectOptions[0] = {
                value : -1,
                title : 'Unlimited'
            };
            for(i=1;i<=30;i++){
                $scope.selectOptions[i] = {
                    value : i,
                    title : i + " Day"
                };
            }

            $scope.selectedTimeout = function(item){
                $scope.validity = item;
                $scope.$rgDigest();
            };
            $scope.selectedLocation = function(location){
                //$scope.$apply(function(){
                    $scope.feedLocation = location;
                //});
                $scope.$rgDigest();
            };

            $scope.resetFeedLocation = function(){
                $scope.feedLocation = {};
                $scope.$rgDigest();
            };

           // $scope.showEmotion = false;
            $scope.emotions = [];
            $scope.tagList = [];

            $scope.addTag = function(item){
                var index = $scope.tagList.indexOf(item);
                if(index === -1){
                    $scope.tagList.push(item);
                }
                $scope.$rgDigest();

            };

            $scope.removeTag = function(usr){
                    var index = $scope.tagList.indexOf(usr);
                    if(index >=0){
                        $scope.tagList.splice(index, 1);
                    }
                    $scope.$rgDigest();
            };

            $scope.chooseEmotion = function(subCat){
                $scope.emotions.length = 0;//note : now we only support one media at a limt
                $scope.emotions.push(subCat);
                $scope.$rgDigest();
            };

            var pageVal = feedFactory.getCurrentPageValue();

            $scope.showAddTag  = pageVal.action !== OPERATION_TYPES.SYSTEM.TYPE_GROUP_NEWS_FEED;



        }]);
})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }
    feedApp.controller('FeedDashboardController', ['$scope','$controller','OPERATION_TYPES','Ringalert',
        function ($scope,$controller,OPERATION_TYPES,Ringalert){
            $scope.pagekey = OPERATION_TYPES.SYSTEM.TYPE_NEWS_FEED + '.all';
            $scope.action = OPERATION_TYPES.SYSTEM.TYPE_NEWS_FEED;
            $scope.params = {actn:OPERATION_TYPES.SYSTEM.TYPE_NEWS_FEED};
            $scope.forAdd = "my";
            $controller('FeedMainController', {$scope: $scope});

        }]);

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('FeedProfileController',['$scope','$controller','$routeParams','OPERATION_TYPES',
        function($scope,$controller,$routeParams,OPERATION_TYPES){

            var uId = $routeParams.uId,
                helperob,
                mapkey = uId,action;

            /* helperob ( Helper Object) sets where to submit the post, my wall or fiends wall
            *  my post : @value : "my"
            *  friend post : @value : "friend
            *
            * */

            if($scope.currentUser && $scope.currentUser.equals(uId)){
                helperob = "my";
                action = OPERATION_TYPES.SYSTEM.TYPE_MY_NEWS_FEED;

            }else{
                helperob = "friend";
                action = OPERATION_TYPES.SYSTEM.TYPE_FRIEND_NEWSFEED;
            }
            mapkey = action +"."+ uId;

            $scope.pagekey = mapkey;
            $scope.action = action;
            $scope.params = {actn:action,fndId:uId};
            $scope.forAdd = helperob;
            $scope.sortBy = 'at';
            $controller('FeedMainController', {$scope: $scope});
        }]);


})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('FeedCircleController',['$scope','$controller','$routeParams','OPERATION_TYPES', 'feedFactory',
        function($scope,$controller,$routeParams,OPERATION_TYPES, feedFactory){
            //$scope.column = helper.feedColumn();
            var feeds = [],
                page= 'circle',
                cicleId = $routeParams.circleId,
                helperob,
                mapkey = OPERATION_TYPES.SYSTEM.TYPE_GROUP_NEWS_FEED + "." + cicleId;

            $scope.pagekey = mapkey;

            $scope.action = OPERATION_TYPES.SYSTEM.TYPE_GROUP_NEWS_FEED;

            $scope.params = {actn:OPERATION_TYPES.SYSTEM.TYPE_GROUP_NEWS_FEED, grpId:cicleId};

            $scope.forAdd = page;
            $scope.shareMenuDisabled = true;
            
            $controller('FeedMainController', {$scope: $scope});

        }]);


})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', [
                'ngWebSocket', 'ringid.puller', 'ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('FeedMediasController',['$scope','$controller','$routeParams','OPERATION_TYPES', 'feedFactory',
        function($scope,$controller,$routeParams,OPERATION_TYPES, feedFactory){
            //$scope.column = helper.feedColumn();
            var feeds = [],
                page= 'my',
                // cicleId = $routeParams.circleId,
                helperob,
                mapkey = OPERATION_TYPES.SYSTEM.TYPE_MEDIAS_NEWS_FEED + ".medias";

            $scope.pagekey = mapkey;

            $scope.action = OPERATION_TYPES.SYSTEM.TYPE_MEDIAS_NEWS_FEED;

            $scope.params = {actn:OPERATION_TYPES.SYSTEM.TYPE_MEDIAS_NEWS_FEED, pvtid:0,st:0,mtf:0};
            $scope.a_f_m = 'f';

            $scope.setTrending = function(v){
                $scope.params.mtf = v;
                var pre_v = $scope.a_f_m;//previous value
                if(v === 1){
                    $scope.a_f_m = 't';//trending // a_f_m = active_filter_menu
                }else{
                    $scope.a_f_m = 'f';//friends
                }

                if(pre_v !== $scope.a_f_m){ // filter changed so we need to call
                    feedFactory.reset();
                    feedFactory.initFeedRequest($scope.params);
                    $scope.$rgDigest();
                }
                
            };

            $scope.forAdd = page;
            $scope.shareMenuDisabled = true;
            $scope.showPostBox = function(){return false;};
            $scope.showSpecialFeed = function(){return false;};
            $controller('FeedMainController', {$scope: $scope});

        }]);


})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', ['ringid.utils', 'ringid.config'
            ]);
    }

    feedApp.controller('feedTagUserListController',feedTagUserListController);
    feedTagUserListController.$inject = ['$scope','remoteData','userFactory','InviteFactory'];

    function feedTagUserListController($scope, remoteData ,User,InviteFactory){
        var tagUserIds = remoteData.fTgLst;
        $scope.usersUtIds =[];
        $scope.users =[];
        var usercount = tagUserIds.length;
        if(usercount){
            $scope.total = usercount;
            for(var i = 0;i < tagUserIds.length;i++){
                tagUserIds[i].fn = tagUserIds[i].nm;
                $scope.users.push(User.createByUtId(tagUserIds[i],true));
            }
        }

        $scope.getMutualFriend = function(user) {
            return{
                data: function() {
                    return {
                        target: user
                    };
                },
                promise: InviteFactory.getMutualFriend(user)
            };
        };

    }

})();

(function() {
    'use strict';
    var feedApp;

    try {
        feedApp = angular.module('ringid.feed');
    } catch (e) {
        feedApp = angular
            .module('ringid.feed', ['ringid.utils', 'ringid.config'
            ]);
    }
    feedApp.filter("filterUserByName",function(){
        return function(items, name) {
                            if (items) {
                                var filtered = [];
                                var nameMatch = new RegExp(name, 'i');
                                for (var i = 0; i < items.length; i++) {
                                    if(items[i].getName().match(nameMatch)){
                                        filtered.push(items[i]);
                                    }
                                }
                                return filtered;
                            }
                };
            });
    feedApp.controller('feedEditTagController',feedEditTagController);
    feedEditTagController.$inject = ['$scope','localData', 'remoteData', '$$connector','feedFactory','OPERATION_TYPES','userFactory','$filter','friendsFactory','Ringalert', 'Auth'];

    function feedEditTagController($scope, localData, remoteData, $$connector,feedFactory,OPERATION_TYPES,User,$filter,friendsFactory,Ringalert, Auth){

        var feed = localData.feed,
            sentRequest=false,
            friends = [], //feed.getTagUsers();
            tagUsers = [],
            tagUsersBackup = [],
            users = [];
        
        $scope.users = [] ;
        $scope.filterText='';
        $scope.loading = true;
        $scope.currentType = 'a';//all shows at  first

        var currentUser = Auth.currentUser();

        function setUsers(){
            $scope.users = $filter('filterUserByName')(users,$scope.filterText);
        }

        function searchRequest(){
            if(sentRequest)return;
            friendsFactory.searchContact({schPm: $scope.filterText}, true);
            $scope.loading = true;
            sentRequest = true;
        } 

        $scope.$watch('filterText', function(newValue, oldValue) {

            setUsers();
            if($scope.users.length < 5 && newValue.length > oldValue.length){ //newValue.length > oldValue.length for making sure not sending request while backspacing
                sentRequest = false;
                searchRequest();
            }else{
                sentRequest = false;
                $scope.loading = false;
            }
        });

        $scope.$watch(friendsFactory.friends.length(), function(newValue, oldValue) {

            crossMatch();
            $scope.loading = false;
            sentRequest = false;

        });

        function crossMatch(){

            if($scope.currentType !== 'a'){
                setUsers();return;
            }

            friendsFactory.friends.doForAll(function(item){

                var liteu = item.getLiteUser();

                if( users.contains( liteu, function(a,b){ return a.equals(b,'utId'); } ) !== -1){
                    return;
                }

                if( tagUsers.contains(liteu,function(a,b){ return a.equals(b,'utId'); }) === -1){
                    users.push(liteu);
                }

            });

            var temp = tagUsers.filter(function(templu){
                return users.contains( templu, function(a,b){ return a.equals(b,'utId'); } ) === -1;
            });

            users = users.concat(temp);
            setUsers();
        }



        if( !!remoteData ){

            if(remoteData.fTgLst && remoteData.fTgLst.length){

                for(var i = 0;i < remoteData.fTgLst.length;i++){

                    remoteData.fTgLst[i].fn = remoteData.fTgLst[i].nm;


                    if( tagUsers.contains(remoteData.fTgLst[i].utId,function(a,b){ return a.equals(b,'utId'); }) === -1)
                    {
                        tagUsers.push(User.createByUtId(remoteData.fTgLst[i],true));//saving the lite user
                        tagUsersBackup.push(tagUsers[i]);
                    }

                }

                crossMatch();

            }
        }

        $scope.loading = false;




        if(!feed.hasTagUsers()){
            crossMatch();
        }

        $scope.toggle = function(type){
            if($scope.currentType == type){
                return;
            }
            $scope.currentType = type;
            if(type == 'a'){
                users = [];
                crossMatch();
            }else{
                users = tagUsers;
                setUsers();
            }
            
        };

        $scope.checked = function(item){
            return tagUsers.indexOf(item) > -1;
        };

        $scope.loadMore = function(){
            if($scope.filterText.length){
                searchRequest();
            }else{
                friendsFactory.getContactDetails();
                $scope.loading = true;
            }            
            
        };

        $scope.addRemoveTag = function(event,item){
            var index = tagUsers.indexOf(item);
            if(index > -1){
                tagUsers.splice(index, 1);
            }else{
                tagUsers.push(item);
                if(($scope.users.length - tagUsers.length) < 5){
                    $scope.loadMore();
                }
            }
        };

        $scope.saveTagUser = function(){

                var removed = tagUsersBackup.difference(tagUsers),
                    added = tagUsers.difference(tagUsersBackup),
                    index;

                if(!removed.length && !added.length){
                    Ringalert.show("Please Make Your Changes Before Submit",'warning');
                    return;
                 }

                 if(added.length === 0 && removed.length === tagUsersBackup.length){ //all user has been removed so if feed is empty we should not post the request
                    if(!feed.validateForUpdateTag()){
                        Ringalert.show("You can't submit an empty feed",'warning');
                        return;
                    }
                 }
                var removedTaggedFriends = {};
                var newTaggedFriends = {};

                if(removed.length){
                    for(index=0;index<removed.length;index++){
                        removedTaggedFriends[removed[index].getUtId()] = true;
                    }
                }

                if(added.length){
                    for(index=0;index<added.length;index++){
                        newTaggedFriends[added[index].getUtId()] = true;
                    }
                }

                var tagFriendIds = {
                    'removed' : Object.keys(removedTaggedFriends),
                    'new' : Object.keys(newTaggedFriends)
                };

                feedFactory.updateFeed(currentUser,
                    feed.getKey(),
                    feed.text(),
                    feed.getLocationInfo(),
                    feed.getOgData(),
                    feed.getFeelings(),
                    tagFriendIds
                ).then(function (json) {
                    feed.updateTagUser(json);
                    $scope.$close(feed);

                },function(json){
                    Ringalert.show(json,'error');
                });


                 //$$connector.request(dataToUpdate,OPERATION_TYPES.SYSTEM.REQUEST_TYPE.UPDATE).then(function(json){//success function
                 //       if(json.sucs){
                 //           feed.updateTagUser(json);
                 //           $scope.$close(feed);
                 //       }else{
                 //           Ringalert.show(json,'error');
                 //       }
                 //},function(reason){//error function
                 //   Ringalert.show(reason,'error');
                 //});
        };
        $scope.$on('$destroy', function () {
            //$$connector.unsubscribe(subKey);
        });

    }

})();

/*
 * © Ipvision
 */
//window.WebSocket = null;
//window.onbeforeunload = function (e) {
//	return "Are you sure you want to navigate away from this page";
//};
(function () {
    'use strict';
    var app;
    app = angular
        .module('ringid', [
            //'ngRoute',
            'oc.lazyLoad',
            'ringid.config',
            'ringid.language',
            'ringid.connector',
            'ringid.global.services',
            'ringid.global.directives',
            'ngWebSocket',
            'ui-notification',
            'ringid.filters',
            'ringid.sticker',
            'ringid.common.factories',
            'ringid.common.services',
            'ringid.common.controllers',
            'ringid.notification',
            'ringid.auth',
            'ringid.profile',
            'ringid.friend',
            'ringid.feed',
            'ringid.circle',
            'ringid.chat',
            'ringid.common.directives',
        ]);

})();

/*
 * © Ipvision
 */
//window.WebSocket = null;
//window.onbeforeunload = function (e) {
//	return "Are you sure you want to navigate away from this page";
//};
(function () {
    'use strict';
    var app;
    app = angular
        .module('ringid')
        .controller('ApplicationController', ApplicationController);

    ApplicationController.$inject = ['SystemEvents', '$scope', '$rootScope', '$$connector', 'Storage', 'Auth', 'StickerFactory', 'OPERATION_TYPES', '$location','Ringalert', 'utilsFactory','RING_ROUTES',
                                    'friendsFactory', 'InviteFactory', 'Media', 'NotificationFactory', 'circlesManager', 'ChatConnector'];
    function ApplicationController(SystemEvents, $scope, $rootScope, $$connector, Storage, Auth, StickerFactory, OPERATION_TYPES, $location,Ringalert, utilsFactory,RING_ROUTES,
                                  friendsFactory, InviteFactory, Media, NotificationFactory, circlesManager, ChatConnector) {
        var OTYPES = OPERATION_TYPES.SYSTEM.AUTH,
            loginPending = true;
            //lastChecked = +Storage.getCookie('la');
            //

        $scope.openSignIn = function() {
            return {
                    data: function () {
                        return {
                            'fromPopup': true
                        };
                    },
            };
        };

        $scope.activePath = null; // for active menu link
        $scope.currentUser = Auth.currentUser();
        $scope.templatePath = 'pages/index-login.html';
        $scope.isLoggedIn = false;
        $scope.isPending = function() {
            return loginPending;
        };

        $scope.showFriendsBar = false;
        $scope.toggleFriendsBar = function(){
            $scope.showFriendsBar = !$scope.showFriendsBar;
            $scope.$rgDigest();
        };



        function appInit() {
            $scope.isLoggedIn = Auth.isLoggedIn();
            $$connector.init();

            if ($scope.isLoggedIn) {

                $scope.currentUser = Auth.currentUser();
                $scope.templatePath = 'pages/index-dashboard.html';
                $$connector.resume();
                $$connector.keepAlive();

                // bootstrap application by pulling necessary data
                setTimeout(friendsFactory.initFriends, 2000);

                //setTimeout(InviteFactory.init, 4000); // put inside rg-invite directive with 5 second delay
                setTimeout(circlesManager.init, 5000); // put inside menu.controller upon clicking circle menu
                setTimeout(NotificationFactory.init, 5000);
                setTimeout(StickerFactory.initStickerData, 5000);
                setTimeout(Media.init, 10000);

                ChatConnector.sendGlobal('uId', Auth.currentUser().getKey());

            } else {
                $scope.templatePath = 'pages/index-login.html';
            }

            $scope.$rgDigest();
            setTimeout(function() {
                loginPending = false;
                $scope.$rgDigest();
            });
        }


        $scope.$on(SystemEvents.AUTH.LOGIN, function () {
            appInit();
        });

        $scope.$on('CONNECTION_ERROR',function(){
            var reloaded = Storage.getCookie('reloaded');
            if(!reloaded){
                Storage.setCookie('reloaded',1);
                //Auth.reloadHome();
            }else{
                $$connector.reset();
            }
        });

        $scope.$on('$locationChangeStart', function(event,next, current) {
            if(next){
                $$connector.notifyRouteChange();
            }

         });

        function activate() {
            $$connector.subscribe( Auth.handleInvalidSession , {
                action: [
                    OTYPES.TYPE_SESSION_VALIDATION,
                    OTYPES.TYPE_INVALID_LOGIN_SESSION,
                    OTYPES.TYPE_MULTIPLE_SESSION
                ]
            });

            Auth.ensureLoginState();
            $scope.$rgDigest();
        }
        activate();




    }


})();

/*
 * © Ipvision
 */
//window.WebSocket = null;
//window.onbeforeunload = function (e) {
//	return "Are you sure you want to navigate away from this page";
//};
(function () {
    'use strict';
    var app;
    app = angular
        .module('ringid')
        .run(['$rootScope', '$window', '$document','$$connector', '$ringhttp', 'settings', function ($rootScope, $window, $document,$$connector, $ringhttp, settings) {
            //$http.defaults.headers.common['x-app-version']= settings.apiVersion;
           // $$connector.init();
            var windowElement = angular.element($window),
                vendorPrefix, prevEvent;
                $$connector.init();
                function activeTab(event){
                    if (prevEvent !== 'inactive') {
                        $rootScope.$broadcast('ringInactive', event);
                    }
                    prevEvent = 'inactive';
                }
            function inactiveTab(event) {
                if (prevEvent !== 'active') {
                    $rootScope.$broadcast('ringActive', event);
                }
                prevEvent = 'active';
            }
            windowElement.on('inactive',activeTab);

            windowElement.on('active', inactiveTab);
            //console.log(languageLoader.get('default'));
            //$rootScope.__ = function (key,lang){
            //    return languageLoader.get(key);
            //};


            function windowVisibilityChangeHandler(event) {
                if (this[vendorPrefix ? vendorPrefix + 'Hidden' : 'hidden'] && prevEvent !== 'inactive') {
                    $rootScope.$broadcast('ringInactive', event);
                    prevEvent = 'inactive';
                } else if (prevEvent !== 'active') {
                    $rootScope.$broadcast('ringActive', event);
                    prevEvent = 'active';
                }

            }

            if ('hidden' in $document) {
                vendorPrefix = '';
            } else {
                angular.forEach(['moz', 'webkit', 'ms'], function (prefix) {
                    if ((prefix + 'Hidden') in $document[0]) {
                        vendorPrefix = prefix;
                    }
                });
            }
            if (angular.isDefined(vendorPrefix) && vendorPrefix !== '') {
                $document[0].addEventListener(vendorPrefix + 'visibilitychange', windowVisibilityChangeHandler);
            }


            // NEED TO ENABLE LATER WHEN SERVER RESPONSE IS CORRECT
            $ringhttp.get(settings.constantServer).success(function(json){
                var ob = angular.fromJson(json);
                    settings.updateUrlBase(ob);
                    ob = null;
            });


            // SOCIAL LOGIN SIGNUP
            //$window.fbAsyncInit = function() {
              //FB.init({
                //appId      : settings.fbAppId,
                //cookie     : true,  // enable cookies to allow the server to access
                                    //// the session
                //xfbml      : true,  // parse social plugins on this page
                //version    : 'v2.2' // use version 2.2
              //});
            //};


            //// Load the SDK asynchronously
            //(function(d, s, id) {
                //var js, fjs = d.getElementsByTagName(s)[0];
                //if (d.getElementById(id)) { return;}
                //js = d.createElement(s); js.id = id;
                //js.src = "//connect.facebook.net/en_US/sdk.js";
                //fjs.parentNode.insertBefore(js, fjs);
            //}(document, 'script', 'facebook-jssdk'));

        }]);

})();

/*
 * © Ipvision
 */

(function () {
    'use strict';

    angular
        .module('ringid')
        .config(['$compileProvider','$routeProvider', '$locationProvider','$httpProvider' , 'RING_ROUTES', 'settings', '$ocLazyLoadProvider',
                function ($compileProvider, $routeProvider, $locationProvider,$httpProvider, RING_ROUTES, settings, $ocLazyLoadProvider){

                    $ocLazyLoadProvider.config({
                        debug: true,
                        events: true,
                        modules: [{
                            name: 'ringidFriends',
                            files:[
                                'app/friend/factories/friends.factory.js',
                                'app/friend/factories/friends.http.service.js',
                                'app/friend/friend.module.js',
                                'app/friend/directives/rg-friends.directive.js',
                                'app/friend/directives/rg-requests.directive.js',
                            ],
                            //cache: true
                        }, {
                            name: 'ringidFeed',
                            files: [
                                'app/feed/feed.module.js',
                                'app/feed/services/ringfeed.map.factory.js',
                                'app/feed/services/feed.factory.js',

                                //'app/feed/services/feed.http.service.js',
                                'app/feed/directives/rg-feed-subscriber.directive.js',
                                'app/feed/directives/feedimages.directive.js',
                                'app/feed/directives/show-more.directive.js',
                                'app/feed/directives/rg-incoming-feed.directive.js',
                                'app/feed/directives/feed-timeout-option.directive.js',
                                'app/feed/directives/feed-repeat.js',


                                'app/feed/directives/feed-location-view.directive.js',
                                'app/feed/directives/feed-location-menu.directive.js',


                                'app/feed/directives/rg-like.directive.js',
                                'app/feed/directives/rg-comments.directive.js',

                                'app/feed/directives/rg-news-feed-top.directive.js',
                                'app/feed/directives/rg-news-feed-bottom.directive.js',
                                'app/feed/directives/rg-news-feed-details.directive.js',
                                'app/feed/directives/rg-news-feed-shared-feed.directive.js',
                                'app/feed/directives/rg-news-feed-menu.directive.js',
                                //'app/feed/directives/rg-news-feed-comment.directive.js',//not used in anywhere
                                'app/feed/directives/feed-message.directive.js',

                                'app/feed/directives/rg-single-feed.directive.js',
                                'app/feed/directives/rg-single-feed-details.directive.js',
                                //'app/feed/directives/rg-single-feed-comment.directive.js',//not used in anywhere

                                'app/feed/directives/feed-inline-share.directive.js',
                                'app/feed/controllers/feed.main.controller.js',
                                'app/feed/controllers/feed.single.sub.controller.js',
                                'app/feed/controllers/feed.sub.controller.js',
                                'app/feed/controllers/feed.whoshare.controller.js',

                                'app/feed/controllers/feed.ringbox.whoshare.controller.js',
                                //'app/feed/controllers/feed.single.whoshare.controller.js',//not used anywhere

                                'app/feed/controllers/feed.share.controller.js',
                                'app/feed/controllers/feed.ringbox.share.controller.js',
                                'app/feed/controllers/feed.inline.share.controller.js',
                                'app/feed/controllers/feed.add.controller.js',
                                'app/feed/controllers/feed.dashboard.controller.js',
                                'app/feed/controllers/feed.profile.controller.js',
                                'app/feed/controllers/feed.circle.controller.js',
                                'app/feed/controllers/feed.tag.user.list.controller.js',
                                'app/feed/controllers/feed.edit.tag.controller.js',
                            ]
                        }]
                    });
                $httpProvider.useApplyAsync(true);
                $compileProvider.debugInfoEnabled(settings.debugEnabled);
                $routeProvider.
                        when(RING_ROUTES.HOME, {
                            templateUrl: 'pages/index.html',
                            //resolve: {
                                //// load necessary modules
                                //loadFriendsModule: ['$ocLazyLoad', 'Auth', '$q', function($ocLazyLoad, Auth, $q) {
                                    //if (Auth.isLoggedIn()) {
                                        //return $ocLazyLoad.load('ringidFriends');
                                    //} else {
                                        //var defer = $q.defer();
                                        //defer.resolve();
                                        //return defer.promise;
                                    //}

                                //}],
                                //loadFeedModule: ['$ocLazyLoad', 'Auth', '$q', function($ocLazyLoad, Auth, $q) {
                                    //if (Auth.isLoggedIn()) {
                                        //return $ocLazyLoad.load('ringidFeed');
                                    //} else {
                                        //var defer = $q.defer();
                                        //defer.resolve();
                                        //return defer.promise;
                                    //}
                                //}]
                            //}
                        }).when(RING_ROUTES.LOGIN_SOCIAL, {
                            templateUrl: 'pages/index.html'
                            //resolve: {
                                //'urlfix': ['$location', function($location) {
                                //}]
                            //}
                        }).when(RING_ROUTES.SIGNUP_SOCIAL, {
                            templateUrl: 'pages/index.html'
                        }).when(RING_ROUTES.USER_PROFILE, {
                            templateUrl: '/pages/profile/profile.html',
                            resolve: {
                                user: ['profileFactory', '$route', '$location', '$q', 'Ringalert', 'Auth', function(profileFactory, $route, $location, $q, Ringalert, Auth) {
                                    var deferred = $q.defer();
                                    Auth.isPendingAsync().then(function() {
                                        profileFactory.getUserDetailsByUId($route.current.params.uId).then(function(user){
                                            deferred.resolve(user);
                                        }, function() {
                                            Ringalert.show('User not found', 'error');
                                            // if going to profile redirect to home
                                            if ($location.path().indexOf('profile') > -1) {
                                                $location.path('/');
                                            }
                                            deferred.reject();
                                        });

                                    });

                                    return deferred.promise;
                                }]
                            }
                        }).when(RING_ROUTES.CIRCLE_HOME, {
                            resolve: {
                                pending: ['Auth', function(Auth) {
                                   return Auth.isPendingAsync();
                                }]
                            },
                            templateUrl: 'pages/home/circle.html'
                        }).when(RING_ROUTES.SINGLE_FEED, {
                            resolve: {
                                pending: ['Auth', function(Auth) {
                                   return Auth.isPendingAsync();
                                }]
                            },
                            templateUrl: 'pages/index-singlefeed.html'
                        }).when(RING_ROUTES.MEDIA_FEEDS, {
                            templateUrl: 'pages/home/media.feed.html'
                        }).when(RING_ROUTES.WHO_SHARED_FEED, {
                            resolve: {
                                pending: ['Auth', function(Auth) {
                                   return Auth.isPendingAsync();
                                }]
                            },
                            templateUrl: 'pages/index-who-sharedfeed.html'
                        }).when('/media', {// for media page test pupose
                            resolve: {
                                pending: ['Auth', function(Auth) {
                                   return Auth.isPendingAsync();
                                }]
                            },
                            templateUrl: 'pages/media-list.html'
                        }).when('/media/myalbums',{
                            resolve: {
                                pending: ['Auth', function(Auth) {
                                   return Auth.isPendingAsync();
                                }]
                            },
                            templateUrl:'pages/mediasearch/my.albums.html',
                        }).when(RING_ROUTES.MEDIA_POST, {
                            resolve: {
                                pending: ['Auth', function(Auth) {
                                   return Auth.isPendingAsync();
                                }]
                            },
                            templateUrl:'pages/mediasearch/media.upload.html',
                            controller: 'MediaPostController'
                        }).when('/media/:albumtype',{
                            resolve: {
                                pending: ['Auth', function(Auth) {
                                   return Auth.isPendingAsync();
                                }]
                            },
                            templateUrl:'pages/mediasearch/albums.all.html',
                            controller:'allAlbumTypeController'
                        }).when('/media/:stype/:sk?', {// for media page test pupose
                            resolve: {
                                pending: ['Auth', function(Auth) {
                                   return Auth.isPendingAsync();
                                }]
                            },
                            templateUrl: 'pages/mediasearch/search.result.html',
                            controller:'mSearchResultController'
                        }).when('/media/:albumtype/:utid/:albumid',{
                            resolve: {
                                pending: ['Auth', function(Auth) {
                                   return Auth.isPendingAsync();
                                }]
                            },
                            templateUrl:'pages/mediasearch/albums.all.html',
                            controller:'allAlbumTypeController'
                        }).when('/chat',{
                            resolve: {
                                pending: ['Auth', function(Auth) {
                                   return Auth.isPendingAsync();
                                }]
                            },
                            templateUrl: 'pages/partials/chat/single-page/home.html',
                            controller : 'ChatHistoryController'
                        }).when('/circle',{
                            templateUrl: 'pages/circle-partials/all-circle.html',
                            controller : 'allCirclePopupController'
                        }).when('/allnotification',{
                            templateUrl: 'pages/partials/all-notification.html'
                        }).when('/allfriendrequest',{
                            templateUrl: 'pages/partials/all-friend-request.html'
                        }).when('/medianew', {// for media page test pupose
                            resolve: {
                                pending: ['Auth', function(Auth) {
                                   return Auth.isPendingAsync();
                                }]
                            },
                            templateUrl: 'pages/mediapage.html'
                        })

                        // .when(RING_ROUTES.SINGLE_IMAGE, {
                        //     templateUrl: 'pages/index-singleimage.html'

                        // })
                        .when(RING_ROUTES.FAQ, {
                            redirectTo: function(params, currentPath, currentSearch) {
                                window.location.href = location.protocol + '//' + location.host + '/faq.xhtml';
                            }
                        }).when(RING_ROUTES.API_DASHBOARD, {
                            templateUrl: 'app/apidashboard/templates/api.index.html'
                        }).otherwise({
                            redirectTo: '/'
                        });


                //check browser support
                //if(window.history && window.history.pushState){
                    //$locationProvider.html5Mode(true); //will cause an error $location in HTML5 mode requires a  tag to be present! Unless you set baseUrl tag after head tag like so: <head> <base href="/">

                     //to know more about setting base URL visit: https://docs.angularjs.org/error/$location/nobase

                     //if you don't wish to set base URL then use this
                    //$locationProvider.html5Mode({
                        //enabled: true,
                        //requireBase: false
                    //});
                //}

            }])
        .run(['$rootScope', '$location', 'Auth', 'rgDropdownService', 'rgSearchService', '$ringbox',
             function($rootScope, $location, Auth, rgDropdownService, rgSearchService, $ringbox) {
                $rootScope.$on('$routeChangeStart', function(event, next, current) {
                    //var loginDoneInterval;
                    //function loginDone() {
                        if(!Auth.isPending() && !Auth.isLoggedIn() && !$rootScope.doingSilentLogin &&  $location.url() !==  '/' )  {
                            $location.path('/');
                            revertScopes(true);
                        } else {
                            $ringbox.closeAll();
                            // close any dropdown if any is open
                            rgDropdownService.close();
                            // close search dropdown if open
                            rgSearchService.close();
                            revertScopes(true);
                        }

                    //}
                    //// if not logged in go to login page
                    //if (Auth.isPending() ) {
                        //loginDoneInterval = setInterval(function() {
                            //if (!Auth.isPending()) {
                                //clearInterval(loginDoneInterval);
                                //loginDone();
                            //}
                        //}, 2000);
                    //} else {
                        //loginDone();
                    //}
                });

                //$rootScope.$on('$routeChangeSuccess', function() {
                    //$rootScope.$rgDigest();
                //});


                 requestAnimationFrame(function(){
                    //var loader = document.querySelector('#global-loader');
                    //loader.style.display = 'none';
                    //loader = null;
                 });


                /* $rgGigest start*/


                var $rgQueue =[];
                var $root = Object.getPrototypeOf($rootScope);
                var childHead = [];
                $rootScope.$ignoreScopes = [];
                $root.$coreDigest = $root.$digest;

                function revertScopes(reset) {

                    for(var i=0;i<$rootScope.$ignoreScopes.length;i++) {

                        if(childHead[$rootScope.$ignoreScopes[i].$id]) {
                            $rootScope.$ignoreScopes[i].$$childHead = childHead[$rootScope.$ignoreScopes[i].$id];
                         }
                    }

                    childHead = [];

                    if(reset) {
                      $rootScope.$ignoreScopes = [];
                    }
                }

                function notifyScopes() {
                    revertScopes();
                    for(var i=0;i<$rootScope.$ignoreScopes.length;i++) {

                          if($rootScope.$ignoreScopes[i]) {
                              $rootScope.$ignoreScopes[i].$broadcast('$destroy');
                              //$rootScope.$ignoreScopes[i].$destroy();
                          }
                    }
                }


                $root.$rgDigest = function() {


                    if (!$rootScope.$$phase) {

                        if(this.$id==1 && $rootScope.$ignoreScopes.length > 0) {

                           for(var i=0;i<$rootScope.$ignoreScopes.length;i++) {
                              childHead[$rootScope.$ignoreScopes[i].$id] = $rootScope.$ignoreScopes[i].$$childHead;
                              $rootScope.$ignoreScopes[i].$$childHead = null;
                           }

                          $rootScope.$$postDigest(function() {
                               revertScopes();
                           });
                        }

                        this.$coreDigest();
              	    }
                    else {

                    	if($rgQueue.indexOf(this) ==-1 && this.$id != 1) {
                   		  	  $rgQueue.push(this);
                   		  	  $rgQueue.sort(function(a, b) { return    a.$id - b.$id });

                   	      	var queue = [], target, current, parent;

                   		  	  while($rgQueue.length > 1) {

                   		          target = $rgQueue.pop();
                   			        for(var i=$rgQueue.length-1; i >= 0; i--) {
                       		   		    current = $rgQueue[i];
                       		   		    parent = target.$parent;
                       		    	    while( parent != current && parent != null) {
                       		       	    parent = parent.$parent;
                       			 	      }
                   			 	        if(parent != null)  break;
                   			        }
                   		         if(parent == null) queue.push(target);
                   		      }

                   		      while(target = queue.pop()) {
                   		         $rgQueue.push(target);
                   		      }
                      }

                   	  $rootScope.$$postDigest(function(){
                     	    if($rgQueue.length > 0) $rgQueue.pop().$rgDigest();
                      });
                    }
              };
           /* end of $rgGigest */

           $root.$digest = function() {
               this.$rgDigest();
           };

           $root.addIgnore = function() {
              if($rootScope.$ignoreScopes.indexOf(this) == -1) {
                 $rootScope.$ignoreScopes.push(this);
              }
           }

           $root.removeIgnore = function() {
              var index;
              if ((index = $rootScope.$ignoreScopes.indexOf(this)) > -1) {
                 $rootScope.$ignoreScopes.splice(index, 1);
              }
           }

           /*Utility function that returns total watchers*/
           $root.calc = function() {

          		var total = 0, total_scope=0, target, current, next, t0 = window.performance.now();
           		target = this;
           		current = target;

                do {
             		total += (current.$$watchers)?current.$$watchers.length:0;
             		total_scope++;

             		if (!(next = (current.$$childHead ||
                		(current !== target && current.$$nextSibling)))) {
              			while (current !== target && !(next = current.$$nextSibling)) {
                		 current = current.$parent;
              		    }
            		}
          		 } while ((current = next));

           };

       }
    ]);

})();
>>>>>>> develop
